<!DOCTYPE HTML>
<!--
/***************************************************************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 *
 ***************************************************************************************************************************/
 -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<style type="text/css">
		/* For viewing in Page Designer */
		@IMPORT url("../../../../../../javadoc.css");

		/* For viewing in REST interface */
		@IMPORT url("../htdocs/javadoc.css");
		body { 
			margin: 20px; 
		}	
	</style>
	<script>
		/* Replace all @code and @link tags. */	
		window.onload = function() {
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@code ([^\}]+)\}/g, '<code>$1</code>');
			document.body.innerHTML = document.body.innerHTML.replace(/\{\@link (([^\}]+)\.)?([^\.\}]+)\}/g, '<code>$3</code>');
		}
	</script>
</head>
<body>
<p>XML serialization and parsing support</p>
<script>
	function toggle(x) {
		var div = x.nextSibling;
		while (div != null && div.nodeType != 1)
			div = div.nextSibling;
		if (div != null) {
			var d = div.style.display;
			if (d == 'block' || d == '') {
				div.style.display = 'none';
				x.className += " closed";
			} else {
				div.style.display = 'block';
				x.className = x.className.replace(/(?:^|\s)closed(?!\S)/g , '' );
			}
		}
	}
</script>

<a id='TOC'></a><h5 class='toc'>Table of Contents</h5>
<ol class='toc'>
	<li><p><a class='doclink' href='#Overview'>XML support overview</a></p> 
	<ol>
		<li><p><a class='doclink' href='#OverviewExample'>XML support overview - example</a></p>
	</ol>
	<li><p><a class='doclink' href='#XmlSerializer'>XmlSerializer class</a></p> 
	<ol>
		<li><p><a class='doclink' href='#Methodology'>XML support methodology</a></p>
		<li><p><a class='doclink' href='#XmlAnnotation'>@Xml annotations</a></p>
		<ol>
			<li><p><a class='doclink' href='#XmlName'>@Bean.typeName()</a></p>
			<li><p><a class='doclink' href='#XmlChildName'>@Xml.childName()</a></p>
			<li><p><a class='doclink' href='#XmlFormat'>@Xml.format()</a></p>
		</ol>
		<li><p><a class='doclink' href='#Namespaces'>Namespaces</a></p>
		<ol>
			<li><p><a class='doclink' href='#AutoDetectNamespaces'>Auto-detection of namespaces</a></p>
		</ol>
		<li><p><a class='doclink' href='#BeanAnnotations'>@Bean and @BeanProperty annotations</a></p>
		<li><p><a class='doclink' href='#Collections'>Collections</a></p>
		<li><p><a class='doclink' href='#XmlSchemaSupport'>XML-Schema support</a></p>
		<li><p><a class='doclink' href='#Recursion'> Non-tree models and recursion detection</a></p>
		<li><p><a class='doclink' href='#SerializerConfigurableProperties'>Configurable properties</a></p>
		<li><p><a class='doclink' href='#SerializerOtherNotes'>Other notes</a></p>
	</ol>
	<li><p><a class='doclink' href='#XmlParser'>XmlParser class</a></p> 
	<ol>
		<li><p><a class='doclink' href='#GenericParsing'>Parsing into generic POJO models</a></p>
		<li><p><a class='doclink' href='#ParserConfigurableProperties'>Configurable properties</a></p>
		<li><p><a class='doclink' href='#ParserOtherNotes'>Other notes</a></p>
	</ol>
</ol>


<!-- ======================================================================================================== -->
<a id="Overview"></a>
<h2 class='topic' onclick='toggle(this)'>1 - XML support overview</h2>
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from XML using ultra-efficient serializers and parsers.
		<br>The XML serializer converts POJOs directly to XML without the need for intermediate DOM objects.
		<br>Likewise, the XML parser uses a STaX parser and creates POJOs directly without intermediate DOM objects. 
	</p>
	<p>
		Unlike frameworks such as JAXB, Juneau does not require POJO classes to be annotated to produce and consume 
		XML.
		<br>For example, it can serialize and parse instances of any of the following POJO types:
	</p>
	<ul class='spaced-list'>
		<li>
			Java primitive objects (e.g. <code>String</code>, <code>Integer</code>, <code>Boolean</code>, 
			<code>Float</code>).
		<li>
			Java collections framework objects (e.g. <code>HashSet</code>, <code>TreeMap</code>) containing anything 
			on this list.
		<li>
			Multi-dimensional arrays of any type on this list.
		<li>
			Java Beans with properties of any type on this list.
		<li>
			Classes with standard transformations to and from <code>Strings</code> (e.g. classes containing 
			<code>toString()</code>, <code>fromString()</code>, <code>valueOf()</code>, 
			<code>constructor(String)</code>).
	</ul>
	<p>
		In addition to the types shown above, Juneau includes the ability to define transforms to transform 
		non-standard object and property types to serializable forms (e.g. to transform <code>Calendars</code> to and 
		from <code>ISO8601</code> strings, or <code>byte[]</code> arrays to and from base-64 encoded strings).
		<br>These transforms can be associated with serializers/parsers, or can be associated with classes or bean 
		properties through type and method annotations.
	</p>
	<p>
		Refer to <a href='../../../../overview-summary.html#juneau-marshall.PojoCategories' class='doclink'>POJO Categories</a> 
		for a complete definition of supported POJOs.
	</p>
	<p>
		While annotations are not required to produce or consume XML, several XML annotations are provided for handling 
		namespaces and fine-tuning the format of the XML produced.
	</p>
	
	<h6 class='topic'>Prerequisites</h6>
	<p>
		The Juneau XML serialization and parsing support does not require any external prerequisites.  
		It only requires Java 1.6 or above.
	</p>

	<!-- ======================================================================================================== -->
	<a id="OverviewExample"></a>
	<h3 class='topic' onclick='toggle(this)'>1.1 - XML support overview - example</h3>
	<div class='topic'>
		<p>
			The example shown here is from the Address Book resource located in the <code>juneau-examples-rest</code> 
			microservice project.
			<br>The POJO model consists of a <code>List</code> of <code>Person</code> beans, with each <code>Person</code> 
			containing zero or more <code>Address</code> beans.
		</p>
		<p>
			When you point a browser at <code>/sample/addressBook</code>, the POJO is rendered as HTML:
		</p>
		<img class='bordered' src="doc-files/Example_HTML.png">
		<p>
			By appending <code>?Accept=<i>mediaType</i>&amp;plainText=true</code> to the URL, you can view the data 
			in the various supported XML formats:
		</p>
		
		<h6 class='figure'>Normal XML</h6>
		<img class='bordered' src="doc-files/Example_XML.png">
		
		<h6 class='figure'>Simplified XML</h6>
		<img class='bordered' src="doc-files/Example_XMLSimple.png">

		<p>
			In addition to serializing POJOs to XML, Juneau includes support for serializing the POJO metamodel to 
			XML Schema, with support for multiple namespaces.
		</p>
		
		<h6 class='figure'>XML Schema</h6>
		<img class='bordered' src="doc-files/Example_XMLSchema.png">
	</div>
</div>


<!-- ======================================================================================================== -->
<a id="XmlSerializer"></a>
<h2 class='topic' onclick='toggle(this)'>2 - XmlSerializer class</h2>
<div class='topic'>
	<p>
		{@link org.apache.juneau.xml.XmlSerializer} is the class used to convert POJOs to XML.
		<br>{@link org.apache.juneau.xml.XmlDocSerializer} is a subclass that adds an XML declaration element to the output 
		before the POJO is serialized.
	</p>	
	<p>
		The XML serializer includes many configurable settings.
		<br>Static reusable instances of XML serializers are provided with commonly-used settings:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT} 
			- All default settings.
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_SQ} 
			- Use single quotes on attributes.  Typically useful for testing since it makes string comparison simpler.
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_SQ_READABLE} 
			- Use single quotes on attributes and add whitespace for readability.
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS} 
			- Same as DEFAULT but with namespaces enabled.
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS_SQ} 
			- Same as DEFAULT_SQ but with namespaces enabled.
		<li>
			{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS_SQ_READABLE} 
			- Same as DEFAULT_SQ_READABLE but with namespaces enabled.
	</ul>
	<p>
		In addition, DTO beans are provided that use the XML serializer and parser for the following languages:
	</p>
	<ul>
		<li><a class='doclink' href='../dto/atom/package-summary.html#TOC'>org.apache.juneau.dto.atom</a> 
			- ATOM beans.
		<li><a class='doclink' href='../dto/cognos/package-summary.html#TOC'>org.apache.juneau.dto.cognos</a> 
			- Cognos beans.
		<li><a class='doclink' href='../dto/html5/package-summary.html#TOC'>org.apache.juneau.dto.html5</a> 
			- HTML5 beans.
	</ul>
	<p>
		Refer to the package-level Javadocs for more information about those formats.
	</p>
	
	<h6 class='topic'>Notes about examples</h6>
	<p>
		The examples shown in this document will use single-quote, readable settings.
		<br>For brevity, the examples will use public fields instead of getters/setters to reduce the size of the examples.
		<br>In the real world, you'll typically want to use standard bean getters and setters.
	</p>
	<p>
		To start off simple, we'll begin with the following simplified bean and build upon it.
	</p>
	<p class='bcode'>
	<jk>public class</jk> Person {
		<jc>// Bean properties</jc>
		<jk>public int</jk> <jf>id</jf>;
		<jk>public</jk> String <jf>name</jf>;

		<jc>// Bean constructor (needed by parser)</jc>
		<jk>public</jk> Person() {}

		<jc>// Normal constructor</jc>
		<jk>public</jk> Person(<jk>int</jk> id, String name) {
			<jk>this</jk>.<jf>id</jf> = id;
			<jk>this</jk>.<jf>name</jf> = name;
		}
	}
	</p>
	<p>
		The following code shows how to convert this to simple XML (no namespaces):
	</p>
	<p class='bcode'>
	<jc>// Create a new serializer with readable output, no namespaces yet.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder()
		.ws()  <jc>// or .useWhitespace(true)</jc>  
		.sq()  <jc>// or .quoteChar('\'')</jc>
		.ns()  <jc>// or .enableNamespaces(false)</jc>
		.build();

	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>);

	<jc>// Serialize the bean to XML.</jc>
	String xml = s.serialize(p);
	</p>
	<p>
		<i>Side note:</i>  Serializers can also be created by cloning existing serializers:
	</p>
	<p class='bcode'>
	<jc>// Create a new serializer with readable output, no namespaces yet, but use cloning method.</jc>
	XmlSerializer s = XmlSerializer.<jsf>DEFAULT_SQ_READABLE</jsf>
		.builder()
		.ns()
		.build();
	</p>
	<p>
		The code above produces the following output:
	</p>
	<p class='bcode'><xt>
	&lt;object&gt;
		&lt;id&gt;<xv>1</xv>&lt;/id&gt;
		&lt;name&gt;<xv>John Smith</xv>&lt;/name&gt;
	&lt;/object&gt;
	</xt></p>
	<p>
		The first thing you may notice is how the bean instance is represented by the element <xt>&lt;object&gt;</xt>.
		<br>When objects have no name associated with them, Juneau provides a default generalized name that maps to the 
		equivalent JSON data type.
		<br>Some cases when objects do not have names:
	</p>
	<ul>
		<li>Root element
		<li>Object in an array, collection, or map.
	</ul>
	<p>
		The generalized name reflects the JSON-equivalent data type.
		<br>Juneau produces JSON-equivalent XML, meaning any valid JSON document can be losslessly converted into an XML 
		equivalent.
		<br>In fact, all of the Juneau serializers and parsers are built upon this JSON-equivalence.
	</p>

	
	<!-- ======================================================================================================== -->
	<a id="Methodology"></a>
	<h3 class='topic' onclick='toggle(this)'>2.1 - XML support methodology</h3>
	<div class='topic'>
		<p>
			The following examples show how different data types are represented in XML.
			They mirror how the data structures are represented in JSON.
		</p>
		
		<h6 class='topic'>Simple types</h6>
		<p>
			The representation of loose (not a direct bean property value) simple types are shown below:
		</p>
		<table class='styled' style='width:auto'>
			<tr>
				<th>Data type</th>
				<th>JSON example</th>
				<th>XML</th>
			</tr>
			<tr>
				<td>string</td>
				<td class='code'><js>'foo'</js></td>
				<td class='code'><xt>&lt;string&gt;</xt>foo<xt>&lt;/string&gt;</xt></td>
			</tr>
			<tr>
				<td>boolean</td>
				<td class='code'><jk>true</jk></td>
				<td class='code'><xt>&lt;boolean&gt;</xt>true<xt>&lt;/boolean&gt;</xt></td>
			</tr>
			<tr>
				<td>integer</td>
				<td class='code'>123</td>
				<td class='code'><xt>&lt;number&gt;</xt>123<xt>&lt;/number&gt;</xt></td>
			</tr>
			<tr>
				<td>float</td>
				<td class='code'>1.23</td>
				<td class='code'><xt>&lt;number&gt;</xt>1.23<xt>&lt;/number&gt;</xt></td>
			</tr>
			<tr>
				<td>null</td>
				<td class='code'><jk>null</jk></td>
				<td class='code'><xt>&lt;null/&gt;</xt></td>
			</tr>
		</table>
		
		<h6 class='topic'>Maps</h6>
		<p>
			Loose maps and beans use the element <xt>&lt;object&gt;</xt> for encapsulation.
		</p>
		<p>
			<xa>_type</xa> attributes are added to bean properties or map entries if the type cannot be inferred 
			through reflection (e.g. an <code>Object</code> or superclass/interface value type).
		</p>
		<table class='styled' style='width:auto'>
			<tr>
				<th>Data type</th>
				<th>JSON example</th>
				<th>XML</th>
			</tr>
			<tr>
				<td class='code'>
	Map&lt;String,String&gt;
				</td>
				<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: <jk>null</jk>
	}
				</td>
				<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>v1</xv>&lt;/k1&gt;
		&lt;k2 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
			</xt></td>
			</tr>
			<tr>
				<td class='code'>
	Map&lt;String,Number&gt;
				</td>
				<td class='code'>
	{
		k1: 123,
		k2: 1.23,
		k3: <jk>null</jk>
	}
				</td>
				<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>123</xv>&lt;/k1&gt;
		&lt;k2&gt;<xv>1.23</xv>&lt;/k2&gt;
		&lt;k3 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	Map&lt;String,Object&gt;
				</td>
				<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: 123,
		k3: 1.23,
		k4: <jk>true</jk>,
		k5: <jk>null</jk>
	}
				</td>
				<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>v1</xv>&lt;/k1&gt;
		&lt;k2 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;k3 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>1.23</xv>&lt;/k3&gt;
		&lt;k4 <xa>_type</xa>=<xs>'boolean'</xs>&gt;<xv>true</xv>&lt;/k4&gt;
		&lt;k5 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
				</xt></td>
			</tr>
		</table>
		
		<h6 class='topic'>Arrays</h6>
		<p>
			Loose collections and arrays use the element <xt>&lt;array&gt;</xt> for encapsulation.
		</p>
		<table class='styled' style='width:auto'>
			<tr>
				<th>Data type</th>
				<th>JSON example</th>
				<th>XML</th>
			</tr>
			<tr>
				<td class='code'>
	String[]
				</td>
				<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	Number[]
				</td>
				<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	Object[]
				</td>
				<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	String[][]
				</td>
				<td class='code'>
	[
		[<js>'foo'</js>, <jk>null</jk>],
		<jk>null</jk>,
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;array&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;null/&gt;
		&lt;/array&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	<jk>int</jk>[]
				</td>
				<td class='code'>
	[
		123
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	<jk>boolean</jk>[]
				</td>
				<td class='code'>
	[
		<jk>true</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	List&lt;String&gt;
				</td>
				<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	List&lt;Number&gt;
				</td>
				<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
			<tr>
				<td class='code'>
	List&lt;Object&gt;
				</td>
				<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
				</td>
				<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/array&gt;
				</xt></td>
			</tr>
		</table>

		<h6 class='topic'>Beans</h6>
		<table class='styled' style='width:auto'>
			<tr>
				<th>Data type</th>
				<th>JSON example</th>
				<th>XML</th>
			</tr>
			<tr>
				<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> String a;
		<jk>public</jk> <jk>int</jk> b;
		<jk>public</jk> Object c;  <jc>// String value</jc>
		<jk>public</jk> Object d;  <jc>// Integer value</jc>  	
		<jk>public</jk> MyBean2 e;  
		<jk>public</jk> String[] f;  
	 	<jk>public</jk> <jk>int</jk>[] g;  	
	}
	<jk>class</jk> MyBean2 {
		String h;  
	}
				</td>
				<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123,
		c: <js>'bar'</js>,
		d: 456,
		e: {
			h: <js>'baz'</js>
		}
		f: [<js>'qux'</js>]
		g: [789]
	}
				</td>
				<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
		&lt;c&gt;<xv>bar</xv>&lt;/c&gt;
		&lt;d <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>456</xv>&lt;/d&gt;
		&lt;e&gt;
			&lt;h&gt;<xv>baz</xv>&lt;/h&gt;
		&lt;/e&gt;
		&lt;f&gt;
			&lt;string&gt;<xv>qux</xv>&lt;/string&gt;
		&lt;/f&gt;
		&lt;g&gt;
			&lt;number&gt;<xv>789</xv>&lt;/number&gt;
		&lt;/g&gt;
	&lt;/object&gt;
				</xt></td>
			</tr>
		</table>
		
		<h6 class='topic'>Beans with Map properties</h6>
		<table class='styled' style='width:auto'>
			<tr>
				<th>Data type</th>
				<th>JSON example</th>
				<th>XML</th>
			</tr>
			<tr>
				<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> Map&lt;String,String&gt; a;
		<jk>public</jk> Map&lt;String,Number&gt; b;
		<jk>public</jk> Map&lt;String,Object&gt; c; 
	}
				</td>
				<td class='code'>
	{
		a: {
			k1: <js>'foo'</js>
		},
		b: {
			k2: 123
		},
		c: {
			k3: <js>'bar'</js>,
			k4: 456,
			k5: <jk>true</jk>,
			k6: <jk>null</jk>
		}
	}
				</td>
				<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;<xv>foo</xv>&lt;/k1&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;k2&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;/b&gt;
		&lt;c&gt;
			&lt;k3&gt;<xv>bar</xv>&lt;/k3&gt;
			&lt;k4 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>456</xv>&lt;/k4&gt;
			&lt;k5 <xa>_type</xa>=<xs>'boolean'</xs>&gt;<xv>true</xv>&lt;/k5&gt;
			&lt;k6 <xa>_type</xa>=<xs>'null'</xs>/&gt;
		&lt;/c&gt;
	&lt;/object&gt;
				</xt></td>
			</tr>
		</table>
	</div>
		
		
	<!-- ======================================================================================================== -->
	<a id="XmlAnnotation"></a>
	<h3 class='topic' onclick='toggle(this)'>2.2 - @Xml annotations</h3>
	<div class='topic'>
		<p>
			Just because Juneau allows you to serialize ordinary POJOs to XML doesn't mean you are limited to just 
			JSON-equivalent XML.
			<br>Several annotations are provided in the <a class='doclink' href='annotation/package-summary.html#TOC'>
			org.apache.juneau.xml.annotation</a> package for customizing the output.
		</p>

		<!-- ======================================================================================================== -->
		<a id="XmlName"></a>
		<h4 class='topic' onclick='toggle(this)'>2.2.1 - @Bean.typeName()</h4>
		<div class='topic'>
			<p>
				The {@link org.apache.juneau.annotation.Bean#typeName() @Bean.typeName()} annotation can be used to 
				override the Juneau default name on bean elements. 
				Types names serve two distinct purposes:
			</p>
			<ol>
				<li>To override the element name.
				<li>To serve as a class identifier so that the bean class can be inferred during parsing if it
					cannot automatically be inferred through reflection.
			</ol>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String a;
		<jk>public int</jk> b;
	}	
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/id&gt;
		&lt;b&gt;<xv>123</xv>&lt;/name&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;X&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/id&gt;
		&lt;b&gt;<xv>123</xv>&lt;/name&gt;
	&lt;/X&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				On bean properties, a <xa>_type</xa> attribute will be added if a type name is present and the bean 
				class cannot be inferred through reflection.
			</p>
			<p>
				In the following example, a type attribute is used on property 'b' but not property 'a' since
				'b' is of type <code>Object</code> and therefore the bean class cannot be inferred.
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Java</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> BeanX a = <jk>new</jk> BeanX();
		<jk>public</jk> Object b = <jk>new</jk> BeanX();
	}
	
	<ja>@Bean</ja>(typeName=<js>"X"</js>)
	<jk>class</jk> BeanX {
		<jk>public</jk> String fx = <js>"foo"</js>;
	}
		
					</td>
					<td class='code'><xt>
&lt;object&gt;
	&lt;a&gt;
		&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
	&lt;/a&gt;
	&lt;b&gt;
		&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
	&lt;/b&gt;
&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
&lt;object&gt;
	&lt;a&gt;
		&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
	&lt;/a&gt;
	&lt;b <xa>_type</xa>=<xs>'X'</xs>&gt;
		&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
	&lt;/b&gt;
&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<ul class='doctree'>
				<li class='info'>
					<code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code>, 
					<code>array</code>, and <code>null</code> are reserved keywords that cannot be used as type names.
			</ul>
			<p>
				Beans with type names are often used in conjunction with the 
				{@link org.apache.juneau.annotation.Bean#beanDictionary() @Bean.beanDictionary()} and 
				{@link org.apache.juneau.annotation.BeanProperty#beanDictionary() @BeanProperty.beanDictionary()} 
				annotations so that the beans can be resolved at parse time.  
				These annotations are not necessary during serialization, but are needed during parsing in order to 
				resolve the bean types.
			</p>
			<p>
				The following examples show how type names are used under various circumstances.  
			</p>
			<p>
				Pay special attention to when <xa>_type</xa> attributes are and are not used.
			</p>
			
			<h6 class='figure'>Examples</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Java</th>
					<th>XML</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWithArrayPropertiesWithTypeNames {
		<jk>public</jk> BeanX[] b1 = <jk>new</jk> BeanX[]{ 
			<jk>new</jk> BeanX() 
		};
		<jk>public</jk> Object[] b2 = <jk>new</jk> BeanX[]{ 
			<jk>new</jk> BeanX() 
		};
		<jk>public</jk> Object[] b3 = <jk>new</jk> Object[]{ 
			<jk>new</jk> BeanX() 
		};
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b2&gt;
		&lt;b3&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b3&gt;
	&lt;/object&gt;
					</xt></td>				
				</tr>				
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWith2dArrayPropertiesWithTypeNames {
		<jk>public</jk> BeanX[][] b1 = <jk>new</jk> BeanX[][]{{
			<jk>new</jk> BeanX()
		}};
		<jk>public</jk> Object[][] b2 = <jk>new</jk> BeanX[][]{{
			<jk>new</jk> BeanX()
		}};
		<jk>public</jk> Object[][] b3 = <jk>new</jk> Object[][]{{
			<jk>new</jk> BeanX()
		}};
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b2&gt;
		&lt;b3&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b3&gt;
	&lt;/object&gt;
					</xt></td>				
				</tr>		
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWithMapPropertiesWithTypeNames {
		<jk>public</jk> Map&lt;String,BeanX&gt; b1 = <jk>new</jk> HashMap&lt;&gt;() {{ 
			put(<js>"k1"</js>, <jk>new</jk> BeanX()); 
		}};
		<jk>public</jk> Map&lt;String,Object&gt; b2 = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k2"</js>, <jk>new</jk> BeanX());
		}}
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;k1&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/k1&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;k2 <xa>_type</xa>=<xs>'X'</xs>&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/k2&gt;
		&lt;/b2&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				Bean type names are also used for resolution when abstract fields are used.
				The following examples show how they are used in a variety of circumstances.
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Java</th>
					<th>XML</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractFields {
		<jk>public</jk> A a = <jk>new</jk> A();
		<jk>public</jk> IA ia = <jk>new</jk> A();
		<jk>public</jk> AA aa = <jk>new</jk> A();
		<jk>public</jk> Object o = <jk>new</jk> A();
	}
	
	<jk>interface</jk> IA {}
	
	<jk>abstract class</jk> AA <jk>implements</jk> IA {}

	<ja>@Bean</ja>(typeName=<js>"A"</js>)
	<jk>class</jk> A <jk>extends</jk> AA {
		<jk>public</jk> String fa = <js>"foo"</js>;
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/a&gt;
		&lt;ia <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/ia&gt;
		&lt;aa <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/aa&gt;
		&lt;o <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/o&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractArrayFields {
		<jk>public</jk> A[] a = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> IA[] ia1 = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> IA[] ia2 = <jk>new</jk> IA[]{<jk>new</jk> A()};
		<jk>public</jk> AA[] aa1 = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> AA[] aa2 = <jk>new</jk> AA[]{<jk>new</jk> A()};
		<jk>public</jk> Object[] o1 = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> Object[] o2 = <jk>new</jk> Object[]{<jk>new</jk> A()};
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/a&gt;
		&lt;ia1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/ia1&gt;
		&lt;ia2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/ia2&gt;
		&lt;aa1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/aa1&gt;
		&lt;aa2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/aa2&gt;
		&lt;o1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/o1&gt;
		&lt;o2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/o2&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractMapFields {
		<jk>public</jk> Map&lt;String,A&gt; a = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k1"</js>, <jk>new</jk> A());
		}};
		<jk>public</jk> Map&lt;String,AA&gt; b = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k2"</js>, <jk>new</jk> A());
		}};
		<jk>public</jk> Map&lt;String,Object&gt; c = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k3"</js>, <jk>new</jk> A());
		}};
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k1&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;k2 <xa>_type</xa>=<xs>'A'</xs>&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k2&gt;
		&lt;/b&gt;
		&lt;c&gt;
			&lt;k3 <xa>_type</xa>=<xs>'A'</xs>&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k3&gt;
		&lt;/c&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(beanDictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractMapArrayFields {
		<jk>public</jk> Map&lt;String,A[]&gt; a = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"a1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,IA[]&gt; ia = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"ia1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"ia2"</js>, <jk>new</jk> IA[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,AA[]&gt; aa = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"aa1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"aa2"</js>, <jk>new</jk> AA[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,Object[]&gt; o = <jk>new</jk>LinkedHashMap&lt;&gt;() {{
			put(<js>"o1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"o2"</js>, <jk>new</jk> AA[]{<jk>new</jk> A()});
		}};
	}
					</td>				
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;a1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/a1&gt;
		&lt;/a&gt;
		&lt;ia&gt;
			&lt;ia1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/ia1&gt;
			&lt;ia2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/ia2&gt;
		&lt;/ia&gt;
		&lt;aa&gt;
			&lt;aa1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/aa1&gt;
			&lt;aa2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/aa2&gt;
		&lt;/aa&gt;
		&lt;o&gt;
			&lt;o1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/o1&gt;
			&lt;o2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/o2&gt;
		&lt;/o&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				On a side note, characters that cannot be represented in XML 1.0 are encoded using a simple encoding.
				Note in the examples below, some characters such as <js>'\n'</js>, <js>'\t</js>', and <js>'\r'</js>
				can be represented as XML entities when used in text but not in element names.  Other characters such as
				<js>'\b'</js> and <js>'\f'</js> cannot be encoded in XML 1.0 at all without inventing our own notation.
				Whitespace characters in element names are encoded as well as whitespace end characters in text.
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Java</th>
					<th>XML</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> BeanWithSpecialCharacters {
		<jk>public</jk> String a = <js>"  \b\f\n\t\r  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>_x0020_ _x0008__x000C_&amp;#x000a;&amp;#x0009;&amp;#x000d; _x0020_</xv>&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"  \b\f\n\t\r  "</js>)
	<jk>class</jk> BeanWithNamesWithSpecialCharacters {
		<ja>@BeanProperty</ja>(name=<js>"  \b\f\n\t\r  "</js>)
		<jk>public</jk> String a = <js>"  \b\f\n\t\r  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
		&lt;_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;<xv>_x0020_ _x0008__x000C_&amp;#x000a;&amp;#x0009;&amp;#x000d; _x0020_</xv>&lt;/_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
	&lt;/_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				While it's true that these characters CAN be represented in XML 1.1, it's impossible to parse XML 1.1 
				text in Java without the XML containing an XML declaration.
				Unfortunately, this, and the uselessness of the 
				{@link javax.xml.stream.XMLInputFactory#IS_REPLACING_ENTITY_REFERENCES} setting in Java
				forced us to make some hard design decisions that may not be the most elegant.
			</p>
		</div>
		

		<!-- ======================================================================================================== -->
		<a id="XmlChildName"></a>
		<h4 class='topic' onclick='toggle(this)'>2.2.2 - @Xml.childName()</h4>
		<div class='topic'>		
			<p>
				The {@link org.apache.juneau.xml.annotation.Xml#childName() @Xml.childName()} annotation can be used to 
				specify the name of XML child elements for bean properties of type collection or array.
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"X"</js>)
		<jk>public</jk> String[] a;
		<ja>@Xml</ja>(childName=<js>"Y"</js>)
		<jk>public</jk> int[] b;
	}
					</td>
					<td class='code'>
	{
		a: [<js>'foo'</js>,<js>'bar'</js>],
		b: [123,456]
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;number&gt;<xv>123</xv>&lt;/number&gt;
			&lt;number&gt;<xv>456</xv>&lt;/number&gt;
		&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;X&gt;<xv>foo</xv>&lt;/X&gt;
			&lt;X&gt;<xv>bar</xv>&lt;/X&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;Y&gt;<xv>123</xv>&lt;/Y&gt;
			&lt;Y&gt;<xv>456</xv>&lt;/Y&gt;
		&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"child"</js>)
		<jk>public</jk> int[] a;
	}
					</td>
					<td class='code'>
	{
		a: [123,456]
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;child&gt;<xv>foo</xv>&lt;/child&gt;
			&lt;child&gt;<xv>bar</xv>&lt;/child&gt;
		&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
		</div>
			

		<!-- ======================================================================================================== -->
		<a id="XmlFormat"></a>
		<h4 class='topic' onclick='toggle(this)'>2.2.3 - @Xml.format()</h4>
		<div class='topic'>
			<p>
				The {@link org.apache.juneau.xml.annotation.Xml#format() @Xml.format()} annotation can be used to tweak 
				the XML format of a POJO.
				<br>The value is set to an enum value of type {@link org.apache.juneau.xml.annotation.XmlFormat}.
				<br>This annotation can be applied to both classes and bean properties.
			</p>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTR} format can be applied to bean properties to 
				serialize them as XML attributes instead of elements.
				<br>Note that this only supports properties of simple types (e.g. strings, numbers, booleans).
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String a;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>/&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format can be applied to bean classes to 
				force all bean properties to be serialized as XML attributes instead of child elements.
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String a;
		<jk>public int</jk> b;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs> <xa>b</xa>=<xs>'123'</xs>/&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENT} format can be applied to bean properties 
				to override the {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format applied on the bean 
				class.
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String a;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENT</jsf>)
		<jk>public int</jk> b;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs></xs>&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format can be applied to a single bean 
				property of type <code>Map&lt;String,Object&gt;</code> to denote arbitrary XML attribute values on the 
				element.
				<br>These can be mixed with other {@link org.apache.juneau.xml.annotation.XmlFormat#ATTR} annotated 
				properties, but there must not be an overlap in bean property names and map keys. 
			</p>
			
			<h6 class='figure'>Example</h6>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
		<jk>public</jk> Map&lt;String,Object&gt; a;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public int</jk> b;
	}
					</td>
					<td class='code'>
	{
		a: {
			k1: <js>'foo'</js>, 
			k2: 123, 
		},
		b: 456
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;<xv>foo</xv>&lt;/k1&gt;
			&lt;k2 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;/a&gt;
		&lt;b&gt;<xv>456</xv>&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object <xa>k1</xa>=<xs>'foo'</xs> <xa>k2</xa>=<xs>'123'</xs> <xa>b</xa>=<xs>'456'</xs>/&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#COLLAPSED} format can be applied to bean properties
				of type array/Collection.
				<br>This causes the child objects to be serialized directly inside the bean element.
				<br>This format must be used in conjunction with {@link org.apache.juneau.xml.annotation.Xml#childName()}
				to differentiate which collection the values came from if you plan on parsing the output back into beans.
				<br>Note that child names must not conflict with other property names.
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotation</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"A"</js>,format=XmlFormat.<jsf>COLLAPSED</jsf>)
		<jk>public</jk> String[] a;
		<ja>@Xml</ja>(childName=<js>"B"</js>,format=XmlFormat.<jsf>COLLAPSED</jsf>)
		<jk>public int</jk>[] b;
	}
					</td>
					<td class='code'>
	{
		a: [<js>'foo'</js>,<js>'bar'</js>],
		b: [123,456]
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;number&gt;<xv>123</xv>&lt;/number&gt;
			&lt;number&gt;<xv>456</xv>&lt;/number&gt;
		&lt;/b&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;A&gt;<xv>foo</xv>&lt;/A&gt;
		&lt;A&gt;<xv>bar</xv>&lt;/A&gt;
		&lt;B&gt;<xv>123</xv>&lt;/B&gt;
		&lt;B&gt;<xv>456</xv>&lt;/B&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENTS} format can be applied to a single bean 
				property of either a simple type or array/Collection.
				<br>It allows free-form child elements to be formed.
				<br>All other properties on the bean MUST be serialized as attributes.
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>With annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String a;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENTS</jsf>)
		<jk>public</jk> String b;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>,
		b: <js>'bar'</js>
	}
					</td>
					<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>&gt;
		&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String a;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENTS</jsf>)
		<jk>public</jk> Object[] b;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>,
		b: [
			<js>'bar'</js>, 
			<js>'baz'</js>, 
			123, 
			<jk>true</jk>,
			<jk>null</jk>
		]
	}
					</td>
					<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>&gt;
		&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;string&gt;<xv>baz</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} format is similar to 
				{@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENTS} except elements names on primitive types 
				(string/number/boolean/null) are stripped from the output.
				This format particularly useful when combined with bean dictionaries to produce mixed content.  
				<br>The bean dictionary isn't used during serialization, but it is needed during parsing to resolve bean 
				types.
			</p>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED_PWS} format identical to 
				{@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} except whitespace characters are preserved in 
				the output.  
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotations</th>
					<th>With annotations</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<ja>@BeanProperty</ja>(beanDictionary={MyBeanX.<jk>class</jk>, MyBeanY.<jk>class</jk>})	
		<jk>public</jk> Object[] a;
	}
	
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBeanX {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String b;
	}
	
	<ja>@Bean</ja>(typeName=<js>"Y"</js>)	
	<jk>class</jk> MyBeanY {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String c;
	}
					</td>
					<td class='code'>
	{
		a: [
			<js>'foo'</js>,
			{ _type:<js>'X'</js>, b:<js>'bar'</js> }
			<js>'baz'</js>,
			{ _type:<js>'Y'</js>, b:<js>'qux'</js> },
			<js>'quux'</js>
		]
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;object&gt;
				&lt;b&gt;<xv>bar</xv>&lt;/b&gt;
			&lt;/object&gt;
			&lt;string&gt;<xv>baz</xv>&lt;/string&gt;
			&lt;object&gt;
				&lt;b&gt;<xv>qux</xv>&lt;/b&gt;
			&lt;/object&gt;
			&lt;string&gt;<xv>quux</xv>&lt;/string&gt;
		&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;<xv>foo</xv>&lt;X <xa>b</xa>=<xs>'bar'</xs>/&gt;<xv>baz</xv>&lt;Y <xa>c</xa>=<xs>'qux'</xs>/&gt;<xv>quux</xv>&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				Whitespace (tabs and newlines) are not added to MIXED child nodes in readable-output mode. 
				This helps ensures strings in the serialized output can be losslessly parsed back into their original 
				forms when they contain whitespace characters.
				If the {@link javax.xml.stream.XMLInputFactory#IS_REPLACING_ENTITY_REFERENCES} setting was not useless 
				in Java, we could support lossless readable XML for MIXED content.  
				But as of Java 8, it still does not work. 
			</p>
			<p>
				XML suffers from other deficiencies as well that affect MIXED content.  
				For example, <xt>&lt;X&gt;&lt;/X&gt;</xt> and <xt>&lt;X/&gt;</xt> are equivalent in XML and 
				indistinguishable by the Java XML parsers.  
				This makes it impossible to differentiate between an empty element and an element containing an empty 
				string.  
				This causes empty strings to get lost in translation. 
				To alleviate this, we use the constructs <js>"_xE000_"</js> to represent an empty string, and 
				<js>"_x0020_"</js> to represent leading and trailing spaces.
			</p>
			<p>
				The examples below show how whitespace is handled under various circumstances:
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>XML</th>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a = <jk>null</jk>;
	}
					</td>
					<td class='code'><xt>
	&lt;X/&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a = <js>""</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a = <js>" "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a = <js>"  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020__x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a = <js>"  foobar  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_ foobar _x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String a = <jk>null</jk>;
	}
					</td>
					<td class='code'><xt>
	&lt;X/&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String a = <js>""</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String a = <js>" "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv> </xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String a = <js>"  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>  </xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String a = <js>"  foobar  "</js>;
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>  foobar  </xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] a = <jk>null</jk>;
	}
					</td>
					<td class='code'><xt>
	&lt;X/&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>""</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>" "</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>"  "</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020__x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{
			<js>"  foobar  "</js>
		};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_ foobar _x0020_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] a = <jk>null</jk>;
	}
					</td>
					<td class='code'><xt>
	&lt;X/&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>""</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>" "</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv> </xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{<js>"  "</js>};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>  </xv>&lt;/X&gt;
					</xt></td>
				</tr>
				<tr>
					<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String a[] = <jk>new</jk> String[]{
			<js>"  foobar  "</js>
		};
	}
					</td>
					<td class='code'><xt>
	&lt;X&gt;<xv>  foobar  </xv>&lt;/X&gt;
					</xt></td>
				</tr>
			</table>
			
			<p>
				It should be noted that when using <jsf>MIXED</jsf>, you are not guaranteed to parse back the exact 
				same content since side-by-side strings in the content will end up concatenated when parsed.
			</p>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} format is similar to 
				{@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} except it's meant for solitary objects that 
				get serialized as simple child text nodes.
				<br>Any object that can be serialize to a <code>String</code> can be used.
				<br>The {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT_PWS} is the same except whitespace is 
				preserved in the output.
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>Without annotations</th>
					<th>With annotations</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String a;
	}
					</td>
					<td class='code'>
	{
		a: <js>'foo'</js>
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
	&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;<xv>foo</xv>&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
			<p>
				The {@link org.apache.juneau.xml.annotation.XmlFormat#XMLTEXT} format is similar to 
				{@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} except it's meant for strings containing XML 
				that should be serialized as-is to the document.
				<br>Any object that can be serialize to a <code>String</code> can be used.
				<br>During parsing, the element content gets parsed with the rest of the document and then re-serialized to 
				XML before being set as the property value.  
				This process may not be perfect (e.g. double quotes may be replaced by single quotes, etc...).
			</p>
			<table class='styled' style='width:auto'>
				<tr>
					<th>Data type</th>
					<th>JSON example</th>
					<th>With TEXT annotation</th>
					<th>With XMLTEXT annotation</th>
				</tr>
				<tr>
					<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>XMLTEXT</jsf>)
		<jk>public</jk> String a;
	}
					</td>
					<td class='code'>
	{
		a: <js>'Some &lt;b&gt;XML&lt;/b&gt; text'</js>
	}
					</td>
					<td class='code'><xt>
	&lt;object&gt;<xv>Some &amp;lt;b&amp;gt;XML&amp;lt;/b&amp;gt; text</xv>&lt;/object&gt;
					</xt></td>
					<td class='code'><xt>
	&lt;object&gt;<xv>Some <xt>&lt;b&gt;</xt>XML<xt>&lt;/b&gt;</xt> text</xv>&lt;/object&gt;
					</xt></td>
				</tr>
			</table>
		</div>
	</div>


	<!-- ======================================================================================================== -->
	<a id="Namespaces"></a>
	<h3 class='topic' onclick='toggle(this)'>2.3 - Namespaces</h3>
	<div class='topic'>
		<p>
			Let's go back to the example of our original <code>Person</code> bean class:
		</p>
		<p class='bcode'>
		<jk>public class</jk> Person {
			<jc>// Bean properties</jc>
			<jk>public int</jk> <jf>id</jf>;
			<jk>public</jk> String <jf>name</jf>;
	
			<jc>// Bean constructor (needed by parser)</jc>
			<jk>public</jk> Person() {}
	
			<jc>// Normal constructor</jc>
			<jk>public</jk> Person(<jk>int</jk> id, String name) {
				<jk>this</jk>.<jf>id</jf> = id;
				<jk>this</jk>.<jf>name</jf> = name;
			}
		}
		</p>
		<p>
			However, this time we'll leave namespaces enabled on the serializer:
		</p>
		<p class='bcode'>
	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	<jc>// Note that this is identical to XmlSerializer.DEFAULT_NS_SQ_READABLE.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder().ns().ws().sq().build();

	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>);

	<jc>// Serialize the bean to XML.</jc>
	String xml = s.serialize(p);
		</p>
		<p>
			Now when we run this code, we'll see namespaces added to our output:
		</p>
		<p class='bcode'>
	<xt>&lt;object</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs><xt>&gt;</xt>
		<xt>&lt;id&gt;</xt>1<xt>&lt;/id&gt;</xt>
		<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
	<xt>&lt;/object&gt;</xt>
		</p>
		<p>
			This isn't too exciting yet since we haven't specified any namespaces yet.
			<br>Therefore, everything is defined under the default <code>Juneau</code> namespace.
		</p>
		<p>
			Namespaces can be defined at the following levels:
		</p>
		<ul class='spaced-list'>
			<li>
				At the package level by using the {@link org.apache.juneau.xml.annotation.XmlSchema @XmlSchema} 
				annotation.
			<li>
				At the class level by using the {@link org.apache.juneau.xml.annotation.Xml @Xml} annotation.
			<li>
				At the bean property level by using the {@link org.apache.juneau.xml.annotation.Xml @Xml} annotation.
		</ul>
		<p>
			It's typically best to specify the namespaces used at the package level.
			<br>We'll do that here for the package containing our test code.
		</p>
		<p class='bcode'>
	<jc>// XML namespaces used in this package</jc>
	<ja>@XmlSchema</ja>(
		prefix=<js>"ab"</js>,
		xmlNs={
			<ja>@XmlNs</ja>(prefix=<js>"ab"</js>, namespaceURI=<js>"http://www.apache.org/addressBook/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"per"</js>, namespaceURI=<js>"http://www.apache.org/person/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"addr"</js>, namespaceURI=<js>"http://www.apache.org/address/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"mail"</js>, namespaceURI=<js>"http://www.apache.org/mail/"</js>)
		}
	)
	<jk>package</jk> org.apache.juneau.examples.addressbook;
	<jk>import</jk> org.apache.juneau.xml.annotation.*;
		</p>
		<p>
			We're defining four namespaces in this package and designating <js>"http://www.apache.org/addressBook/"</js> 
			as the default namespace for all classes and properties within this package.
		</p>
		<p>
			Take special note that the <ja>@XmlSchema</ja> is modeled after the equivalent JAXB annotation, but is
			defined in the <a class='doclink' 
			href='annotation/package-summary.html#TOC'>org.apache.juneau.xml.annotation</a> package.
			<br>Other XML annotations are also modeled after JAXB. 
			However, since many of the features of JAXB are already implemented for all serializers and parsers
			at a higher level through various general annotations such as {@link org.apache.juneau.annotation.Bean} 
			and {@link org.apache.juneau.annotation.BeanProperty} it was decided to maintain separate Juneau XML 
			annotations instead of reusing JAXB annotations.
			<br>This may change in some future implementation, but for now it was decided that having separate Juneau XML 
			annotations was less confusing.
		</p>
		<p>
			On our bean class, we'll specify to use the <js>"http://www.apache.org/person/"</js> namespace:
		</p>
		<p class='bcode'>
	<ja>@Xml</ja>(prefix=<js>"per"</js>)
	<ja>@Bean</ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
		...
		</p>
		<p>
			Now when we serialize the bean, we get the following:
		</p>
		<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
		</p>
		<p>
			We can simplify the output by setting the default namespace on the serializer so that all the elements do 
			not need to be prefixed:
		<p class='bcode'>
	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder()
		.ws()
		.sq()
		.ns()
		.defaultNamespaceUri(<js>"http://www.apache.org/person/"</js>)
		.build();
		</p>
		<p>
			This produces the following equivalent where the elements don't need prefixes since they're already in the 
			default document namespace:
		</p>
		<p class='bcode'>
	<xt>&lt;person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/person/'</xs>
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs><xt>&gt;</xt>
		<xt>&lt;id&gt;</xt>1<xt>&lt;/id&gt;</xt>
		<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
	<xt>&lt;/person&gt;</xt>		
		</p>


		<!-- ======================================================================================================== -->
		<a id="AutoDetectNamespaces"></a>
		<h4 class='topic' onclick='toggle(this)'>2.3.1 - Auto-detection of namespaces</h4>
		<div class='topic'>
			<p>
				One important property on the XML serializer class is 
				{@link org.apache.juneau.xml.XmlSerializer#XML_autoDetectNamespaces XML_autoDetectNamespaces}.
				<br>This property tells the serializer to make a first-pass over the data structure to look for namespaces 
				defined on classes and bean properties.
				<br>In high-performance environments, you may want to consider disabling auto-detection and providing your 
				own explicit list of namespaces to the serializer to avoid this scanning step.
			</p>
			<p>
				The following code will produce the same output as before, but will perform slightly better since it 
				avoids this pre-scan step.
			</p>
			<p class='bcode'>
	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder()
		.ws()
		.sq()
		.autoDetectNamespaces(<jk>false</jk>)
		.namespaces(<js>"{per:'http://www.apache.org/person/'}"</js>)
		.build();
			</p>
		</div>
		
	</div>
	
	<!-- ======================================================================================================== -->
	<a id="BeanAnnotations"></a>
	<h3 class='topic' onclick='toggle(this)'>2.4 - @Bean and @BeanProperty annotations</h3>
	<div class='topic'>
		<p>
			The {@link org.apache.juneau.annotation.Bean @Bean} and {@link org.apache.juneau.annotation.BeanProperty @BeanProperty} 
			annotations are used to customize the behavior of beans across the entire framework.
			<br>In addition to using them to identify the resource URI for the bean shown above, they have various other 
			uses:
		</p>
		<ul class='spaced-list'>
			<li>
				Hiding bean properties.
			<li>
				Specifying the ordering of bean properties.
			<li>
				Overriding the names of bean properties.
			<li>
				Associating transforms at both the class and property level (to convert non-serializable POJOs to 
				serializable forms).
		</ul>
		<p>
			For example, we now add a <code>birthDate</code> property, and associate a transform with it to transform
			it to an ISO8601 date-time string in GMT time.
			<br>By default, <code>Calendars</code> are treated as beans by the framework, which is usually not how you want 
			them serialized.
			<br>Using transforms, we can convert them to standardized string forms.
		</p>
		<p class='bcode'>	
	<ja>@Xml</ja>(prefix=<js>"per"</js>)
	<ja>@Bean</ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<ja>@BeanProperty</ja>(swap=CalendarSwap.ISO8601DTZ.<jk>class</jk>) <jk>public</jk> Calendar birthDate;
		...
		
		<jc>// Normal constructor</jc>
		<jk>public</jk> Person(<jk>int</jk> id, String name, String uri, String addressBookUri, String birthDate) 
				<jk>throws</jk> Exception {
			...
			<jk>this</jk>.<jf>birthDate</jf> = <jk>new</jk> GregorianCalendar();
			<jk>this</jk>.<jf>birthDate</jf>
				.setTime(DateFormat.<jsm>getDateInstance</jsm>(DateFormat.<jsf>MEDIUM</jsf>)
				.parse(birthDate));
		}
	}
		</p>
		<p>
			Next, we alter our code to pass in the birthdate:
		</p>
		<p class='bcode'>
	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>, <js>"http://sample/addressBook/person/1"</js>, 
		<js>"http://sample/addressBook"</js>, <js>"Aug 12, 1946"</js>);
		</p>
		<p>
			Now when we rerun the sample code, we'll get the following:
		</p>
		<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:addressBookUri&gt;</xt>http://sample/addressBook<xt>&lt;/per:addressBookUri&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T00:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
		</p>
		<p>
			Another useful feature is the {@link org.apache.juneau.annotation.Bean#propertyNamer()} annotation that 
			allows you to plug in your own logic for determining bean property names.
			<br>The {@link org.apache.juneau.PropertyNamerDLC} is an example of an alternate property namer.
			It converts bean property names to lowercase-dashed format.
		</p>
		
		<h6 class='figure'>Example</h6>
		<p class='bcode'>	
	<ja>@Xml</ja>(prefix=<js>"per"</js>)
	<ja>@Bean</ja>(typeName=<js>"person"</js>,propertyNamer=PropertyNamerDLC.<jk>class</jk>)
	<jk>public class</jk> Person {
		...
		</p>
		
		<h6 class='figure'>Results</h6>
		<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:address-book-uri&gt;</xt>http://sample/addressBook<xt>&lt;/per:address-book-uri&gt;</xt>
		<xt>&lt;per:birth-date&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/per:birth-date&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
		</p>
	</div>
	
		
	<!-- ======================================================================================================== -->
	<a id="Collections"></a>
	<h3 class='topic' onclick='toggle(this)'>2.5 - Collections</h3>
	<div class='topic'>
		<p>
			In our example, let's add a list-of-beans property to our sample class:
		</p>
		<p class='bcode'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> LinkedList&lt;Address&gt; <jf>addresses</jf> = <jk>new</jk> LinkedList&lt;Address&gt;();
		...
	}
		</p>
		<p>
			The <code>Address</code> class has the following properties defined:
		</p>
		<p class='bcode'>
	<ja>@Xml</ja>(prefix=<js>"addr"</js>)
	<ja>@Bean</ja>(typeName=<js>"address"</js>)
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<ja>@Xml</ja>(format=<jsf>ATTR</jsf>) <jk>public</jk> URI <jf>uri</jf>;
		<jk>public</jk> URI <jf>personUri</jf>;
		<jk>public int</jk> <jf>id</jf>;
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public</jk> String <jf>street</jf>, <jf>city</jf>, <jf>state</jf>;
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;
	}
		</p>
		<p>
			Next, add some quick-and-dirty code to add an address to our person bean:
		</p>
		<p class='bcode'>
	<jc>// Create a new serializer with readable output.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder().ws().sq().build();

	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>, <js>"http://sample/addressBook/person/1"</js>, 
		<js>"http://sample/addressBook"</js>, <js>"Aug 12, 1946"</js>);
	Address a = <jk>new</jk> Address();
	a.<jf>uri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/address/1"</js>);
	a.<jf>personUri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/person/1"</js>);
	a.<jf>id</jf> = 1;
	a.<jf>street</jf> = <js>"100 Main Street"</js>;
	a.<jf>city</jf> = <js>"Anywhereville"</js>;
	a.<jf>state</jf> = <js>"NY"</js>;
	a.<jf>zip</jf> = 12345;
	a.<jf>isCurrent</jf> = <jk>true</jk>;
	p.<jf>addresses</jf>.add(a);	
		</p>
		<p>
			Now when we run the sample code, we get the following:
		</p>
		<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:addressBookUri&gt;</xt>http://sample/addressBook<xt>&lt;/per:addressBookUri&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
		<xt>&lt;per:addresses&gt;</xt>
			<xt>&lt;addr:address</xt> <xa>uri</xa>=<xs>'http://sample/addressBook/address/1'</xs><xt>&gt;</xt>
				<xt>&lt;addr:personUri&gt;</xt>http://sample/addressBook/person/1<xt>&lt;/addr:personUri&gt;</xt>
				<xt>&lt;addr:id&gt;</xt>1<xt>&lt;/addr:id&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/per:addresses&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
		</p>
	</div>
	

	<!-- ======================================================================================================== -->
	<a id="XmlSchemaSupport"></a>
	<h3 class='topic' onclick='toggle(this)'>2.6 - XML-Schema support</h3>
	<div class='topic'>
		<p>
			Juneau provides the {@link org.apache.juneau.xml.XmlSchemaSerializer} class for generating XML-Schema 
			documents that describe the output generated by the {@link org.apache.juneau.xml.XmlSerializer} class.
			<br>This class shares the same properties as <code>XmlSerializer</code>.
			<br>Since the XML output differs based on settings on the XML serializer class, the XML-Schema serializer
			class must have the same property values as the XML serializer class it's describes.
			<br>To help facilitate creating an XML Schema serializer with the same properties as the corresponding 
			XML serializer, the {@link org.apache.juneau.xml.XmlSerializer#getSchemaSerializer()} method 
			has been added.
		</p>
		<p>
			XML-Schema requires a separate file for each namespace.
			<br>Unfortunately, does not mesh well with the Juneau serializer architecture which serializes to single writers.
			<br>To get around this limitation, the schema serializer will produce a single output, but with multiple
			schema documents separated by the null character (<js>'\u0000'</js>) to make it simple to split apart.
		</p>
		<p>
			Lets start with an example where everything is in the same namespace.
			<br>We'll use the classes from before, but remove the references to namespaces.
			<br>Since we have not defined a default namespace, everything is defined under the default Juneau namespace.
		</p>
		<p class='bcode'>
	<ja>@Bean</ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
		<jc>// Bean properties</jc>
		<jk>public int</jk> <jf>id</jf>;
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Xml</ja>(format=<jsf>ATTR</jsf>) <jk>public</jk> URI <jf>uri</jf>;
		<jk>public</jk> URI <jf>addressBookUri</jf>;
		<ja>@BeanProperty</ja>(swap=CalendarSwap.ISO8601DTZ.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> LinkedList&lt;Address&gt; <jf>addresses</jf> = <jk>new</jk> LinkedList&lt;Address&gt;();

		<jc>// Bean constructor (needed by parser)</jc>
		<jk>public</jk> Person() {}

		<jc>// Normal constructor</jc>
		<jk>public</jk> Person(<jk>int</jk> id, String name, String uri, String addressBookUri, String birthDate) 
				<jk>throws</jk> Exception {
			<jk>this</jk>.<jf>id</jf> = id;
			<jk>this</jk>.<jf>name</jf> = name;
			<jk>this</jk>.<jf>uri</jf> = <jk>new</jk> URI(uri);
			<jk>this</jk>.<jf>addressBookUri</jf> = <jk>new</jk> URI(addressBookUri);
			<jk>this</jk>.<jf>birthDate</jf> = <jk>new</jk> GregorianCalendar();
			<jk>this</jk>.<jf>birthDate</jf>.setTime(DateFormat.getDateInstance(DateFormat.<jsf>MEDIUM</jsf>).parse(birthDate));
		}
	}

	<ja>@Bean</ja>(typeName=<js>"address"</js>)
	<jk>public class</jk> Address {
		<jc>// Bean properties</jc>
		<ja>@Xml</ja>(format=<jsf>ATTR</jsf>) <jk>public</jk> URI <jf>uri</jf>;
		<jk>public</jk> URI <jf>personUri</jf>;
		<jk>public int</jk> <jf>id</jf>;
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>, <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;
	}
		</p>
		<p>
			The code for creating our POJO model and generating XML Schema is shown below:
		</p>
		<p class='bcode'>
	<jc>// Create a new serializer with readable output.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder()
		.ws()
		.ns()
		.sq()
		.addNamespaceUrisToRoot(<jk>true</jk>)
		.build();

	<jc>// Create the equivalent schema serializer.</jc>
	XmlSchemaSerializer ss = s.getSchemaSerializer();

	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>, <js>"http://sample/addressBook/person/1"</js>, 
		<js>"http://sample/addressBook"</js>, <js>"Aug 12, 1946"</js>);
	Address a = <jk>new</jk> Address();
	a.<jf>uri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/address/1"</js>);
	a.<jf>personUri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/person/1"</js>);
	a.<jf>id</jf> = 1;
	a.<jf>street</jf> = <js>"100 Main Street"</js>;
	a.<jf>city</jf> = <js>"Anywhereville"</js>;
	a.<jf>state</jf> = <js>"NY"</js>;
	a.<jf>zip</jf> = 12345;
	a.<jf>isCurrent</jf> = <jk>true</jk>;
	p.<jf>addresses</jf>.add(a);

	<jc>// Serialize the bean to XML.</jc>
	String xml = s.serialize(p);
	
	<jc>// Get the XML Schema corresponding to the XML generated above.</jc>
	String xmlSchema = ss.serialize(p);
		</p>
		
		<h6 class='figure'>XML results</h6>
		<p class='bcode'>
	<xt>&lt;person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;id&gt;</xt>1<xt>&lt;/id&gt;</xt>
		<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
		<xt>&lt;addressBookUri&gt;</xt>http://sample/addressBook<xt>&lt;/addressBookUri&gt;</xt>
		<xt>&lt;birthDate&gt;</xt>1946-08-12T00:00:00Z<xt>&lt;/birthDate&gt;</xt>
		<xt>&lt;addresses&gt;</xt>
			<xt>&lt;address</xt> <xa>uri</xa>=<xs>'http://sample/addressBook/address/1'</xs><xt>&gt;</xt>
				<xt>&lt;personUri&gt;</xt>http://sample/addressBook/person/1<xt>&lt;/personUri&gt;</xt>
				<xt>&lt;id&gt;</xt>1<xt>&lt;/id&gt;</xt>
				<xt>&lt;street&gt;</xt>100 Main Street<xt>&lt;/street&gt;</xt>
				<xt>&lt;city&gt;</xt>Anywhereville<xt>&lt;/city&gt;</xt>
				<xt>&lt;state&gt;</xt>NY<xt>&lt;/state&gt;</xt>
				<xt>&lt;zip&gt;</xt>12345<xt>&lt;/zip&gt;</xt>
				<xt>&lt;isCurrent&gt;</xt>true<xt>&lt;/isCurrent&gt;</xt>
			<xt>&lt;/address&gt;</xt>
		<xt>&lt;/addresses&gt;</xt>
	<xt>&lt;/person&gt;</xt>				
		</p>
		
		<h6 class='figure'>XML-Schema results</h6>
		<p class='bcode'>
	<xt>&lt;schema</xt> 
			<xa>xmlns</xa>=<xs>'http://www.w3.org/2001/XMLSchema'</xs> 
			<xa>targetNamespace</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>elementFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs><xt>&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'person'</xs> <xa>_type</xa>=<xs>'juneau:org.apache.juneau.examples.addressbook.Person'</xs><xt>/&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'org.apache.juneau.examples.addressbook.Person'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'id'</xs> <xa>_type</xa>=<xs>'integer'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'name'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'addressBookUri'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'birthDate'</xs> <xa>_type</xa>=<xs>'juneau:java.util.Calendar'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'addresses'</xs> <xa>_type</xa>=<xs>'juneau:java.util.LinkedList_x003C_org.apache.juneau.examples.addressbook.Address_x003E_'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
			<xt>&lt;attribute</xt> <xa>name</xa>=<xs>'uri'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.util.Calendar'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;any</xt> <xa>processContents</xa>=<xs>'skip'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.util.LinkedList_x003C_org.apache.juneau.examples.addressbook.Address_x003E_'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;choice</xt> <xa>minOccurs</xa>=<xs>'0'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs><xt>&gt;</xt>
					<xt>&lt;element</xt> <xa>name</xa>=<xs>'address'</xs> <xa>_type</xa>=<xs>'juneau:org.apache.juneau.examples.addressbook.Address'</xs><xt>/&gt;</xt>
					<xt>&lt;element</xt> <xa>name</xa>=<xs>'null'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
				<xt>&lt;/choice&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'org.apache.juneau.examples.addressbook.Address'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'personUri'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'id'</xs> <xa>_type</xa>=<xs>'integer'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'street'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'city'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'state'</xs> <xa>_type</xa>=<xs>'string'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'zip'</xs> <xa>_type</xa>=<xs>'integer'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
				<xt>&lt;element</xt> <xa>name</xa>=<xs>'isCurrent'</xs> <xa>_type</xa>=<xs>'boolean'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
			<xt>&lt;attribute</xt> <xa>name</xa>=<xs>'uri'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
	<xt>&lt;/schema&gt;</xt>
		</p>
		<p>
			Now if we add in some namespaces, we'll see how multiple namespaces are handled.
		</p>
		<p class='bcode'>
	<ja>@Xml</ja></ja>(prefix=<js>"per"</js>)
	<ja>@Bean</ja></ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
	...
	}

	<ja>@Xml</ja>(prefix=<js>"addr"</js>)
	<ja>@Bean</ja>(typeName=<js>"address"</js>)
	<jk>public class</jk> Address {
		...
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public</jk> String <jf>street</jf>, <jf>city</jf>, <jf>state</jf>;
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public int</jk> <jf>zip</jf>;
		...
	}
		</p>
		
		<h6 class='figure'>XML results</h6>
		<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:addressBookUri&gt;</xt>http://sample/addressBook<xt>&lt;/per:addressBookUri&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T00:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
		<xt>&lt;per:addresses&gt;</xt>
			<xt>&lt;addr:address</xt> <xa>uri</xa>=<xs>'http://sample/addressBook/address/1'</xs><xt>&gt;</xt>
				<xt>&lt;addr:personUri&gt;</xt>http://sample/addressBook/person/1<xt>&lt;/addr:personUri&gt;</xt>
				<xt>&lt;addr:id&gt;</xt>1<xt>&lt;/addr:id&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/per:addresses&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
		</p>
		<p>
			The schema consists of 4 documents separated by a <js>'\u0000'</js> character.
		</p>
		
		<h6 class='figure'>XML-Schema results</h6>
		<p class='bcode'>
	<xt>&lt;schema</xt> 
			<xa>xmlns</xa>=<xs>'http://www.w3.org/2001/XMLSchema'</xs> 
			<xa>targetNamespace</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>elementFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs><xt>&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/person/'</xs> <xa>schemaLocation</xa>=<xs>'per.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/address/'</xs> <xa>schemaLocation</xa>=<xs>'addr.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/mail/'</xs> <xa>schemaLocation</xa>=<xs>'mail.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'int'</xs><xt>&gt;</xt>
			<xt>&lt;simpleContent&gt;</xt>
				<xt>&lt;extension</xt> <xa>base</xa>=<xs>'integer'</xs><xt>/&gt;</xt>
			<xt>&lt;/simpleContent&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.lang.String'</xs><xt>&gt;</xt>
			<xt>&lt;simpleContent&gt;</xt>
				<xt>&lt;extension</xt> <xa>base</xa>=<xs>'string'</xs><xt>/&gt;</xt>
			<xt>&lt;/simpleContent&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.net.URI'</xs><xt>&gt;</xt>
			<xt>&lt;simpleContent&gt;</xt>
				<xt>&lt;extension</xt> <xa>base</xa>=<xs>'string'</xs><xt>/&gt;</xt>
			<xt>&lt;/simpleContent&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.util.Calendar'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;any</xt> <xa>processContents</xa>=<xs>'skip'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs> <xa>minOccurs</xa>=<xs>'0'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'java.util.LinkedList_x003C_org.apache.juneau.examples.addressbook.Address_x003E_'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;choice</xt> <xa>minOccurs</xa>=<xs>'0'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs><xt>&gt;</xt>
					<xt>&lt;element</xt> <xa>name</xa>=<xs>'address'</xs> <xa>_type</xa>=<xs>'addr:org.apache.juneau.examples.addressbook.Address'</xs><xt>/&gt;</xt>
					<xt>&lt;element</xt> <xa>name</xa>=<xs>'null'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
				<xt>&lt;/choice&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'boolean'</xs><xt>&gt;</xt>
			<xt>&lt;simpleContent&gt;</xt>
				<xt>&lt;extension</xt> <xa>base</xa>=<xs>'boolean'</xs><xt>/&gt;</xt>
			<xt>&lt;/simpleContent&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
	<xt>&lt;/schema&gt;</xt>
	[\u0000]
	<xt>&lt;schema</xt> 
			<xa>xmlns</xa>=<xs>'http://www.w3.org/2001/XMLSchema'</xs> 
			<xa>targetNamespace</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>elementFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>attributeFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs><xt>&gt;</xt>
		<xt>&lt;impor</xt>t <xa>namespace</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> <xa>schemaLocation</xa>=<xs>'juneau.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/address/'</xs> <xa>schemaLocation</xa>=<xs>'addr.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/mail/'</xs> <xa>schemaLocation</xa>=<xs>'mail.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'person'</xs> <xa>_type</xa>=<xs>'per:org.apache.juneau.examples.addressbook.Person'</xs><xt>/&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'org.apache.juneau.examples.addressbook.Person'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;any</xt> <xa>minOccurs</xa>=<xs>'0'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
			<xt>&lt;attribute</xt> <xa>name</xa>=<xs>'uri'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'id'</xs> <xa>_type</xa>=<xs>'juneau:int'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'name'</xs> <xa>_type</xa>=<xs>'juneau:java.lang.String'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'addressBookUri'</xs> <xa>_type</xa>=<xs>'juneau:java.net.URI'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'birthDate'</xs> <xa>_type</xa>=<xs>'juneau:java.util.Calendar'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'addresses'</xs> <xa>_type</xa>=<xs>'juneau:java.util.LinkedList_x003C_org.apache.juneau.examples.addressbook.Address_x003E_'</xs><xt>/&gt;</xt>
	<xt>&lt;/schema&gt;</xt>
	[\u0000]
	<xt>&lt;schema</xt> 
			<xa>xmlns</xa>=<xs>'http://www.w3.org/2001/XMLSchema'</xs> 
			<xa>targetNamespace</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>elementFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>attributeFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs><xt>&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> <xa>schemaLocation</xa>=<xs>'juneau.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/person/'</xs> <xa>schemaLocation</xa>=<xs>'per.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/mail/'</xs> <xa>schemaLocation</xa>=<xs>'mail.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;complexType</xt> <xa>name</xa>=<xs>'org.apache.juneau.examples.addressbook.Address'</xs><xt>&gt;</xt>
			<xt>&lt;sequence&gt;</xt>
				<xt>&lt;any</xt> <xa>minOccurs</xa>=<xs>'0'</xs> <xa>maxOccurs</xa>=<xs>'unbounded'</xs><xt>/&gt;</xt>
			<xt>&lt;/sequence&gt;</xt>
			<xt>&lt;attribute</xt> <xa>name</xa>=<xs>'uri'</xs> <xa>_type</xa>=<xs>'string'</xs><xt>/&gt;</xt>
		<xt>&lt;/complexType&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'personUri'</xs> <xa>_type</xa>=<xs>'juneau:java.net.URI'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'id'</xs> <xa>_type</xa>=<xs>'juneau:int'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'isCurrent'</xs> <xa>_type</xa>=<xs>'juneau:boolean'</xs><xt>/&gt;</xt>
	<xt>&lt;/schema&gt;</xt>
	[\u0000]
	<xt>&lt;schema</xt> 
			<xa>xmlns</xa>=<xs>'http://www.w3.org/2001/XMLSchema'</xs> 
			<xa>targetNamespace</xa>=<xs>'http://www.apache.org/mail/'</xs> 
			<xa>elementFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>attributeFormDefault</xa>=<xs>'qualified'</xs> 
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs><xt>&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> <xa>schemaLocation</xa>=<xs>'juneau.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/person/'</xs> <xa>schemaLocation</xa>=<xs>'per.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;import</xt> <xa>namespace</xa>=<xs>'http://www.apache.org/address/'</xs> <xa>schemaLocation</xa>=<xs>'addr.xsd'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'street'</xs> <xa>_type</xa>=<xs>'juneau:java.lang.String'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'city'</xs> <xa>_type</xa>=<xs>'juneau:java.lang.String'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'state'</xs> <xa>_type</xa>=<xs>'juneau:java.lang.String'</xs><xt>/&gt;</xt>
		<xt>&lt;element</xt> <xa>name</xa>=<xs>'zip'</xs> <xa>_type</xa>=<xs>'juneau:int'</xs><xt>/&gt;</xt>
	<xt>&lt;/schema&gt;</xt>	
		</p>
		<p>
			For convenience, the {@link org.apache.juneau.xml.XmlSchemaSerializer
			#getValidator(SerializerSession,Object)} method is provided to create a 
			{@link javax.xml.validation.Validator} using the input from the serialize method.
		</p>
	</div>


	<!-- ======================================================================================================== -->
	<a id="Recursion"></a>
	<h3 class='topic' onclick='toggle(this)'>2.7 - Non-tree models and recursion detection</h3>
	<div class='topic'>
		<p>
			The XML serializer is designed to be used against POJO tree structures. 
			<br>It expects that there not be loops in the POJO model (e.g. children with references to parents, etc...).
			<br>If you try to serialize models with loops, you will usually cause a <code>StackOverflowError</code> to 
			be thrown (if {@link org.apache.juneau.serializer.Serializer#SERIALIZER_maxDepth} is not reached 
			first).
		</p>
		<p>
			If you still want to use the XML serializer on such models, Juneau provides the 
			{@link org.apache.juneau.serializer.Serializer#SERIALIZER_detectRecursions} setting.
			<br>It tells the serializer to look for instances of an object in the current branch of the tree and skip 
			serialization when a duplicate is encountered.
		</p>
		<p>
			For example, let's make a POJO model out of the following classes:
		</p>
		<p class='bcode'>
	<ja>@Bean</ja>(typeName=<js>"a"</js>)
	<jk>public class</jk> A {
		<jk>public</jk> B b;
	}
	
	<jk>public class</jk> B {
		<jk>public</jk> C c;
	}
	
	<jk>public class</jk> C {
		<jk>public</jk> A a;
	}
		</p>
		<p>
			Now we create a model with a loop and serialize the results.
		</p>
		<p class='bcode'>
	<jc>// Create a new serializer with readable output.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder()
		.ws()
		.sq()
		.ns()
		.detectRecursions(<jk>true</jk>)
		.build();

	<jc>// Create a recursive loop.</jc>
	A a = <jk>new</jk> A();
	a.<jf>b</jf> = <jk>new</jk> B();
	a.<jf>b</jf>.<jf>c</jf> = <jk>new</jk> C();
	a.<jf>b</jf>.<jf>c</jf>.<jf>a</jf> = a;
	
	<jc>// Serialize to XML.</jc>
	String xml = s.serialize(a);
		</p>
		<p>
			What we end up with is the following, which does not serialize the contents of the <code>c</code> field:
		</p>
		<p class='bcode'>
	<xt>&lt;a&gt;</xt>
		<xt>&lt;b&gt;</xt>
			<xt>&lt;c/&gt;</xt>
		<xt>&lt;/b&gt;</xt>
	<xt>&lt;/a&gt;</xt>		
		</p>
		<p>
			Without recursion detection enabled, this would cause a stack-overflow error.
		</p>
		<p>
			Recursion detection introduces a performance penalty of around 20%.
			<br>For this reason the setting is disabled by default.
		</p>
	</div>


	<!-- ======================================================================================================== -->
	<a id="SerializerConfigurableProperties"></a>
	<h3 class='topic' onclick='toggle(this)'>2.8 - Configurable properties</h3>
	<div class='topic'>
		<p>
			See the following classes for all configurable properties that can be used on this serializer:
		</p>
		<ul>
			<li>{@link org.apache.juneau.BeanContext} - Bean context properties.
			<li>{@link org.apache.juneau.xml.XmlSerializerContext} - Serializer context properties.
		</ul>
	</div>		


	<!-- ======================================================================================================== -->
	<a id="SerializerOtherNotes"></a>
	<h3 class='topic' onclick='toggle(this)'>2.9 - Other notes</h3>
	<div class='topic'>
		<ul class='spaced-list'>
			<li>
				Like all other Juneau serializers, the XML serializer is thread safe and maintains an internal cache of 
				bean classes encountered.
				<br>For performance reasons, it's recommended that serializers be reused whenever possible instead of 
				always creating new instances.
		</ul>
	</div>
</div>


<!-- ======================================================================================================== -->
<a id="XmlParser"></a>
<h2 class='topic' onclick='toggle(this)'>3 - XmlParser class</h2>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.xml.XmlParser} class is the class used to parse Juneau-generated XML back into 
		POJOs.
	</p>	
	<p>
		A static reusable instance of <code>XmlParser</code> is also provided for convenience:
	</p>
	<ul>
		<li>{@link org.apache.juneau.xml.XmlParser#DEFAULT}
	</ul>
	<p>
		Let's build upon the previous example and parse the generated XML back into the original bean.
		<br>We start with the XML that was generated.
	</p>
	<p class='bcode'>
	<jc>// Create a new serializer with readable output.</jc>
	XmlSerializer s = <jk>new</jk> XmlSerializerBuilder().ws().sq().ns().build();

	<jc>// Create our bean.</jc>
	Person p = <jk>new</jk> Person(1, <js>"John Smith"</js>, <js>"http://sample/addressBook/person/1"</js>, 
		<js>"http://sample/addressBook"</js>, <js>"Aug 12, 1946"</js>);
	Address a = <jk>new</jk> Address();
	a.<jf>uri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/address/1"</js>);
	a.<jf>personUri</jf> = <jk>new</jk> URI(<js>"http://sample/addressBook/person/1"</js>);
	a.<jf>id</jf> = 1;
	a.<jf>street</jf> = <js>"100 Main Street"</js>;
	a.<jf>city</jf> = <js>"Anywhereville"</js>;
	a.<jf>state</jf> = <js>"NY"</js>;
	a.<jf>zip</jf> = 12345;
	a.<jf>isCurrent</jf> = <jk>true</jk>;
	p.<jf>addresses</jf>.add(a);	

	<jc>// Serialize the bean to XML.</jc>
	String xml = s.serialize(p);
	</p>
	<p>
		This code produced the following:
	</p>
	<p class='bcode'>
	<xt>&lt;per:person</xt> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs> 
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs> 
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs> 
			<xa>uri</xa>=<xs>'http://sample/addressBook/person/1'</xs><xt>&gt;</xt>
		<xt>&lt;per:id&gt;</xt>1<xt>&lt;/per:id&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:addressBookUri&gt;</xt>http://sample/addressBook<xt>&lt;/per:addressBookUri&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
		<xt>&lt;per:addresses&gt;</xt>
			<xt>&lt;addr:address</xt> <xa>uri</xa>=<xs>'http://sample/addressBook/address/1'</xs><xt>&gt;</xt>
				<xt>&lt;addr:personUri&gt;</xt>http://sample/addressBook/person/1<xt>&lt;/addr:personUri&gt;</xt>
				<xt>&lt;addr:id&gt;</xt>1<xt>&lt;/addr:id&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/per:addresses&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
	</p>
	<p>
		The code to convert this back into a bean is:
	</p>
	<p class='bcode'>
	<jc>// Parse it back into a bean using the reusable XML parser.</jc>
	Person p = XmlParser.<jsf>DEFAULT</jsf>.parse(xml, Person.<jk>class</jk>);

	<jc>// Render it as JSON.</jc>
	String json = JsonSerializer.<jsf>DEFAULT_LAX_READABLE</jsf>.serialize(p);
	</p>
	<p>
		We print it out to JSON to show that all the data has been preserved:
	</p>
	<p class='bcode'>
	{
		id: 1, 
		name: <js>'John Smith'</js>, 
		uri: <js>'http://sample/addressBook/person/1'</js>, 
		addressBookUri: <js>'http://sample/addressBook'</js>, 
		birthDate: <js>'1946-08-12T00:00:00Z'</js>, 
		addresses: [
			{
				uri: <js>'http://sample/addressBook/address/1'</js>, 
				personUri: <js>'http://sample/addressBook/person/1'</js>, 
				id: 1, 
				street: <js>'100 Main Street'</js>, 
				city: <js>'Anywhereville'</js>, 
				state: <js>'NY'</js>, 
				zip: 12345, 
				isCurrent: <jk>true</jk>
			}
		]
	}	
	</p>
	

	<!-- ======================================================================================================== -->
	<a id="GenericParsing"></a>
	<h3 class='topic' onclick='toggle(this)'>3.1 - Parsing into generic POJO models</h3>
	<div class='topic'>
		<p>
			The XML parser is not limited to parsing back into the original bean classes.
			<br>If the bean classes are not available on the parsing side, the parser can also be used to parse into a 
			generic model consisting of <code>Maps</code>, <code>Collections</code>, and primitive objects.
		</p>
		<p>
			You can parse into any <code>Map</code> type (e.g. <code>HashMap</code>, <code>TreeMap</code>), but
			using {@link org.apache.juneau.ObjectMap} is recommended since it has many convenience methods
			for converting values to various types.
			<br>The same is true when parsing collections.  You can use any Collection (e.g. <code>HashSet</code>, 
			<code>LinkedList</code>) or array (e.g. <code>Object[]</code>, <code>String[]</code>, 
			<code>String[][]</code>), but using {@link org.apache.juneau.ObjectList} is recommended.
		</p>
		<p>
			When the map or list type is not specified, or is the abstract <code>Map</code>, <code>Collection</code>, 
			or <code>List</code> types, the parser will use <code>ObjectMap</code> and <code>ObjectList</code> by 
			default.
		</p>
	</div>
	

	<!-- ======================================================================================================== -->
	<a id="ParserConfigurableProperties"></a>
	<h3 class='topic' onclick='toggle(this)'>3.2 - Configurable properties</h3>
	<div class='topic'>
		<p>
			See the following classes for all configurable properties that can be used on this parser:
		</p>
		<ul>
			<li>{@link org.apache.juneau.BeanContext} - Bean context properties.
			<li>{@link org.apache.juneau.xml.XmlParserContext} - Parser context properties.
		</ul>
	</div>		


	<!-- ======================================================================================================== -->
	<a id="ParserOtherNotes"></a>
	<h3 class='topic' onclick='toggle(this)'>3.3 - Other notes</h3>
	<div class='topic'>
		<ul class='spaced-list'>
			<li>
				Like all other Juneau parsers, the XML parser is thread safe and maintains an internal cache of bean 
				classes encountered.
				<br>For performance reasons, it's recommended that parser be reused whenever possible instead of always 
				creating new instances.
		</ul>
	</div>
	
</div>

<p align="center"><i><b>*** fn ***</b></i></p>

</body>
</html>				