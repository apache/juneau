
<!DOCTYPE HTML>
<!--
/***************************************************************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 ***************************************************************************************************************************/
 -->
<body>
<h1 class='title'>Apache Juneau <juneauVersion>9.0.0</juneauVersion> Documentation</h1>

<a href='#TOC' id='TOC'></a><h5 class='toc'>Table of Contents</h5>
<ol class='toc'>
	<li><p class='toc2'><a class='doclink' href='#Overview'>Overview</a></p>
	<ol>
		<li><p><a class='doclink' href='#o.Marshalling'>Marshalling</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.EndToEndRest'>End-to-End REST</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.RestServer'>REST Server</a></p>
		<li><p><a class='doclink' href='#o.RestClient'>REST Client</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.Dtos'>DTOs</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.ConfigFiles'>Config Files</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.FluentAssertions'>Fluent Assertions</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#o.GeneralDesign'>General Design</a><span class='update'>created: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-marshall'>juneau-marshall</a></p>
	<ol>
		<li><p><a class='doclink' href='#jm.Marshallers'>Marshallers</a></p>
		<li><p><a class='doclink' href='#jm.SerializersAndParsers'>Serializers and Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.BeanContexts'>Bean Contexts</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.JavaBeansSupport'>Java Beans Support</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jm.BeanAnnotation'>@Bean Annotation</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.BeanpAnnotation'>@Beanp Annotation</a><span class='update'>updated: 8.1.0,8.1.2,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.BeancAnnotation'>@Beanc Annotation</a><span class='update'>updated: 8.1.0,8.1.2</span></p>
			<li><p><a class='doclink' href='#jm.BeanIgnoreAnnotation'>@BeanIgnore Annotation</a></p>
			<li><p><a class='doclink' href='#jm.NamePropertyAnnotation'>@NameProperty Annotation</a></p>
			<li><p><a class='doclink' href='#jm.ParentPropertyAnnotation'>@ParentProperty Annotation</a></p>
			<li><p><a class='doclink' href='#jm.PojoBuilders'>POJO Builders</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.BypassSerialization'>Bypass Serialization using Readers and InputStreams</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.HttpPartSerializersParsers'>HTTP Part Serializers and Parsers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.ContextSettings'>Context Settings</a><span class='update'>updated: 8.1.3,<b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.ContextAnnotations'>Context Annotations</a><span class='update'>created: 8.1.0, updated: 8.1.3,8.2.0,<b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.JsonMap'>JsonMap and JsonList</a><span class='update'>updated: 8.2.0</span></p>
		<li><p><a class='doclink' href='#jm.ComplexDataTypes'>Complex Data Types</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.SerializerSetsParserSets'>SerializerSets and ParserSets</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.Swaps'>Swaps</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jm.DefaultSwaps'>Default Swaps</a></p>
			<li><p><a class='doclink' href='#jm.AutoSwaps'>Auto-detected swaps</a><span class='update'>created: 8.1.0</span></p>
			<li><p><a class='doclink' href='#jm.PerMediaTypeSwaps'>Per-media-type Swaps</a><span class='update'>updated: 8.1.0,8.2.0</span></p>
			<li><p><a class='doclink' href='#jm.OneWaySwaps'>One-way Swaps</a></p>
			<li><p><a class='doclink' href='#jm.SwapAnnotation'>@Swap Annotation</a><span class='update'>updated: 8.0.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.TemplatedSwaps'>Templated Swaps</a></p>
			<li><p><a class='doclink' href='#jm.SurrogateClasses'>Surrogate Classes</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.DynamicallyAppliedAnnotations'>Dynamically Applied Annotations</a><span class='update'>created: 8.1.3, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.BeanDictionaries'>Bean Names and Dictionaries</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jm.BeanSubTypes'>Bean Subtypes</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.VirtualBeans'>Virtual Beans</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.Recursion'>Non-Tree Models and Recursion Detection</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.ParsingIntoGenericModels'>Parsing into Generic Models</a><span class='update'>updated: 8.2.0</span></p>
		<li><p><a class='doclink' href='#jm.ReadingContinuousStreams'>Reading Continuous Streams</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.MarshallingUris'>URIs</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.JacksonComparison'>Comparison with Jackson</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.PojoCategories'>POJO Categories</a></p>
		<li><p><a class='doclink' href='#jm.SimpleVariableLanguage'>Simple Variable Language</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.SvlVariables'>SVL Variables</a><span class='update'>updated: 8.0.0,8.1.0</span></p>
			<li><p><a class='doclink' href='#jm.VarResolvers'>VarResolvers and VarResolverSessions</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.DefaultVarResolver'>VarResolver.DEFAULT</a><span class='update'>created: 8.1.0</span></p>
			<li><p><a class='doclink' href='#jm.SvlOtherNotes'>Other Notes</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.Encoders'>Encoders</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.ObjectTools'>Object Tools</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jm.JsonDetails'>JSON Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.JsonMethodology'>JSON Methodology</a></p>
			<li><p><a class='doclink' href='#jm.JsonSerializers'>JSON Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.Json5'>JSON 5</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.JsonParsers'>JSON Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.JsonAnnotation'>@Json Annotation</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.JsonSchemaDetails'>JSON-Schema Support</a></p>
		<li><p><a class='doclink' href='#jm.XmlDetails'>XML Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.XmlMethodology'>XML Methodology</a></p>
			<li><p><a class='doclink' href='#jm.XmlSerializers'>XML Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.XmlParsers'>XML Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.XmlBeanTypeNameAnnotation'>@Bean(typeName) Annotation</a></p>
			<li><p><a class='doclink' href='#jm.XmlChildNameAnnotation'>@Xml(childName) Annotation</a></p>
			<li><p><a class='doclink' href='#jm.XmlFormatAnnotation'>@Xml(format) Annotation</a></p>
			<li><p><a class='doclink' href='#jm.XmlNamespaces'>Namespaces</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.HtmlDetails'>HTML Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.HtmlMethodology'>HTML Methodology</a></p>
			<li><p><a class='doclink' href='#jm.HtmlSerializers'>HTML Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.HtmlParsers'>HTML Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.HtmlAnnotation'>@Html Annotation</a></p>
			<li><p><a class='doclink' href='#jm.HtmlRenderAnnotation'>@Html(render) Annotation</a></p>
			<li><p><a class='doclink' href='#jm.HtmlDocSerializer'>HtmlDocSerializer</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.BasicHtmlDocTemplate'>BasicHtmlDocTemplate</a></p>
			<li><p><a class='doclink' href='#jm.HtmlCustomTemplates'>Custom Templates</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.HtmlSchema'>HTML-Schema Support</a></p>
		<li><p><a class='doclink' href='#jm.UonDetails'>UON Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.UonMethodology'>UON Methodology</a></p>
			<li><p><a class='doclink' href='#jm.UonSerializers'>UON Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.UonParsers'>UON Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jm.UrlEncodingDetails'>URL-Encoding Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.UrlEncMethodology'>URL-Encoding Methodology</a></p>
			<li><p><a class='doclink' href='#jm.UrlEncSerializers'>URL-Encoding Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.UrlEncParsers'>URL-Encoding Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.UrlEncodingAnnotation'>@UrlEncoding Annotation</a></p>
		</ol>
		<li><p><a class='doclink' href='#jm.MsgPackDetails'>MessagePack Details</a></p>
		<ol>
			<li><p><a class='doclink' href='#jm.MsgPackSerializers'>MessagePack Serializers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.MsgPackParsers'>MessagePack Parsers</a><span class='update'>updated: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jm.OpenApiDetails'>OpenAPI Details</a><span class='update'>updated: 8.2.0</span></p>
		<ol>
			<li><p><a class='doclink' href='#jm.OpenApiMethodology'>OpenAPI Methodology</a><span class='update'>updated: 8.2.0</span></p>
			<li><p><a class='doclink' href='#jm.OpenApiSerializers'>OpenAPI Serializers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jm.OpenApiParsers'>OpenAPI Parsers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jm.BestPractices'>Best Practices</a></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-marshall-rdf'>juneau-marshall-rdf</a></p>
	<li><p class='toc2'><a class='doclink' href='#juneau-dto'>juneau-dto</a></p>
	<ol>
		<li><p><a class='doclink' href='#jd.Html5'>HTML5</a></p>
		<li><p><a class='doclink' href='#jd.Atom'>Atom</a></p>
		<li><p><a class='doclink' href='#jd.Swagger'>Swagger</a></p>
		<li><p><a class='doclink' href='#jd.SwaggerUi'>Swagger UI</a></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-config'>juneau-config</a></p>
	<ol>
		<li><p><a class='doclink' href='#jc.Overview'>Overview</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jc.SyntaxRules'>Syntax Rules</a></p>
		</ol>
		<li><p><a class='doclink' href='#jc.ReadingEntries'>Reading Entries</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jc.Pojos'>POJOs</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jc.Arrays'>Arrays</a></p>
			<li><p><a class='doclink' href='#jc.JCFObjects'>Java Collection Framework Objects</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jc.BinaryData'>Binary Data</a><span class='update'>updated: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jc.Variables'>Variables</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jc.LogicVariables'>Logic Variables</a></p>
		</ol>
		<li><p><a class='doclink' href='#jc.ModdedEntries'>Modded/Encoded Entries</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jc.Sections'>Sections</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jc.SettingValues'>Setting Values</a></p>
		<ol>
			<li><p><a class='doclink' href='#jc.FileSystemChanges'>File System Changes</a></p>
			<li><p><a class='doclink' href='#jc.CustomEntrySerialization'>Custom Entry Serialization</a></p>
			<li><p><a class='doclink' href='#jc.BulkSettingValues'>Setting Values in Bulk</a></p>
		</ol>
		<li><p><a class='doclink' href='#jc.Listeners'>Listeners</a></p>
		<li><p><a class='doclink' href='#jc.SerializingConfigs'>Serializing</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jc.ConfigImports'>Imports</a><span class='update'>updated: 8.1.0</span></p>
		<li><p><a class='doclink' href='#jc.ConfigStores'>Config Stores</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jc.MemoryStore'>MemoryStore</a></p>
			<li><p><a class='doclink' href='#jc.FileStore'>FileStore</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jc.CustomStores'>Custom ConfigStores</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jc.StoreListeners'>ConfigStore Listeners</a></p>
		</ol>
		<li><p><a class='doclink' href='#jc.ReadOnlyConfigs'>Read-only Configs</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jc.ClosingConfigs'>Closing Configs</a></p>
		<li><p><a class='doclink' href='#jc.SystemDefaultConfig'>System Default Config</a><span class='update'>created: 8.0.0, updated: 8.1.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-assertions'>juneau-assertions</a><span class='update'>created: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#ja.Overview'>Overview</a><span class='update'>created: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-rest-common'>juneau-rest-common</a><span class='update'>created: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#jrc.HelperClasses'>Helper Classes</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.Annotations'>Annotations</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.HttpHeaders'>HTTP Headers</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.HttpParts'>HTTP Parts</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#HttpEntitiesAndResources'>HTTP Entities and Resources</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.HttpResponses'>HTTP Responses</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.RemoteProxyInterfaces'>Remote Proxy Interfaces</a><span class='update'>created: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-rest-server'>juneau-rest-server</a><span class='update'>updated: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#jrs.Overview'>Overview</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.AnnotatedClasses'>@Rest-Annotated Classes</a><span class='update'>updated: 8.1.2,<b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jrs.PredefinedClasses'>Predefined Classes</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.ChildResources'>Child Resources</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.PathVariables'>Path Variables</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.Deployment'>Deployment</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.LifecycleHooks'>Lifecycle Hooks</a><span class='update'>updated: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jrs.RestOpAnnotatedMethods'>@RestOp-Annotated Methods</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jrs.InferredHttpMethodsAndPaths'>Inferred HTTP Methods and Paths</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.JavaMethodParameters'>Java Method Parameters</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.JavaMethodReturnTypes'>Java Method Return Types</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.JavaMethodThrowableTypes'>Java Method Throwable Types</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.PathPatterns'>Path Patterns</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.Matchers'>Matchers</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.OverloadingHttpMethods'>Overloading HTTP Methods</a></p>
			<li><p><a class='doclink' href='#jrs.AdditionalInformation'>Additional Information</a><span class='update'>updated: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jrs.HttpParts'>HTTP Parts</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jrs.PartMarshallers'>Part Marshallers</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.HttpPartAnnotations'>HTTP Part Annotations</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.DefaultParts'>Default Parts</a><span class='update'>created: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.RequestBeans'>@Request Beans</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.ResponseBeans'>@Response Beans</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.HttpPartApis'>HTTP Part APIs</a><span class='update'>created: <b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jrs.Marshalling'>Marshalling</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.HandlingFormPosts'>Form Posts</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.Guards'>Guards</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.Converters'>Converters</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.LocalizedMessages'>Localized Messages</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.Encoders'>Encoders</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.ConfigurationFiles'>Configuration Files</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.SvlVariables'>SVL Variables</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.StaticFiles'>Static files</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.ClientVersioning'>Client Versioning</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.Swagger'>Swagger</a></p>
		<ol>
			<li><p><a class='doclink' href='#jrs.BasicRestServletSwagger'>BasicRestServlet/BasicRestObject</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.BasicSwaggerInfo'>Basic Swagger Info</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.SwaggerTags'>Tags</a></p>
			<li><p><a class='doclink' href='#jrs.SwaggerOperations'>Operations</a></p>
			<li><p><a class='doclink' href='#jrs.SwaggerParameters'>Parameters</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.SwaggerResponses'>Responses</a></p>
			<li><p><a class='doclink' href='#jrs.SwaggerModels'>Models</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.SwaggerStylesheet'>SwaggerUI.css</a></p>
		</ol>
		<li><p><a class='doclink' href='#jrs.ExecutionStatistics'>REST method execution statistics</a><span class='update'>created: 8.1.3, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.HtmlDocAnnotation'>@HtmlDocConfig</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jrs.HtmlUIvsDI'>User Interfaces (UI) vs. Developer Interfaces (DI)</a></p>
			<li><p><a class='doclink' href='#jrs.HtmlWidgets'>Widgets</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.HtmlPredefinedWidgets'>Predefined Widgets</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.HtmlUiCustomization'>UI Customization</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrs.HtmlStylesheets'>Stylesheets</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></p>
		</ol>
		<li><p><a class='doclink' href='#jrs.LoggingAndDebugging'>Logging / Debugging</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.HttpStatusCodes'>HTTP Status Codes</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.BuiltInParameters'>Built-in Parameters</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.UsingWithOsgi'>Using with OSGi</a></p>
		<li><p><a class='doclink' href='#jrs.RestContext'>RestContext</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.RestOpContext'>RestOpContext</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.ResponseProcessors'>Response Processors</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.RestRpc'>REST/RPC</a><span class='update'>updated: 8.0.0,<b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.SerializingUris'>Serializing URIs</a><span class='update'>updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.UtilityBeans'>Utility Beans</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.HtmlBeans'>Using with HTML Beans</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrs.OtherNotes'>Other Notes</a></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-rest-server-springboot'>juneau-rest-server-springboot</a><span class='update'>created: 8.0.0, updated: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#jrss.Overview'>Overview</a><span class='update'>created: 8.0.0, updated: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-rest-client'>juneau-rest-client</a><span class='update'>updated: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#jrc.PojoMarshalling'>POJO Marshalling</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.RequestParts'>Request Parts</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.RequestContent'>Request Content</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.ResponseStatus'>Response Status</a><span class='update'>created: 8.1.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.ResponseHeaders'>Response Headers</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.ResponseContent'>Response Content</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.CustomCallHandlers'>Custom Call Handlers</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.Interceptors'>Interceptors</a><span class='update'>created: 8.2.0</span></p>
		<li><p><a class='doclink' href='#jrc.Proxies'>REST Proxies</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<ol>
			<li><p><a class='doclink' href='#jrc.Remote'>@Remote</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.RemoteMethod'>@RemoteOp</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Content'>@Content</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.FormData'>@FormData</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Query'>@Query</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Header'>@Header</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Path'>@Path</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Request'>@Request</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.Response'>@Response</a><span class='update'>updated: <b>9.0.0</b></span></p>
			<li><p><a class='doclink' href='#jrc.DualPurposeInterfaces'>Dual-purpose (end-to-end) interfaces</a><span class='update'>created: 8.0.0</span></p>
		</ol>
		<li><p><a class='doclink' href='#jrc.LoggingAndDebugging'>Logging and Debugging</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.CustomizingHttpClient'>Customizing HttpClient</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jrc.ExtendingRestClient'>Extending RestClient</a><span class='update'>created: 8.2.0</span></p>
		<li><p><a class='doclink' href='#jrc.Authentication'>Authentication</a><span class='update'>updated: 8.2.0</span></p>
		<ol>
			<li><p><a class='doclink' href='#jrc.AuthenticationBASIC'>BASIC Authentication</a></p>
			<li><p><a class='doclink' href='#jrc.AuthenticationForm'>FORM-based Authentication</a></p>
			<li><p><a class='doclink' href='#jrc.AuthenticationOIDC'>OIDC Authentication</a></p>
		</ol>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-rest-mock'>juneau-rest-mock</a><span class='update'>created: 8.1.0, updated: 8.2.0</span></p>
	<ol>
		<li><p><a class='doclink' href='#jrm.MockRestClient'>MockRestClient</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-microservice-core'>juneau-microservice-core</a><span class='update'>created: 8.1.0</span></p>
	<ol>
		<li><p><a class='doclink' href='#jmc.Overview'>Microservice Overview</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.LifecycleMethods'>Lifecycle Methods</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.Args'>Args</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.Manifest'>Manifest</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.Config'>Config</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.SystemProperties'>System properties</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.VarResolver'>VarResolver</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.ConsoleCommands'>Console Commands</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmc.Listeners'>Listeners</a><span class='update'>created: 8.0.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-microservice-jetty'>juneau-microservice-jetty</a><span class='update'>created: 8.1.0</span></p>
	<ol>
		<li><p><a class='doclink' href='#jmj.Overview'>Overview</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.LifecycleMethods'>Lifecycle Methods</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.ResourceClasses'>Resource Classes</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.PredefinedResourceClasses'>Predefined Resource Classes</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.Config'>Config</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.JettyXml'>Jetty.xml file</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.UiCustomization'>UI Customization</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#jmj.Extending'>Extending JettyMicroservice</a><span class='update'>created: 8.0.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#my-jetty-microservice'>my-jetty-microservice</a><span class='update'>created: 8.1.0</span></p>
	<ol>
		<li><p><a class='doclink' href='#mjm.Installing'>Installing in Eclipse</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#mjm.Running'>Running in Eclipse</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#mjm.Building'>Building and Running from Command-Line</a><span class='update'>created: 8.0.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#my-springboot-microservice'>my-springboot-microservice</a><span class='update'>created: 8.0.0</span></p>
	<ol>
		<li><p><a class='doclink' href='#msm.Installing'>Installing in Eclipse</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#msm.Running'>Running in Eclipse</a><span class='update'>created: 8.0.0</span></p>
		<li><p><a class='doclink' href='#msm.Building'>Building and Running from Command-Line</a><span class='update'>created: 8.0.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#juneau-petstore'>juneau-petstore</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></p>
	<ol>
		<li><p><a class='doclink' href='#jp.RunningTheApp'>Running the Pet Store App</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jp.juneau-petstore-api'>juneau-petstore-api</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jp.juneau-petstore-client'>juneau-petstore-client</a><span class='update'>created: <b>9.0.0</b></span></p>
		<li><p><a class='doclink' href='#jp.juneau-petstore-server'>juneau-petstore-server</a><span class='update'>created: <b>9.0.0</b></span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#Security'>Security Best-Practices</a></p>
	<ol>
		<li><p><a class='doclink' href='#s.Marshall'>juneau-marshall</a><span class='update'>created: 8.2.0</span></p>
		<li><p><a class='doclink' href='#s.Svl'>juneau-svl</a><span class='update'>created: 8.2.0</span></p>
		<li><p><a class='doclink' href='#s.Rest'>juneau-rest-server</a><span class='update'>created: 8.2.0</span></p>
	</ol>
	<li><p class='toc2'><a class='doclink' href='#v9.0-migration-guide'>v9.0 Migration Guide</a></p>
</ol>


<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#Overview' id='Overview'>1 - Overview</a></h2>
<div class='topic'><!-- START: 1 - Overview -->
<h5 class='topic'>About</h5>
<div class='topic'>
	<p>
		Apache Juneauâ„¢ is a single cohesive Java ecosystem for marshalling Java objects to a wide variety of 
		language types and creating annotation-based REST end-to-end server and client APIs.  
	</p>
	
	<p>
		The Juneau ecosystem consists of the following parts:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Category</th><th>Maven Artifacts</th><th>Description</th><th>Prereqs</th>
		</tr>
		<tr class='dark bb'>
			<td rowspan="5" style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-core</td>
			<td class='code'><a class='doclink' href='#juneau-marshall'>juneau-marshall</a></td>
			<td>
				<ul>
					<li>Serializers and parsers for JSON (various flavors), XML, HTML, URL-Encoding, UON, OpenAPI, PlainText, CSV, SOAP, and MessagePack.</li>
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Apache HttpCore 4.4</li>
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'><a class='doclink' href='#juneau-marshall-rdf'>juneau-marshall-rdf</a></td>
			<td>
				<ul>
					<li>Serializers and parsers for RDF/XML (various flavors), N3, NTriple, and Turtle.
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Apache HttpCore 4.4</li>
					<li>Apache Jena 2.7.1</li>
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'><a class='doclink' href='#juneau-dto'>juneau-dto</a></td>
			<td>
				<ul>
					<li>Data Transfer Objects for HTML5, Atom, Cognos, JSON-Schema, and Swagger
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li><i>None</i></li>
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'><a class='doclink' href='#juneau-config'>juneau-config</a></td>
			<td>
				<ul>
					<li>Configuration File API</li>
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li><i>None</i></li>
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'><a class='doclink' href='#juneau-assertions'>juneau-assertions</a></td>
			<td>
				<ul>
					<li>Fluent-style assertions API</li>
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li><i>None</i></li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan="6" style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-rest</td>
			<td class='code'><a class='doclink' href='#juneau-rest-server'>juneau-rest-common</a></td>
			<td>
				<ul>
					<li>REST APIs common to client and server side.</li>
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Apache HttpCore 4.4</li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'><a class='doclink' href='#juneau-rest-server'>juneau-rest-server</a></td>
			<td>
				<ul>
					<li>REST Servlet API
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Servlet 3.1+</li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'><a class='doclink' href='#juneau-rest-server-springboot'>juneau-rest-server-springboot</a></td>
			<td>
				<ul>
					<li>REST Spring Boot integration
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Spring Boot 2.0+</li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'><a class='doclink' href='#juneau-rest-client'>juneau-rest-client</a></td>
			<td>
				<ul>
					<li>REST Client API
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Apache HttpClient 4.5</li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'><a class='doclink' href='#juneau-rest-client'>juneau-rest-mock</a></td>
			<td>
				<ul>
					<li>REST Testing API</li>
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Apache HttpClient 4.5</li>
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'><a class='doclink' href='#my-springboot-microservice'>my-springboot-microservice</a></td>
			<td>
				<ul>
					<li>Spring Boot developer template</li>
				<ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Spring Boot 2.0+</li>
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan="2" style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-examples</td>
			<td class='code'>juneau-examples-core</td>
			<td>
				<ul>
					<li>Core code examples</li>
				<ul>
			</td>
			<td></td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-examples-rest</td>
			<td>
				<ul>
					<li>REST code examples</li>
				<ul>
			</td>
			<td></td>
		</tr>
		<tr class='light bb'>
			<td rowspan="1" style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-all</td>
			<td class='code'><c>juneau-all</c></td>
			<td>
				Combination of the following:
				<ul style='margin:0px 10px;'>
					<li>juneau-marshall
					<li>juneau-dto
					<li>juneau-config
					<li>juneau-assertions
					<li>juneau-rest-common
					<li>juneau-rest-server
					<li>juneau-rest-client
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Servlet 3.1+
					<li>Apache HttpClient 4.5+
				</ul>
			</td>
		</tr>
	</table>
	
	<p>
		The current version of Juneau is <c><juneauVersion>9.0.0</juneauVersion></c>.
		The easiest way to pull in the library is through the following maven dependency:
	</p>
	<p class='bxml'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-all<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	<p>
		If you would like to work with the bleeding-edge code, you can access the <c><juneauVersionNext>9.0.1</juneauVersionNext>-SNAPSHOT</c>
		version through the following repository:
	</p>
	<p class='bxml'>
	<xt>&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;<xv>apache.snapshots</xv>&lt;/id&gt;
			&lt;url&gt;<xv>http://repository.apache.org/snapshots/</xv>&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;<xv>true</xv>&lt;/enabled&gt;
				&lt;updatePolicy&gt;<xv>always</xv>&lt;/updatePolicy&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;</xt>
	</p>	
	<p>
		Each of the components are also packaged as stand-alone OSGi modules.
	</p>
</div>

<h5 class='topic'>Features</h5>
<div class='topic'>
	<ul class='spaced-list'>
		<li>
			Fast memory-efficient serialization.
		<li>
			Fast, safe, memory-efficient parsing.  Parsers are not susceptible to deserialization attacks.
		<li>
			KISS is our mantra!  No auto-wiring.  No code generation.  No dependency injection.  Just add it to your classpath and use it.  Extremely simple unit testing!
		<li>
			Enjoyable to use
		<li>
			Tiny - ~1MB
		<li>
			Exhaustively tested
		<li>
			Lots of up-to-date documentation and examples
		<li>
			Minimal library dependencies making it ideal for use in uber-jars.
		<li>
			Built on top of Servlet and Apache HttpClient APIs that allow you to use the newest HTTP/2 features
			such as request/response multiplexing and server push.
		<li>
			All modules work with Java 8 through at least 18.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.Marshalling' id='o.Marshalling'>1.1 - Marshalling</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.1 - o.Marshalling -->
<div class='topic'>
	<p>
		The <a class="doclink" href="#juneau-marshall">juneau-marshall</a> library includes easy-to-use and highly customizable serializers and parsers based around
		a common API.  It allows you to marshall Java POJOs directly to and from a wide variety of language types
		without the need for intermediate Document Object Models making them extremely efficient.
	</p>
	<p>
		Supported languages include:
		<ul>
			<li>JSON
			<li>XML
			<li>HTML
			<li>UON
			<li>URL-Encoding
			<li>MessagePack
			<li>OpenAPI
			<li>SOAP/XML
			<li>CSV
			<li>YAML (coming soon)
			<li>RDF/XML
			<li>RDF/XML-Abbrev 
			<li>N-Triple
			<li>Turtle
			<li>N3
		</ul>
	</p>
	<ul>
		<li class='note'>
			The marshalling support can be thought of as similar to Jackson except for support of a wide variety of languages.
			Additionally, JSON marshalling is about 20% faster than Jackson yet supports the same usecases.
	</ul>
	<p>
		The default serializers can often be used to serialize POJOs in a single line of code:
	</p>
	<p class='bjava'>
	<jc>// A simple bean</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String <jf>name</jf> = <js>"John Smith"</js>;
		<jk>public int</jk> <jf>age</jf> = 21;
	}
	
	<jc>// Produces:
	// "{"name":"John Smith","age":21}"</jc>
	String <jv>json</jv> = Json.<jsm>of</jsm>(<jk>new</jk> Person());
	</p>
	<p>
		Parsing back into POJOs is equally simple for any of the supported languages.
		Language fragments are also supported.
	</p>
	<p class='bjava'>
	<jc>// Parse a JSON object as a bean.</jc>
	String <jv>json</jv> = <js>"{\"name\":\"John Smith\","\age\":21}"</js>;
	Person <jv>person</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, Person.<jk>class</jk>);
	</p>
	<p>
		Marshalling support is provided for a wide variety of POJO types including:
	</p>
	<ul>
		<li>Primitives and primitive objects
		<li>Beans
		<li>Java Collections Framework objects (e.g. Collections, Maps)
		<li>Arrays
		<li>POJOs
	</ul>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.PojoCategories">Pojo Categories</a> for an exhaustive list of categories supported out-of-the-box.
	</ul>
</div>

<h5 class='topic'>Serializer/Parser Builders</h5>
<div class='topic'>
	<p>
		Marshallers like the one shown above are pairings of serializers and parsers.  
		Serializers and parsers are builder-based using fluent methods allowing you to quickly create, clone, and modify them
		in single lines of code.
	</p>
	<p class='bjava'>
	<jc>// Create a serializer from scratch programmatically using a builder.</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.simple()                           <jc>// Simple mode</jc>
		.sq()                               <jc>// Use single quotes</jc>
		.timeZone(TimeZone.<jsf>GMT</jsf>)             <jc>// For timezone-specific serialization</jc>
		.locale(Locale.<jsf>JAPAN</jsf>)               <jc>// For locale-specific serialization</jc>
		.sortCollections()
		.sortProperties()
		.keepNullProperties()
		.trimStrings()
		.beanMethodVisibility(<jsf>PROTECTED</jsf>)    <jc>// Control which fields/methods are serialized</jc>
		.beanDictionary(                    <jc>// Adds type variables for resolution during parsing</jc>
			MyBeanA.<jk>class</jk>, 
			MyBeanB.<jk>class</jk>
		)
		.debug()                            <jc>// Debug mode</jc>
		.build();
	</p>
	<p>
		Many POJOs such as primitives, beans, collections, arrays, and classes with various known constructors and methods are serializable out-of-the-box.
	</p>
	<p> 
		<a class="doclink" href="#jm.Swaps">Swaps</a> allow you to replace non-serializable objects with serializable equivalents.
		The {@link org.apache.juneau.swaps} package contains a variety of predefined swaps.
	</p>
	<p class='bjava'>
	<jc>// Create a serializer from scratch programmatically using a builder.</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.swaps(                             <jc>// Swap unserializable classes with surrogate POJOs</jc>
			IteratorSwap.<jk>class</jk>,              <jc>// Iterators swapped with lists</jc>
			ByteArrayBase64Swap.<jk>class</jk>,       <jc>// byte[] swapped with base-64 encoded strings</jc>
			CalendarSwap.ISO8601DT.<jk>class</jk>     <jc>// Calendars swapped with ISO8601-compliant strings</jc>
		)
		.build();
	</p>
	<p>
		Any POJO that doesn't fit into the category of a bean/collection/array/primitive and doesn't have a swap
		associated with it is converted to simple strings.
		By default, various instance and static methods and constructors on POJO classes are automatically detected and supported
		for marshalling a POJO to and from a string.
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.SerializersAndParsers"></a> for more information.
	</ul>
</div>

<h5 class='topic'>Bean Annotations</h5>
<div class='topic'>
	<p>
		Beans and POJO classes, methods, fields, and constructors can also be annotated with a variety of annotations to customize how they are marshalled:
	</p>
	<p class='bjava'>
	<jc>// Sort bean properties by name.</jc>
	<jc>// Exclude city/state from marshalling.</jc>
	<ja>@Bean</ja>(sort=<jk>true</jk>, excludeProperties=<js>"city,state"</js>)
	<jk>public class</jk> Address { ... }

	<jc>// Specify an implementation class for an interface.</jc>
	<ja>@Marshalled</ja>(implClass=AutomobileImpl.<jk>class</jk>)
	<jk>public interface</jk> Automobile { ... }
	</p>
	<p>
		As a general rule, any capabilities provided by bean annotations can be programmatically specified
		via the builder APIs.  This allows the marshallers to be used equivalently on either your own code
		that you have access to, or external code where you only have access to binaries.
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.JavaBeansSupport">Java Beans Support</a> for more information.
	</ul>
</div>

<h5 class='topic'>Configuration Annotations</h5>
<div class='topic'>
	<p>
		Serializers and parsers can also be configured using annotations.
	</p>
	<p class='bjava'>
	<ja>@BeanConfig</ja>(sortProperties=<js>"true"</js>)
	<ja>@SerializerConfig</ja>(quoteChar=<js>"'"</js>)
	<ja>@RdfConfig</ja>(rdfxml_tab=<js>"5"</js>, addRootProperty=<js>"true"</js>)
	<jk>public class</jk> MyAnnotatedClass {...}
	
	<jc>// Create a serializer configured using annotations.</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.applyAnnotations(MyAnnotatedClass.<jk>class</jk>)
		.build();
	</p>
	<p>
		Config annotations are extensively used in the REST Servlet APIs to configure how POJOs are marshalled through REST interfaces.
	</p>
	<p>
		Config variables also support embedded variables for resolving settings at runtime.
	</p>
	<p class='bjava'>
	<jc>// Sort properties depending on value of system property "sortProperties".</jc>
	<ja>@BeanConfig</ja>(sortProperties=<js>"$S{sortProperties,false}"</js>)
	</p>
	<p>
		Default values for config settings can be overridden via system properties or environment variables.
		For example, the system property "BeanContext.sortProperties" or environment variable "BEANCONTEXT_SORTPROPERTIES" can be
		used to set the default value for the sort properties setting.
	</p>
	<p>
		Bean annotations can also be programmatically attached to POJOs using config annototations like so:
	</p>
	<p class='bjava'>
	<ja>@Bean</ja>(onClass=Address.<jk>class</jk>, sort=<jk>true</jk>, excludeProperties=<js>"city,state"</js>)
	<jk>public class</jk> MyAnnotatedClass {...}
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.ContextAnnotations">Context Annotations</a> for more information.
	</ul>
</div>

<h5 class='topic'>JSON 5 Marshalling</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.json.Json5Serializer} class can be used to serialized POJOs into JSON 5 notation.
	</p>
	<p>
		JSON 5 is similar to JSON except for the following:
	</p>
	<ul class='spaced-list'>
		<li>JSON attributes are only quoted when necessary.
		<li>Uses single-quotes for quoting.
	</ul>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Some free-form JSON.</jc>
	Map <jv>map</jv> = JsonMap.<jsm>of</jsm>(
		<js>"foo"</js>, <js>"x1"</js>,
		<js>"_bar"</js>, <js>"x2"</js>,
		<js>" baz "</js>, <js>"x3"</js>,
		<js>"123"</js>, <js>"x4"</js>,
		<js>"return"</js>, <js>"x5"</js>,
		<js>""</js>, <js>"x6"</js>
	);
	</p>
	<p class='bjson'>
	<joc>// Serialized to standard JSON</joc>
	{
		<jok>"foo"</jok>: <jov>"x1"</jov>,
		<jok>"_bar"</jok>: <jov>"x2"</jov>,
		<jok>" baz "</jok>: <jov>"x3"</jov>,
		<jok>"123"</jok>: <jov>"x4"</jov>,
		<jok>"return"</jok>: <jov>"x5"</jov>,
		<jok>""</jok>: <jov>"x6"</jov>
	}
	</p>	 		
	<p class='bjson'>
	<joc>// Serialized to JSON 5</joc>
	{
		<jok>foo</jok>: <jov>'x1'</jov>,
		<jok>_bar</jok>: <jov>'x2'</jov>,
		<jok>' baz '</jok>: <jov>'x3'</jov>,  <joc>// Quoted due to embedded spaces.</joc>
		<jok>'123'</jok>: <jov>'x4'</jov>,    <joc>// Quoted to prevent confusion with number.</joc>
		<jok>'return'</jok>: <jov>'x5'</jov>, <joc>// Quoted because it's a keyword.</joc>
		<jok>''</jok>: <jov>'x6'</jov>        <joc>// Quoted because it's an empty string.</joc>
	}
	</p>
	<p>
		JSON 5 is still valid Javascript.
		The advantage to simplified JSON is you can represent it in a Java String in minimal form with minimal escaping.
		This is particularly useful in cases such as unit testing where you can easily validate POJOs by simplifying them to JSON 5 and do a simple string comparison.
	</p>
	<p class='bjava'>
	WriterSerializer <jv>serializer</jv> = Json5Serializer.<jsf>DEFAULT</jsf>;
	<jsm>assertString</jsm>(<jv>serializer</jv>.toString(<jv>myPojo</jv>)).is(<js>"{foo:'bar',baz:123}"</js>);
	</p>			
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.Json5">JSON 5</a> for more information.
	</ul>
</div>

<h5 class='topic'>UON Marshalling</h5>
<div class='topic'>
	<p>
		The Marshalling API also supports UON (URL-Encoded Object Notation).
		It allows JSON-like data structures (OBJECT, ARRAY, NUMBER, BOOLEAN, STRING, NULL) in HTTP constructs (query parameters, form parameters,
		headers, URL parts) without violating RFC2396.
		This allows POJOs to be converted directly into these HTTP constructs which is not possible in other languages such as JSON.
	</p>
	<p class='buon'>
	(
		id=1, 
		name=<js>'John+Smith'</js>, 
		uri=<js>http://sample/addressBook/person/1</js>, 
		addressBookUri=<js>http://sample/addressBook</js>,
		birthDate=<js>1946-08-12T00:00:00Z</js>,
		addresses=@(
			(
				uri=<js>http://sample/addressBook/address/1</js>, 
				personUri=<js>http://sample/addressBook/person/1</js>, 
				id=<js>1</js>, 
				street=<js>'100+Main+Street'</js>, 
				city=<js>Anywhereville</js>, 
				state=<js>NY</js>, 
				zip=<js>12345</js>, 
				isCurrent=<jk>true</jk>
			)
		)
	)
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.UonDetails">UON Details</a> for more information.
	</ul>
</div>
<h5 class='topic'>OpenAPI Marshalling</h5>
<div class='topic'>
	<p>
		The Marshalling API also supports schema-based OpenAPI serialization.
		It allows HTTP parts to be marshalled to-and-from POJOs based on OpenAPI schema definitions.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httpart.HttpPartSchema.*;
	
	<jc>// Schema - Pipe-delimited list of comma-delimited longs.</jc>
	HttpPartSchema <jv>schema</jv> = <jsm>tArrayPipes</jsm>().items(
		<jsm>tArrayCsv</jsm>().items(
			<jsm>tInt64</jsm>()
		)
	).build();

	<jc>// Our value to serialize</jc>
	Object <jv>value</jv> = <jk>new long</jk>[][]{{1,2,3},{4,5,6},{7,8,9}};

	<jc>// Produces "1,2,3|4,5,6|7,8,9"</jc>
	String <jv>output</jv> = OpenApi.<jsm>of</jsm>(<jv>schema</jv>, <jv>value</jv>);
	</p>
	<p>
		Schema-based serialization and parsing is used heavily in both the server and client REST APIs with built-in schema
		validations support in various HTTP part annotations.
	</p>
	<p class='bjava'>
	<jc>// REST server method with HTTP parts using schema validation.</jc>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(
		<ja>@Query</ja>(name=<js>"myParam"</js>, schema=<ja>@Schema</ja>(min=1, max=32)) <jk>int</jk> <jv>myParam</jv>,
		<ja>@Header</ja>(<js>"MyHeader"</js>, schema=<ja>@Schema</ja>(pattern=<js>"foo.*"</js>)) String <jv>p2</jv>
	) {...}
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.OpenApiDetails">OpenAPI Details</a> for more information.
	</ul>
</div>

<h5 class='topic'>JsonMap/JsonList</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.collections.JsonMap} and {@link org.apache.juneau.collections.JsonList} collections classes allow you
		to programmatically build generic JSON data structures.  They are similar in concept to 
		<c>JSONObject</c> and <c>JSONArray</c> that you find in other JSON marshalling APIs but
		can be used to generate DOMs in any of the supported languages.
	</p>
	<p class='bjava'>
	<jc>// Create JSON strings from scratch using fluent-style code.</jc>
	String <jv>myMap</jv> = JsonMap.<jsm>create</jsm>().append(<js>"foo"</js>,<js>"bar"</js>).asJson(); 
	String <jv>myList</jv> = JsonList.<jsm>of</jsm>(<js>"foo"</js>, 123, <jk>null</jk>, <jv>jsonObject</jv>).asJson(); 
	
	<jc>// Parse directly from JSON into generic DOMs.</jc>
	Map&lt;String,Object&gt; <jv>myMap</jv> = JsonMap.<jsm>ofJson</jsm>(<js>"{foo:'bar'}"</js>); 
	List&lt;Object&gt; <jv>myList</jv> = JsonList.<jsm>ofJson</jsm>(<js>"['foo',123,null]"</js>); 
	</p>
	<p>
		These classes provide lots of convenience methods including:
	</p>
	<ul>
		<li>Methods for direct marshalling to/from any of the other supported languages.
		<li>Methods for quick conversions to other data types including collections, beans, arrays, etc...
	</ul>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.JsonMap">JsonMap and JsonList</a> for more information.
	</ul>
</div>

<h5 class='topic'>Serializer and Parser Sets</h5>
<div class='topic'>
	<p>
		{@link org.apache.juneau.serializer.SerializerSet} and {@link org.apache.juneau.parser.ParserSet} classes allow serializers and parsers 
		to be retrieved by W3C-compliant HTTP <code>Accept</code> and <code>Content-Type</code> values:
	</p>
	<p class='bjava'>
	<jc>// Construct a new serializer group with configuration parameters that get applied 
	// to all serializers.</jc>
	SerializerSet <jv>serializerSet</jv> = SerializerSet
		.<jsm>create</jsm>()
		.add(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>);
		.forEach(<jv>x</jv> -&gt; <jv>x</jv>.swaps(CalendarSwap.ISO8601DT.<jk>class</jk>))
		.forEachWS(<jv>x</jv> -&gt; <jv>x</jv>.useWhitespace())
		.build();

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the specified writer.</jc>
	<jc>// Fully RFC2616 compliant.</jc>
	<jv>serializerSet</jv>
		.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(<jv>person</jv>, <jv>myWriter</jv>);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserSet <jv>parserSet</jv> = ParserSet
		.<jsm>create</jsm>()
		.add(JsonParser.<jk>class</jk>, UrlEncodingParser.<jk>class</jk>);
		.forEach(<jv>x</jv> -&gt; <jv>x</jv>.swaps(CalendarSwap.ISO8601DT.<jk>class</jk>))
		.build();

	Person <jv>person</jv> = <jv>parserSet</jv>
		.getParser(<js>"text/json"</js>)
		.parse(<jv>myReader</jv>, Person.<jk>class</jk>);
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.SerializerSetsParserSets">SerializerSets and ParserSets</a> for more information.
	</ul>
</div>

<h5 class='topic'>SVL Variables</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.svl} package defines an API for a language called "Simple Variable Language".
		In a nutshell, Simple Variable Language (or SVL) is text that contains variables of the form
		<js>"$varName{varKey}"</js>.
	</p>
	<p>
		Variables can be recursively nested within the varKey (e.g. <js>"$FOO{$BAR{xxx},$BAZ{xxx}}"</js>).
		Variables can also return values that themselves contain more variables.
	</p>
	<p class='bjava'>
	<jc>// Use the default variable resolver to resolve a string that 
	// contains $S (system property) variables</jc>
	String <jv>myProperty</jv> = VarResolver.<jsf>DEFAULT</jsf>.resolve(<js>"The Java home directory is $S{java.home}"</js>);
	</p>
	<p>
		The SVL variables are used widely throughout various annotations defined in Juneau allowing many features to be configured
		via external sources such as configuration files or environment variables/system properties.  The SVL APIs are 
		extensible allowing for the addition of new types of variables.
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.SimpleVariableLanguage">Simple Variable Language</a> for more information.
	</ul>
</div>
</div><!-- END: 1.1 - o.Marshalling -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.EndToEndRest' id='o.EndToEndRest'>1.2 - End-to-End REST</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.2 - o.EndToEndRest -->
<div class='topic'>
	<p>
		The <a class="doclink" href="#juneau-rest-server">juneau-rest-server</a> and <a class="doclink" href="#juneau-rest-client">juneau-rest-client</a> libraries
		provide server and client side REST capabilities that can be used by themselves, or together to create
		simplified yet sophisticated Java-based REST communications layers that completely hide away the complexities
		of the REST protocol.
	</p>
	<p>
		A typical pattern is to define a REST API on the server side:
	</p>
	<p class='bjava'>	
	<ja>@Rest</ja>(path=<js>"/petstore"</js>)
	<jk>public class</jk> PetStoreRest {
		
		<ja>@RestPost</ja>(path=<js>"/pets"</js>, guards=AdminGuard.<jk>class</jk>)
		<jk>public</jk> Ok addPet(
			<ja>@Content</ja> CreatePet <jv>createPetBean</jv>, 
			<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>, 
			<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
		) <jk>throws</jk> BadRequest, Unauthorized, InternalServerError {
			<jc>// Process request here.</jc>
			<jk>return</jk> Ok.<jsf>OK</jsf>;  <jc>// Standard 400-OK response.</jc>
		}
	}
	</p>	
	<p>
		Then define a Java interface that can be provided to consumers of your API to access your REST API:
	</p>
	<p class='bjava'>	
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStoreClient {
		
		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		Ok addPet(
			<ja>@Content</ja> CreatePet <jv>createPet</jv>, 
			<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>, 
			<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
		) <jk>throws</jk> BadRequest, Unauthorized, InternalServerError;
	}
	</p>
	<p>
		Note that you may choose to have your service class implement your interface.  The REST libraries will
		happily look for annotations defined on methods of parent classes and interfaces.  It's up to you how
		you want to design it.
	</p>
	<p>
		Finally, the {@link org.apache.juneau.rest.client.RestClient} class is used to construct a remote proxy to our REST service:
	<p class='bjava'>	
	<jc>// Use a RestClient with default JSON 5 support and BASIC auth.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json5().basicAuth(...).build();
	
	<jc>// Instantiate our proxy interface.</jc>
	PetStoreClient <jv>store</jv> = <jv>client</jv>.getRemote(PetStoreClient.<jk>class</jk>, <js>"http://localhost:10000"</js>);
	
	<jc>// Use it to create a pet.</jc>
	CreatePet <jv>createPet</jv> = <jk>new</jk> CreatePet(<js>"Fluffy"</js>, 9.99);
	Pet <jv>pet</jv> = <jv>store</jv>.addPet(<jv>createPet</jv>, UUID.<jsm>randomUUID</jsm>(), <jk>true</jk>);
	</p>
	<p>
		The call above translates to the following REST call:
	</p>
	<p class='bcode'>
	POST http://localhost:10000/petstore/pets?debug=true HTTP/1.1
	Accept: application/json
	Content-Type: application/json
	Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
	E-Tag: 475588d4-0b27-4f56-9296-cc683251d314
	
	{
		name: 'Fluffy',
		price: 9.99 
	}
	</p>
	<p>
		It looks simplistic but the server and client APIs are highly sophisticated libraries that allow you
		to perform complex tasks using very little code.
	</p>
</div>
</div><!-- END: 1.2 - o.EndToEndRest -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.RestServer' id='o.RestServer'>1.3 - REST Server</a></h3>
<div class='topic'><!-- START: 1.3 - o.RestServer -->
<h5 class='topic'>@Rest-Annotated Resources</h5>
<div class='topic'>
	<p>
		A REST resource is simply a Java class annotated with {@link org.apache.juneau.rest.annotation.Rest}.
		The most common case is a class that extends {@link org.apache.juneau.rest.servlet.BasicRestServlet}, which itself is simply an 
		extension of {@link javax.servlet.http.HttpServlet} which allows it to be deployed as a servlet.  
	</p>
	<p class='bjava'>
	<jc>// Sample REST resource that prints out a simple "Hello world!" message.</jc>
	<ja>@Rest</ja>(
		path=<js>"/helloWorld"</js>,
		title=<js>"Hello World"</js>,
		description=<js>"An example of the simplest-possible resource"</js>
	)
	<ja>@HtmlDoc</ja>(
		navlinks={
			<js>"up: request:/.."</js>,
			<js>"options: servlet:/?method=OPTIONS"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a resource that simply response with a 'Hello world!' message&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;The POJO serialized is a simple String.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<ja>@BeanConfig</ja>(sortProperties=<js>"true"</js>)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {
	
		<ja>@RestGet</ja>(path=<js>"/*"</js>, summary=<js>"Responds with \"Hello world!\""</js>)
		<jk>public</jk> String sayHello() {
			<jk>return</jk> <js>"Hello world!"</js>;
		}
	}
	</p>
	<p>
		This is what it looks like in a browser.
	</p>
	<p class='bcode'>
	http://localhost:10000/helloWorld
	</p>
	<img class='bordered w800' src='doc-files/jrs.HelloWorldExample.1.png'>
	<ul class='spaced-list'>
		<li>Parsers for request bodies are selected based on the request <c>Content-Type</c> header.
		<li>Serializers for response bodies are selected based on the request <c>Accept</c> header.
		<ul>
			<li>In this case, it's the {@link org.apache.juneau.html.HtmlDocSerializer} serializer based on the
				browser's default <c>Accept</c> header that's asking for HTML.
		</ul>
		<li>REST resource classes and methods can be annotated with configuration annotations for the serializers and parsers (such as <ja>@HtmlConfig</ja> and <ja>@BeanConfig</ja> shown above).
		<li>Annotations such as the title, summary, and descriptions shown above are used for auto-generated Swagger UI pages (described later).
	</ul>
</div>

<h5 class='topic'>REST Children</h5>
<div class='topic'>
	<p>
		Child Resources are REST servlets or objects that are linked to parent resources through the 
		{@link org.apache.juneau.rest.annotation.Rest#children() @Rest(children)} annotation.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jd>/** Parent Resource */</jd>
	<ja>@Rest</ja>(
		path=<js>"/parent"</js>,
		children={
			MyChildResource.<jk>class</jk>
		}
	)
	<jk>public</jk> MyParentResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p class='bjava'>
	<jd>/** Child Resource */</jd>
 	<ja>@Rest</ja>(
		path=<js>"/child"</js>  <jc>// Path relative to parent resource.</jc>
	)
	<jc>// Note that we don't need to extend from RestServlet.</jc>
	<jk>public</jk> MyChildResource <jk>implements</jk> BasicRestObject {
		...
	} 
	</p>
	<p>
		The path of the child resource gets appended to the path of the parent resource. 
		So in the example above, the child resource is accessed through the URL <l>/parent/child</l>.
	</p>
	<p>
		The advantage of using child resources is that they do not need to be declared in the JEE <l>web.xml</l> 
		file.
		Initialization of and access to the child resources occurs through the parent resource.
		Children can be nested arbitrary deep to create complex REST interfaces with a single top-level REST servlet.
	</p>
</div>

<h5 class='topic'>Predefined Configuration Interfaces</h5>
<div class='topic'>
	<p>
		The servlets in the previous section implemented the {@link org.apache.juneau.rest.config.BasicUniversalConfig} which simply defines
		a preconfigured set of annotations that get inherited by the child classes:
	</p>
	<p class='bjava'>
	<jd>/**
	 * Predefined configuration for a REST resource that supports all languages 
	 * and provides common default configuration values.</jd>
	 */</jd>
	<ja>@Rest</ja>(
	
		<jc>// Default serializers for all Java methods in the class.</jc>
		serializers={
			HtmlDocSerializer.<jk>class</jk>,
			HtmlStrippedDocSerializer.<jk>class</jk>,
			HtmlSchemaDocSerializer.<jk>class</jk>,
			JsonSerializer.<jk>class</jk>,
			Json5Serializer.<jk>class</jk>,
			JsonSchemaSerializer.<jk>class</jk>,
			XmlDocSerializer.<jk>class</jk>,
			UonSerializer.<jk>class</jk>,
			UrlEncodingSerializer.<jk>class</jk>,
			OpenApiSerializer.<jk>class</jk>,
			MsgPackSerializer.<jk>class</jk>,
			SoapXmlSerializer.<jk>class</jk>,
			PlainTextSerializer.<jk>class</jk>,
			CsvSerializer.<jk>class</jk>
		},
	
		<jc>// Default parsers for all Java methods in the class.</jc>
		parsers={
			JsonParser.<jk>class</jk>,
			Json5Parser.<jk>class</jk>,
			XmlParser.<jk>class</jk>,
			HtmlParser.<jk>class</jk>,
			UonParser.<jk>class</jk>,
			UrlEncodingParser.<jk>class</jk>,
			OpenApiParser.<jk>class</jk>,
			MsgPackParser.<jk>class</jk>,
			PlainTextParser.<jk>class</jk>,
			CsvParser.<jk>class</jk>
		}
	)
	<jk>public interface</jk> BasicUniversalConfig <jk>extends</jk> DefaultConfig, DefaultHtmlConfig {}
	</p>
	<p class='bjava'>
	<jd>/**
	 * Predefined REST configuration that defines common default values for all configurations.
	 */</jd>
	<ja>@Rest</ja>(
		<jc>// Configuration file.</jc>
		config=<js>"$S{j.configFile,$E{J_CONFIG_FILE,SYSTEM_DEFAULT}}"</js>,
	
		<jc>// Standard fields.</jc>
		path=<js>""</js>,
		roleGuard=<js>""</js>,
		rolesDeclared=<js>""</js>,
	
		<jc>// Configuration beans.</jc>
		converters={},
		encoders={IdentityEncoder.<jk>class</jk>},
		guards={},
		parsers={},
		partParser=OpenApiParser.<jk>class</jk>,
		partSerializer=OpenApiSerializer.<jk>class</jk>,
		responseProcessors={
			ReaderProcessor.<jk>class</jk>,
			InputStreamProcessor.<jk>class</jk>,
			ThrowableProcessor.<jk>class</jk>,
			HttpResponseProcessor.<jk>class</jk>,
			HttpResourceProcessor.<jk>class</jk>,
			HttpEntityProcessor.<jk>class</jk>,
			ResponseBeanProcessor.<jk>class</jk>,
			PlainTextPojoProcessor.<jk>class</jk>,
			SerializedPojoProcessor.<jk>class</jk>
		},
		restOpArgs={
			AttributeArg.<jk>class</jk>,
			ContentArg.<jk>class</jk>,
			FormDataArg.<jk>class</jk>,
			HasFormDataArg.<jk>class</jk>,
			HasQueryArg.<jk>class</jk>,
			HeaderArg.<jk>class</jk>,
			HttpServletRequestArgs.<jk>class</jk>,
			HttpServletResponseArgs.<jk>class</jk>,
			HttpSessionArgs.<jk>class</jk>,
			InputStreamParserArg.<jk>class</jk>,
			MethodArg.<jk>class</jk>,
			ParserArg.<jk>class</jk>,
			PathArg.<jk>class</jk>,
			QueryArg.<jk>class</jk>,
			ReaderParserArg.<jk>class</jk>,
			RequestBeanArg.<jk>class</jk>,
			ResponseBeanArg.<jk>class</jk>,
			ResponseHeaderArg.<jk>class</jk>,
			ResponseCodeArg.<jk>class</jk>,
			RestContextArgs.<jk>class</jk>,
			RestSessionArgs.<jk>class</jk>,
			RestOpContextArgs.<jk>class</jk>,
			RestOpSessionArgs.<jk>class</jk>,
			RestRequestArgs.<jk>class</jk>,
			RestResponseArgs.<jk>class</jk>,
			DefaultArg.<jk>class</jk>
		},
		serializers={},
	
		<jc>// Configurable settings.</jc>
		allowedHeaderParams=<js>"$S{j.allowedHeaderParams,$E{J_ALLOWED_HEADER_PARAMS,Accept,Content-Type}}"</js>,
		allowedMethodHeaders=<js>"$S{j.allowedMethodHeaders,$E{J_ALLOWED_METHOD_HEADERS,}}"</js>,
		allowedMethodParams=<js>"$S{j.allowedMethodParams,$E{J_ALLOWED_METHOD_PARAMS,HEAD,OPTIONS}}"</js>,
		clientVersionHeader=<js>"$S{j.clientVersionHeader,$E{J_CLIENT_VERSION_HEADER,Client-Version}}"</js>,
		debug=<js>"$S{j.debug,$E{J_DEBUG,}}"</js>,
		debugOn=<js>"$S{j.debugOn,$E{J_DEBUG_ON,}}"</js>,
		defaultAccept=<js>"$S{j.defaultAccept,$E{J_DEFAULT_ACCEPT,}}"</js>,
		defaultCharset=<js>"$S{j.defaultCharset,$E{J_DEFAULT_CHARSET,UTF-8}}"</js>,
		defaultContentType=<js>"$S{j.defaultContentType,$E{J_DEFAULT_CONTENT_TYPE,}}"</js>,
		defaultRequestAttributes=<js>"$S{j.defaultRequestAttributes,$E{J_DEFAULT_REQUEST_ATTRIBUTES,}}"</js>,
		defaultRequestHeaders=<js>"$S{j.defaultRequestHeaders,$E{J_DEFAULT_REQUEST_HEADERS,}}"</js>,
		defaultResponseHeaders=<js>"$S{j.defaultResponseHeaders,$E{J_DEFAULT_RESPONSE_HEADERS,}}"</js>,
		disableContentParam=<js>"$S{j.disableContentParam,$E{J_DISABLE_CONTENT_PARAM,false}}"</js>,
		maxInput=<js>"$S{j.maxInput,$E{J_MAX_INPUT,1000000}}"</js>,
		messages=<js>"$S{j.messages,$E{J_MESSAGES,}}"</js>,
		renderResponseStackTraces=<js>"$S{j.renderResponseStackTraces,$E{J_RENDER_RESPONSE_STACK_TRACES,false}}"</js>,
		uriAuthority=<js>"$S{j.uriAuthority,$E{J_URI_AUTHORITY,}}"</js>,
		uriContext=<js>"$S{j.uriContext,$E{J_URI_CONTEXT,}}"</js>,
		uriRelativity=<js>"$S{j.uriRelativity,$E{J_URI_RELATIVITY,}}"</js>,
		uriResolution=<js>"$S{j.uriResolution,$E{J_URI_RESOLUTION,}}"</js>,
	
		<jc>// Metadata settings.</jc>
		consumes={},
		description=<js>""</js>,
		produces={},
		siteName=<js>"$S{j.siteName,$E{J_SITE_NAME,}}"</js>,
		swagger=@Swagger,
		title=<js>"$S{j.title,$E{J_TITLE,}}"</js>,
	
		<jc>// Injectable/overridable beans.</jc>
		beanStore=BeanStore.Void.<jk>class</jk>,  <jc>// Defaults to BeanStore.</jc>
		callLogger=CallLogger.Void.<jk>class</jk>,  <jc>// Defaults to BasicCallLogger.</jc>
		debugEnablement=DebugEnablement.Void.<jk>class</jk>,  <jc>// Defaults to BasicDefaultEnablement.</jc>
		fileFinder=FileFinder.Void.<jk>class</jk>,  <jc>// Defaults to BasicFileFinder.</jc>
		staticFiles=StaticFiles.Void.<jk>class</jk>,  <jc>// Defaults to BasicStaticFiles.</jc>
		swaggerProvider=SwaggerProvider.Void.<jk>class</jk>,  <jc>// Defaults to BasicSwaggerProvider.</jc>
	
		<jc>// Overridable context classes.</jc>
		contextClass=RestContext.<jk>class</jk>,
		restChildrenClass=RestChildren.<jk>class</jk>,
		restOpContextClass=RestOpContext.<jk>class</jk>,
		restOperationsClass=RestOperations.<jk>class</jk>
	)
	<ja>@BeanConfig</ja>(
		<jc>// When parsing generated beans, ignore unknown properties 
		// that may only exist as getters and not setters.</jc>
		ignoreUnknownBeanProperties=<js>"true"</js>,
		ignoreUnknownEnumValues=<js>"true"</js>
	)
	<ja>@SerializerConfig</ja>(
		<jc>// Enable automatic resolution of URI objects to root-relative values.</jc>
		uriResolution=<js>"ROOT_RELATIVE"</js>
	)
	<jk>public interface</jk> DefaultConfig {}
	</p>
	<p class='bjava'>
	<jd>/**
	 * Predefined REST configuration that defines common default values the HTML Doc serializer.
	 */</jd>
	<ja>@HtmlDocConfig</ja>(
	
		<jc>// Default page header contents.</jc>
		header={
			<js>"&lt;h1&gt;$RS{title}&lt;/h1&gt;"</js>,  <jc>// Use @Rest(title)</jc>
			<js>"&lt;h2&gt;$RS{operationSummary,description}&lt;/h2&gt;"</js>, <jc>// Use either @RestOp(summary) or @Rest(description)</jc>
			<js>"$C{REST/header}"</js>  <jc>// Extra header HTML defined in external config file.</jc>
		},
	
		<jc>// Basic page navigation links.</jc>
		navlinks={
			<js>"up: request:/.."</js>
		},
	
		<jc>// Default stylesheet to use for the page.
		// Can be overridden from external config file.
		// Default is DevOps look-and-feel (aka Depression look-and-feel).</jc>
		stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>,
	
		<jc>// Default contents to add to the &lt;head&gt; section of the HTML page.
		// Use it to add a favicon link to the page.</jc>
		head=<js>"$C{REST/head}"</js>,
	
		<jc>// No default page footer contents.
		// Can be overridden from external config file.</jc>
		footer=<js>"$C{REST/footer}"</js>,
	
		<jc>// By default, table cell contents should not wrap.</jc>
		nowrap=<js>"true"</js>
	)
	<jk>public interface</jk> DefaultHtmlConfig {}
	</p>
	<p>
		The {@link org.apache.juneau.rest.config} package contains other basic configurations for use.
		Annotations are aggregated from child-to-parent order allowing for these basic configurations
		to be extended and modified, or you can create your own annotations from scratch.
	</p>
</div>	
	
<h5 class='topic'>REST Group Pages</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.servlet.BasicRestServletGroup} class provides a default "router" page for 
		child resources when a parent resource is nothing more than a grouping of child resources.
	</p>		
	<p>
		The <l>RootResources</l> class in the Samples project is an example of a router page:
	</p>
	<p class='bjava'>		
	<jd>/**
	 * Sample REST resource showing how to implement a "router" resource page.
	 */</jd>
	<ja>@Rest</ja>(
		path=<js>"/"</js>,
		title=<js>"Root resources"</js>,
		description=<js>"Example of a router resource page."</js>,
		children={
			HelloWorldResource.<jk>class</jk>,
			PetStoreResource.<jk>class</jk>,
			DtoExamples.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {
		<jc>// NO CODE!!!</jc>
	}
	</p>
	<p>
		When you bring up this resource in a browser, you see the following that provides a list
		of navigable links to your child resources:
	</p>
	<p class='bcode'>
	http://localhost:10000
	</p>
	<img class='bordered w800' src='doc-files/jrs.RouterPages.1.png'/>
</div>

<h5 class='topic'>REST Resource Methods</h5>
<div class='topic'>
	<p>
		The real power behind the REST server API is the ability to define Java methods as REST endpoints.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestPost</ja>(path=<js>"/pets"</js>, guards=AdminGuard.<jk>class</jk>)
	<jk>public</jk> Ok addPet(
		<ja>@Content</ja> CreatePet <jv>createPetBean</jv>, 
		<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>, 
		<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
	) <jk>throws</jk> BadRequest, Unauthorized, InternalServerError {
		<jc>// Process request.</jc>
		<jk>return</jk> Ok.<jsf>OK</jsf>;
	}
	</p>
	<p>
		Java methods on {@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated classes have the following format:
	</p>
	<p class='bjava'>
	<ja>@RestOp</ja>(method=<js>"..."</js>, path=<js>"..."</js>)
	<ja><i>&lt;config-annotations&gt;</i></ja>
	<jk>public</jk> <i>&lt;return-type&gt;</i> method(<i>&lt;args&gt;</i>) <jk>throws</jk> <i>&lt;throwables&gt;</i> {
		...
	}
	</p>
	<p>
		The various parts require their own topics to fully appreciate the scope of abilities but the following is a summary:
	</p>
	<ul class='spaced-list'>
		<li>Annotated with {@link org.apache.juneau.rest.annotation.RestOp @RestOp}.
		<ul>
			<li>Also available: {@link org.apache.juneau.rest.annotation.RestGet @RestGet} / {@link org.apache.juneau.rest.annotation.RestPut @RestPut} / {@link org.apache.juneau.rest.annotation.RestPost @RestPost} / {@link org.apache.juneau.rest.annotation.RestDelete @RestDelete}.
			<li>Annotation optional if using standard naming conventions (e.g. <c>getFoo()</c> equivalent to <c><ja>@RestGet</ja>(path=<js>"/foo"</js>)</c>).
		</ul>
		<li>Optionally annotated with config annotations such as {@link org.apache.juneau.annotation.BeanConfig @BeanConfig} and {@link org.apache.juneau.html.annotation.HtmlDocConfig @HtmlDocConfig} that 
			customize the behavior of serializers and parsers at the method level.
		<li>Returned object gets serialized as the HTTP response body.
		<ul>
			<li>Typically a POJO serialized based on {@link org.apache.juneau.http.header.Accept} request header.
			<li>Support for raw values such as <c>Readers</c> and <c>InputStreams</c> (among others).
			<li>Support for response beans annotated with {@link org.apache.juneau.http.annotation.Response @Response}.
			<li>Support for Apache Http Core interfaces: {@link org.apache.http.HttpEntity} / {@link org.apache.http.HttpResponse} / {@link org.apache.juneau.http.resource.HttpResource}.
			<li>Standard HTTP responses such as {@link org.apache.juneau.http.response.Ok} and {@link org.apache.juneau.http.response.TemporaryRedirect} provided in {@link org.apache.juneau.http.response} package.
			<li>Extensible API for defining custom return types.
		</ul>
		<li>A wide range of possible argument types including:
		<ul>
			<li>Standard {@link javax.servlet.http.HttpServletRequest} / {@link javax.servlet.http.HttpServletResponse} objects.
			<li>Extended {@link org.apache.juneau.rest.RestRequest} / {@link org.apache.juneau.rest.RestResponse} objects.
			<li>Parsed HTTP parts with either the arguments or beans annotated with {@link org.apache.juneau.http.annotation.Path @Path} / {@link org.apache.juneau.http.annotation.Header @Header} / {@link org.apache.juneau.http.annotation.Query @Query} / {@link org.apache.juneau.http.annotation.FormData @FormData}.
			<li>Parsed HTTP body with either the argument or bean annotated with {@link org.apache.juneau.http.annotation.Content @Content}.
			<li>Raw HTTP request body with <c>InputStream</c> or <c>Reader</c>.
			<li>Raw HTTP response body with <c>OutputStream</c> or <c>Writer</c>.
			<li>Request beans annotated with {@link org.apache.juneau.http.annotation.Request @Request}.
			<li>Response beans annotated with {@link org.apache.juneau.http.annotation.Response @Response}.
			<li>Standard HTTP headers such as {@link org.apache.juneau.http.header.Accept} and {@link org.apache.juneau.http.header.ContentType}  provided in {@link org.apache.juneau.http.header} package.
			<li>Auto-generated {@link org.apache.juneau.dto.swagger.Swagger}.
			<li>Various other standard objects such as {@link java.security.Principal}, {@link javax.servlet.http.Cookie}, {@link javax.servlet.http.HttpSession}, and {@link java.util.ResourceBundle}.
			<li>Spring beans or other injectable beans.
			<li>Extensible API for defining custom argument types.
		</ul>
		<li>Throwables can be anything.
		<ul>
			<li>Typically one of the standard HTTP responses such as {@link org.apache.juneau.http.response.BadRequest} or {@link org.apache.juneau.http.response.NotFound} provided in {@link org.apache.juneau.http.response} package.
			<li>Can define your own {@link org.apache.juneau.http.annotation.Response @Response}-annotated throwables.
			<li>Anything else gets converted to an {@link org.apache.juneau.http.response.InternalServerError}. 
		</ul>
	</ul>
</div>
	
<h5 class='topic'>Deploying as a Servlet</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.servlet.BasicRestServlet} class is the entry point for your REST resources.
		It extends directly from <l>HttpServlet</l> and is deployed like any other servlet (such as a standard <c>web.xml</c> file).
	</p>
	<p>
		When the servlet <l>init()</l> method is called, it triggers the code to find and process the <l>@Rest</l>
		annotations on that class and all child classes.
		These get constructed into a {@link org.apache.juneau.rest.RestContext} object that holds all the configuration
		information about your resource in a read-only object.
	</p>
	<p>
		Most developers are not going to be using the <l>RestServlet</l> class itself, and instead will
		extend from one of the preconfigured default servlets such as {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestServletGroup} 
		which provides universal language support, basic instrumentation, and auto-generated Swagger UI.
	</p>
</div>

<h5 class='topic'>Deploying in Spring Boot</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} class is typically entry point for your REST resources
		when working within a Spring Boot environment.  It extends from 
		{@link org.apache.juneau.rest.springboot.SpringRestServlet} which provides additional capabilities including:
	</p>
	<ul>
		<li>Your REST resources can be defined as injectable Spring beans.
		<li>Various capabilities within the REST Server library (e.g. logging, instrumentation, call handling, API extensions) can be defined via
			Spring beans and automatically pulled into the framework.
	</ul>
	<p>
		Most developers are not going to be using the <l>RestServlet</l> class itself, and instead will
		extend from one of the preconfigured default servlets such as {@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} and {@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup}
		that have the same capabilites as the {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestServletGroup} counterparts.
	</p>
	<h5 class='figure'>Example configuration file:</h5>
	<p class='bjava'>
	<ja>@Configuration</ja>
	<jk>public class</jk> MySpringConfiguration {
		
		<jd>/**
		 * Our root REST bean.
		 * Note that this must extend from SpringRestServlet so that child resources can be 
		 * resolved as Spring beans.
		 * All REST objects are attached to this bean using the {@link org.apache.juneau.rest.annotation.Rest#children()} annotation.
		 */</jd>
		<ja>@Bean</ja>
		<jk>public</jk> RootResources getRootResources() {
			<jk>return new</jk> RootResources();
		}
	
		<jd>/**
		 * Optionally return the HelloWorldResource object as an injectable bean.
		 */</jd>
		<ja>@Bean</ja>
		<jk>public</jk> HelloWorldResource getHelloWorldResource() {
			<jk>return new</jk> HelloWorldResource();
		}
	
		<jd>/**
		 * Map our servlet to a path.
		 */</jd>
		<ja>@Bean</ja>
		<jk>public</jk> ServletRegistrationBean&lt;Servlet&gt; getRootServlet(RootResources <jv>rootResources</jv>) {
			<jk>return new</jk> ServletRegistrationBean&lt;&gt;(<jv>rootResources</jv>, <js>"/*"</js>);
		}
	}
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		children={
			HelloWorldResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicSpringRestServletGroup {
		<jc>// No code!</jc>
	}
	</p>
</div>

<h5 class='topic'>Additional Information</h5>
<div class='topic'>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#juneau-rest-server">juneau-rest-server</a> for more information.
	</ul>
</div>
</div><!-- END: 1.3 - o.RestServer -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.RestClient' id='o.RestClient'>1.4 - REST Client</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.4 - o.RestClient -->
<div class='topic'>
	<p>
		Built upon the feature-rich Apache HttpClient library, the Juneau RestClient API adds support for fluent-style
		REST calls and the ability to perform marshalling of POJOs to and from HTTP parts.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON support and download a bean.</jc>
	MyBean <jv>bean</jv> = RestClient.<jsm>create</jsm>()
		.json5()
		.build()
		.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(200)
		.assertHeader(<js>"Content-Type"</js>).matchesSimple(<js>"application/json*"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
</div>

<h5 class='topic'>REST Testing Framework</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestClient} class is used for performing serverless unit testing of {@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated
		and {@link org.apache.juneau.http.remote.Remote @Remote}-annotated classes.  It perform full serialization and parsing of the HTTP request and responses, 
		but bypasses the network layer to significantly improve speed while still performing real testing.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>public class</jk> MockTest {

		<jc>// A simple bean with one field.</jc>
		<jk>public static class</jk> MyBean {
			<jk>public int</jk> <jf>foo</jf> = 1;
		}

		<jc>// Our REST resource to test.</jc>
		<jc>// Simply echos the response.</jc>
		<ja>@Rest</ja>
		<jk>public static class</jk> EchoRest <jk>extends</jk> BasicRestServlet {

			<ja>@RestPut</ja>
			<jk>public</jk> MyBean echo(<ja>@Content</ja> MyBean <jv>bean</jv>) {
				<jk>return</jk> <jv>bean</jv>;
			}
		}

		<jc>// Our JUnit test.</jc>
		<ja>@Test</ja>
		<jk>public void</jk> testEcho() <jk>throws</jk> Exception {

			MyBean <jv>myBean</jv> = <jk>new</jk> MyBean();

			<jc>// Do a round-trip on the bean through the REST interface</jc>
			<jv>myBean</jv> = MockRestClient
				.<jsm>create</jsm>(EchoRest.<jk>class</jk>)
				.json5()
				.build()
				.put(<js>"/echo"</js>, <jv>myBean</jv>)
				.run()
				.assertStatus().is(200)
				.assertContent().is(<js>"{foo:1}"</js>)
				.getContent().as(MyBean.<jk>class</jk>);

			<jsm>assertEquals</jsm>(1, <jv>myBean</jv>.<jf>foo</jf>);
		}
	}
	</p>
</div>


<h5 class='topic'>Additional Information</h5>
<div class='topic'>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#juneau-rest-client">juneau-rest-client</a> for more information.
	</ul>
</div>
</div><!-- END: 1.4 - o.RestClient -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.Dtos' id='o.Dtos'>1.5 - DTOs</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.5 - o.Dtos -->
<div class='topic'>
	<p>
		The <a class="doclink" href="#juneau-dto">juneau-dto</a> library contains several predefined POJOs for generating commonly-used document types that
		are designed to be used with the Juneau Marshaller APIs for both serializing and parsing.
	</p>
</div>

<h5 class='topic'>HTML5</h5>
<div class='topic'>
	<p>
		The Juneau HTML5 DTOs are simply beans with fluent-style setters that allow you to quickly construct HTML
		fragments as Java objects.  These object can then be serialized to HTML using one of the existing HTML 
		serializers, or to other languages such as JSON using the JSON serializers.
	</p>
	<p>
		The {@link org.apache.juneau.dto.html5.HtmlBuilder} class is a utility class with predefined static methods
		that allow you to easily construct DTO instances in a minimal amount of code. 
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;

	<jc>// An HTML table</jc>	
	Object <jv>mytable</jv> = 	
		<jsm>table</jsm>(
			<jsm>tr</jsm>(
				<jsm>th</jsm>(<js>"c1"</js>),
				<jsm>th</jsm>(<js>"c2"</js>)
			),
			<jsm>tr</jsm>(
				<jsm>td</jsm>(<js>"v1"</js>),
				<jsm>td</jsm>(<js>"v2"</js>)
			)
		);
		
	String <jv>html</jv> = Html.<jsm>of</jsm>(<jv>mytable</jv>);
	</p>
	<p class='bxml'><xt>
	&lt;table&gt;
		&lt;tr&gt;
			&lt;th&gt;<xv>c1</xv>&lt;/th&gt;
			&lt;th&gt;<xv>c2</xv>&lt;/th&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>v1</xv>&lt;/td&gt;
			&lt;td&gt;<xv>v2</xv>&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
	</xt></p>	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jd.Html5">HTML5</a> for more information.
	</ul>
</div>

<h5 class='topic'>ATOM</h5>
<div class='topic'>
	<p>
		The Juneau ATOM feed DTOs are simply beans with fluent-style setters.
		The following code shows a feed being created programmatically using the 
		{@link org.apache.juneau.dto.atom.AtomBuilder} class.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.atom.AtomBuilder.*;
	
	Feed <jv>feed</jv> = 
		<jsm>feed</jsm>(<js>"tag:juneau.apache.org"</js>, <js>"Juneau ATOM specification"</js>, <js>"2016-01-02T03:04:05Z"</js>)
		.subtitle(<jsm>text</jsm>(<js>"html"</js>).text(<js>"Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau"</js>))
		.links(
			<jsm>link</jsm>(<js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org"</js>).hreflang(<js>"en"</js>),
			<jsm>link</jsm>(<js>"self"</js>, <js>"application/atom+xml"</js>, <js>"http://juneau.apache.org/feed.atom"</js>)
		)
		.rights(<js>"Copyright (c) ..."</js>)
		.generator(
			<jsm>generator</jsm>(<js>"Juneau"</js>).uri(<js>"http://juneau.apache.org/"</js>).version(<js>"1.0"</js>)
		)
		.entries(
			<jsm>entry</jsm>(<js>"tag:juneau.sample.com,2013:1.2345"</js>, <js>"Juneau ATOM specification snapshot"</js>, <js>"2016-01-02T03:04:05Z"</js>)
			.links(
				<jsm>link</jsm><js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org/juneau.atom"</js>),
				<jsm>link</jsm>(<js>"enclosure"</js>, <js>"audio/mpeg"</js>, <js>"http://juneau.apache.org/audio/juneau_podcast.mp3"</js>).length(1337)
			)
			.published(<js>"2016-01-02T03:04:05Z"</js>)
			.authors(
				<jsm>person</jsm>(<js>"Jane Smith"</js>).uri(<js>"http://juneau.apache.org/"</js>).email(<js>"janesmith@apache.org"</js>)
			)
			.contributors(
				<jsm>person</jsm>(<js>"John Smith"</js>)
			)
			.content(
				<jsm>content</jsm>(<js>"xhtml"</js>)
				.lang(<js>"en"</js>)
				.base(<js>"http://www.apache.org/"</js>)
				.text(<js>"&lt;div&gt;&lt;p&gt;&lt;i&gt;[Update: Juneau supports ATOM.]&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;"</js>)
			)
		);

	<jc>// Create a serializer with readable output, no namespaces yet.</jc>
	XmlSerializer <jv>serializer</jv> = XmlSerializer.<jsm>create</jsm>().sq().ws().build();

	<jc>// Serialize to ATOM/XML</jc>
	String <jv>atomXml</jv> = <jv>serializer</jv>.serialize(<jv>feed</jv>);
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jd.Atom">Atom</a> for more information.
	</ul>
</div>

<h5 class='topic'>Swagger</h5>
<div class='topic'>
	<p>
		The Juneau Swagger DTOs are simply beans with fluent-style setters that allow you to quickly construct 
		Swagger documents as Java objects.  
		These object can then be serialized to JSON using one of the existing JSON serializers, or to other 
		languages such as XML or HTML using the other serializers.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>static import</jk> org.apache.juneau.dto.swagger.SwaggerBuilder.*;

	Swagger <jv>swagger</jv> = <jsm>swagger</jsm>()
		.swagger(<js>"2.0"</js>)
		.info(
			<jsm>info</jsm>(<js>"Swagger Petstore"</js>, <js>"1.0.0"</js>)
				.description(<js>"This is a sample server Petstore server."</js>)
				.termsOfService(<js>"http://swagger.io/terms/"</js>)
				.contact(
					<jsm>contact</jsm>().email(<js>"apiteam@swagger.io"</js>)
				)
				.license(
					<jsm>license</jsm>(<js>"Apache 2.0"</js>).url(<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>)
				)
		)
		.host(<js>"petstore.swagger.io"</js>)
		.basePath(<js>"/v2"</js>)
		.tags(
			<jsm>tag</jsm>(<js>"pet"</js>).description(<js>"Everything about your Pets"</js>)
				.externalDocs(
					<jsm>externalDocumentation</jsm>(<js>"http://swagger.io"</js>, <js>"http://swagger.io"</js>)
				)
		)
		.schemes(<js>"http"</js>)
		.path(<js>"/pet"</js>, <js>"post"</js>,
			<jsm>operation</jsm>()
				.tags(<js>"pet"</js>)
				.summary(<js>"Add a new pet to the store"</js>)
				.description(<js>""</js>)
				.operationId(<js>"addPet"</js>)
				.consumes(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.produces(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.parameters(
					<jsm>parameterInfo</jsm>(<js>"body"</js>, <js>"body"</js>)
						.description(<js>"Pet object that needs to be added to the store"</js>)
						.required(<jk>true</jk>)
				)
				.response(405, <jsm>responseInfo</jsm>(<js>"Invalid input"</js>))
		);

	<jc>// Serialize using JSON serializer.</jc>
	String <jv>swaggerJson</jv> = Json.<jsm>of</jsm>(<jv>swagger</jv>);
	
	<jc>// Or just use toString() or asJson().</jc>
	String <jv>swaggerJson</jv> = <jv>swagger</jv>.asJson();
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jd.Swagger">Swagger</a> for more information.
	</ul>
</div>

<h5 class='topic'>SwaggerUI</h5>
<div class='topic'>
	<p>
		The {@link org.apache.juneau.dto.swagger.ui.SwaggerUI} class is a DTO class for generating Swagger user interfaces
		from {@link org.apache.juneau.dto.swagger.Swagger} beans.
	</p>
	<p>
		The <c>PetStore</c> example described later provides an example of auto-generated Swagger JSON:
	</p>
	<img class='bordered w900' src='doc-files/jd.SwaggerUI.json.png'>
	<p>
		Using {@link org.apache.juneau.dto.swagger.ui.SwaggerUI}, we're able to render that JSON as a Swagger user interface
		when the request is asking for HTML:
	</p>
	<img class='bordered w900' src='doc-files/jd.SwaggerUI.html.png'>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jd.SwaggerUi">Swagger UI</a> for more information.
	</ul>
</div>
</div><!-- END: 1.5 - o.Dtos -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.ConfigFiles' id='o.ConfigFiles'>1.6 - Config Files</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.6 - o.ConfigFiles -->
<div class='topic'>
	<p>
		The <a class="doclink" href="#juneau-config">juneau-config</a> library contains a powerful API for creating and using INI-style config files.
	</p>
	<h5 class='figure'>Example configuration file:</h5>
	<p class='bini'>
	<cc># A set of entries</cc>
	<cs>[Section1]</cs>

	<cc># An integer</cc>
	<ck>key1</ck> = <cv>1</cv>

	<cc># A boolean</cc>
	<ck>key2</ck> = <cv>true</cv>
	
	<cc># An array</cc>
	<ck>key3</ck> = <cv>1,2,3</cv>

	<cc># A POJO</cc>
	<ck>key4</ck> = <cv>http://bar</cv>
	</p>
	<p>
		Config files are accessed through the {@link org.apache.juneau.config.Config} class which
		are created through the {@link org.apache.juneau.config.Config.Builder} class.
		Builder creator methods are provided on the <c>Config</c> class:
	</p>
	<p class='bjava'>
	<jc>// Create a Config object</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>().name(<js>"MyConfig.cfg"</js>).build();
	
	<jc>// Read values from section #1</jc>
	<jk>int</jk> <jv>key1</jv> = <jv>config</jv>.getInt(<js>"Section1/key1"</js>);
	<jk>boolean</jk> <jv>key2</jv> = <jv>config</jv>.getBoolean(<js>"Section1/key2"</js>);
	<jk>int</jk>[] <jv>key3</jv> = <jv>config</jv>.getObject(<js>"Section1/key3"</js>, <jk>int</jk>[].<jk>class</jk>);
	URL <jv>key4</jv> = <jv>config</jv>.getObject(<js>"Section1/key4"</js>, URL.<jk>class</jk>);
	</p>
	<p>
		The config language may look simple but it is a very powerful feature with many capabilities.
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#juneau-config">juneau-config</a> for more information.
	</ul>
</div>
</div><!-- END: 1.6 - o.ConfigFiles -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.FluentAssertions' id='o.FluentAssertions'>1.7 - Fluent Assertions</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.7 - o.FluentAssertions -->
<div class='topic'>
	<p>
		The <a class="doclink" href="#juneau-assertions">juneau-assertions</a> module in Juneau is a powerful API for performing fluent style assertions.
	</p>
	<p>
		Fluent assertions have two types of methods:
	</p>
	<ul>
		<li><c>"asX"</c> methods which perform transformations.
		<li><c>"isX"</c> methods which perform assertions.
	</ul>
	<p>
		Multiple transformations and assertions can be performed per statement.
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.assertions.Assertions.*;
	<jk>import static</jk> org.apache.juneau.assertions.AssertionPredicates.*;
	
	<jc>// Check the contents of a string.</jc>
	<jsm>assertString</jsm>(<js>"foo, bar"</js>)
		.asSplit(<js>","</js>)
		.asTrimmed()
		.is(<js>"foo"</js>, <js>"bar"</js>);

	<jc>// Extract a subset of properties from a list of beans and compare using Simplified JSON.</jc>
	List&lt;MyBean&gt; <jv>myListOfBeans</jv> = ...;
	<jsm>assertBeanList</jsm>(<jv>myListOfBeans</jv>)
		.asPropertyMaps(<js>"a,b"</js>)
		.asJson().is(<js>"[{a:1,b:'foo'}]"</js>);
	
	<jc>// Perform an arbitrary Predicate check against a bean.</jc>
	MyBean <jv>myBean</jv> = ...;
	<jsm>assertBean</jsm>(<jv>myBean</jv>)
		.is(<jv>x</jv> -&gt; <jsm>isValidCheck</jsm>(<jv>x</jv>))
	
	<jc>// Check that a list of strings has less than 10 entries and the first</jc>
	<jc>// 3 entries are [foo, bar*, null] using assertion predicates.</jc>
	List&lt;String&gt; <jv>myListOfStrings</jv> = ...;
	<jsm>assertStringList</jsm>(<jv>myListOfStrings</jv>)
		.asSize().isLt(10)
		.asFirst(3)
			.is(<jsm>eq</jsm>(<js>"foo"</js>),<jsm>match</jsm>(<js>"bar*"</js>),<jsm>isNull</jsm>())
	
	<jc>// Check that an exception is thrown and is the specified type and has the specified message.</jc>
	<jsm>assertThrown</jsm>(()-&gt;<jv>myBean</jv>.runBadMethod())
		.isExists()
		.isExactType(RuntimeException.<jk>class</jk>)
		.asMessage().is(<js>"foo"</js>);
	</p>
	<p>
		The Assertions APIs are used throughout the REST client and server APIs for performing inline assertions on REST requests and responses.
	</p>

	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON support and download a bean.</jc>
	MyBean <jv>bean</jv> = RestClient.<jsm>create</jsm>()
		.json5()
		.build()
		.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(200)
		.assertHeader(<js>"Content-Type"</js>).isMatches(<js>"application/json*"</js>)
		.getContent().assertValue().asString().isContains(<js>"OK"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#ja.Overview">Fluent Assertions</a> for more information.
	</ul>
</div>
</div><!-- END: 1.7 - o.FluentAssertions -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#o.GeneralDesign' id='o.GeneralDesign'>1.8 - General Design</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 1.8 - o.GeneralDesign -->
<div class='topic'>
	<p>
		The Juneau framework uses the design pattern of builders, context, and session objects:
	</p>
	<ul>
		<li>Context Builders - Modifiable objects that allow you to define configuration settings for contexts.
		<li>Contexts - Unmodifiable thread-safe objects meant to be cacheable and reusable.
		<li>Sessions - Modifiable objects usually meant for one-time use.
	</ul>
	<p>
		This is a general design pattern used throughout the framework including the REST client and server APIs.
	</p>
	<p>
		The following shows the general pattern for creating sessions:
	</p>
	<p class='bjava'>
	<jc>// Create a reusable context object (in this case a serializer).</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()                 <jc>// Instantiates a context builder.</jc>
		.findFluentSetters()      <jc>// Sets a configuration value.</jc>
		.build();                 <jc>// Creates a context.</jc>
	
	<jc>// Create a one-time session object.</jc>
	WriterSerializerSession <jv>session</jv> = <jv>serializer</jv>
		.createSession()           <jc>// Instantiates a session builder.</jc>
		.useWhitespace()           <jc>// Sets a session value.</jc>
		.build();                  <jc>// Creates a session.</jc>
		
	<jc>// Use it.</jc>
	String <jv>json</jv> = <jv>session</jv>.serialize(<jv>myBean</jv>);
	</p>
	<p>
		Typically developers will not deal with session objects and will just use convenience
		methods on the context classes themselves that handle creation of sessions:
	</p>
	<p class='bjava'>
	<jc>// Just use serialize method on WriterSerializer class.</jc>
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jv>myBean</jv>);
	</p>
	<p>
		Most context objects also have static default instances that can be used in leu of
		creating new contexts as well:
	</p>
	<p class='bjava'>
	<jc>// Just use one of the static context instances.</jc>
	String <jv>json</jv> = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>myBean</jv>);
	</p>
	<p>
		Most context classes also have the ability to clone and modify existing context objects:
	</p>
	<p class='bjava'>
	<jc>// Clone and modify an existing context object.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsf>DEFAULT</jsf>
		.copy()                   <jc>// Instantiates a context builder.</jc>
		.findFluentSetters()      <jc>// Sets a configuration value.</jc>
		.build();                 <jc>// Creates a context.</jc>
	</p>	
	<p>
		The default values of many context settings can also be set via system properties and environment variables.
		The javadocs on these settings will identify when this is possible.
	</p>
	<p>
		The framework makes heavy use of caching of existing context objects with the same builder settings.  
		This is a critical reason why Juneau achieve impressive performance.  
		Using Java reflection to find out all information about a bean type is expensive.
		By caching context objects, we only need to reflect that bean type once and store that information in the context
		for reuse by all serializers and parsers that share the same bean context configuration settings.
	</p>
</div>
</div><!-- END: 1.8 - o.GeneralDesign -->
</div><!-- END: 1 - Overview -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-marshall' id='juneau-marshall'>2 - juneau-marshall</a></h2>
<div class='topic'><!-- START: 2 - juneau-marshall -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-marshall<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-marshall-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.marshall_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The <c>juneau-marshall</c> artifact contains the following:
	</p>
	<ul>
		<li>Foundation for all serializers and parsers.
		<li>Implementations for all serializers and parsers except RDF languages.
		<li>Extensions to Apache HttpCore components used by both client and server APIs.
		<li>Assertions APIs.
		<li>Various reusable utilities used throughout the framework.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.Marshallers' id='jm.Marshallers'>2.1 - Marshallers</a></h3>
<div class='topic'><!-- START: 2.1 - jm.Marshallers -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.marshaller.Marshaller Marshallers} are simple pairings of a {@link org.apache.juneau.serializer.Serializer}
		and {@link org.apache.juneau.parser.Parser} with convenience methods for serializing and parsing POJOs.
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.marshaller.Marshaller}
			<ul>
				<li class='jm'><c>T</c>&nbsp;&nbsp;{@link org.apache.juneau.marshaller.Marshaller#read(Object,Class) read(Object,Class&lt;T&gt;)}
			</ul>
			<ul>
				<li class='jac'>{@link org.apache.juneau.marshaller.CharMarshaller}
					<ul>
						<li class='jm'><c>String</c>&nbsp;&nbsp;{@link org.apache.juneau.marshaller.CharMarshaller#write(Object) write(Object)}
						<ul class='javatreec'>
							<li class='jc'>{@link org.apache.juneau.marshaller.Csv}
							<li class='jc'>{@link org.apache.juneau.marshaller.Html}
							<li class='jc'>{@link org.apache.juneau.marshaller.Json}
							<li class='jc'>{@link org.apache.juneau.marshaller.OpenApi}
							<li class='jc'>{@link org.apache.juneau.marshaller.PlainText}
							<li class='jc'>{@link org.apache.juneau.marshaller.Json5}
							<li class='jc'>{@link org.apache.juneau.marshaller.Uon}
							<li class='jc'>{@link org.apache.juneau.marshaller.UrlEncoding}
							<li class='jc'>{@link org.apache.juneau.marshaller.Xml}
						</ul>
					</ul>
				<li class='jac'>{@link org.apache.juneau.marshaller.StreamMarshaller}
					<ul>
						<li class='jm'><c><jk>byte</jk>[]</c>&nbsp;&nbsp;{@link org.apache.juneau.marshaller.StreamMarshaller#write(Object) write(Object)}
						<ul class='javatreec'>
							<li class='jc'>{@link org.apache.juneau.marshaller.MsgPack}
						</ul>
					</ul>
				</ul>
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Using instance.</jc>
	Json <jv>json</jv> = <jk>new</jk> Json();
	MyPojo <jv>myPojo</jv> = <jv>json</jv>.read(<jv>string</jv>, MyPojo.<jk>class</jk>);
	String <jv>string</jv> = <jv>json</jv>.write(<jv>myPojo</jv>);
	</p>
	<p class='bjava'>
	<jc>// Using DEFAULT instance.</jc>
	MyPojo <jv>myPojo</jv> = Json.<jsf>DEFAULT</jsf>.read(<jv>string</jv>, MyPojo.<jk>class</jk>);
	String <jv>string</jv> = Json.<jsf>DEFAULT</jsf>.write(<jv>myPojo</jv>);
	</p>
	<p>
		Juneau comes with the following predefined marshallers:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.marshaller.Csv}
		<li class='jc'>{@link org.apache.juneau.marshaller.Html}
		<li class='jc'>{@link org.apache.juneau.marshaller.Json}
		<li class='jc'>{@link org.apache.juneau.marshaller.MsgPack}
		<li class='jc'>{@link org.apache.juneau.marshaller.OpenApi}
		<li class='jc'>{@link org.apache.juneau.marshaller.PlainText}
		<li class='jc'>{@link org.apache.juneau.marshaller.Json5}
		<li class='jc'>{@link org.apache.juneau.marshaller.Uon}
		<li class='jc'>{@link org.apache.juneau.marshaller.UrlEncoding}
		<li class='jc'>{@link org.apache.juneau.marshaller.Xml}
	</ul>
	<p>
		Each predefined marshaller also includes static convenience from/to methods to make it even easier to
		perform marshalling on POJOs:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.marshaller.Json}
			<ul>
				<li class='jm'><c>String</c>&nbsp;&nbsp;<i>{@link org.apache.juneau.marshaller.Json#of(Object) of(Object)}</i>
				<li class='jm'><c>T</c>&nbsp;&nbsp;<i>{@link org.apache.juneau.marshaller.Json#to(Object,Class) to(Object,Class&lt;T&gt;)}</i>
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Using shortcut static methods.</jc>
	MyPojo <jv>myPojo</jv> = Json.<jsm>to</jsm>(<jv>jsonString</jv>, MyPojo.<jk>class</jk>);
	String <jv>json</jv> = Json.<jsm>of</jsm>(<jv>myPojo</jv>);
	</p>
</div>
</div><!-- END: 2.1 - jm.Marshallers -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.SerializersAndParsers' id='jm.SerializersAndParsers'>2.2 - Serializers and Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.2 - jm.SerializersAndParsers -->
<div class='topic'>
	<p>
		One of the goals of Juneau was to make serialization as simple as possible.  
		In a single line of code, you should be able to serialize and parse most POJOs.
		Despite this simplicity, Juneau provides lots of extensibility and configuration properties for tailoring how 
		POJOs are serialized and parsed.
	</p>
	<p>
		The built-in serializers in Juneau are fast, efficient, and highly configurable.
		They work by serializing POJOs directly to streams instead of using intermediate Document Object Model 
		objects.
	</p>
	<p>
		In most cases, you can serialize objects in one line of code by using one of the default serializers:
	</p>
	<p class='bjava'>
	<jc>// A simple bean</jc>
	<jk>public class</jk> Person {
		<jk>public</jk> String <jf>name</jf> = <js>"John Smith"</js>;
		<jk>public int</jk> <jf>age</jf> = 21;
	}

	<jc>// Serialize to JSON, XML, or HTML</jc>
	Person <jv>person</jv> = <jk>new</jk> Person();

	<jc>// Produces:
	//	"{\"name\":\"John Smith\",\"age\":21}"</jc>
	String <jv>json</jv> = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);

	<jc>// Produces:
	//	"{name:'John Smith',age:21}"</jc>
	String <jv>json</jv> = Json5Serializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);

	<jc>// Produces:
	//	&lt;object&gt;
	//	  &lt;name&gt;John Smith&lt;/name&gt;
	//	  &lt;age&gt;21&lt;/age&gt;
	//	&lt;/object&gt;</jc>
	String <jv>xml</jv> = XmlSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);

	<jc>// Produces:
	//	&lt;table&gt;
	//	  &lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;value&lt;/th&gt;&lt;/tr&gt;
	//	  &lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;John Smith&lt;/td&gt;&lt;/tr&gt;
	//	  &lt;tr&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;21&lt;/td&gt;&lt;/tr&gt;
	//	&lt;/table&gt;</jc>
	String <jv>html</jv> = HtmlSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);
	
	<jc>// Produces:
	//	"(name='John Smith',age=21)"</jc>
	String <jv>uon</jv> = UonSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);

	<jc>// Produces:
	//	"name='John+Smith'&amp;age=21"</jc>
	String <jv>urlencoding</jv> = UrlEncodingSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);

	<jc>// Produces:
	// 82 A4 6E 61 6D 65 AA 4A 6F 68 6E 20 53 6D 69 74 68 A3 61 67 65 15 </jc>
	<jk>byte</jk>[] <jv>bytes</jv> = MsgPackSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>person</jv>);
	</p>
	
	<p>
		In addition to the default serializers, customized serializers can be created using various built-in options:
	</p>
	
	<p class='bjava'>
	<jc>// Use one of the default serializers to serialize a POJO</jc>
	String <jv>json</jv> = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>someObject</jv>);

	<jc>// Create a custom serializer for lax syntax using single quote characters</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().simple().sq().build();
	
	<jc>// Clone an existing serializer and modify it to use single-quotes</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer.<jsf>DEFAULT</jsf>.copy().sq().build();
	
	<jc>// Serialize a POJO to JSON</jc>
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jv>someObject</jv>);
	</p>
	<p>
		Default serialization support is provided for Java primitives, <c>Maps</c>, <c>Collections</c>, 
		beans, and arrays. 
		Extensible support for other data types such as <c>Calendars</c>, <c>Dates</c>, 
		<c>Iterators</c> is available through the use of POJO swaps (described later).
	</p>
	<hr>
	<p>
		Parsers work by parsing input directly into POJOs instead of having to create intermediate Document Object 
		Models.
		This allows them to parse input with minimal object creation.
	</p>
	<p>
		Like the serializers, you can often parse objects in one line of code by using one of the default parsers:
	</p>
	<p class='bjava'>
	<jc>// Use one of the predefined parsers.</jc>
	Parser <jv>parser</jv> = JsonParser.<jsf>DEFAULT</jsf>;

	<jc>// Parse a JSON object as a bean.</jc>
	String <jv>json</jv> = <js>"{name:'John Smith',age:21}"</js>;
	Person <jv>person</jv> = <jv>parser</jv>.parse(<jv>json</jv>, Person.<jk>class</jk>);

	<jc>// Or parse it into a generic Map.</jc>
	Map <jv>map</jv> = <jv>parser</jv>.parse(<jv>json</jv>, Map.<jk>class</jk>);

	<jc>// Parse a JSON string.</jc>
	<jv>json</jv> = <js>"'foobar'"</js>;
	String <jv>string</jv> = <jv>parser</jv>.parse(<jv>json</jv>, String.<jk>class</jk>);

	<jc>// Parse a JSON number as a Long or Float.</jc>
	<jv>json</jv> = <js>"123"</js>;
	Long <jv>_long</jv> = <jv>parser</jv>.parse(<jv>json</jv>, Long.<jk>class</jk>);
	Float <jv>_float</jv> = <jv>parser</jv>.parse(<jv>json</jv>, Float.<jk>class</jk>);

	<jc>// Parse a JSON object as a HashMap&lt;String,Person&gt;.</jc>
	<jv>json</jv> = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; <jv>map2</jv> = <jv>parser</jv>.parse(<jv>json</jv>, HashMap.<jk>class</jk>, String.<jk>class</jk>, Person.<jk>class</jk>)

	<jc>// Parse a JSON object as a HashMap&lt;String,LinkedList&lt;Person&gt;&gt;.</jc>
	<jv>json</jv> = <js>"{a:[{name:'John Smith',age:21},{name:'Joe Smith',age:42}]}"</js>;
	Map&lt;String,List&lt;Person&gt;&gt; <jv>map3</jv> = <jv>parser</jv>.parse(<jv>json</jv>, HashMap.<jk>class</jk>, String.<jk>class</jk>, 
		LinkedList.<jk>class</jk>, Person.<jk>class</jk>)

	<jc>// Parse a JSON array of integers as a Collection of Integers or int[] array.</jc>
	<jv>json</jv> = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; <jv>list</jv> = <jv>parser</jv>.parse(<jv>json</jv>, LinkedList.<jk>class</jk>, Integer.<jk>class</jk>);
	<jk>int</jk>[] <jv>ints</jv> = <jv>parser</jv>.parse(<jv>json</jv>, <jk>int</jk>[].<jk>class</jk>);
	</p>
	<p>
		The parsers can also be used to populating existing bean and collection objects:
	</p>
	<p class='bjava'>
	<jc>// Use one of the predefined parsers.</jc>
	Parser <jv>parser</jv> = JsonParser.<jsf>DEFAULT</jsf>;

	<jc>// Populate the properties on an existing bean from a JSON object.</jc>
	String <jv>json</jv> = <js>"{name:'John Smith',age:21}"</js>;
	Person <jv>person</jv> = <jk>new</jk> Person();
	<jv>parser</jv>.parseIntoBean(<jv>json</jv>, <jv>person</jv>);

	<jc>// Populate an existing list from a JSON array of numbers.</jc>
	<jv>json</jv> = <js>"[1,2,3]"</js>;
	List&lt;Integer&gt; <jv>list</jv> = <jk>new</jk> LinkedList&lt;Integer&gt;();
	<jv>parser</jv>.parseIntoCollection(<jv>json</jv>, <jv>list</jv>, Integer.<jk>class</jk>);

	<jc>// Populate an existing map from a JSON object containing beans.</jc>
	<jv>json</jv> = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	Map&lt;String,Person&gt; <jv>map</jv> = <jk>new</jk> TreeMap&lt;String,Person&gt;();
	<jv>parser</jv>.parseIntoMap(<jv>json</jv>, <jv>map</jv>, String.<jk>class</jk>, Person.<jk>class</jk>);
	</p>
	<br>
	<div class='info'>
		In the example above, we're parsing "lax" JSON (single quotes, unquoted attributes).
		The JSON parser can handle any valid JSON syntax (such as quoted or unquoted attributes, single or double 
		quotes).
		It can also handle JSON fragments and embedded Javascript comments. 
		Many of the JSON examples provided will use lax syntax which is easier to read since we don't have to deal 
		with escapes.  
	</div>
	
	<ul class='seealso'>
		<li class='jc'>{@link org.apache.juneau.examples.serializer.ImageSerializer} - Example of a custom serializer.
		<li class='jc'>{@link org.apache.juneau.examples.parser.ImageParser} - Example of a custom parser.
	</ul>
</div>
</div><!-- END: 2.2 - jm.SerializersAndParsers -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.BeanContexts' id='jm.BeanContexts'>2.3 - Bean Contexts</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.3 - jm.BeanContexts -->
<div class='topic'>
	<p>
		At the heart of the marshalling APIs is the {@link org.apache.juneau.BeanContext Bean Context} API that provides a common
		framework for marshalling beans and POJOs across all serializers and parsers. 
		All serializers and parsers (and their builders) extend from the bean context API classes.
	</p>
	<p>
		One important feature of the bean context API is the ability to wrap Java beans inside maps to allow
		properties to be accessed through a Map layer.  Although this is used internally by all the serializers and parsers,
		it's often useful to use this feature by itself.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Wrap a bean in a map and do some simple get/set calls.</jc>
	BeanMap&lt;MyBean&gt; <jv>myBeanMap</jv> = BeanContext.<jsf>DEFAULT_SESSION</jsf>.toBeanMap(<jv>myBean</jv>);
	<jv>myBeanMap</jv>.put(<js>"myProperty"</js>, 123);
	<jk>int</jk> <jv>myProperty</jv> = <jv>myBeanMap</jv>.get(<js>"myProperty"</js>, <jk>int</jk>.<jk>class</jk>);
	</p>
	<p>
		The bean context API provides many settings that fine-tune how POJOs should be handled during marshalling.
	</p>
	<ul class='seealso'>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
	</ul>
</div>
</div><!-- END: 2.3 - jm.BeanContexts -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.JavaBeansSupport' id='jm.JavaBeansSupport'>2.4 - Java Beans Support</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.4 - jm.JavaBeansSupport -->
<div class='topic'>
	<p>
		Out-of-the-box, Juneau supports marshalling of Java beans with standard public getters and setters, public
		fields, and fluent setters (e.g. <c>withX</c> naming convention).  There are also many settings and
		annotations that can be used to customize how bean properties are detected.  The following is an example of
		some of the ways to define bean properties:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
	
		<jc>// Public field property.</jc>
		<jk>public</jk> String <jf>property1</jf>;
		
		<jc>// Standard public getters/setters.</jc>
		<jk>public</jk> String getProperty2() {...}
		<jk>public void</jk> setProperty2(String <jv>value</jv>) {...}
		
		<jc>// With fluent-style setter.</jc>
		<jk>public</jk> String getProperty3() {...}
		<jk>public</jk> MyBean withProperty3(String <jv>value</jv>) {...}
		
		<jc>// Read-only property (ignored by parsers).</jc>
		<jk>public</jk> String getProperty4() {...}
		
		<jc>// Write-only property (ignored by serializers).</jc>
		<jk>public void</jk> setProperty5(String <jv>value</jv>) {...}
		
		<jc>// Non-standard getters/setters identified by annotation.</jc>
		<ja>@Beanp</ja>
		<jk>public</jk> String property6() {...}
		<ja>@Beanp</ja>
		<jk>public void</jk> property6(String value) {...}
		
		<jc>// Non-standard getters/setters identified by annotation with overridden names.</jc>
		<ja>@Beanp</ja>(<js>"property7"</js>)
		<jk>public</jk> String property7X() {...}
		<ja>@Beanp</ja>(<js>"property7"</js>)
		<jk>public void</jk> property7X(String <jv>value</jv>) {...}

		<jc>// Non-public getters/setters identified by annotation.</jc>
		<ja>@Beanp</ja>
		<jk>private</jk> String getProperty8() {...}
		<ja>@Beanp</ja>
		<jk>private void</jk> setProperty8(String <jv>value</jv>) {...}
		
		<jc>// Ignore a method that looks like a getter.</jc>
		<ja>@BeanIgnore</ja>
		<jk>public</jk> String getNotAProperty() {...}
	}
	</p>
	<p>
		Several settings exist to allow you to customize how bean properties are handled by serializers and parsers:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanClassVisibility(Visibility) beanClassVisibility(Visibility)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanConstructorVisibility(Visibility) beanConstructorVisibility(Visibility)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanFieldVisibility(Visibility) beanFieldVisibility(Visibility)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanMethodVisibility(Visibility) beanMethodVisibility(Visibility)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beansRequireDefaultConstructor() beansRequireDefaultConstructor()}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beansRequireSerializable() beansRequireSerializable()}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beansRequireSettersForGetters() beansRequireSettersForGetters()}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#disableBeansRequireSomeProperties() disableBeansRequireSomeProperties()}
			</ul>
		</li>
	</ul>
	<p>
		Settings and equivalent annotations are also available to control which properties are marshalled and how they are ordered.
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanProperties(Class,String) beanProperties(Class,String)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanPropertiesExcludes(Class,String) beanPropertiesExcludes(Class,String)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanPropertiesReadOnly(Class,String) beanPropertiesReadOnly(Class,String) }
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanPropertiesWriteOnly(Class,String) beanPropertiesWriteOnly(Class,String)}
			</ul>
		</li>
	</ul>
	<p>
		It's common to use the {@link org.apache.juneau.annotation.Bean#properties @Bean(properties|p)} annotation to force the ordering
		of properties during marshalling.  IBM JVMs keep the ordering of fields and methods in the compiled bytecodebut
		Oracle JVMs do not and return fields/methods in random order.  The {@link org.apache.juneau.annotation.Bean#properties @Bean(properties|p)} annotation was added to 
		help with this limitation.
	</p>
	<p class='bjava'>
	<jc>// Bean should be marshalled with properties in the specified order.</jc>
	<ja>@Bean</ja>(properties=<js>"foo,bar,baz"</js>)
	<jk>public class</jk> MyBean {
		...
	}
	</p>
	
	<ul class='seealso'>
		<li class='doclink'><a class="doclink" href="#jm.PojoCategories">POJO Categories</a> - Marshalling rules for POJOs.
		<li class='doclink'><a class="doclink" href="#jm.BeanDictionaries">Bean Dictionaries</a> - Handling properties with subclassable types.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BeanAnnotation' id='jm.BeanAnnotation'>2.4.1 - @Bean Annotation</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.4.1 - jm.BeanAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.Bean @Bean} annotation is used to tailor how beans are 
		interpreted by the framework.
	</p>
	<p> 
		Bean property inclusion and ordering on a bean class can be done using the 
		{@link org.apache.juneau.annotation.Bean#properties() @Bean(properties|p)} annotation.
	</p>
	<p class='bjava'>
	<jc>// Address class with only street/city/state properties (in that order).</jc>
	<jc>// All other properties are ignored.</jc>
	<ja>@Bean</ja>(properties=<js>"street,city,state"</js>)
	<jk>public class</jk> Address { ... }
	</p>
	<p> 
		Bean properties can be excluded using the {@link org.apache.juneau.annotation.Bean#excludeProperties() @Bean(excludeProperties|xp)}
		annotation.
	</p>
	<p class='bjava'>
	<jc>// Address class with only street/city/state properties (in that order).</jc>
	<jc>// All other properties are ignored.</jc>
	<ja>@Bean</ja>(excludeProperties=<js>"city,state"</js>})
	<jk>public class</jk> Address { ... }
	</p>
	<p>
		Bean properties can be sorted alphabetically using {@link org.apache.juneau.annotation.Bean#sort() @Bean(sort)}
	</p>
	<p class='bjava'>
	<jc>// Address class with only street/city/state properties (in that order).</jc>
	<jc>// All other properties are ignored.</jc>
	<ja>@Bean</ja>(sort=<jk>true</jk>)
	<jk>public class</jk> MyBean { ... }
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Bean#propertyNamer() @Bean(propertyNamer)} annotation
		is used to provide customized naming of properties.
	</p>
	<p>
		Property namers are used to transform bean property names from standard form to some other form.
		For example, the {@link org.apache.juneau.PropertyNamerDLC} will convert property names to 
		dashed-lowercase, and these will be used as attribute names in JSON and element names in XML.
	</p>
	<p class='bjava'>
	<jc>// Define a class with dashed-lowercase property names.</jc>
	<ja>@Bean</ja>(propertyNamer=PropertyNamerDashedLC.<jk>class</jk>)
	<jk>public class</jk> MyBean { ... }
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Bean#interfaceClass @Bean(interfaceClass)} annotation is used
		to limit properties on beans to specific interface classes.
		When specified, only the list of properties defined on the interface class will be used during 
		serialization.
		Additional properties on subclasses will be ignored.
	</p>
	<p class='bjava'>
	<jc>// Parent class</jc>
	<ja>@Bean</ja>(interfaceClass=A.<jk>class</jk>)
	<jk>public abstract class</jk> A {
		<jk>public</jk> String <jf>f0</jf> = <js>"f0"</js>;
	}
	
	<jc>// Child class</jc>
	<jk>public class</jk> A1 <jk>extends</jk> A {
		<jk>public</jk> String <jf>f1</jf> = <js>"f1"</js>;
	}

	A1 <jv>a1</jv> = <jk>new</jk> A1();
	String <jv>result</jv> = Json5.<jsm>of</jsm>(<jv>a1</jv>);
	<jsm>assertEquals</jsm>(<js>"{f0:'f0'}"</js>, <jv>result</jv>);  <jc>// Note f1 is not serialized.</jc> 
	</p>
	<p>
		Note that this annotation can be used on the parent class so that it filters to all child classes.
		Or can be set individually on the child classes.
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Bean#stopClass @Bean(stopClass)} annotation is another
		way to limit which properties are serialized (except from the opposite direction).
		It's identical in purpose to the stop class specified by {@link java.beans.Introspector#getBeanInfo(Class, Class)}.
		Any properties in the stop class or in its base classes will be ignored during analysis.
	</p>
	<p>
		For example, in the following class hierarchy, instances of <c>C3</c> will include property 
		<c>p3</c> but not <c>p1</c> or <c>p2</c>.
	</p>
	<p class='bjava'>
	<jk>public class</jk> C1 {
		<jk>public int</jk> getP1();
	}

	<jk>public class</jk> C2 <jk>extends</jk> C1 {
		<jk>public int</jk> getP2();
	}

	<ja>@Bean</ja>(stopClass=C2.<jk>class</jk>)
	<jk>public class</jk> C3 <jk>extends</jk> C2 {
		<jk>public int</jk> getP3();
	}
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Bean#interceptor() @Bean(interceptor)} annotation
		and {@link org.apache.juneau.swap.BeanInterceptor} class can be used to perform interception
		and inline handling of bean getter and setter calls.
	</p>
	<p class='bjava'>
	<jc>// Interceptor that strips out sensitive information on Address beans.</jc>
	<jk>public class</jk> AddressInterceptor <jk>extends</jk> BeanInterceptor&lt;Address&gt; {
	
		<ja>@Override</ja>
		<jk>public</jk> Object readProperty(Address <jv>bean</jv>, String <jv>name</jv>, Object <jv>value</jv>) {
			<jk>if</jk> (<js>"taxInfo"</js>.equals(<jv>name</jv>))
				<jk>return</jk> <js>"redacted"</js>;
			<jk>return</jk> <jv>value</jv>;
		}

		<ja>@Override</ja>
		<jk>public</jk> Object writeProperty(Address <jv>bean</jv>, String <jv>name</jv>, Object <jv>value</jv>) {
			<jk>if</jk> (<js>"taxInfo"</js>.equals(<jv>name</jv>) &amp;&amp; <js>"redacted"</js>.equals(<jv>value</jv>))
				<jk>return</jk> TaxInfoUtils.<jsm>lookup</jsm>(<jv>bean</jv>.getStreet(), <jv>bean</jv>.getCity(), <jv>bean</jv>.getState());
			<jk>return</jk> <jv>value</jv>;
		}
	}
 
	<jc>// Register interceptor on bean class.</jc>
	<ja>@Bean</ja>(interceptor=AddressInterceptor.<jk>class</jk>)
	<jk>public class</jk> Address {
		<jk>public</jk> String getTaxInfo() {...}
		<jk>public void</jk> setTaxInfo(String <jv>value</jv>) {...}
	}
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Bean#on() @Bean(on)} and {@link org.apache.juneau.annotation.Bean#onClass() @Bean(onClass)}
		annotations can be used to programmatically attach <ja>@Bean</ja> annotations to classes. 
	</p>
	<p class='bjava'>
	<ja>@Bean</ja>(onClass=Address.<jk>class</jk>, sort=<jk>true</jk>, excludeProperties=<js>"city,state"</js>)
	<jk>public class</jk> MyAnnotatedClass {...}

	<jc>// Create a serializer configured using annotations.</jc>
	JsonSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.applyAnnotations(MyAnnotatedClass.<jk>class</jk>)
		.build();
	</p>
</div><!-- END: 2.4.1 - jm.BeanAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BeanpAnnotation' id='jm.BeanpAnnotation'>2.4.2 - @Beanp Annotation</a><span class='update'>updated: 8.1.0,8.1.2,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.4.2 - jm.BeanpAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.Beanp @Beanp} annotation is used to tailor how 
		individual bean properties are interpreted by the framework.
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#name() @Beanp(name)} annotation
		is used to override the name of the bean property.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<ja>@Beanp</ja>(name=<js>"Bar"</js>)
		<jk>public</jk> String getFoo() {...}
	}
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Name @Name} annotation is a shortcut for specifying a bean property name:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<ja>@Name</ja>(<js>"Bar"</js>)
		<jk>public</jk> String getFoo() {...}
	}
	</p>
	<p>
		If the {@link org.apache.juneau.BeanContext.Builder#beanFieldVisibility(Visibility) beanFieldVisibility} setting on the bean context excludes this field 
		(e.g. the visibility is set to the default of PUBLIC but the field is PROTECTED), this annotation 
		can be used to force the field to be identified as a property.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<ja>@Beanp</ja>
		<jk>protected</jk> String getFoo() {...}
	}
	</p>
	<p>
		The bean property named <js>"*"</js> is the designated "dynamic property" which allows for "extra" bean
		properties not otherwise defined.
		This is similar in concept to the Jackson <ja>@JsonGetterAll</ja> and <ja>@JsonSetterAll</ja> 
		annotations but generalized for all supported marshall languages.
		The primary purpose is for backwards compatibility in parsing newer streams with addition 
		information into older beans.
	</p>
	<p>
		The following shows various ways of using dynamic bean properties.
	</p>
	<p class='bjava'>
	<jc>// Option #1 - A simple public Map field.</jc>
	<jc>// The field name can be anything.</jc>
	<jk>public class</jk> BeanWithDynaField {

		<ja>@Beanp</ja>(<js>"*"</js>)
		<jk>public</jk> Map&lt;String,Object&gt; <jf>extraStuff</jf> = <jk>new</jk> LinkedHashMap&lt;String,Object&gt;();
	}

	<jc>// Option #2 - Getters and setters.</jc>
	<jc>// Method names can be anything.</jc>
	<jc>// Getter must return a Map with String keys.</jc>
	<jc>// Setter must take in two arguments, a String and Object.</jc>
	<jk>public class</jk> BeanWithDynaMethods {

		<ja>@Beanp</ja>(<js>"*"</js>)
		<jk>public</jk> Map&lt;String,Object&gt; getMyExtraStuff() {
			...
		}

		<ja>@Beanp</ja>(<js>"*"</js>)
		<jk>public void</jk> setAnExtraField(String <jv>name</jv>, Object <jv>value</jv>) {
			...
		}
	}

	<jc>// Option #3 - Getter only.</jc>
	<jc>// Properties will be added through the getter.</jc>
	<jk>public class</jk> BeanWithDynaGetterOnly {

		<ja>@Beanp</ja>(<js>"*"</js>)
		<jk>public</jk> Map&lt;String,Object&gt; getMyExtraStuff() {
			...
		}
	}
	</p>
	<p>
		Similar rules apply for value types and swaps.
		The property values optionally can be any serializable type or use swaps.
	</p>
	<p class='bjava'>
	<jc>// A serializable type other than Object.</jc>
	<jk>public class</jk> BeanWithDynaFieldWithListValues {

		<ja>@Beanp</ja>(<js>"*"</js>)
		<jk>public</jk> Map&lt;String,List&lt;String&gt;&gt; getMyExtraStuff() {
			...
		}
	}

	<jc>// A swapped value.</jc>
	<jk>public class</jk> BeanWithDynaFieldWithSwappedValues {

		<ja>@Beanp</ja>(name=<js>"*"</js>, swap=TemporalCalendarSwap.IsoOffsetDateTime.<jk>class</jk>)
		<jk>public</jk> Map&lt;String,Calendar&gt; getMyExtraStuff() {
			...
		}
	}
	</p>
	<div class='info'>
		Note that if you're not interested in these additional properties, you can also use the
		{@link org.apache.juneau.BeanContext.Builder#ignoreUnknownBeanProperties() ignoreUnknownBeanProperties} setting to ignore values 
		that don't fit into existing properties.
	</div>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#value() @Beanp(value)} annotation
		is a synonym for {@link org.apache.juneau.annotation.Beanp#name() @Beanp(name)}.
		Use it in cases where you're only specifying a name so that you can shorten your annotation.
	</p>
	<p>
		The following annotations are equivalent:
	</p>
	<p class='bjava'>
	<ja>@Beanp</ja>(name=<js>"foo"</js>)

	<ja>@Beanp</ja>(<js>"foo"</js>)
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#type() @Beanp(type)} annotation
		is used to identify a specialized class type for a generalized property.
		Normally the type is inferred through reflection of the field type or getter return type.
		However, you'll want to specify this value if you're parsing beans where the bean property class 
		is an interface or abstract class to identify the bean type to instantiate.
		Otherwise, you may cause an {@link java.lang.InstantiationException} when trying to set these fields.
	</p>
	<p>
		This property must denote a concrete class with a no-arg constructor.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {

		<jc>// Identify concrete type as a HashMap.</jc>
		<ja>@Beanp</ja>(type=HashMap.<jk>class</jk>)
		<jk>public</jk> Map <jf>p1</jf>;
	}
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#params() @Beanp(params)} annotation
		is for bean properties of type map or collection.
		It's used to identify the class types of the contents of the bean property object when
		the general parameter types are interfaces or abstract classes.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {

		<jc>// This is a HashMap&lt;String,Integer&gt;.</jc>
		<ja>@Beanp</ja>(type=HashMap.<jk>class</jk>, params={String.<jk>class</jk>,Integer.<jk>class</jk>})
		<jk>public</jk> Map <jf>p1</jf>;
	}
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#properties() @Beanp(properties)} 
		annotation is used to limit which child properties are rendered by the serializers.
		It can be used on any of the following bean property types:
	</p>
	<ul class='spaced-list'>
		<li>Beans - Only render the specified properties of the bean.
		<li>Maps - Only render the specified entries in the map.
		<li>Bean/Map arrays - Same but applied to each element in the array.
		<li>Bean/Map collections - Same but applied to each element in the collection.
	</ul>
	<p class='bjava'>
	<jk>public class</jk> MyClass {

		<jc>// Only render 'f1' when serializing this bean property.</jc>
		<ja>@Beanp</ja>(properties={<js>"f1"</js>})
		<jk>public</jk> MyChildClass <jf>x1</jf> = <jk>new</jk> MyChildClass();
	}

	<jk>public class</jk> MyChildClass {
		<jk>public int</jk> <jf>f1</jf> = 1;
		<jk>public int</jk> <jf>f2</jf> = 2;
	}

	<jc>// Renders "{x1:{f1:1}}"</jc>
	String <jv>json</jv> = Json.<jsm>of</jsm>(<jk>new</jk> MyClass());
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Beanp#format() @Beanp(format)} 
		annotation specifies a String format for converting a bean property value to a formatted string.
	</p>
	<p class='bjava'>
	<jc>// Serialize a float as a string with 2 decimal places.</jc>
	<ja>@Beanp</ja>(format=<js>"$%.2f"</js>)
	<jk>public float</jk> <jf>price</jf>;
	</p>
</div>
</div><!-- END: 2.4.2 - jm.BeanpAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BeancAnnotation' id='jm.BeancAnnotation'>2.4.3 - @Beanc Annotation</a><span class='update'>updated: 8.1.0,8.1.2</span></h4>
<div class='topic'><!-- START: 2.4.3 - jm.BeancAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.Beanc @Beanc} annotation is used to 
		map constructor arguments to property names on bean with read-only properties.
		Since method parameter names are lost during compilation, this annotation essentially redefines 
		them so that they are available at runtime.
	</p>
	<p>
		The definition of a read-only bean is a bean with properties with only getters, like shown below:
	</p>	
	<p class='bjava'>
	<jc>// Our read-only bean.</jc>
	<jk>public class</jk> Person {
		<jk>private final</jk> String <jf>name</jf>;
		<jk>private final int</jk> <jf>age</jf>;

		<ja>@Beanc</ja>(properties=<js>"name,age"</js>})
		<jk>public</jk> Person(String <jv>name</jv>, <jk>int</jk> <jv>age</jv>) {
			<jk>this</jk>.<jf>name</jf> = <jv>name</jv>;
			<jk>this</jk>.<jf>age</jf> = <jv>age</jv>;
		}

		<jc>// Read only properties.</jc>
		<jc>// Getters but no setters.</jc>

		<jk>public</jk> String getName() {
			<jk>return</jk> <jf>name</jf>;
		}

		<jk>public int</jk> getAge() {
			<jk>return</jk> <jf>age</jf>;
		}
	}			
	</p>
	<p class='bjava'>
	<jc>// Parsing into a read-only bean.</jc>
	String <jv>json</jv> = <js>"{name:'John Smith',age:45}"</js>;
	Person <jv>person</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, Person.<jk>class</jk>);
	String <jv>name</jv> = <jv>person</jv>.getName();  <jc>// "John Smith"</jc>
	<jk>int</jk> <jv>age</jv> = <jv>person</jv>.getAge();   <jc>// 45</jc>
	</p>
	<p>
		Beans can also be defined with a combination of read-only and read-write properties.
	</p>
	<p>
		The {@link org.apache.juneau.annotation.Name @Name} annotation can also be used instead of <c><ja>@Beanc</ja>(properties)</c>:
	</p>
	<p class='bjava'>
	<ja>@Beanc</ja>
	<jk>public</jk> Person(<ja>@Name</ja>(<js>"name"</js>) String <jv>name</jv>, <ja>@Name</ja>(<js>"age"</js>) <jk>int</jk> <jv>age</jv>) {
		<jk>this</jk>.<jf>name</jf> = <jv>name</jv>;
		<jk>this</jk>.<jf>age</jf> = <jv>age</jv>;
	}
	</p>
	<p>
		If neither <c><ja>@Beanc</ja>(properties)</c> or <ja>@Name</ja> is used to identify the bean property names, 
		we will try to use the parameter names if they are available in the bytecode.
	</p>
</div>
</div><!-- END: 2.4.3 - jm.BeancAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BeanIgnoreAnnotation' id='jm.BeanIgnoreAnnotation'>2.4.4 - @BeanIgnore Annotation</a></h4>
<div class='topic'><!-- START: 2.4.4 - jm.BeanIgnoreAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.BeanIgnore @BeanIgnore} annotation is used to
		ignore classes, fields, and methods from being interpreted as beans or bean components.
	</p> 
	<p>
		When applied to classes, objects will be converted to strings even though they look like beans.
	</p>
	<p class='bjava'>
	<jc>// Not really a bean!  Use toString() instead!</jc>
	<ja>@BeanIgnore</ja>
	<jk>public class</jk> MyBean {...}
	</p>
	<p>
		When applied to fields and getters/setters, they will be ignored as bean properties.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		
		<jc>// Not a bean property!</jc>
		<ja>@BeanIgnore</ja>
		<jk>public</jk> String <jf>foo</jf>;
		
		<jc>// Not a bean property!</jc>
		<ja>@BeanIgnore</ja>
		<jk>public</jk> String getBar() {...}
	}
	</p>
</div>
</div><!-- END: 2.4.4 - jm.BeanIgnoreAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.NamePropertyAnnotation' id='jm.NamePropertyAnnotation'>2.4.5 - @NameProperty Annotation</a></h4>
<div class='topic'><!-- START: 2.4.5 - jm.NamePropertyAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.NameProperty @NameProperty} annotation is used to
		identify a setter as a method for setting the name of a POJO as it's known by its parent object.
	</p>
	<p>
		A commonly-used case is when you're parsing a JSON map containing beans where one of the bean 
		properties is the key used in the map.
	</p>
	<p class='bjson'>
	<jc>// JSON</jc> 
	{
		<jok>id1</jok>: {<jok>name</jok>: <jov>'John Smith'</jov>, <jok>sex</jok>: <jov>'M'</jov>},
		<jok>id2</jok>: {<jok>name</jok>: <jov>'Jane Doe'</jov>, <jok>sex</jok>: <jov>'F'</jov>}
	}
	</p>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<ja>@NameProperty</ja> 
		<jk>public</jk> String <jf>id</jf>;  <jc>// Value gets assigned from object key</jc>
		
		<jk>public</jk> String <jf>name</jf>;
		
		<jk>public char</jk> <jf>sex</jf>;
	}
	</p>
</div>
</div><!-- END: 2.4.5 - jm.NamePropertyAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.ParentPropertyAnnotation' id='jm.ParentPropertyAnnotation'>2.4.6 - @ParentProperty Annotation</a></h4>
<div class='topic'><!-- START: 2.4.6 - jm.ParentPropertyAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.ParentProperty @ParentProperty} annotation is used to
		identify a setter as a method for adding a parent reference to a child object.
	</p>
	<p>
		A commonly-used case is when you're parsing beans and a child bean has a reference to a parent bean.
	</p>
	<p class='bjava'>
	<jk>public class</jk> AddressBook {
		<jk>public</jk> List&lt;Person&gt; <jf>people</jf>;
	}

	<jk>public class</jk> Person {
	
		<ja>@ParentProperty</ja> 
		<jk>public</jk> AddressBook <jf>addressBook</jf>;  <jc>// A reference to the containing address book.</jc>
		
		<jk>public</jk> String <jf>name</jf>;
		
		<jk>public char</jk> <jf>sex</jf>;
	}
	</p>
	<p>
		Parsers will automatically set this field for you in the child beans.
	</p>
</div>
</div><!-- END: 2.4.6 - jm.ParentPropertyAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.PojoBuilders' id='jm.PojoBuilders'>2.4.7 - POJO Builders</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.4.7 - jm.PojoBuilders -->
<div class='topic'>
	<p>
		Juneau parsers can use builders to instantiate POJOs.
		This is useful in cases where you want to create beans with read-only properties.
		Note that while it's possible to do this using the {@link org.apache.juneau.annotation.Beanc @Beanc}
		annotation, using builders can often be cleaner.
	</p>
	<p>
		A typical builder usage is shown below:
	</p>
	<p class='bjava'>
	MyBean <jv>bean</jv> = MyBean.<jsm>create</jsm>().foo(<js>"foo"</js>).bar(123).build();
	</p>								
	<p>
		The typical code for such a builder using a static inner class is shown below:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
	
		<jc>// Read-only properties.</jc>
		<jk>public final</jk> String <jf>foo</jf>;
		<jk>public final int</jk> <jf>bar</jf>;
		
		<jc>// Private constructor.</jc>
		<jk>private</jk> MyBean(Builder <jv>builder</jv>) {
			<jk>this</jk>.<jf>foo</jf> = <jv>builder</jv>.<jf>foo</jf>;
			<jk>this</jk>.<jf>bar</jf> = <jv>builder</jv>.<jf>bar</jf>;
		}

		<jc>// Static method that creates a builder.</jc>
		<jk>public static</jk> Builder <jsm>create</jsm>() {
			<jk>return new</jk> Builder();
		}

		<jc>// Builder class.</jc>
		<jk>public static class</jk> Builder {
			String <jf>foo</jf>;
			<jk>int</jk> <jf>bar</jf>;
			
			<jc>// Method that creates the bean.</jc>
			<jk>public</jk> MyBean build() {
				<jk>return new</jk> MyBean(<jk>this</jk>);
			}
			
			<jc>// Bean property setters.</jc>
			
			<ja>@Beanp</ja>
			<jk>public</jk> Builder foo(String <jv>foo</jv>) {
				<jk>this</jk>.<jf>foo</jf> = <jv>foo</jv>;
				<jk>return this</jk>;
			}
			
			<ja>@Beanp</ja>
			<jk>public</jk> Builder bar(<jk>int</jk> <jv>bar</jv>) {
				<jk>this</jk>.<jf>bar</jf> = <jv>bar</jv>;
				<jk>return this</jk>;
			}
		}
	}
	</p>
	<p>
		The POJO class can be any type including beans.
		Builders MUST be beans with one or more writable properties.
		The bean properties themselves do not need to be readable (i.e. getters are optional).
	</p>
	<p>
		Builders require two parts:
	</p>
	<ol>
		<li>A way to detect and instantiate a builder using reflection.
		<li>A way to instantiate a POJO from a builder.
	</ol>
	<p>
		The first can be accomplished through <b>any</b> of the following:
	</p>
	<ul class='spaced-list'>
		<li>A static <c>create()</c> method on the POJO class that returns a builder instance.
			<p class='bjava nomargin'>
	<jk>public static</jk> Builder <jsm>create</jsm>() {...}
			</p>
		<li>A public constructor on the POJO class that takes in a single parameter that implements the {@link org.apache.juneau.swap.Builder} interface.
			<br>The builder class must have a public no-arg constructor.
			<p class='bjava nomargin'>
	<jk>public</jk> MyBean(Builder <jv>builder</jv>) {...}
			</p>
		<li>A {@link org.apache.juneau.annotation.Builder @Builder} annotation on the POJO class to explicitly identify it.
			<br>The builder class must have a public no-arg constructor.
			<p class='bjava nomargin'>
	<ja>@Builder</ja>(Builder.<jk>class</jk>)
	<jk>public class</jk> MyBean {...}
			</p>
	</ul>
	<p>
		The second can be accomplished through <b>any</b> of the following:
	</p>
	<ul class='spaced-list'>
		<li>The existence of a <c>build()</c> method on the builder class.
			<p class='bjava nomargin'>
	<jk>public</jk> MyBean build() {...}
			</p>
		<li>The existence of a public constructor on the POJO class that takes in the builder instance.
			<p class='bjava nomargin'>
	<jk>public</jk> MyBean(Builder <jv>builder</jv>) {...}
			</p>
	</ul>
	<ul class='seealso'>
		<li class='ja'>{@link org.apache.juneau.annotation.Builder}
		<li class='jic'>{@link org.apache.juneau.swap.Builder}
	</ul>
</div>
</div><!-- END: 2.4.7 - jm.PojoBuilders -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BypassSerialization' id='jm.BypassSerialization'>2.4.8 - Bypass Serialization using Readers and InputStreams</a></h4>
<div class='topic'><!-- START: 2.4.8 - jm.BypassSerialization -->
<div class='topic'>
	<p>
		Juneau serializers treat instances of <c>Readers</c> and <c>InputStreams</c> special by 
		simply serializing their contents directly to the output stream or writer.
		This allows you to embed fully customized serializer output.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jc>// A bean property that produces raw JSON.</jc>
		<jk>public</jk> Reader <jf>f1</jf> = <jk>new</jk> StringReader(<js>"{'foo':'bar'}"</js>);	
	}	
	
	<jc>// Produces "{f1:{'foo':'bar'}}"</jc>
	String <jv>json</jv> = Json5.<jsm>of</jsm>(<jk>new</jk> MyBean());
	</p>			
	<p>
		Note that if you're serializing Readers and InputStreams, it's up to you to make sure you're producing
		valid output (in this case JSON).
	</p>
	<p>
		A more typical scenario where this is useful is by using swaps to convert POJOs to Readers whose 
		contents are determined via the {@link org.apache.juneau.BeanSession#getMediaType()} method.
		In the following example, we're customizing the JSON output for a particular bean type but leaving
		all other renditions as-is:
	</p>			
	<p class='bjava'>
	<ja>@Swap</ja>(MyBeanSwapSometimes.<jk>class</jk>)
	<jk>public class</jk> MyBean {...}
	
	<jc>// A swap that produces specialized output for JSON but default serialization for</jc>
	<jc>// all other media types.</jc>
	<jk>public class</jk> MyBeanSwapSometimes <jk>extends</jk> ObjectSwap&lt;MyBean,Object&gt; {
		<jk>public</jk> Object swap(BeanSession <jv>session</jv>, MyPojo <jv>object</jv>) <jk>throws</jk> Exception {
			MediaType <jv>mediaType</jv> = <jv>session</jv>.getMediaType();
			<jk>if</jk> (<jv>mediaType</jv>.hasSubType(<js>"json"</js>))
				<jk>return new</jk> StringReader(<js>"{myPojo:'foobar'}"</js>);  <jc>// Custom JSON output</jc>
			<jk>return</jk> <jv>object</jv>;  <jc>// Otherwise serialize it as a normal bean</jc>
		}
	}
	</p>	
	<div class='info'>
		Due to the nature of the RDF serializers, Readers and InputStreams are serialized as literals,
		not as RDF text.
		This is due to the fact that the RDF serializers use a DOM for serialization so we don't have
		access to the underlying stream.
	</div>
</div>
</div><!-- END: 2.4.8 - jm.BypassSerialization -->
</div><!-- END: 2.4 - jm.JavaBeansSupport -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.HttpPartSerializersParsers' id='jm.HttpPartSerializersParsers'>2.5 - HTTP Part Serializers and Parsers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.5 - jm.HttpPartSerializersParsers -->
<div class='topic'>
	<p>
		There is a separate set of serializers and parsers for marshalling HTTP parts (query, form-data, headers, path variables, and plain-text request bodies).
		The distinction is that these are designed to marshall directly to-and-from strings based on Open-API schema information.
	</p>
	<p class='bjava'>
	<jc>// Schema information about our part.</jc>
	HttpPartSchema <jv>schema</jv> = HttpPartSchema
		.<jsm>tArrayPipes</jsm>()
		.items(
			HttpPartSchema
				.<jsm>tArrayCsv</jsm>()
				.items(
					HttpPartSchema.<jsm>tInt64</jsm>(<js>"integer"</js>,<js>"int64"</js>)
				)
		)
		.build();

	<jc>// Our value to serialize</jc>
	Object <jv>value</jv> = <jk>new long</jk>[][]{{1,2,3},{4,5,6},{7,8,9}};

	<jc>// Produces "1,2,3|4,5,6|7,8,9"</jc>
	String <jv>output</jv> = OpenApi.<jsm>of</jsm>(HttpPartType.<jsf>HEADER</jsf>, <jv>schema</jv>, <jv>value</jv>);
	
	<jc>// Produces "[[1,2,3],[4,5,6],[7,8,9]]</jc>
	<jk>long</jk>[][] <jv>value</jv> = OpenApi.<jsm>to</jsm>(HttpPartType.<jsf>HEADER</jsf>, <jv>schema</jv>, <jv>output</jv>, <jk>long</jk>[][].<jk>class</jk>);
	</p>
	<p>
		The {@link org.apache.juneau.httppart.HttpPartSchema} class also provides convenience static methods for creation of custom schemas.
		The equivalent to the schema above can be structured like so:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;
	
	<jc>// Schema information about our part.</jc>
	HttpPartSchema <jv>schema</jv> = <jsm>tArrayPipes</jsm>(<jsm>tArrayCsv</jsm>(<jsm>tInt64</jsm>())).build();
	</p>
	<p>
		The class hierarchy for the part marshallers are:
	</p>
	
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.httppart.HttpPartSerializer}
			<ul>
				<li class='jc'>{@link org.apache.juneau.httppart.SimplePartSerializer} - Serializes directly to strings.
				<li class='jc'>{@link org.apache.juneau.uon.UonSerializer} - Serializes to UON notation.
					<ul>
						<li class='jc'>{@link org.apache.juneau.oapi.OpenApiSerializer} - Serializes using Open-API schema rules.
					</ul>
				</li>
			</ul>
		</li>
		<li class='jic'>{@link org.apache.juneau.httppart.HttpPartParser}
			<ul>
				<li class='jc'>{@link org.apache.juneau.httppart.SimplePartParser} - Parses directly from strings.
				<li class='jc'>{@link org.apache.juneau.uon.UonParser} - Parses from UON notation.
					<ul>
						<li class='jc'>{@link org.apache.juneau.oapi.OpenApiParser} - Parses using Open-API schema rules.
					</ul>
				</li>
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.5 - jm.HttpPartSerializersParsers -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ContextSettings' id='jm.ContextSettings'>2.6 - Context Settings</a><span class='update'>updated: 8.1.3,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.6 - jm.ContextSettings -->
<div class='topic'>
	<p>
		Serializers and parsers have a wide variety of configurable settings.  Their builders all extend from the 
		{@link org.apache.juneau.BeanContext.Builder} class that allows you to easily construct new instances from scratch or build upon existing instances.
		For example, the following code shows how to configure a JSON serializer:
	</p>
	<p class='bjava'>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()          <jc>// Create a JsonSerializer.Builder</jc>
		.simpleMode()      <jc>// Simple mode</jc>
		.ws()              <jc>// Use whitespace</jc>
		.sq()              <jc>// Use single quotes </jc>
		.sortProperties()  <jc>// Sort bean properties by name</jc>
		.build();          <jc>// Create a JsonSerializer</jc>
	</p>
	<p>
		However, each of the serializers and parsers already contain reusable instances with common configurations.
		For example, JSON has the following predefined reusable serializers and parsers:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.json.JsonSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.JsonSerializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.JsonSerializer#DEFAULT_READABLE DEFAULT_READABLE}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.json.Json5Serializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.Json5Serializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.Json5Serializer#DEFAULT_READABLE DEFAULT_READABLE}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.json.JsonParser} 
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.JsonParser#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.JsonParser#DEFAULT_STRICT DEFAULT_STRICT}
			</ul>
		</li>
	</ul>
	<p>
		These can be used directly, as follows:
	</p>
	<p class='bjava'>
	<jc>// Serialize a POJO to LAX JSON.</jc>
	String <jv>json</jv> = Json5Serializer.<jsf>DEFAULT</jsf>.serialize(<jv>myPojo</jv>);
	</p>
	<p>
		For performance reasons, serializers and parsers are immutable.
		However, they can be 'copied' and modified using the <c>copy()</c> method.
	</p>
	<p class='bjava'>
	<jc>// Clone and customize an existing serializer.</jc>
	WriterSerializer <jv>serializer</jv> = Json5Serializer.<jsf>DEFAULT</jsf>
		.copy()          <jc>// Create a new builder with copied settings.</jc>
		.quoteChar(<js>'"'</js>)  <jc>// Use a different quote character.</jc>
		.build();
	</p>
	<p>
		Default values for configurable settings can be set globally using either system properties or environment variables.
		<br>For example, the default <c>useWhitespace</c> setting can be set by either the system property <js>"WriterSerializer.useWhitespace"</js>
		or environment variable <js>"WRITERSERIALIZER_USEWHITESPACE"</js>.
		The builder setters will identify when default values can be set this way.
	</p>
</div>
</div><!-- END: 2.6 - jm.ContextSettings -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ContextAnnotations' id='jm.ContextAnnotations'>2.7 - Context Annotations</a><span class='update'>created: 8.1.0, updated: 8.1.3,8.2.0,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.7 - jm.ContextAnnotations -->
<div class='topic'>
	<p>
		All configurable properties described in the previous section have annotation equivalents that can be applied on
		classes or methods.
	</p>
	<p>
		In the section on the REST server API, we describe how to configure serializers and parsers using <ja>@XConfig</ja>
		annotations like those shown below:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/addressBook"</js>,
		title=<js>"Address Book REST API"</js>
		...
	)
	<ja>@SerializerConfig</ja>(quoteChar=<js>"'"</js>)
	<ja>@RdfConfig</ja>(rdfxml_tab=<js>"5"</js>, addRootProperty=<js>"true"</js>)
	<ja>@BeanConfig</ja>(sortProperties=<js>"true"</js>, examples=<js>"Feed: $F{AddressBook_example.json}"</js>)
	<ja>@Bean</ja>(onClass=Address.<jk>class</jk>, properties=<js>"street,city,state"</js>)
	<jk>public class</jk> AddressBookResource <jk>extends</jk> BasicRestServlet {
		...
	}
	</p>
	<p>
		Config annotations defined on classes and methods can be applied to serializers and parsers using the following methods:	
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#applyAnnotations(Class...) applyAnnotations(Class...)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#applyAnnotations(Method...) applyAnnotations(Method...)}
			</ul>
		</li>
	</ul>
	<p>
		The following example shows how annotations defined on a dummy class can be applied to a serializer:
	</p>
	<p class='bjava'>
	<ja>@SerializerConfig</ja>(quoteChar=<js>"'"</js>)
	<ja>@Bean</ja>(on=<js>"Address"</js>, properties=<js>"street,city,state"</js>)
	<jk>public static class</jk> DummyClass {}
	
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().applyAnnotations(DummyClass.<jk>class</jk>).build();
	String <jv>json</jv> = <jv>serializer</jv>.toString(<jv>addressBean</jv>);
	</p>
	<p>
		Config annotations are provided for all serializers and parsers:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.annotation.BeanConfig BeanConfig}
		<li class='ja'>{@link org.apache.juneau.csv.annotation.CsvConfig CsvConfig}
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlConfig HtmlConfig}
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlDocConfig HtmlDocConfig}
		<li class='ja'>{@link org.apache.juneau.json.annotation.JsonConfig JsonConfig}
		<li class='ja'>{@link org.apache.juneau.jsonschema.annotation.JsonSchemaConfig JsonSchemaConfig}
		<li class='ja'>{@link org.apache.juneau.msgpack.annotation.MsgPackConfig MsgPackConfig}
		<li class='ja'>{@link org.apache.juneau.oapi.annotation.OpenApiConfig OpenApiConfig}
		<li class='ja'>{@link org.apache.juneau.parser.annotation.ParserConfig ParserConfig}
		<li class='ja'>{@link org.apache.juneau.plaintext.annotation.PlainTextConfig PlainTextConfig}
		<li class='ja'>{@link org.apache.juneau.serializer.annotation.SerializerConfig SerializerConfig}
		<li class='ja'>{@link org.apache.juneau.soap.annotation.SoapXmlConfig SoapXmlConfig}
		<li class='ja'>{@link org.apache.juneau.uon.annotation.UonConfig UonConfig}
		<li class='ja'>{@link org.apache.juneau.urlencoding.annotation.UrlEncodingConfig UrlEncodingConfig}
		<li class='ja'>{@link org.apache.juneau.xml.annotation.XmlConfig XmlConfig}
	</ul>
	<p>
		Annotations normally applied to bean classes/methods/fields/parameters 
		can also be programmatically attatched to beans by using the <js>"on"</js> or <js>"onClass"</js> annotation values as seen 
		on the <ja>@Bean</ja> annotation in the example above.
		These include:
	</p>
	<p>
		Annotations can also be applied directly to serializers and parsers using the following method:	
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#annotations(Annotation...) annotations(Annotation...)} 
			</ul>
		</li>
	</ul>
	<p>
		The following example shows a concrete implementation of an annotation can be applied to a serializer:
	</p>
	<p class='bjava'>
	<jk>public class</jk> Address {...}
	
	<ja>Bean</ja> <jv>ba</jv> = <jk>new</jk> BeanAnnotation(<js>"Address"</js>).properties(<js>"street,city,state"</js>);
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().annotations(<jv>ba</jv>).build();
	String <jv>json</jv> = <jv>serializer</jv>.toString(<jv>addressBean</jv>); <jc>// Will print street,city,state</jc>
	</p>
	
	<p>
		Concrete annotation implementations are provided for all annotations.
	</p>
	<p>
		Any number of matching config or concrete annotations can be applied.  They are applied in the order they are provided
		to the context.  Therefore any values can be overridden.  Config and concrete annotations also override any class or method
		level annotations 
	</p>
	
	<p class='bjava'>
	<ja>@Bean</ja>(properties=<js>"street,city"</js>) <jc>// Will be overridden</jc>
	<jk>public class</jk> Address {...}
	
	<ja>Bean</ja> <jv>beanAnnotation</jv> = <jk>new</jk> BeanAnnotation(<js>"Address"</js>).properties(<js>"street,city,state"</js>);
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().annotations(<jv>beanAnnotation</jv>).build();
	String <jv>json</jv> = <jv>serializer</jv>.toString(<jv>addressBean</jv>);  <jc>// Will print street,city,state</jc>
	</p>
</div>
</div><!-- END: 2.7 - jm.ContextAnnotations -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.JsonMap' id='jm.JsonMap'>2.8 - JsonMap and JsonList</a><span class='update'>updated: 8.2.0</span></h3>
<div class='topic'><!-- START: 2.8 - jm.JsonMap -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.collections.JsonMap} and {@link org.apache.juneau.collections.JsonList} classes are generic Java 
		representations of JSON objects and arrays.  
		These classes can be used to create "unstructured" models for serialization (as opposed to "structured" 
		models consisting of beans).  
		If you want to quickly generate JSON/XML/HTML from generic maps/collections, or parse JSON/XML/HTML into 
		generic maps/collections, these classes work well.  
	</p>
	<p>
		These classes extend directly from the following JCF classes:
	</p>
	<ul class='javatree'>
		<li class='jc'> 
			{@link java.util.LinkedHashMap java.util.LinkedHashMap}
			<ul>
				<li class='jc'> 
				{@link org.apache.juneau.collections.JsonMap org.apache.juneau.collections.JsonMap}
			</ul>
		</li>
		<li class='jc'> 
			{@link java.util.LinkedList java.util.LinkedList}
			<ul>
				<li class='jc'> 
					{@link org.apache.juneau.collections.JsonList org.apache.juneau.collections.JsonList}
			</ul>
		</li>
	</ul>
	<p>
		The <l>JsonMap</l> and <l>JsonList</l> classes are very similar to the <l>JSONObject</l> and 
		<l>JSONArray</l> classes found in other libraries.  
		However, the names were chosen because the concepts of <l>Maps</l> and <l>Lists</l> are already familiar to 
		Java programmers, and these classes can be used with any of the serializers or parsers.
	</p>
	<p>
		These object can be serialized in one of two ways:
	</p>
	<ol class='spaced-list'>
		<li>
			Using the provided {@link org.apache.juneau.collections.JsonMap#writeTo(java.io.Writer)} or 
			{@link org.apache.juneau.collections.JsonList#writeTo(java.io.Writer)} methods.
		<li>
			Passing them to one of the {@link org.apache.juneau.serializer.Serializer} serialize methods.
		<li>
			Simply calling the {@link org.apache.juneau.collections.JsonMap#asJson()}/{@link org.apache.juneau.collections.JsonMap#toString()} or {@link org.apache.juneau.collections.JsonList#asString()}/{@link org.apache.juneau.collections.JsonList#toString()}
			methods which will serialize it as Simplified JSON.
	</ol>
	<p>
		Any valid JSON can be parsed into an unstructured model consisting of generic 
		{@link org.apache.juneau.collections.JsonMap} and {@link org.apache.juneau.collections.JsonList} objects. 
		
		(Any valid XML can also be parsed into an unstructured model)
	</p>
	<p class='bjava'>
	<jc>// Parse an arbitrary JSON document into an unstructered data model
	// consisting of JsonMaps, JsonLists, and java primitive objects.</jc>
	String <jv>json</jv> = <js>"{a:{name:'John Smith',age:21},b:{name:'Joe Smith',age:42}}"</js>;
	JsonMap <jv>map</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, JsonMap.<jk>class</jk>);

	<jc>// Use JsonMap API to extract data from the unstructured model.</jc>
	<jk>int</jk> <jv>johnSmithAge</jv> = <jv>map</jv>.getMap(<js>"a"</js>).getInt(<js>"age"</js>);
	
	<jc>// Convert it back into JSON.</jc>
	<jv>json</jv> = Json.<jsm>of</jsm>(<jv>map</jv>);
	
	<jc>// Or convert it to XML.</jc>
	String <jv>xml</jv> = Xml.<jsm>of</jsm>(<jv>map</jv>);

	<jc>// Or just use toString() or asJson().</jc>
	<jv>json</jv> = <jv>map</jv>.toString();
	<jv>json</jv> = <jv>map</jv>.asJson();
	</p>
	<p>
		The <c>JsonMap</c> and <c>JsonList</c> classes have many convenience features:
	</p>
	<p class='bjava'>	
	<jc>// Convert the map to a bean.</jc>		
	MyBean <jv>myBean</jv> = <jv>map</jv>.cast(MyBean.<jk>class</jk>);
			
	<jc>// Find entries by multiple keys.</jc>
	MyBean <jv>myBean</jv> = <jv>map</jv>.find(MyBean.<jk>class</jk>, <js>"key1"</js>, <js>"key2"</js>);
	
	<jc>// Fluent-style appenders.</jc>
	<jv>map</jv>.append(<js>"key1"</js>, <js>"val1"</js>).append(<js>"key2"</js>, <js>"val2"</js>);
			
	<jc>// REST-like functions for manipulating nodes in the data structure using URL-like notation.</jc>
	<jv>map</jv>.getAt(<js>"foo/bar/myBean"</js>, MyBean.<jk>class</jk>);		
	<jv>map</jv>.putAt(<js>"foo/bar/myBean"</js>, MyBean.<jk>class</jk>);		
	<jv>map</jv>.postAt(<js>"foo/bar/myListOfBeans"</js>, MyBean.<jk>class</jk>);		
	<jv>map</jv>.deleteAt(<js>"foo/bar/myBean"</js>);		
	
	<jc>// Copy with inclusion or exclusion.</jc>
	JsonMap <jv>map2</jv> = <jv>map</jv>.include(<js>"key1"</js>, <js>"key2"</js>, <js>"key3"</js>);
	JsonMap <jv>map3</jv> = <jv>map</jv>.exclude(<js>"key1"</js>, <js>"key2"</js>, <js>"key3"</js>);
	
	<jc>// Serialize using another serializer.</jc>
	String <jv>xml</jv> = <jv>map</jv>.serializeTo(XmlSerializer.<jsf>DEFAULT</jsf>);
	
	<jc>// Nested maps.</jc>
	<jv>map</jv>.inner(<jv>anotherMap</jv>);
	</p>
	
	<div class='info'>
		As a general rule, if you do not specify a target type during parsing, or if the target type cannot be 
		determined through reflection, the parsers automatically generate <l>JsonMaps</l> and <l>JsonLists</l>.
	</div>
</div>
</div><!-- END: 2.8 - jm.JsonMap -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ComplexDataTypes' id='jm.ComplexDataTypes'>2.9 - Complex Data Types</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.9 - jm.ComplexDataTypes -->
<div class='topic'>
	<p>
		The Juneau parsers have the ability to parse into complex data types that consist of multidimensional arrays and nested maps and collections
		using the methods below:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.parser.Parser}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.parser.Parser#parse(Object,Class) parse(Object,Class)}
				<li class='jm'>{@link org.apache.juneau.parser.Parser#parse(Object,Type,Type...) parse(Object,Type,Type...)}
			</ul>
		</li>
	</ul>	
	<p>
		Arrays are simple enough and can be constructed using the first method:
	</p>
	<p class='bjava'>
	String <jv>json</jv> = <js>"[1,2,3]"</js>;
	<jk>int</jk>[] <jv>array</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, <jk>int</jk>[].<jk>class</jk>);
	</p>
	<p>
		For data types consisting of nested collections an maps such as <c>Map&lt;String,List&lt;MyBean&gt;&gt;</c>, you need to
		use the second parse method that allows you to define the parameter types of the collections classes.
		For example:
	</p>
	<p class='bjava'>
	String <jv>json</jv> = <js>"{foo:[{bar:'baz'}]}"</js>;
	TreeMap&lt;String,List&lt;MyBean&gt;&gt; <jv>map</jv> = Json.<jsm>to</jsm>(
		<jv>json</jv>,             <jc>// Input being parsed.</jc>
		TreeMap.<jk>class</jk>,    <jc>// Top-level data type.</jc>
		String.<jk>class</jk>,     <jc>// Key type of map.</jc>
		LinkedList.<jk>class</jk>, <jc>// Value type of map.</jc>
		MyBean.<jk>class</jk>      <jc>// Value type of list.</jc>
	);
	</p>
	<p>
		<c>Collection</c> classes are assumed to be followed by zero or one objects indicating the element type.
		<br><c>Map</c> classes are assumed to be followed by zero or two meta objects indicating the key and value types.
		<br>The arguments can be arbitrarily long to indicate arbitrarily complex data structures.
	</p>
	<p>
		Similar methods for converting to complex types can be found on the {@link org.apache.juneau.rest.httppart.RequestContent} and {@link org.apache.juneau.rest.httppart.RequestHttpPart} classes,
		and the {@link org.apache.juneau.BeanSession#convertToType(Object,Type,Type...)} method.
	</p>
</div>
</div><!-- END: 2.9 - jm.ComplexDataTypes -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.SerializerSetsParserSets' id='jm.SerializerSetsParserSets'>2.10 - SerializerSets and ParserSets</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.10 - jm.SerializerSetsParserSets -->
<div class='topic'>
	<p>
		On top of the serializers and parsers are the {@link org.apache.juneau.serializer.SerializerSet} and 
		{@link org.apache.juneau.parser.ParserSet} classes.
		These classes allow serializers and parsers to be grouped and retrieved by W3C-compliant HTTP <c>Accept</c> 
		and <c>Content-Type</c> values...
	</p>
	<p class='bjava'>
	<jc>// Construct a new serializer group with configuration parameters that get applied 
	// to all serializers.</jc>
	SerializerSet <jv>serializers</jv> = SerializerSet.<jsm>create</jsm>()
		.add(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>)
		.forEach(<jv>x</jv> -&gt; <jv>x</jv>.swaps(TemporalCalendarSwap.IsoLocalDateTime.<jk>class</jk>))
		.forEachWS(<jv>x</jv> -&gt; <jv>x</jv>.ws())   <jc>// or .useWhitespace(true)</jc>
		.build();

	<jc>// Find the appropriate serializer by Accept type and serialize our POJO to the 
	// specified writer.</jc>
	<jv>serializers</jv>
		.getSerializer(<js>"text/invalid, text/json;q=0.8, text/*;q:0.6, *\/*;q=0.0"</js>)
		.serialize(<jv>myPerson</jv>, <jv>myWriter</jv>);
		
	<jc>// Construct a new parser group with configuration parameters that get applied to all parsers.</jc>
	ParserSet <jv>parsers</jv> = ParserSet.<jsm>create</jsm>()
		.add(JsonSerializer.<jk>class</jk>, UrlEncodingSerializer.<jk>class</jk>)
		.forEach(<jv>x</jv> -&gt; <jv>x</jv>.swaps(CalendarSwap.IsoLocalDateTime.<jk>class</jk>))
		.build();

	Person <jv>myPerson</jv> = <jv>parsers</jv>
		.getParser(<js>"text/json"</js>)
		.parse(<jv>myReader</jv>, Person.<jk>class</jk>);
	</p>
	<p>
		The REST servlet API builds upon the <c>SerializerSet</c> and <c>ParserSet</c> classes 
		to provide annotated REST servlets that automatically negotiate the HTTP media types and allow the developer
		to work with requests and responses as POJOs.
	</p>			
</div>
</div><!-- END: 2.10 - jm.SerializerSetsParserSets -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.Swaps' id='jm.Swaps'>2.11 - Swaps</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.11 - jm.Swaps -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.swap.ObjectSwap Swaps} are a critical component of Juneau.
		They allow the serializers and parsers to handle Java objects that wouldn't normally be serializable.
	</p>
	<p>
		Swaps are, simply put, 'object swappers' that swap in serializable objects for 
		non-serializable ones during serialization, and vis-versa during parsing.
		Some examples of non-serializable objects are <c>File</c>, <c>Reader</c>, 
		<c>Iterable</c>, etc...
		These are classes that aren't beans and cannot be represented as simple maps, collections, or primitives.
	</p>
	<p>
		In the following example, we introduce a <c>ObjectSwap</c> that will swap in a bean of a particular type
		with a map containing customized key-value pairs:
	</p>
	<p class='bjava'>
	<jc>// Sample swap for converting a bean to a specialized map of key-value pairs.</jc>
	<jk>public class</jk> MyBeanSwap <jk>extends</jk> ObjectSwap&lt;MyBean,JsonMap&gt; {
		
		<jc>// Converts a bean to a generic map.</jc>
		<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
		<jk>public</jk> JsonMap swap(BeanSession <jv>session</jv>, MyBean <jv>bean</jv>) {
			<jk>return</jk> JsonMap.<jsm>of</jsm>(<js>"foo"</js>, <jv>bean</jv>.getBar());
		}
		
		<jc>// Converts the generic map back into a bean.</jc>
		<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
		<jk>public</jk> MyBean unswap(BeanSession <jv>session</jv>, JsonMap <jv>map</jv>, ClassMeta&lt;?&gt; <jv>hint</jv>) <jk>throws</jk> Exception {
			MyBean <jv>bean</jv> = <jk>new</jk> MyBean();
			<jv>bean</jv>.setBar(<jv>map</jv>.getString(<js>"foo"</js>));
			<jk>return</jk> <jv>bean</jv>;
		}
	}
	</p>
	<p>
		The swap can then be associated with serializers and parsers like so:
	</p>
	<p class='bjava'>
	<jc>// Create a new JSON serializer with our swap.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().simple().swaps(MyBeanSwap.<jk>class</jk>).build();
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jk>new</jk> MyBean());
	
	<jc>// Create a JSON parser with our swap.</jc>
	ReaderParser <jv>parser</jv> = JsonParser.<jsm>create</jsm>().swaps(MyBeanSwap.<jk>class</jk>).build();
	MyBean <jv>bean</jv> = <jv>parser</jv>.parse(<jv>json</jv>, MyBean.<jk>class</jk>);
	</p>
	<p>
		Another example of a <c>ObjectSwap</c> is one that converts <c><jk>byte</jk>[]</c> arrays to
		BASE64-encoded strings:
	</p>
	<p class='bjava'>
	<jk>public class</jk> ByteArrayBase64Swap <jk>extends</jk> StringSwap&lt;<jk>byte</jk>[]&gt; {
	
		<ja>@Override</ja> <jc>/* StringSwap */</jc>
		<jk>public</jk> String swap(<jk>byte</jk>[] <jv>bytes</jv>) <jk>throws</jk> Exception {
			ByteArrayOutputStream <jv>baos</jv> = <jk>new</jk> ByteArrayOutputStream();
			OutputStream <jv>b64os</jv> = MimeUtility.encode(<jv>baos</jv>, <js>"base64"</js>);
			<jv>b64os</jv>.write(<jv>bytes</jv>);
			<jv>b64os</jv>.close();
			<jk>return new</jk> String(<jv>baos</jv>.toByteArray());
		}
		
		<ja>@Override</ja> <jc>/* StringSwap */</jc>
		<jk>public byte</jk>[] unswap(String <jv>string</jv>, ClassMeta&lt;?&gt; <jv>hint</jv>) <jk>throws</jk> Exception {
			<jk>byte</jk>[] <jv>bytes</jv> = <jv>string</jv>.getBytes();
			ByteArrayInputStream <jv>bais</jv> = <jk>new</jk> ByteArrayInputStream(<jv>bytes</jv>);
			InputStream <jv>b64is</jv> = MimeUtility.<jsm>decode</jsm>(<jv>bais</jv>, <js>"base64"</js>);
			<jk>byte</jk>[] <jv>tmp</jv> = <jk>new byte</jk>[<jv>bytes</jv>.<jf>length</jf>];
			<jk>int</jk> <jv>n</jv> = <jv>b64is</jv>.read(<jv>tmp</jv>);
			<jk>byte</jk>[] <jv>res</jv> = <jk>new byte</jk>[<jv>n</jv>];
			System.<jsm>arraycopy</jsm>(<jv>tmp</jv>, 0, <jv>res</jv>, 0, <jv>n</jv>);
			<jk>return</jk> <jv>res</jv>;
		}
	}
	</p>
	<p>
		The following example shows the BASE64 swap in use:
	</p>
	<p class='bjava'>
	<jc>// Create a JSON serializer and register the BASE64 encoding swap with it.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().simple().swaps(ByteArrayBase64Swap.<jk>class</jk>).build();
	ReaderParser <jv>parser</jv> = JsonParser.<jsm>create</jsm>().swaps(ByteArrayBase64Swap.<jk>class</jk>).build();
	
	<jk>byte</jk>[] <jv>bytes</jv> = {1,2,3};
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jv>bytes</jv>);      <jc>// Produces "'AQID'"</jc>
	<jv>bytes</jv> = <jv>parser</jv>.parse(<jv>json</jv>, <jk>byte</jk>[].<jk>class</jk>);       <jc>// Reproduces {1,2,3}</jc>
	
	<jk>byte</jk>[][] <jv>bytes2d</jv> = {{1,2,3},{4,5,6},<jk>null</jk>};
	<jv>json</jv> = <jv>serializer</jv>.serialize(<jv>bytes2d</jv>);           <jc>// Produces "['AQID','BAUG',null]"</jc>
	<jv>bytes2d</jv> = <jv>parser</jv>.parse(<jv>json</jv>, <jk>byte</jk>[][].<jk>class</jk>);   <jc>// Reproduces {{1,2,3},{4,5,6},null}</jc>
	</p>
	<p>
		The {@link org.apache.juneau.BeanContextable.Builder#swap(Class,Class,ThrowingFunction)} and {@link org.apache.juneau.BeanContextable.Builder#swap(Class,Class,ThrowingFunction,ThrowingFunction)}
		methods are another way to define swaps by using functions.
	</p>
	<p class='bjava'>
	<jc>// Use a function to convert beans to strings.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.simple()
		.swap(MyBean.<jk>class</jk>, String.<jk>class</jk>, <jv>x</jv> -&gt; <jsm>myBeanStringifier</jsm>(<jv>x</jv>))
		.build();
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.DefaultSwaps' id='jm.DefaultSwaps'>2.11.1 - Default Swaps</a></h4>
<div class='topic'><!-- START: 2.11.1 - jm.DefaultSwaps -->
<div class='topic'>
	<p>
		By default, all serializers and parsers have built in <c>ObjectSwaps</c> defined for the following common data types:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link java.util.Enumeration}
		<li class='jc'>{@link java.util.Iterator}
		<li class='jc'>{@link java.util.Locale}
		<li class='jc'>{@link java.lang.Class}
		<li class='jc'>{@link java.util.Calendar}
		<li class='jc'>{@link java.util.Date}
		<li class='jc'>{@link java.time.Instant}
		<li class='jc'>{@link java.time.ZonedDateTime}
		<li class='jc'>{@link java.time.LocalDate}
		<li class='jc'>{@link java.time.LocalDateTime}
		<li class='jc'>{@link java.time.LocalTime}
		<li class='jc'>{@link java.time.OffsetDateTime}
		<li class='jc'>{@link java.time.OffsetTime}
		<li class='jc'>{@link java.time.Year}
		<li class='jc'>{@link java.time.YearMonth}
		<li class='jc'>{@link java.time.temporal.Temporal}
		<li class='jc'>{@link java.util.TimeZone}
		<li class='jc'>{@link javax.xml.datatype.XMLGregorianCalendar}
		<li class='jc'>{@link java.time.ZoneId}
	</ul>
	<p>
		Various other swaps are provided in the {@link org.apache.juneau.swaps} package.
	</p>
</div>
</div><!-- END: 2.11.1 - jm.DefaultSwaps -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.AutoSwaps' id='jm.AutoSwaps'>2.11.2 - Auto-detected swaps</a><span class='update'>created: 8.1.0</span></h4>
<div class='topic'><!-- START: 2.11.2 - jm.AutoSwaps -->
<div class='topic'>
	<p>
		Various methods can be defined on a class directly to affect how it gets serialized.
		This can often be simpler than using <c>ObjectSwaps</c>.
	</p>
	<p>
		Objects serialized as <c>Strings</c> can be parsed back into their original objects by 
		implementing one of the following methods on the class:
	</p>		
	<ul class='spaced-list'>
		<li>
			<c><jk>public static</jk> T fromString(String)</c> method.
			<br>Any of the following method names also work: 
			<ul>
				<li><c>valueOf(String)</c>
				<li><c>parse(String)</c>
				<li><c>parseString(String)</c>
				<li><c>forName(String)</c>
				<li><c>forString(String)</c>
			</ul>
		<li>
			<c><jk>public</jk> T(String)</c> constructor.
	</ul>
	<p>
		Note that these methods cover conversion from several built-in Java types, meaning the parsers can 
		automatically construct these objects from strings:
	</p>
	<ul>
		<li><c>fromString(String)</c> - {@link java.util.UUID}
		<li><c>valueOf(String)</c> - {@link java.lang.Boolean}, {@link java.lang.Byte}, 
			{@link java.lang.Double}, {@link java.lang.Float}, 
			{@link java.lang.Integer}, {@link java.lang.Long}, {@link java.lang.Short}, {@link java.sql.Date}, 
			{@link java.sql.Time}, {@link java.sql.Timestamp}
		<li><c>parse(String)</c> - {@link java.text.DateFormat}, {@link java.text.MessageFormat}, 
			{@link java.text.NumberFormat}, {@link java.util.Date}, {@link java.util.logging.Level}
		<li><c>parseString(String)</c> - {@link javax.xml.bind.DatatypeConverter}
		<li><c>forName(String)</c> - {@link java.lang.Class}
	</ul>
	<p>
		If you want to force a bean-like class to be serialized as a string, you can use the 
		{@link org.apache.juneau.annotation.BeanIgnore @BeanIgnore} annotation on the class to force it to be 
		serialized to a string using the <c>toString()</c> method.
	</p>
	<p>
		Serializing to other intermediate objects can be accomplished by defining a swap method directly on the 
		class:
	</p>			
	<ul>
		<li><c><jk>public</jk> X swap()</c> method, where <c>X</c> is any serializable object.
		<li><c><jk>public</jk> X swap(BeanSession)</c> method, where <c>X</c> is any serializable object.
		<li><c><jk>public static</jk> MyPojo unswap(X)</c> method, where <c>X</c> is any serializable object.
		<li><c><jk>public static</jk> MyPojo swap(X,BeanSession)</c> method, where <c>X</c> is any serializable object.
	</ul>
	<p>
		Serializing to and from Maps can be accomplished by defining any of the following methods:
	</p>			
	<ul>
		<li><c><jk>public</jk> Map toMap()</c> method.
			<br>Can be any type of map with string keys and object vals. 
		<li><c><jk>public</jk> JsonMap toMap()</c> method. 
		<li><c><jk>public</jk> Map toMap(BeanSession)</c> method.
			<br>Can be any type of map with string keys and object vals. 
		<li><c><jk>public</jk> JsonMap toMap(BeanSession)</c> method.
		<li><c><jk>public static</jk> MyPojo fromMap(Map)</c> method.
			<br>Can be any type of map with string keys and object vals. 
		<li><c><jk>public static</jk> MyPojo fromMap(JsonMap)</c> method.
		<li><c><jk>public static</jk> MyPojo fromMap(Map,BeanSession)</c> method.
			<br>Can be any type of map with string keys and object vals. 
		<li><c><jk>public static</jk> MyPojo fromMap(JsonMap,BeanSession)</c> method.
	</ul>
	<p>
		The <c>BeanSession</c> parameter allows you access to various information about the current 
		serialization session.
		For example, you could provide customized results based on the media type being produced 
		({@link org.apache.juneau.BeanSession#getMediaType()}).
	</p>
	<p>
		The following example shows how an HTML5 form template object can be created that gets serialized as a 
		populated HTML5 {@link org.apache.juneau.dto.html5.Form} bean.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<jd>/**
	 * A simple HTML form template whose serialized form is an HTML5 Form object.
	 */</jd>
	<jk>public class</jk> FormTemplate {
		
		<jk>private</jk> String <jf>action</jf>;
		<jk>private int</jk> <jf>value1</jf>;
		<jk>private boolean</jk> <jf>value2</jf>;
		
		<jc>// Some constructor that initializes our fields. </jc>
		<jk>public</jk> FormTemplate(String <jv>action</jv>, <jk>int</jk> <jv>value1</jv>, <jk>boolean</jk> <jv>value2</jv>) {
			<jk>this</jk>.<jf>action</jf> = <jv>action</jv>;
			<jk>this</jk>.<jf>value1</jf> = <jv>value1</jv>;
			<jk>this</jk>.<jf>value2</jf> = <jv>value2</jv>;
		}
		
		<jc>// Special swap method that converts this template to a serializable bean</jc>
		<jk>public</jk> Form swap(BeanSession <jv>session</jv>) {
			<jk>return</jk> <jsm>form</jsm>(<jf>action</jf>,
				<jsm>input</jsm>(<js>"text"</js>).name(<js>"v1"</js>).value(<jf>value1</jf>),
				<jsm>input</jsm>(<js>"text"</js>).name(<js>"v2"</js>).value(<jf>value2</jf>)
			);
		}
	}
	</p>
	<p>
		Swapped objects can be converted back into their original form by the parsers by specifying one of the 
		following methods:
	</p>
	<ul>
		<li><c><jk>public static</jk> T unswap(BeanSession, X)</c> method where <c>X</c> is the 
			swap class type.
		<li><c><jk>public</jk> T(X)</c> constructor where <c>X</c> is the swap class type.
	</ul>
	<p>
		The following shows how our form template class can be modified to allow the parsers to reconstruct our 
		original object:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<jd>/**
	 * A simple HTML form template whose serialized form is an HTML5 Form object.
	 * This time with parsing support.
	 */</jd>
	<ja>@Bean</ja>(dictionary=HtmlBeanDictionary.<jk>class</jk>)
	<jk>public class</jk> FormTemplate {
		
		<jk>private</jk> String <jf>action</jf>;
		<jk>private int</jk> <jf>value1</jf>;
		<jk>private boolean</jk> <jf>value2</jf>;
		
		<jc>// Our 'unswap' constructor</jc>
		<jk>public</jk> FormTemplate(Form <jv>form</jv>) {
			<jk>this</jk>.<jf>action</jf> = <jv>form</jv>.getAttr(<js>"action"</js>);
			<jk>this</jk>.<jf>value1</jf> = <jv>form</jv>.getChild(Input.<jk>class</jk>, 0)
				.getAttr(<jk>int</jk>.<jk>class</jk>, <js>"value"</js>);
			<jk>this</jk>.<jf>value2</jf> = <jv>form</jv>.getChild(Input.<jk>class</jk>, 1)
				.getAttr(<jk>boolean</jk>.<jk>class</jk>, <js>"value"</js>);
		}
		
		<jk>public</jk> FormTemplate(String <jv>action</jv>, <jk>int</jk> <jv>value1</jv>, <jk>boolean</jk> <jv>value2</jv>) {
			<jk>this</jk>.<jf>action</jf> = <jv>action</jv>;
			<jk>this</jk>.<jf>value1</jf> = <jv>value1</jv>;
			<jk>this</jk>.<jf>value2</jf> = <jv>value2</jv>;
		}
		
		<jk>public</jk> Form swap(BeanSession <jv>session</jv>) {
			<jk>return</jk> <jsm>form</jsm>(<jf>action</jf>,
				<jsm>input</jsm>(<js>"text"</js>).name(<js>"v1"</js>).value(<jf>value1</jf>),
				<jsm>input</jsm>(<js>"text"</js>).name(<js>"v2"</js>).value(<jf>value2</jf>)
			);
		}
	}
	</p>
</div>
</div><!-- END: 2.11.2 - jm.AutoSwaps -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.PerMediaTypeSwaps' id='jm.PerMediaTypeSwaps'>2.11.3 - Per-media-type Swaps</a><span class='update'>updated: 8.1.0,8.2.0</span></h4>
<div class='topic'><!-- START: 2.11.3 - jm.PerMediaTypeSwaps -->
<div class='topic'>
	<p>
		Swaps can also be defined per-media-type.		
	</p>
	<p>	
		The {@link org.apache.juneau.swap.ObjectSwap#forMediaTypes()} method can be overridden to 
		provide a set of media types that the swap is invoked on.
		It's also possible to define multiple swaps against the same object as long as they're differentiated 
		by media type.
		When multiple swaps are defined, the best-match media type is used.
	</p>
	<p>
		In the following example, we define 3 swaps against the same object.  
		One for JSON, one for XML, and one for all other types.
	</p>
	<p class='bjava'>
	<jk>public class</jk> ObjectSwapTest {

		<jk>public static class</jk> MyPojo {}

		<jk>public static class</jk> MyJsonSwap <jk>extends</jk> StringSwap&lt;MyPojo&gt; {
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> MediaType[] forMediaTypes() {
				<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/json"</js>);
			}
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> String swap(BeanSession <jv>session</jv>, MyPojo <jv>pojo</jv>) <jk>throws</jk> Exception {
				<jk>return</jk> <js>"It's JSON!"</js>;
			}
		}

		<jk>public static class</jk> MyXmlSwap <jk>extends</jk> StringSwap&lt;MyPojo&gt; {
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> MediaType[] forMediaTypes() {
				<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/xml"</js>);
			}
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> String swap(BeanSession <jv>session</jv>, MyPojo <jv>pojo</jv>) <jk>throws</jk> Exception {
				<jk>return</jk> <js>"It's XML!"</js>;
			}
		}

		<jk>public static class</jk> MyOtherSwap <jk>extends</jk> StringSwap&lt;MyPojo&gt; {
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> MediaType[] forMediaTypes() {
				<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/*"</js>);
			}
			<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
			<jk>public</jk> String swap(BeanSession <jv>session</jv>, MyPojo <jv>pojo</jv>) <jk>throws</jk> Exception {
				<jk>return</jk> <js>"It's something else!"</js>;
			}
		}

		<ja>@Test</ja>
		<jk>public void</jk> doTest() <jk>throws</jk> Exception {

			SerializerSet <jv>serializers</jv> = SerializersSet.<jsm>create</jsm>()
				.add(JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>, HtmlSerializer.<jk>class</jk>)
				.forEach(<jv>x</jv> -&gt; <jv>x</jv>.swaps(MyJsonSwap.<jk>class</jk>, MyXmlSwap.<jk>class</jk>, MyOtherSwap.<jk>class</jk>))
				.forEachWS(<jv>x</jv> -&gt; <jv>x</jv>.ws())
				.build();

			MyPojo <jv>myPojo</jv> = <jk>new</jk> MyPojo();

			String <jv>json</jv> = <jv>seralizers</jv>.getWriterSerializer(<js>"text/json"</js>).serialize(<jv>myPojo</jv>);
			<jsm>assertEquals</jsm>(<js>"'It\\'s JSON!'"</js>, <jv>json</jv>);

			String <jv>xml</jv> = <jv>seralizers</jv>.getWriterSerializer(<js>"text/xml"</js>).serialize(<jv>myPojo</jv>);
			<jsm>assertEquals</jsm>(<js>"&lt;string&gt;It's XML!&lt;/string&gt;"</js>, <jv>xml</jv>);

			String <jv>html</jv> = <jv>seralizers</jv>.getWriterSerializer(<js>"text/html"</js>).serialize(<jv>myPojo</jv>);
			<jsm>assertEquals</jsm>(<js>"&lt;string&gt;It's something else!&lt;/string&gt;"</js>, <jv>html</jv>);
		}
	}
	</p>
	<p>
		When multiple swaps match the same media type, a best-match algorithm is applied to find the correct
		swap to use.
	</p>
	<p>
		In later sections we describe how annotations can be used to shorten this syntax:
	</p>
	<p class='bjava'>
	<ja>@Swap</ja>(MyJsonSwap.<jk>class</jk>)
	<ja>@Swap</ja>(MyXmlSwap.<jk>class</jk>)
	<ja>@Swap</ja>(MyOtherSwap.<jk>class</jk>)
	<jk>public static class</jk> MyPojo {}

	<ja>@Swap</ja>(mediaTypes=<js>"&#42;/json"</js>)
	<jk>public static class</jk> MyJsonSwap <jk>extends</jk> ObjectSwap&lt;MyPojo,String&gt; {...}

	<ja>@Swap</ja>(mediaTypes=<js>"&#42;/xml"</js>)
	<jk>public static class</jk> MyXmlSwap <jk>extends</jk> ObjectSwap&lt;MyPojo,String&gt; {...}

	<ja>@Swap</ja>(mediaTypes=<js>"&#42;/*"</js>)
	<jk>public static class</jk> MyOtherSwap <jk>extends</jk> ObjectSwap&lt;MyPojo,String&gt; {...}
	</p>
</div>
</div><!-- END: 2.11.3 - jm.PerMediaTypeSwaps -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.OneWaySwaps' id='jm.OneWaySwaps'>2.11.4 - One-way Swaps</a></h4>
<div class='topic'><!-- START: 2.11.4 - jm.OneWaySwaps -->
<div class='topic'>
	<p>
		In the previous sections, we defined two-way swaps, meaning swaps where the original objects could be 
		reconstructing during parsing. 
		However, there are certain kinds of objects that we may want to support for serializing but that are not 
		possible to reconstruct during parsing.  
		For these, we can use one-way object swaps.
	</p>
	<p>
		A one-way swap is simply an object transform that only implements the {@code swap()} method.  
		The {@code unswap()} method is simply left unimplemented.
	</p>
	<p>
		An example of a one-way swaps would be one that allows {@code Iterators} to be serialized as JSON arrays.  
		It can make sense to be able to render {@code Iterators} as arrays but in general it's not possible to 
		reconstruct an {@code Iterator} during parsing. 
	</p>
	<p class='bjava'>
	<jk>public class</jk> IteratorSwap <jk>extends</jk> ObjectSwap&lt;Iterator,List&gt; {
		<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
		<jk>public</jk> List swap(Iterator <jv>iterator</jv>) {
			List <jv>list</jv> = <jk>new</jk> LinkedList();
			<jk>while</jk> (<jv>iterator</jv>.hasNext())
				<jv>list</jv>.add(<jv>iterator</jv>.next());
			<jk>return</jk> <jv>list</jv>;
		}
	}
	</p>
	<p>
		Here is an example of our one-way swap being used.  
		Note that trying to parse the original object will cause a {@link org.apache.juneau.parser.ParseException} 
		to be thrown.
	</p>
	<p class='bjava'>
	<jc>// Create a JSON serializer that can serialize Iterators.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer.<jsm>create</jsm>().simple().swaps(IteratorSwap.<jk>class</jk>).build();
	
	<jc>// Construct an iterator we want to serialize.</jc>
	Iterator <jv>iterator</jv> = JsonList.<jsm>of</jsm>(1,2,3).iterator();
	
	<jc>// Serialize our Iterator</jc>
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jv>iterator</jv>);		<jc>// Produces "[1,2,3]"</jc>
	
	<jc>// Try to parse it.</jc>
	ReaderParser <jv>parser</jv> = JsonParser.<jsm>create</jsm>().swaps(IteratorSwap.<jk>class</jk>).build();
	<jv>iterator</jv> = <jv>parser</jv>.parse(<jv>json</jv>, Iterator.<jk>class</jk>);		<jc>// Throws ParseException!!!</jc>
	</p>
</div>
</div><!-- END: 2.11.4 - jm.OneWaySwaps -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.SwapAnnotation' id='jm.SwapAnnotation'>2.11.5 - @Swap Annotation</a><span class='update'>updated: 8.0.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.11.5 - jm.SwapAnnotation -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.annotation.Swap @Swap} can be used to associate a swap class using an 
		annotation.
		This is often cleaner than using the builder <c>swaps()</c> method since you can keep
		your swap class near your POJO class. 
	</p>
	<p class='bjava'>
	<ja>@Swap</ja>(MyObjectSwap.<jk>class</jk>)
	<jk>public class</jk> MyPojo {
		...
	}
	
	<jc>// Sample swap for converting MyPojo classes to a simple string.</jc>
	<jk>public class</jk> MyObjectSwap <jk>extends</jk> ObjectSwap&lt;MyPojo,String&gt; {
		
		<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
		<jk>public</jk> String swap(BeanSession <jv>session</jv>, MyPojo <jv>pojo</jv>) {
			<jk>return</jk> <jv>pojo</jv>.toSomeSerializableForm();
		}
	}
	</p>
	<p>
		Multiple swaps can be associated with a class using multiple {@link org.apache.juneau.annotation.Swap @Swap} annotations:
	</p>
	<p class='bjava'>
	<ja>@Swap</ja>(MyJsonSwap.<jk>class</jk>)
	<ja>@Swap</ja>(MyXmlSwap.<jk>class</jk>)
	<ja>@Swap</ja>(MyOtherSwap.<jk>class</jk>)
	<jk>public class</jk> MyPojo {}
	</p>
	<p>
		<c>Readers</c> get serialized directly to the output of a serializer.
		Therefore it's possible to implement a swap that provides fully-customized output.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyJsonSwap <jk>extends</jk> ObjectSwap&lt;MyPojo,Reader&gt; {

		<jk>public</jk> MediaType[] forMediaTypes() {
			<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/json"</js>);
		}

		<jk>public</jk> Reader swap(BeanSession <jv>session</jv>, MyPojo <jv>pojo</jv>) <jk>throws</jk> Exception {
			<jk>return new</jk> StringReader(<js>"{message:'Custom JSON!'}"</js>);
		}
	}
	</p>
	<p>
		The <ja>@Swap</ja> annotation can also be used on getters and setters as well to apply a swap
		to individual property values:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jk>private</jk> MyPojo <jf>myPojo</jf>;
	
		<jc>// Swap applied to bean property.</jc>	
		<ja>@Beanp</ja>(swap=MyPojoSwap.<jk>class</jk>)
		<jk>public</jk> MyPojo getMyPojo() {
			<jk>return</jk> <jf>myPojo</jf>;
		}
	}
	</p>
	<p>
		When applied to bean properties, the swap annotation need only be applied to either the getter, setter, or field.
	</p>
	<p>
		The swap annotation can also be applied to the private field of a bean property, like so:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {

		<ja>@Beanp</ja>(swap=MyPojoSwap.<jk>class</jk>)
		<jk>private</jk> MyPojo <jf>myPojo</jf>;
	
		<jk>public</jk> MyPojo getMyPojo() {
			<jk>return</jk> <jf>myPojo</jf>;
		}
		
		<jk>public</jk> MyBean setMyPojo(MyPojo <jv>myPojo</jv>) {
			<jk>this</jk>.<jf>myPojo</jf> = <jv>myPojo</jv>;
			<jk>return this</jk>;
		}
	}
	</p>
</div>
</div><!-- END: 2.11.5 - jm.SwapAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.TemplatedSwaps' id='jm.TemplatedSwaps'>2.11.6 - Templated Swaps</a></h4>
<div class='topic'><!-- START: 2.11.6 - jm.TemplatedSwaps -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.Swap#template() @Swap(template)} annotation allows you to associate
		arbitrary contextual strings with swaps.
		The primary purpose is for providing template names, such as for Apache FreeMarker, therefore
		the name 'template'.
		However, the usage of the string is open-ended.
	</p>
	<p>
		For example, you could pair a template string like so:
	</p>
	<p class='bjava'>
	<ja>@Swap</ja>(impl=FreeMarkerSwap.<jk>class</jk>, template=<js>"MyPojo.div.ftl"</js>)
	<jk>public class</jk> MyPojo {}
	</p>
	<p>
		The implementation of the FreeMarker swap would look something like this:
	</p>
	<p class='bjava'>
	<jc>// Our templated swap class.</jc>
	<jk>public class</jk> FreeMarkerSwap <jk>extends</jk> ObjectSwap&lt;Object,Reader&gt; {

		<jk>public</jk> MediaType[] forMediaTypes() {
			<jc>// Make sure this only applies to the HTML serializer.</jc>
			<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/html"</js>);
		}

		<jk>public</jk> Reader swap(BeanSession <jv>session</jv>, Object <jv>object</jv>, String <jv>template</jv>) <jk>throws</jk> Exception {
			<jc>// Call some method that uses FreeMarker to convert 'o' to raw HTML using </jc>
			<jc>// the 'MyPojo.div.ftl' template.</jc>
			<jk>return</jk> getFreeMarkerReader(<jv>template</jv>, <jv>object</jv>);  
		}
	}
	</p>
</div>
</div><!-- END: 2.11.6 - jm.TemplatedSwaps -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.SurrogateClasses' id='jm.SurrogateClasses'>2.11.7 - Surrogate Classes</a></h4>
<div class='topic'><!-- START: 2.11.7 - jm.SurrogateClasses -->
<div class='topic'>
	<p>
		Surrogate classes are very similar in concept to <c>ObjectSwaps</c> except they're simpler to define.
	</p>
	<p>
		For example, let's say we want to be able to serialize the following class but it's not serializable for 
		some reason (for example, there are no properties exposed):  
	</p>
	<p class='bjava'>
	<jc>// Not serializable because it's not a bean because it has no public properties.</jc>
	<jk>public class</jk> MyNonSerializableClass {
		<jk>protected</jk> String <jf>foo</jf>;
	}
	</p>
	<p>
		This could be solved with the following <c>ObjectSwap</c>.
	</p>
	<p class='bjava'>
	<jc>// A serializable bean with 1 property.</jc>
	<jk>public class</jk> MySerializableSurrogate {
		<jk>public</jk> String <jf>foo</jf>;
	}
		
	<jc>// An ObjectSwap that swaps out our non-serializable object with our serializable object.</jc>
	<jk>public class</jk> MySwap <jk>extends</jk> ObjectSwap&lt;MyNonSerializableClass,MySerializableSurrogate&gt; {
		<ja>@Override</ja> <jc>/* ObjectSwap */</jc>
		<jk>public</jk> MySerializableSurrogate swap(MyNonSerializableClass <jv>object</jv>) {
			
			<jc>// Create some serializable class and manually copy the data into it.</jc>
			MySerializableSurrogate <jv>surrogate</jv> = <jk>new</jk> MySerializableSurrogate();
			<jv>surrogate</jv>.<jf>foo</jf> = <jv>object</jv>.<jf>foo</jf>;
			<jk>return</jk> <jv>surrogate</jv>;
		}
	}
	</p>
	<p>
		However, the same can be accomplished by using a surrogate class that simply contains a constructor with 
		the non-serializable class as an argument:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MySerializableSurrogate {
		<jk>public</jk> String <jf>foo</jf>;
		
		<jc>// Constructor takes in our non-serializable object!</jc>
		<jk>public</jk> MySerializableSurrogate(MyNonSerializableClass <jv>object</jv>) {
			<jk>this</jk>.<jf>foo</jf> = <jv>object</jv>.<jf>foo</jf>;
		}
	}
	</p>
	<p>
		The surrogate class is registered in the same way as a <c>ObjectSwap</c>:
	</p>
	<p class='bjava'>
	<jc>// Create a JSON serializer that can serialize our unserializable object.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.swaps(MySerializableSurrogate.<jk>class</jk>)
		.build();
	</p>
	<p>
		When the serializer encounters the non-serializable class, it will serialize an instance of the surrogate 
		instead.
	</p>
	
	<ul class='seealso'>
		<li class='jic'>{@link org.apache.juneau.swap.Surrogate}
	</ul>
</div>
</div><!-- END: 2.11.7 - jm.SurrogateClasses -->
</div><!-- END: 2.11 - jm.Swaps -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.DynamicallyAppliedAnnotations' id='jm.DynamicallyAppliedAnnotations'>2.12 - Dynamically Applied Annotations</a><span class='update'>created: 8.1.3, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.12 - jm.DynamicallyAppliedAnnotations -->
<div class='topic'>
	<p>
		In the section <a class="doclink" href="#jm.Swaps">Swaps</a>, you were introduced to annotations that can be applied to bean
		classes, methods, fields, and constructors such as {@link org.apache.juneau.annotation.Bean @Bean}:
	</p>
	<p class='bjava'>
	<jc>// Address class with only street/city/state properties (in that order).</jc>
	<jc>// All other properties are ignored.</jc>
	<ja>@Bean</ja>(properties=<js>"street,city,state"</js>)
	<jk>public class</jk> Address { ... }
	</p>
	<p>
		An alternate way of applying these annotations is to attach them to unrelated classes and methods and then
		tell your serializer or parser where to find them.  
	</p>
	<p class='bjava'>
	<jc>// Unannotated class.</jc>
	<jk>public class</jk> Address { ... }

	<ja>@Bean</ja>(onClass=Address.<jk>class</jk>, properties=<js>"street,city,state"</js>)
	<jk>public static class</jk> DummyClass {}

	WriterSerializer <jv>serializer</jv> = JsonSerializer
		.<jsm>create</jsm>()
		.applyAnnotations(DummyClass.<jk>class</jk>)
		.build();
		
	String <jv>json</jv> = <jv>serializer</jv>.toString(<jv>addressBean</jv>);
	</p>
	<p>
		The advantage to this approach is it allows you to use Juneau annotations on classes/methods/fields/constructors
		where you might not have access to the source code, or when you only want to selectively apply the annotation 
		under certain scenarios instead of globally.
	</p>
	<p>
		For example, the following shows the <ja>@Bean</ja> annotation being selectively applied on a single REST method 
		(described later in <a class="doclink" href="#juneau-rest-server">juneau-rest-server</a>): 
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja> 
	<ja>@Bean</ja>(onClass=Address.<jk>class</jk>, properties=<js>"street,city,state"</js>)
	<jk>public</jk> List&lt;Address&gt; getAddresses() {}
	</p>
	<p>
		Any Juneau annotation that has an <c>on()/onClass()</c> method can be applied dynamically this way.
		These include:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.annotation.Bean}
		<li class='ja'>{@link org.apache.juneau.annotation.Beanc}
		<li class='ja'>{@link org.apache.juneau.annotation.BeanIgnore}
		<li class='ja'>{@link org.apache.juneau.annotation.Beanp}
		<li class='ja'>{@link org.apache.juneau.annotation.Example}
		<li class='ja'>{@link org.apache.juneau.annotation.NameProperty}
		<li class='ja'>{@link org.apache.juneau.annotation.ParentProperty}
		<li class='ja'>{@link org.apache.juneau.annotation.Swap}
		<li class='ja'>{@link org.apache.juneau.annotation.Uri}
		<li class='ja'>{@link org.apache.juneau.csv.annotation.Csv}
		<li class='ja'>{@link org.apache.juneau.html.annotation.Html}
		<li class='ja'>{@link org.apache.juneau.json.annotation.Json}
		<li class='ja'>{@link org.apache.juneau.annotation.Schema}
		<li class='ja'>{@link org.apache.juneau.msgpack.annotation.MsgPack}
		<li class='ja'>{@link org.apache.juneau.oapi.annotation.OpenApi}
		<li class='ja'>{@link org.apache.juneau.plaintext.annotation.PlainText}
		<li class='ja'>{@link org.apache.juneau.soap.annotation.SoapXml}
		<li class='ja'>{@link org.apache.juneau.uon.annotation.Uon}
		<li class='ja'>{@link org.apache.juneau.urlencoding.annotation.UrlEncoding}
		<li class='ja'>{@link org.apache.juneau.xml.annotation.Xml}
	</ul>
	<p>
		The valid pattern matches are:
	</p>
	<ul class='spaced-list'>
		<li>Classes:
			<ul>
				<li>Fully qualified: 
					<ul>
						<li><js>"com.foo.MyClass"</js>
					</ul>
				<li>Fully qualified inner class: 
					<ul>
						<li><js>"com.foo.MyClass$Inner1$Inner2"</js>
					</ul>
				<li>Simple: 
					<ul>
						<li><js>"MyClass"</js>
					</ul>
				<li>Simple inner: 
					<ul>
						<li><js>"MyClass$Inner1$Inner2"</js>
						<li><js>"Inner1$Inner2"</js>
						<li><js>"Inner2"</js>
					</ul>
			</ul>
		<li>Methods:
			<ul>
				<li>Fully qualified with args: 
					<ul>
						<li><js>"com.foo.MyClass.myMethod(String,int)"</js> 
						<li><js>"com.foo.MyClass.myMethod(java.lang.String,int)"</js> 
						<li><js>"com.foo.MyClass.myMethod()"</js>
					</ul>
				<li>Fully qualified: 
					<ul>
						<li><js>"com.foo.MyClass.myMethod"</js>
					</ul>
				<li>Simple with args: 
					<ul>
						<li><js>"MyClass.myMethod(String,int)"</js>
						<li><js>"MyClass.myMethod(java.lang.String,int)"</js>
						<li><js>"MyClass.myMethod()"</js>
					</ul>
				<li>Simple: 
					<ul>
						<li><js>"MyClass.myMethod"</js>
					</ul>
				<li>Simple inner class: 
					<ul>
						<li><js>"MyClass$Inner1$Inner2.myMethod"</js>
						<li><js>"Inner1$Inner2.myMethod"</js>
						<li><js>"Inner2.myMethod"</js>
					</ul>
			</ul>
		<li>Fields:
			<ul>
				<li>Fully qualified: 
					<ul>
						<li><js>"com.foo.MyClass.myField"</js>
					</ul>
				<li>Simple: 
					<ul>
						<li><js>"MyClass.myField"</js>
					</ul>
				<li>Simple inner class: 
					<ul>
						<li><js>"MyClass$Inner1$Inner2.myField"</js>
						<li><js>"Inner1$Inner2.myField"</js>
						<li><js>"Inner2.myField"</js>
					</ul>
			</ul>
		<li>Constructors:
			<ul>
				<li>Fully qualified with args: 
					<ul>
						<li><js>"com.foo.MyClass(String,int)"</js>
						<li><js>"com.foo.MyClass(java.lang.String,int)"</js>
						<li><js>"com.foo.MyClass()"</js>
					</ul>
				<li>Simple with args: 
					<ul>
						<li><js>"MyClass(String,int)"</js>
						<li><js>"MyClass(java.lang.String,int)"</js>
						<li><js>"MyClass()"</js>
					</ul>
				<li>Simple inner class: 
					<ul>
						<li><js>"MyClass$Inner1$Inner2()"</js>
						<li><js>"Inner1$Inner2()"</js>
						<li><js>"Inner2()"</js>
					</ul>
			</ul>
		<li>A comma-delimited list of anything on this list.
	</ul>
</div>
</div><!-- END: 2.12 - jm.DynamicallyAppliedAnnotations -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.BeanDictionaries' id='jm.BeanDictionaries'>2.13 - Bean Names and Dictionaries</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.13 - jm.BeanDictionaries -->
<div class='topic'>
	<p>
		While parsing into beans, Juneau attempts to determine the class types of bean properties through 
		reflection on the bean property getter or setter.
		Often this is insufficient if the property type is an interface or abstract class that cannot be 
		instantiated.
		This is where bean names and dictionaries come into play.
	</p>
	<p>
		Bean names and dictionaries are used for identifying class types when they cannot be inferred through 
		reflection.  
	</p>
	<p>
		Bean classes are given names through the {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)} 
		annotation.
		These names are then added to the serialized output as virtual <js>"_type"</js> properties (or element 
		names in XML).
	</p>
	<p>
		On the parsing side, these type names are resolved to classes through the use of bean dictionaries.
	</p>
	<p>
		For example, if a bean property is of type <c>Object</c>, then the serializer will add 
		<js>"_type"</js> attributes so that the class can be determined during parsing.
	</p>
	<p class='bjava'>
	<ja>@Bean</ja>(typeName=<js>"foo"</js>)
	<jk>public class</jk> Foo {
		<jc>// A bean property where the object types cannot be inferred since it's an Object[].</jc>
		<ja>@Beanp</ja>(dictionary={Bar.<jk>class</jk>,Baz.<jk>class</jk>})
		<jk>public</jk> Object[] <jf>x</jf> = <jk>new</jk> Object[]{<jk>new</jk> Bar(), <jk>new</jk> Baz()};
	}
		
	<ja>@Bean</ja>(typeName=<js>"bar"</js>)
	<jk>public class</jk> Bar {}
		
	<ja>@Bean</ja>(typeName=<js>"baz"</js>)
	<jk>public class</jk> Baz {}
	</p>
	<p>
		When serialized as JSON, <js>"_type"</js> attributes would be added when needed to infer the type during 
		parsing:
	</p>
	<p class='bjson'>
	{
		x: [
			{_type:<js>'bar'</js>},
			{_type:<js>'baz'</js>}
		]
	}
	</p>
	<p>
		Type names can be represented slightly differently in different languages.
		For example, the dictionary name is used as element names when serialized to XML.
		This allows the <c>typeName</c> annotation to be used as a shortcut for defining element names for 
		beans.
	</p>
	<p>
		When serialized as XML, the bean is rendered as:
	</p>
	<p class='bxml'>
	<xt>&lt;foo&gt;</xt>
		<xt>&lt;x&gt;</xt>
			<xt>&lt;bar/&gt;</xt>
			<xt>&lt;baz/&gt;</xt>
		<xt>&lt;/x&gt;</xt>
	<xt>&lt;/foo&gt;</xt>
	</p>
	<p>
		Bean dictionaries are registered through the following:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.annotation.Beanp} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.annotation.Beanp#dictionary() dictionary} 
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.annotation.Bean} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.annotation.Bean#dictionary() dictionary} 
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanDictionary(Class...) beanDictionary(Class...)}
			</ul>
		</li>
	</ul>
	<p>
		The bean dictionary setting can consist of any of the following types:
	</p>
	<ul>
		<li>Any bean class that specifies a value for {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)}.
		<li>Any subclass of {@link org.apache.juneau.BeanDictionaryList} containing a collection of bean classes with type name annotations.
		<li>Any subclass of {@link org.apache.juneau.BeanDictionaryMap} containing a mapping of type names to classes without type name annotations.
		<li>Any array or collection of the objects above.
	</ul>
	<p class='bjava'>
	<jc>// Create a parser and tell it which classes to try to resolve.</jc>
	ReaderParser <jv>parser</jv> = JsonParser
		.<jsm>create</jsm>()
		.dictionary(Foo.<jk>class</jk>, Bar.<jk>class</jk>)
		.build();
	
	<jc>// Use the predefined HTML5 bean dictionary which is a BeanDictionaryList.</jc>
	ReaderParser <jv>parser</jv> = HtmlParser
		.<jsm>create</jsm>()
		.dictionary(HtmlBeanDictionary.<jk>class</jk>)
		.build();
	</p>
	<p>
		The <js>"_type"</js> property name can be overridden through the following:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.annotation.Bean} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.annotation.Bean#typePropertyName() typePropertyName} 
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.BeanContext.Builder} 
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#typePropertyName(String) typePropertyName(String)} 
			</ul>
		</li>
	</ul>
	<p>
		When using the annotation, you'll typically want to define it on an interface class so that it can
		be inherited by all subclasses.
	</p>
	<p class='bjava'>
	<ja>@Bean</ja>(typePropertyName=<js>"mytype"</js>, dictionary={MyClass1.<jk>class</jk>,MyClass2.<jk>class</jk>})
	<jk>public interface</jk> MyInterface {...}

	<ja>@Bean</ja>(typeName=<js>"C1"</js>)
	<jk>public class</jk> MyClass1 <jk>implements</jk> MyInterface {...}

	<ja>@Bean</ja>(typeName=<js>"C2"</js>)
	<jk>public class</jk> MyClass2 <jk>implements</jk> MyInterface {...}

	MyInterface[] <jv>x</jv> = <jk>new</jk> MyInterface[]{ <jk>new</jk> MyClass1(), <jk>new</jk> MyClass2() };

	<jc>// Produces "[{mytype:'C1',...},{mytype:'C2',...}]"</jc>
	String <jv>json</jv> = JsonSerializer.<jsf>DEFAULT</jsf>.serialize(<jv>x</jv>);
	</p>
	<div class='info'>
		Type names do not need to be universally unique.  
		However, they must be unique within a dictionary.
	</div>
	<div class='info'>
		The following reserved words cannot be used as type names:  
		<c>object, array, number, boolean, null</c>.
	</div>
	<div class='info'>
		Serialized type names are DISABLED by default.
		They must be enabled on the serializer using the 
		{@link org.apache.juneau.serializer.Serializer.Builder#addBeanTypes()} 
		setting.
	</div>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BeanSubTypes' id='jm.BeanSubTypes'>2.13.1 - Bean Subtypes</a></h4>
<div class='topic'><!-- START: 2.13.1 - jm.BeanSubTypes -->
<div class='topic'>
	<p>
		In addition to the bean type name support described above, simplified support is provided
		for bean subtypes.
	</p>
	<p>
		Bean subtypes are similar in concept to bean type names, except for the following differences:
	</p>
	<ul>
		<li>You specify the list of possible subclasses through an annotation on a parent bean class.
		<li>You do not need to register the subtype classes on the bean dictionary of the parser.
	</ul>
	<p>
		In the following example, the abstract class has two subclasses:
	</p>
	<p class='bjava'>
	<jc>// Abstract superclass</jc>
	<ja>@Bean</ja>(
		dictionary={A1.<jk>class</jk>, A2.<jk>class</jk>}
	)
	<jk>public abstract class</jk> A {
		<jk>public</jk> String <jf>f0</jf> = <js>"f0"</js>;
	}
	
	<jc>// Subclass 1</jc>
	<ja>@Bean</ja>(typeName=<js>"A1"</js>)
	<jk>public class</jk> A1 <jk>extends</jk> A {
		<jk>public</jk> String <jf>f1</jf>;
	}

	<jc>// Subclass 2</jc>
	<ja>@Bean</ja>(typeName=<js>"A2"</js>)
	<jk>public class</jk> A2 <jk>extends</jk> A {
		<jk>public</jk> String <jf>f2</jf>;
	}
	</p>
	<p>
		When serialized, the subtype is serialized as a virtual <js>"_type"</js> property:
	</p>	
	<p class='bjava'>
	A1 <jv>object</jv> = <jk>new</jk> A1();
	<jv>object</jv>.<jf>f1</jf> = <js>"f1"</js>;
	String <jv>json</jv> = Json5.<jsm>of</jsm>(<jv>object</jv>);
	<jsm>assertEquals</jsm>(<js>"{_type:'A1',f1:'f1',f0:'f0'}"</js>, <jv>json</jv>);
	</p>
	<p>
		The following shows what happens when parsing back into the original object.
	</p>
	<p class='bjava'>
	A <jv>object</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, A.<jk>class</jk>);
	<jsm>assertTrue</jsm>(<jv>object</jv> <jk>instanceof</jk> A1);
	</p>
</div>
</div><!-- END: 2.13.1 - jm.BeanSubTypes -->
</div><!-- END: 2.13 - jm.BeanDictionaries -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.VirtualBeans' id='jm.VirtualBeans'>2.14 - Virtual Beans</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.14 - jm.VirtualBeans -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.BeanContext.Builder#disableInterfaceProxies()} setting (enabled by default) allows
		the Juneau parsers to parse content into virtual beans (bean interfaces without implementation classes).
	</p>
	<p>
		For example, the following code creates an instance of the specified unimplemented interface:
	</p>
	<p class='bjava'>
	<jc>// Our unimplemented interface</jc> 
	<jk>public interface</jk> Address {
		
		String getStreet();
		<jk>void</jk> setStreet(String <jv>value</jv>); 
		
		String getCity();
		<jk>void</jk> setCity(String <jv>value</jv>); 

		StateEnum getState();
		<jk>void</jk> setState(StateEnum <jv>value</jv>); 
		
		<jk>int</jk> getZip();
		<jk>void</jk> setZip(<jk>int</jk> <jv>value</jv>);
	}
	
	<jc>// Our code</jc>
	Address <jv>address</jv> = Json.<jsm>to</jsm>(
		<js>"{street:'123 Main St', city:'Anywhere', state:'PR', zip:12345}"</js>, 
		Address.<jk>class</jk>
	); 
	
	<jk>int</jk> <jv>zip</jv> = <jv>address</jv>.getZip();
	<jv>address</jv>.setState(StateEnum.<jsf>NY</jsf>);
	</p>
	<p>
		Getter and setter values can be any <a class="doclink" href="#jm.PojoCategories">parsable</a> values, even other virtual beans.
	</p>
	<p>
		Under-the-covers, a virtual bean is simply a proxy interface on top of an existing {@link org.apache.juneau.BeanMap}
		instance.  From a programmatic point-of-view, they're indistinguishable from real beans, and can be 
		manipulated and serialized like any other bean.
	</p>	
	<p>
		Virtual beans can also be created programmatically using the {@link org.apache.juneau.BeanContext} class:
	</p>
	<p class='bjava'>
	Address <jv>address</jv> = BeanContext.<jsf>DEFAULT</jsf>.createSession().newBean(Address.<jk>class</jk>);
	</p>
</div>
</div><!-- END: 2.14 - jm.VirtualBeans -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.Recursion' id='jm.Recursion'>2.15 - Non-Tree Models and Recursion Detection</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.15 - jm.Recursion -->
<div class='topic'>
	<p>
		The Juneau Serializer API is designed to be used against POJO tree structures. 
		It expects that there not be loops in the POJO model (e.g. children with references to parents, etc...).
		If you try to serialize models with loops, you will usually cause a <c>StackOverflowError</c> to 
		be thrown (if {@link org.apache.juneau.BeanTraverseContext.Builder#maxDepth(int)} is not reached 
		first).
	</p>
	<p>
		If you still want to use the Juneau serializers on such models, Juneau provides the 
		{@link org.apache.juneau.BeanTraverseContext.Builder#detectRecursions()} setting.
		It tells the serializer to look for instances of an object in the current branch of the tree and skip 
		serialization when a duplicate is encountered.
	</p>
	<p>
		For example, let's make a POJO model out of the following classes:
	</p>
	<p class='bjava'>
	<jk>public class</jk> A {
		<jk>public</jk> B <jf>b</jf>;
	}
	
	<jk>public class</jk> B {
		<jk>public</jk> C <jf>c</jf>;
	}
	
	<jk>public class</jk> C {
		<jk>public</jk> A <jf>a</jf>;
	}
	</p>
	<p>
		Now we create a model with a loop and serialize the results.
	</p>
	<p class='bjava'>
	<jc>// Clone an existing serializer and set property for detecting recursions.</jc>
	WriterSerializer <jv>serializer</jv> = Json5Serializer
		.<jsf>DEFAULT_READABLE</jsf>
		.copy()
		.detectRecursions()
		.build();

	<jc>// Create a recursive loop.</jc>
	A <jv>a</jv> = <jk>new</jk> A();
	<jv>a</jv>.<jf>b</jf> = <jk>new</jk> B();
	<jv>a</jv>.<jf>b</jf>.<jf>c</jf> = <jk>new</jk> C();
	<jv>a</jv>.<jf>b</jf>.<jf>c</jf>.<jf>a</jf> = <jv>a</jv>;
	
	<jc>// Serialize to JSON.</jc>
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jv>a</jv>);
	</p>
	<p>
		What we end up with is the following, which does not serialize the contents of the <c>c</c> field:
	</p>
	<p class='bjson'>
	{
		<jok>b</jok>: {
			<jok>c</jok>: {
			}
		}
	}
	</p>
	<p>
		Without recursion detection enabled, this would cause a stack-overflow error.
	</p>
	<p>
		Recursion detection introduces a performance penalty of around 20%.
		For this reason the setting is disabled by default.
	</p>
</div>
</div><!-- END: 2.15 - jm.Recursion -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ParsingIntoGenericModels' id='jm.ParsingIntoGenericModels'>2.16 - Parsing into Generic Models</a><span class='update'>updated: 8.2.0</span></h3>
<div class='topic'><!-- START: 2.16 - jm.ParsingIntoGenericModels -->
<div class='topic'>
	<p>
		The Juneau parsers are not limited to parsing back into the original bean classes.
		If the bean classes are not available on the parsing side, the parser can also be used to 
		parse into a generic model consisting of <c>Maps</c>, <c>Collections</c>, and primitive
		objects.
	</p>
	<p>
		You can parse into any <c>Map</c> type (e.g. <c>HashMap</c>, <c>TreeMap</c>) but
		using {@link org.apache.juneau.collections.JsonMap} is recommended since it has many convenience methods
		for converting values to various types.
		The same is true when parsing collections.  You can use any Collection (e.g. <c>HashSet</c>, 
		<c>LinkedList</c>) or array (e.g. <c>Object[]</c>, <c>String[]</c>, 
		<c>String[][]</c>) but using {@link org.apache.juneau.collections.JsonList} is recommended.
	</p>
	<p>
		When the map or list type is not specified, or is the abstract <c>Map</c>, <c>Collection</c>, 
		or <c>List</c> types, the parser will use <c>JsonMap</c> and <c>JsonList</c> by 
		default.
	</p>
	<p>
		For example, given the following JSON:
	</p>
	<p class='bjson'>
	{
		id: <jk>1</jk>, 
		name: <js>'John Smith'</js>, 
		uri: <js>'http://sample/addressBook/person/1'</js>, 
		addressBookUri: <js>'http://sample/addressBook'</js>, 
		birthDate: <js>'1946-08-12T00:00:00Z'</js>, 
		addresses: [
			{
				uri: <js>'http://sample/addressBook/address/1'</js>, 
				personUri: <js>'http://sample/addressBook/person/1'</js>, 
				id: <jk>1</jk>, 
				street: <js>'100 Main Street'</js>, 
				city: <js>'Anywhereville'</js>, 
				state: <js>'NY'</js>, 
				zip: <jk>12345</jk>, 
				isCurrent: <jk>true</jk>
			}
		]
	}
	</p>
	<p>
		We can parse this into a generic <c>JsonMap</c>:
	</p>
	<p class='bjava'>	
	<jc>// Parse JSON into a generic POJO model.</jc>
	JsonMap <jv>map</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, JsonMap.<jk>class</jk>);

	<jc>// Convert it back to JSON.</jc>
	String <jv>json</jv> = Json5.<jsm>of</jsm>(<jv>map</jv>);
	</p>
	<p>
		What we end up with is the exact same output.
		Even the numbers and booleans are preserved because they are parsed into <c>Number</c> and 
		<c>Boolean</c> objects when parsing into generic models.
	</p>
	<p class='bjson'>
	{
		id: <jk>1</jk>, 
		name: <js>'John Smith'</js>, 
		uri: <js>'http://sample/addressBook/person/1'</js>, 
		addressBookUri: <js>'http://sample/addressBook'</js>, 
		birthDate: <js>'1946-08-12T00:00:00Z'</js>, 
		addresses: [
			{
				uri: <js>'http://sample/addressBook/address/1'</js>, 
				personUri: <js>'http://sample/addressBook/person/1'</js>, 
				id: <jk>1</jk>, 
				street: <js>'100 Main Street'</js>, 
				city: <js>'Anywhereville'</js>, 
				state: <js>'NY'</js>, 
				zip: <jk>12345</jk>, 
				isCurrent: <jk>true</jk>
			}
		]
	}
	</p>
	<p>
		Once parsed into a generic model, various convenience methods are provided on the <c>JsonMap</c>
			and <c>JsonList</c> classes to retrieve values:
	</p>
	<p class='bjava'>
	<jc>// Parse JSON into a generic POJO model.</jc>
	JsonMap <jv>map</jv> = Json.<jsm>to</jsm>(<jv>json</jv>, JsonMap.<jk>class</jk>);

	<jc>// Get some simple values.</jc>
	String <jv>name</jv> = <jv>map</jv>.getString(<js>"name"</js>);
	<jk>int</jk> <jv>id</jv> = <jv>map</jv>.getInt(<js>"id"</js>);

	<jc>// Get a value convertable from a String.</jc>
	URI <jv>uri</jv> = <jv>map</jv>.get(URI.<jk>class</jk>, <js>"uri"</js>);

	<jc>// Get a value using a swap.</jc>
	TemporalCalendarSwap <jv>swap</jv> = <jk>new</jk> TemporalCalendarSwap.IsoInstant();
	Calendar <jv>birthDate</jv> = <jv>map</jv>.get(<jv>swap</jv>, <js>"birthDate"</js>);

	<jc>// Get the addresses.</jc>
	JsonList <jv>addresses</jv> = <jv>map</jv>.getList(<js>"addresses"</js>);

	<jc>// Get the first address and convert it to a bean.</jc>
	Address <jv>address</jv> = <jv>addresses</jv>.get(Address.<jk>class</jk>, 0);
	</p>
	
	<p>
		As a general rule, parsing into beans is often more efficient than parsing into generic models.
		And working with beans is often less error prone than working with generic models.
	</p>		
</div>
</div><!-- END: 2.16 - jm.ParsingIntoGenericModels -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ReadingContinuousStreams' id='jm.ReadingContinuousStreams'>2.17 - Reading Continuous Streams</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.17 - jm.ReadingContinuousStreams -->
<div class='topic'>
	<p>
		The following parsers can be configured to read continuous streams of objects from the same input stream:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.json.JsonParser}
		<li class='jc'>{@link org.apache.juneau.uon.UonParser}
		<li class='jc'>{@link org.apache.juneau.msgpack.MsgPackParser}
	</ul>
	<p>
		The {@link org.apache.juneau.json.JsonParser} and {@link org.apache.juneau.uon.UonParser}
		classes can read continuous streams by using the {@link org.apache.juneau.parser.Parser.Builder#unbuffered()}
		setting.
		This prevents the parsers from using an internal buffer that would read past the end of the currently
		parsed POJO.
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// If you're calling parse on the same input multiple times, use a session instead of the parser directly.</jc>
	ReaderParserSession <jv>session</jv> = JsonParser.<jsm>create</jsm>().unbuffered().build().createSession();
	Object <jv>pojo</jv>;
	Reader <jv>reader</jv>;

	<jv>reader</jv> = <jk>new</jk> StringReader(<js>"{foo:'bar'}{baz:'qux'}"</js>);
	<jv>pojo</jv> = <jv>session</jv>.parse(<jv>reader</jv>, JsonMap.<jk>class</jk>);  <jc>// {foo:'bar'}</jc>
	<jv>pojo</jv> = <jv>session</jv>.parse(<jv>reader</jv>, JsonMap.<jk>class</jk>);  <jc>// {baz:'qux'}</jc>

	<jv>reader</jv> = <jk>new</jk> StringReader(<js>"[123][456]"</js>);
	<jv>pojo</jv> = <jv>session</jv>.parse(<jv>reader</jv>, <jk>int</jk>[].<jk>class</jk>);  <jc>// [123]</jc>
	<jv>pojo</jv> = <jv>session</jv>.parse(<jv>reader</jv>, <jk>int</jk>[].<jk>class</jk>);  <jc>// [456]</jc>
	</p>
	<p>
		Note that this isn't perfect in all cases since you can't combine two JSON numbers into a single
		reader (e.g. <c>"123" + "456" = "123456"</c>).
	</p>
	<p>
		For obvious reasons, do not use the following properties when reading continuous streams:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.json.JsonParser.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.json.JsonParser.Builder#validateEnd() validateEnd()}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.uon.UonParser.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.uon.UonParser.Builder#validateEnd() validateEnd()}
			</ul>
		</li>
		<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.parser.Parser.Builder#autoCloseStreams() validateEnd()}
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.msgpack.MsgPackParser} class doesn't use any internal buffering to begin with, so it can be used with
		continuous streams without any special properties.
	</p>
</div>
</div><!-- END: 2.17 - jm.ReadingContinuousStreams -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.MarshallingUris' id='jm.MarshallingUris'>2.18 - URIs</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.18 - jm.MarshallingUris -->
<div class='topic'>
	<p>
		Juneau serializers have sophisticated support for transforming relative URIs to absolute form.
	</p>
	<p>
		The following example shows a bean containing URIs of various forms and how they end up serialized. 
	</p>
	<p class='bjava'>
	<jc>// Our bean with properties containing various kinds of URIs.</jc>
	<jk>public class</jk> TestURIs {
		<jk>public</jk> URI
			<jf>a</jf> = URI.<jsm>create</jsm>(<js>"http://www.apache.org/a"</js>),
			<jf>b</jf> = URI.<jsm>create</jsm>(<js>"/b"</js>),
			<jf>c</jf> = URI.<jsm>create</jsm>(<js>"/c/x/y"</js>),
			<jf>d</jf> = URI.<jsm>create</jsm>(<js>"d"</js>),
			<jf>e</jf> = URI.<jsm>create</jsm>(<js>"e/x/y"</js>),
			<jf>f</jf> = URI.<jsm>create</jsm>(<js>""</js>),
			<jf>g</jf> = URI.<jsm>create</jsm>(<js>"context:/g/x"</js>),
			<jf>h</jf> = URI.<jsm>create</jsm>(<js>"context:/h"</js>),
			<jf>i</jf> = URI.<jsm>create</jsm>(<js>"context:/"</js>),
			<jf>j</jf> = URI.<jsm>create</jsm>(<js>"context:/.."</js>),
			<jf>k</jf> = URI.<jsm>create</jsm>(<js>"servlet:/k/x"</js>),
			<jf>l</jf> = URI.<jsm>create</jsm>(<js>"servlet:/l"</js>),
			<jf>m</jf> = URI.<jsm>create</jsm>(<js>"servlet:/"</js>),
			<jf>n</jf> = URI.<jsm>create</jsm>(<js>"servlet:/.."</js>),
			<jf>o</jf> = URI.<jsm>create</jsm>(<js>"request:/o/x"</js>),
			<jf>p</jf> = URI.<jsm>create</jsm>(<js>"request:/p"</js>),
			<jf>q</jf> = URI.<jsm>create</jsm>(<js>"request:/"</js>),
			<jf>r</jf> = URI.<jsm>create</jsm>(<js>"request:/.."</js>);
	}	
	
	<jc>// Create a serializer.</jc>
	WriterSerializer <jv>serializer</jv> = JsonSerializer
		<jsm>create</jsm>()
		.simple()
		.uriContext(
			UriContext.of(
				<js>"http://foo.com:123"</js>,  <jc>// Authority</jc>
				<js>"/myContext"</js>,  <jc>// Context root</jc>
				<js>"/myServlet"</js>,  <jc>// Servlet path</jc>
				<js>"/myPath"</js>  <jc>// Path info</jc>
			)
		)
		.uriResolution(<jsf>ABSOLUTE</jsf>)
		.uriRelativity(<jsf>RESOURCE</jsf>)
		.build();
		
	<jc>// Produces:</jc>
	<jc>// {</jc>
	<jc>//	a:'http://www.apache.org/a',</jc>
	<jc>//	b:'http://foo.com:123/b',</jc>
	<jc>//	c:'http://foo.com:123/c/x/y',</jc>
	<jc>//	d:'http://foo.com:123/myContext/myServlet/d',</jc>
	<jc>//	e:'http://foo.com:123/myContext/myServlet/e/x/y',</jc>
	<jc>//	f:'http://foo.com:123/myContext/myServlet',</jc>
	<jc>//	g:'http://foo.com:123/myContext/g/x',</jc>
	<jc>//	h:'http://foo.com:123/myContext/h',</jc>
	<jc>//	i:'http://foo.com:123/myContext',</jc>
	<jc>//	j:'http://foo.com:123'</jc>
	<jc>//	k:'http://foo.com:123/myContext/myServlet/k/x',</jc>
	<jc>//	l:'http://foo.com:123/myContext/myServlet/l',</jc>
	<jc>//	m:'http://foo.com:123/myContext/myServlet',</jc>
	<jc>//	n:'http://foo.com:123/myContext',</jc>
	<jc>//	o:'http://foo.com:123/myContext/myServlet/myPath/o/x',</jc>
	<jc>//	p:'http://foo.com:123/myContext/myServlet/myPath/p',</jc>
	<jc>//	q:'http://foo.com:123/myContext/myServlet/myPath',</jc>
	<jc>//	r:'http://foo.com:123/myContext/myServlet'</jc>
	<jc>// }</jc>
	String <jv>json</jv> = <jv>serializer</jv>.serialize(<jk>new</jk> TestURIs());
	</p>
	<p>
		URI resolution is controlled by the following settings:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.serializer.Serializer.Builder#uriContext(UriContext)}
			<br>Setting that defines the URI contextual information used to resolve relative URIs.
		</li>
		<li class='jm'>{@link org.apache.juneau.serializer.Serializer.Builder#uriRelativity(UriRelativity)}
			<br>Setting that defines how relative URIs should be interpreted.
			<br>Possible values:
			<ul>
				<li class='jf'>{@link org.apache.juneau.UriRelativity#RESOURCE}
					<br>Relative URIs should be considered relative to the servlet URI.
					<br>(e.g. <js>"http://host:port/context-root/servlet-path"</js>).
				<li class='jf'>{@link org.apache.juneau.UriRelativity#PATH_INFO}
					<br>Relative URIs should be considered relative to the request URI.
					<br>(e.g. <js>"http://host:port/context-root/servlet-path/path-info"</js>).
			</ul>
		</li>
		<li class='jm'>{@link org.apache.juneau.serializer.Serializer.Builder#uriResolution(UriResolution)}
			<br>Setting that defines the final format of serialized URIs.
			<br>Possible values:
			<ul>
				<li class='jf'>{@link org.apache.juneau.UriResolution#ABSOLUTE}
					<br>Resolve to an absolute URL.
					<br>(e.g. <js>"http://host:port/context-root/servlet-path/path-info"</js>).
				<li class='jf'>{@link org.apache.juneau.UriResolution#ROOT_RELATIVE}
					<br>Resolve to a root-relative URL.
					<br>(e.g. <js>"/context-root/servlet-path/path-info"</js>).
				<li class='jf'>{@link org.apache.juneau.UriResolution#NONE}
					<br>Don't do any URL resolution.
			</ul>
		</li>
	</ul>
	<p>
		Juneau automatically interprets any {@link java.net.URL} and {@link java.net.URI} objects as URIs and will
		resolve them accordingly.
		The {@link org.apache.juneau.annotation.Uri @Uri} annotation can be used to extend that to other bean 
		properties and class types so that they also get interpreted as URIs.
		For example:
	</p>
	<p class='bjava'>
	<jc>// Applied to a class whose toString() method returns a URI.</jc>
	<ja>@URI</ja>
	<jk>public class</jk> MyURI {
		<ja>@Override</ja> <jc>/* Object */</jc>
		<jk>public</jk> String toString() {
			<jk>return</jk> <js>"http://localhost:9080/foo/bar"</js>;
		}
	}

	<jc>// Applied to bean properties</jc>
	<jk>public class</jk> MyBean {

		<ja>@URI</ja>
		<jk>public</jk> String <jf>beanUri</jf>;

		<ja>@URI</ja>
		<jk>public</jk> String getParentUri() {
			...
		}
	}
	</p>
</div>
</div><!-- END: 2.18 - jm.MarshallingUris -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.JacksonComparison' id='jm.JacksonComparison'>2.19 - Comparison with Jackson</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.19 - jm.JacksonComparison -->
<div class='topic'>
	<p>
		Juneau was developed independently from Jackson but shares many of the same features and capabilities.
		Whereas Jackson was created to work primarily with JSON, Juneau was created to work for multiple languages.
		Therefore, the terminology and annotations in Juneau are similar but language-agnostic.   
	</p>
	<p>
		The following charts describe equivalent features between the two libraries:
	</p>
	
	<h5 class='topic'>Annotations</h5>
	<table class='styled w800'>
		<tr><th>Jackson</th><th>Juneau</th></tr>
		<tr>
			<td>
				<ja>@JsonGetter</ja>
				<br><ja>@JsonSetter</ja>
			</td>
			<td>
				{@link org.apache.juneau.annotation.Beanp @Beanp}
			</td>
		</tr>
		<tr>
			<td>
				<ja>@JsonAnyGetter</ja>
				<br><ja>@JsonAnySetter</ja>
			</td>
			<td>
				{@link org.apache.juneau.annotation.Beanp#name() @Beanp(name="*")}
			</td>
		</tr>
		<tr>
			<td>
				<ja>@JsonIgnore</ja>
				<br><ja>@JsonIgnoreType</ja>
			</td>
			<td>
				{@link org.apache.juneau.annotation.BeanIgnore @BeanIgnore}
			</td>
		</tr>
		<tr>
			<td><c><ja>@JsonIgnoreProperties</ja>({...})</c></td>
			<td>
				{@link org.apache.juneau.annotation.Bean#excludeProperties @Bean(excludeProperties|xp)}
			</td>
		</tr>
		<tr>
			<td><c><ja>@JsonAutoDetect</ja>(fieldVisibility=...)</c></td>
			<td>
				No equivalent annotation but can be controlled via: 
				<br>{@link org.apache.juneau.BeanContext.Builder#beanFieldVisibility(Visibility)}
				<br>{@link org.apache.juneau.BeanContext.Builder#beanMethodVisibility(Visibility)}
			</td>
		</tr>
		<tr>
			<td>
				<ja>@JsonCreator</ja>
				<br><ja>@JsonProperty</ja>
			</td>
			<td>
				{@link org.apache.juneau.annotation.Beanc @Beanc}
			</td>
		</tr>
		<tr>
			<td><ja>@JacksonInject</ja></td>
			<td>
				No equivalent.
			</td>
				
		</tr>
		<tr>
			<td>
				<ja>@JsonSerialize</ja>
				<br><ja>@JsonDeserialize</ja>
			</td>
			<td>
				Juneau uses swaps to convert non-serializable object to serializable forms:
				<br>{@link org.apache.juneau.annotation.Swap @Swap}
			</td>
		</tr>
		<tr>
			<td><ja>@JsonInclude</ja></td>
			<td>
				No equivalent annotation but can be controlled via various settings:
				<br>{@link org.apache.juneau.BeanContext}
				<br>{@link org.apache.juneau.serializer.Serializer}
			</td>
		</tr>
		<tr>
			<td><ja>@JsonPropertyOrder</ja></td>
			<td>
				{@link org.apache.juneau.annotation.Bean#properties @Bean(properties="...")}
				<br>{@link org.apache.juneau.annotation.Bean#sort @Bean(sort=x)}
			</td>
		</tr>
		<tr>
			<td>
				<ja>@JsonValue</ja>
				<br><ja>@JsonRawValue</ja>
			</td>
			<td>
				Can be replicated using swaps with <c>Reader</c> swapped values.
			</td>
		</tr>
	</table>
</div>
</div><!-- END: 2.19 - jm.JacksonComparison -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.PojoCategories' id='jm.PojoCategories'>2.20 - POJO Categories</a></h3>
<div class='topic'><!-- START: 2.20 - jm.PojoCategories -->
<div class='topic'>
	<p>
		In general, Juneau allows for marshalling for a wide variety of POJO types including:
	</p>
	<p>
		The following chart shows POJOs categorized into groups and whether they can be serialized or parsed:
	</p>
	<h5 class='figure'>General POJO serialization/parsing support</h5>
	<table class='styled w800' style='border-collapse:collapse'>
		<tr><th>Group</th><th>Description</th><th>Examples</th><th>Can<br>serialize?</th><th>Can<br>parse?</th></tr>
		<tr class='dark bb' style='background-color:lightyellow;'>
			<td style='text-align:center'>1</td>
			<td><b>Java primitives and primitive objects</b></td>
			<td>
				<ul class='normal'>
					<li>{@code String}
					<li>{@code Integer}
					<li>{@code Float}
					<li>{@code Boolean}
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>			
		<tr class='dark bb' style='background-color:lightyellow'>
			<td style='text-align:center'>2</td>
			<td><b>Java Collections Framework objects, Java arrays, Java Optionals</b></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>2a</td>
			<td>
				<b>With standard keys/values</b>
				<br>Map keys are group [1, 4a, 6a] objects.
				<br>Map, Collection, Optional, and array values are group [1, 2, 3ac, 4a, 6a] objects.	
			</td>
			<td>
				<ul class='normal'>
					<li><c>HashSet&lt;String,Integer&gt;</c>
					<li><c>TreeMap&lt;Integer,Bean&gt;</c>
					<li><c>List&lt;<jk>int</jk>[][]&gt;</c>
					<li><c>Bean[]</c>
					<li><c>Optional&lt;Bean&gt;</c>
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>2b</td>
			<td>
				<b>With non-standard keys/values</b>
				<br>Map keys are group [2, 3, 4b, 5, 6b, 7] objects.
				<br>Map, Collection, and array values are group [3b, 4b, 5, 6b, 7] objects.	
			</td>
			<td>
				<ul class='normal'>
					<li><c>HashSet&lt;Bean,Integer&gt;</c>
					<li><c>TreeMap&lt;Integer,Reader&gt;</c>
					<li><c>Optional&lt;Reader&gt;</c>
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>			
		<tr class='dark bb' style='background-color:lightyellow'>
			<td style='text-align:center'>3</td>
			<td><b>Java Beans</b></td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>3a</td>
			<td>
				<b>With standard properties</b>
				<br>These are beans that have one or more properties defined by public getter 
				or public fields.
				<br>Properties can also be defined as final read-only fields and passed in as constructor args.
				<br>Property values are group [1, 2, 3ac, 4a, 6a] objects.
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>3b</td>
			<td>
				<b>With non-standard properties or not true beans</b>
				<br>These include true beans that have one or more properties defined by getter 
				and setter methods or properties but property types include group [3b, 4b, 5, 6b, 7] objects.
				<br>This also includes classes that look like beans but aren't true beans.  
				For example, classes that have getters but not setters, or classes without no-arg constructors.	
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>		
		<tr class='light bb'>
			<td style='text-align:center'>3c</td>
			<td>
				<b>Virtual beans</b>
				<br>These are unimplemented bean interfaces with properties of type [1, 2, 3ac, 4a, 6a] objects.
				<br>Parsers will automatically  create interface proxies on top of BeanMap instances.	
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>		
		<tr class='light bb'>
			<td style='text-align:center'>3d</td>
			<td>
				<b>Read-only beans without setters</b>
				<br>The same as 3a but without property setters or constructor args.
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>		
		<tr class='dark bb' style='background-color:lightyellow'>
			<td style='text-align:center'>4</td>
			<td>
				<b>Swapped objects</b>
				<br>These are objects that are not directly serializable but have 
				{@link org.apache.juneau.swap.ObjectSwap ObjectSwaps} associated with them.  
				The purpose of a POJO swap is to convert an object to another object that is easier to serialize 
				and parse.  
				For example, the {@link org.apache.juneau.swaps.TemporalDateSwap.IsoLocalDateTime} class can be used to 
				serialize {@link java.util.Date} objects to ISO8601 strings, and parse them back into 
				{@link java.util.Date} objects.
			</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>4a</td>
			<td>
				<b>2-way swapped to group [1, 2a, 3ac] objects</b>
				<br>For example, a swap that converts a {@code Date} to a {@code String}.
			</td>
			<td>
				<ul class='normal'>
					<li><c>java.util.Date</c>
					<li><c>java.util.GregorianCalendar</c>
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>			
		<tr class='light bb'>
			<td style='text-align:center'>4b</td>
			<td>
				<b>1-way swapped to group [1, 2, 3] objects</b>
				<br>For example, a swap that converts an {@code Iterator} to a {@code List}.  
				This would be one way, since you cannot reconstruct an {@code Iterator}.
			</td>
			<td>
				<ul class='normal'>
					<li><c>java.util.Iterator</c>
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>		
		<tr class='dark bb' style='background-color:lightyellow'>
			<td style='text-align:center'>5</td>
			<td>
				<b>Readers and InputStreams</b>
				<br>Contents are serialized directly to the output stream or writer.
				<br>Typically used for low-level language-specific replacement of POJOs using per-Media-Type 
				POJO swaps.
			</td>
			<td>					
				<ul class='normal'>
					<li>{@code FileInputStream}
					<li>{@code StringReader}
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>		
	
		<tr class='dark bb' style='background-color:lightyellow'>
			<td style='text-align:center'>6</td>
			<td>
				<b>Non-serializable objects with standard methods for converting to a serializable form</b><br>
			</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>		
		<tr class='light bb' style='background-color:lightyellow'>
			<td style='text-align:center'>6a</td>
			<td>
				Classes with a method that converts it to a serializable form:
				<ul>
					<li><c><jk>public</jk> X swap(BeanSession);</c> where <c>X</c> is in groups 
						[1, 2a, 3ac].
					<li><c><jk>public</jk> String toString();</c> where the string is any meaningful data.
				</ul>
				And a method that converts it back into the original object:
				<ul>
					<li><c><jk>public static</jk> T fromString(String);</c>		
					<li><c><jk>public static</jk> T valueOf(String);</c>		
					<li><c><jk>public static</jk> T parse(String);</c>		
					<li><c><jk>public static</jk> T parseString(String);</c>		
					<li><c><jk>public static</jk> T forName(String);</c>		
					<li><c><jk>public static</jk> T forString(String);</c>		
					<li><c><jk>public</jk> T(X);</c> where <c>X</c> is in groups [1, 2a, 3ac].
					<li><c><jk>public static</jk> T unswap(BeanSession,X);</c> where <c>X</c> is in 
						groups [1, 2a, 3ac].		
				</ul>
			</td>
			<td>
				<ul class='normal'>
					<li><c>java.lang.Class</c>
					<li><c>java.sql.Time</c>
					<li><c>java.sql.Timestamp</c>
					<li><c>java.text.MessageFormat</c>
					<li><c>java.text.NumberFormat</c>
					<li><c>java.util.Date</c>
					<li><c>java.util.UUID</c>
					<li><c>java.util.logging.Level</c>
					<li><c>javax.xml.bind.DatatypeConverter</c>
				</ul>
			</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
		</tr>		
		<tr class='light bb' style='background-color:lightyellow'>
			<td style='text-align:center'>6b</td>
			<td>
				Classes that only have a method to convert to a serializable form:
				<ul>
					<li><c><jk>public</jk> X swap(BeanSession);</c> where <c>X</c> is in groups 
						[1, 2, 3].
					<li><c><jk>public</jk> String toString();</c> where the string is any meaningful data.
				</ul>
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>			
		<tr class='dark' style='background-color:lightyellow'>
			<td style='text-align:center'>7</td>
			<td>
				<b>All other objects</b>
				<br>Anything that doesn't fall into one of the groups above are simply converted to {@code Strings} 
				using the {@code toString()} method.
			</td>
			<td>&nbsp;</td>
			<td style='background-color:lightgreen;text-align:center'><b>yes</b></td>
			<td style='background-color:salmon;text-align:center'><b>no</b></td>
		</tr>			
	</table>
	<div class='info'>
		Serializers are designed to work on tree-shaped POJO models.  
		These are models where there are no referential loops (e.g. leaves with references to nodes, or nodes 
		in one branch referencing nodes in another branch).  
		There is a serializer setting {@code detectRecursions} to look for and handle these kinds of loops 
		(by setting these references to <jk>null</jk>) but it is not enabled by default since it introduces 
		a moderate performance penalty. 
	</div>
	
	<h5 class='topic' id='PojosConveribleToStrings'>POJOs convertible to/from Strings</h5>
	<p>
		A separate category exists for POJOs that can be converted to and from Strings.
		These are used in places such as: 
	</p>
	<ul class='spaced-list'>
		<li>Serializing of POJOs to Strings in the REST client API when no serializers are registered.
		<li>Parsing of POJOs from Strings in the REST server API for <js>"text/plain"</js> requests where
		<js>"text/plain"</js> is not already mapped to an existing serializer.
	</ul>
	
	<p>
		As a general rule, all POJOs are converted to Strings using the <c>toString()</c> method.
		However, there is one exception:
	</p>
	<ul class='spaced-list'>
		<li>{@link java.util.TimeZone} - Uses {@link java.util.TimeZone#getID()}
	</ul>
	
	<p>
		POJOs are convertible from Strings using any of the following (matched in the specified order):
	</p>
	<ul class='spaced-list'>
		<li>Any of the following public static non-deprecated methods:
		<ul>
			<li><c>create(String)</c>
			<li><c>fromString(String)</c>
			<li><c>fromValue(String)</c>
			<li><c>valueOf(String)</c>
			<li><c>parse(String)</c>
			<li><c>parseString(String)</c>
			<li><c>forName(String)</c>
			<li><c>forString(String)</c>
		</ul>
		<li>Has a public constructor that takes in a <c>String</c>.
	</ul>
	<p>
		Exceptions exist for the following classes:
	</p>
	<ul class='spaced-list'>
		<li>{@link java.util.TimeZone} - Uses {@link java.util.TimeZone#getTimeZone(String)}
		<li>{@link java.util.Locale} - Uses {@link java.util.Locale#forLanguageTag(String)} after replacing <js>'_'</js> with <js>'-'</js>.
		<li>{@link java.lang.Boolean} - Blank and <js>"null"</js> are interpreted as null values.
		<li>Primitives (except for <c><jk>void</jk>.<jk>class</jk></c>) - Uses the primitive wrapper classes for instantiating from Strings.
	</ul>
	
	<h5 class='topic' id='PojosConveribleToOtherTypes'>POJOs convertible to/from other types</h5>
	<p>
		POJOs are also converted to various other types in places such as the Open-API serializers and parsers. 
		In this section, the type being converted to will be referred to as <c>X</c>.
	</p>
	<p>
		POJOs are considered convertible from X if it has any of the following (matched in the specified order):
	</p>
	<ul class='spaced-list'>
		<li>Any any of the following public static non-deprecated methods:
		<ul>
			<li><c>create(X)</c>
			<li><c>from*(X)</c>
		</ul>
		<li>Has a public constructor that takes in an <c>X</c>.
		<li>The X class has a public non-static no-arg non-deprecated method called <c>to*()</c>.
	</ul>
	<p>
		POJOs are considered convertible from X if any of the reverse of above are true.
	</p>
</div>
</div><!-- END: 2.20 - jm.PojoCategories -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.SimpleVariableLanguage' id='jm.SimpleVariableLanguage'>2.21 - Simple Variable Language</a></h3>
<div class='topic'><!-- START: 2.21 - jm.SimpleVariableLanguage -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.svl} packages defines an API for a language called "Simple Variable Language".
		In a nutshell, Simple Variable Language (or SVL) is text that contains variables of the form <js>"$varName{varKey}"</js>.
		It is used extensively in the Config, REST and Microservice APIs.
	</p>
	<p>
		Most variables can be recursively nested within the varKey (e.g. <js>"$FOO{$BAR{xxx},$BAZ{xxx}}"</js>)
		and can return values that themselves contain more variables.
	</p>
	<p>
		The {@link org.apache.juneau.svl.VarResolver} class is used to resolve variables.
		The {@link org.apache.juneau.svl.VarResolver#DEFAULT} resolver is a reusable instance of this class 
		configured with the following basic variables:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.vars.SystemPropertiesVar} - <c>$S{key[,default]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.EnvVariablesVar} - <c>$E{key[,default]}</c>
	</ul>
	<p>
		The following logic variables are also provided:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.vars.IfVar} - <c>$IF{arg,then[,else]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.SwitchVar} - <c>$SW{arg,pattern1:then1[,pattern2:then2...]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.CoalesceVar} - <c>$CO{arg1[,arg2...]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.PatternMatchVar} - <c>$PM{arg,pattern}</c> 
		<li class='jc'>{@link org.apache.juneau.svl.vars.PatternReplaceVar} - <c>$PR{arg,pattern,replace}</c> 
		<li class='jc'>{@link org.apache.juneau.svl.vars.PatternExtractVar} - <c>$PE{arg,pattern,groupIndex}</c> 
		<li class='jc'>{@link org.apache.juneau.svl.vars.NotEmptyVar} - <c>$NE{arg}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.UpperCaseVar} - <c>$UC{arg}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.LowerCaseVar} - <c>$LC{arg}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.LenVar} - <c>$LN{arg[,delimiter]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.SubstringVar} - <c>$ST{arg,start[,end]}</c>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Use the default variable resolver to resolve a string that contains 
	// $S (system property) variables.</jc>
	String <jv>property</jv> = VarResolver.<jsf>DEFAULT</jsf>.resolve(<js>"The Java home directory is $S{java.home}"</js>);
	</p>
	<p>
		The following shows how variables can be arbitrarily nested...
	</p>
	<p class='bjava'>
	<jc>// Look up a property in the following order:
	// 1) MYPROPERTY environment variable.
	// 2) 'my.property' system property if environment variable not found.
	// 3) 'not found' string if system property not found.</jc>
	String <jv>property</jv> = VarResolver.<jsf>DEFAULT</jsf>.resolve(<js>"$E{MYPROPERTY,$S{my.property,not found}}"</js>);
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.SvlVariables' id='jm.SvlVariables'>2.21.1 - SVL Variables</a><span class='update'>updated: 8.0.0,8.1.0</span></h4>
<div class='topic'><!-- START: 2.21.1 - jm.SvlVariables -->
<div class='topic'>
	<p>
		Variables are defined through the {@link org.apache.juneau.svl.Var} API.
		The API comes with several predefined variables and is easily extensible.
	</p>
	<p>
		The following is an example of a variable that performs URL-Encoding on strings.
	</p>
	<p class='bjava'>
	<jc>// First create our var.</jc>
	<jk>public class</jk> UrlEncodeVar <jk>extends</jk> SimpleVar {
		
		<jc>// Must have a no-arg constructor!</jc>
		<jk>public</jk> UrlEncodeVar() {
			<jk>super</jk>(<js>"UE"</js>);
		}	
		
		<jc>// The method we must implement</jc>
		<ja>@Override</ja>
		<jk>public</jk> String resolve(VarResolverSession <jv>session</jv>, String <jv>key</jv>) {
			<jk>return</jk> URLEncoder.<jsm>encode</jsm>(<jv>key</jv>, <js>"UTF-8"</js>);
		}
	}
	
	<jc>// Next create a var resolver that extends the existing DEFAULT resolver
	// that supports resolving system properties.</jc>
	VarResolver <jv>varResolver</jv> = VarResolver.<jsf>DEFAULT</jsf>
		.copy()
		.vars(UrlEncodeVar.<jk>class</jk>)
		.build();
	
	<jc>// Retrieve a system property and URL-encode it if necessary.</jc>
	String <jv>myProperty</jv> = <jv>varResolver</jv>.resolve(<js>"$UE{$S{my.property}}"</js>);
	</p>
	<p>
		The following shows the class hierarchy of the {@link org.apache.juneau.svl.Var} class:
	</p>  
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.svl.Var} - Superclass of all vars.
			<ul>
				<li class='jac'>{@link org.apache.juneau.svl.SimpleVar} - Superclass of all vars that return strings.
					<ul>
						<li class='jac'>{@link org.apache.juneau.svl.DefaultingVar} - Variables that define a default value if the resolve method returns null.
							<ul>
								<li class='jac'>{@link org.apache.juneau.svl.MapVar} - Variables that pull values from maps.
							</ul>
						</li>
						<li class='jac'>{@link org.apache.juneau.svl.MultipartVar} - Variables that consist of 2 or more comma-delimited arguments.
					</ul>
				</li>
				<li class='jac'>{@link org.apache.juneau.svl.StreamedVar} - Superclass of all vars that stream their value to writers.
			</ul>
		</li>
	</ul>
	<p>
		The following is the list of default variables defined in all modules:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Module</th><th>Class</th><th>Pattern</th>
		</tr>
		<tr class='dark'>
			<td rowspan='16' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-svl</td>
			<td>{@link org.apache.juneau.svl.vars.EnvVariablesVar}</td>
			<td class='code'>$E{key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.SystemPropertiesVar}</td>
			<td class='code'>$S{key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.ArgsVar}</td>
			<td class='code'>$A{key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.ManifestFileVar}</td>
			<td class='code'>$MF{key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.IfVar}</td>
			<td class='code'>$IF{arg,then[,else]}</td>
		</tr>
		<tr class='dark dd'>
			<td>{@link org.apache.juneau.svl.vars.SwitchVar}</td>
			<td class='code'>$SW{arg,pattern1:then1[,pattern2:then2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.CoalesceVar}</td>
			<td class='code'>$CO{arg1[,arg2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.PatternMatchVar}</td>
			<td class='code'>$PM{arg,pattern}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.PatternReplaceVar}</td>
			<td class='code'>$PR{arg,pattern,replace}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.PatternExtractVar}</td>
			<td class='code'>$PE{arg,pattern,groupdIndex}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.NotEmptyVar}</td>
			<td class='code'>$NE{arg}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.UpperCaseVar}</td>
			<td class='code'>$UC{arg}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.LowerCaseVar}</td>
			<td class='code'>$LC{arg}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.LenVar}</td>
			<td class='code'>$LN{arg[,delimiter]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.SubstringVar}</td>
			<td class='code'>$ST{arg,start[,end]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.html.HtmlWidgetVar}</td>
			<td class='code'>$W{name}</td>
		</tr>
		<tr class='light dd'>
			<td rowspan='1' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-config</td>
			<td>{@link org.apache.juneau.config.vars.ConfigVar}</td>
			<td class='code'>$C{key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td rowspan='15' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-rest-server</td>
			<td>{@link org.apache.juneau.rest.vars.FileVar}</td>
			<td class='code'>$F{path[,default]}}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.ServletInitParamVar}</td>
			<td class='code'>$I{name[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.LocalizationVar}</td>
			<td class='code'>$L{key[,args...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestAttributeVar}</td>
			<td class='code'>$RA{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestFormDataVar}</td>
			<td class='code'>$RF{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestHeaderVar}</td>
			<td class='code'>$RH{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestPathVar}</td>
			<td class='code'>$RP{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestQueryVar}</td>
			<td class='code'>$RQ{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestSwaggerVar}</td>
			<td class='code'>$RS{key}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestVar}</td>
			<td class='code'>$R{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.SerializedRequestAttrVar}</td>
			<td class='code'>$SA{contentType,key[,default]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.SwaggerVar}</td>
			<td class='code'>$SS{key1[,key2...]}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.UrlVar}</td>
			<td class='code'>$U{uri}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.UrlEncodeVar}</td>
			<td class='code'>$UE{uriPart}</td>
		</tr>
	</table>
</div>
</div><!-- END: 2.21.1 - jm.SvlVariables -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.VarResolvers' id='jm.VarResolvers'>2.21.2 - VarResolvers and VarResolverSessions</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.21.2 - jm.VarResolvers -->
<div class='topic'>
	<p>
		The main class for performing variable resolution is {@link org.apache.juneau.svl.VarResolver}.
		Two methods are provided for resolving variables:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.VarResolver}
			<ul>
				<li class='jm'>{@link org.apache.juneau.svl.VarResolver#resolve(String) resolve(String)} 
					- Resolves variables and returns the results as a simple string.
				<li class='jm'>{@link org.apache.juneau.svl.VarResolver#resolveTo(String,Writer) resolveTo(String,Writer)} 
					- Resolves variables and sends results to a writer.
			</ul>
		</li>
	</ul>
	<p>
		Var resolvers can rely on the existence of other objects.
		For example, {@link org.apache.juneau.config.vars.ConfigVar} relies on the existence of a {@link org.apache.juneau.config.Config}.
		This is accomplished through the following method:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.VarResolver.Builder} 
			<ul>
				<li class='jm'>{@link org.apache.juneau.svl.VarResolver.Builder#bean(Class,Object) bean(Class&lt;T&gt;, T)} - Specify a bean for all sessions.
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.svl.VarResolverSession}
			<ul>
				<li class='jm'>{@link org.apache.juneau.svl.VarResolverSession#bean(Class,Object) bean(Class&lt;T&gt;, T)} - Specify a bean for this session.
			</ul>
		</li>
	</ul>
	<p>
		Beans are accessible through the following method:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.svl.VarResolverSession#getBean(Class)}
	</ul>
	<p>
		Var resolvers can be cloned and extended by using the {@link org.apache.juneau.svl.VarResolver#copy()} method.
		Cloning a resolver will copy it's {@link org.apache.juneau.svl.Var} class names and context objects.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a resolver that copies the default resolver and adds $C and $A vars.</jc>
	VarResolver <jv>myVarResolver</jv> = VarResolver
		.<jsf>DEFAULT</jsf>
		.copy()
		.vars(ConfigVar.<jk>class</jk>, ArgsVar.<jk>class</jk>)
		.build();
	</p>
</div>
</div><!-- END: 2.21.2 - jm.VarResolvers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.DefaultVarResolver' id='jm.DefaultVarResolver'>2.21.3 - VarResolver.DEFAULT</a><span class='update'>created: 8.1.0</span></h4>
<div class='topic'><!-- START: 2.21.3 - jm.DefaultVarResolver -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.svl.VarResolver#DEFAULT} is a reusable variable resolver with default support for the following variables:
	</p>
	<ul>
		<li><c>$S{key[,default]}</c> - {@link org.apache.juneau.svl.vars.SystemPropertiesVar}
		<li><c>$E{key[,default]}</c> - {@link org.apache.juneau.svl.vars.EnvVariablesVar}
		<li><c>$A{key[,default]}</c> - {@link org.apache.juneau.svl.vars.ArgsVar}
		<li><c>$MF{key[,default]}</c> - {@link org.apache.juneau.svl.vars.ManifestFileVar}
		<li><c>$SW{stringArg,pattern:thenValue[,pattern:thenValue...]}</c> - {@link org.apache.juneau.svl.vars.SwitchVar}
		<li><c>$IF{arg,then[,else]}</c> - {@link org.apache.juneau.svl.vars.IfVar}
		<li><c>$CO{arg[,arg2...]}</c> - {@link org.apache.juneau.svl.vars.CoalesceVar}
		<li><c>$PM{arg,pattern}</c> - {@link org.apache.juneau.svl.vars.PatternMatchVar}
		<li><c>$PR{stringArg,pattern,replace}</c>- {@link org.apache.juneau.svl.vars.PatternReplaceVar}
		<li><c>$PE{arg,pattern,groupIndex}</c> - {@link org.apache.juneau.svl.vars.PatternExtractVar}
		<li><c>$UC{arg}</c> - {@link org.apache.juneau.svl.vars.UpperCaseVar}
		<li><c>$LC{arg}</c> - {@link org.apache.juneau.svl.vars.LowerCaseVar}
		<li><c>$NE{arg}</c> - {@link org.apache.juneau.svl.vars.NotEmptyVar}
		<li><c>$LN{arg[,delimiter]}</c> - {@link org.apache.juneau.svl.vars.LenVar}
		<li><c>$ST{arg,start[,end]}</c> - {@link org.apache.juneau.svl.vars.SubstringVar}
	</ul>
</div>
</div><!-- END: 2.21.3 - jm.DefaultVarResolver -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.SvlOtherNotes' id='jm.SvlOtherNotes'>2.21.4 - Other Notes</a></h4>
<div class='topic'><!-- START: 2.21.4 - jm.SvlOtherNotes -->
<div class='topic'>
	<ul class='spaced-list'>
		<li>
			The escape character <js>'\'</js> can be used when necessary to escape the following characters: 
			<c>$ , { }</c>
		<li>
			<b>WARNING:</b>  It is possible to cause {@link java.lang.StackOverflowError StackOverflowErrors} if 
			your nested variables result in a recursive loop (e.g. the environment variable 
			<c>'MYPROPERTY'</c> has the value <c>'$E{MYPROPERTY}'</c>).
			So don't do that!
		<li>
			As a general rule, this class tries to be as efficient as possible by not creating new strings when not 
			needed.
			<br>For example, calling the resolve method on a string that doesn't contain variables (e.g. 
			<c>resolver.resolve(<js>"foobar"</js>)</c>) will simply be a no-op and return the same string.
	</ul>
</div>
</div><!-- END: 2.21.4 - jm.SvlOtherNotes -->
</div><!-- END: 2.21 - jm.SimpleVariableLanguage -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.Encoders' id='jm.Encoders'>2.22 - Encoders</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.22 - jm.Encoders -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.encoders} package defines an API for handling encoding-based matching
		of <c>Accept-Encoding</c>/<c>Content-Encoding</c> HTTP headers.  It consists of the following classes:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.encoders.EncoderSet}
		<li class='jcc'>{@link org.apache.juneau.encoders.Encoder}
		<ul>
			<li class='jc'>{@link org.apache.juneau.encoders.IdentityEncoder}
			<li class='jc'>{@link org.apache.juneau.encoders.GzipEncoder}
		</ul>
	</ul>
	<h5 class='topic'>EncoderSet</h5>
	<p>
		The {@link org.apache.juneau.encoders.EncoderSet} class represents the set of {@link org.apache.juneau.encoders.Encoder encoders} keyed by codings.
		It maintains a set of encoders and the codings that they can handle.
 		The {@link org.apache.juneau.encoders.EncoderSet#getEncoderMatch(String) getEncoderMatch(String)} and {@link org.apache.juneau.encoders.EncoderSet#getEncoder(String)} 
 		methods are then used to find appropriate encoders for specific <c>Accept-Encoding</c> and <c>Content-Encoding</c> header values.
	</p>
	
	<h5 class='topic'>Match ordering</h5>
	<p>
		Encoders are tried in the order they appear in the set.  The {@link org.apache.juneau.encoders.EncoderSet.Builder#add(Class...)} / {@link org.apache.juneau.encoders.EncoderSet.Builder#add(Encoder...)}
		methods prepend the values to the list to allow them the opportunity to override encoders already in the list.
	</p>
	<p>
		For example, calling <code>builder.add(E1.<jk>class</jk>,E2.<jk>class</jk>).add(E3.<jk>class</jk>,
		E4.<jk>class</jk>)</code> will result in the order <c>E3, E4, E1, E2</c>.
	</p>
	
	<h5 class='section'>Example:</h5>
	<p class='bjava'>
	<jc>// Create an encoder group with support for gzip compression.</jc>
	EncoderSet <jv>encoders</jv> = EncoderSet
		.<jsm>create</jsm>()
		.add(GzipEncoder.<jk>class</jk>)
		.build();

	<jc>// Should return "gzip"</jc>
	String <jv>matchedCoding</jv> = <jv>encoders</jv>.findMatch(<js>"compress;q=1.0, gzip;q=0.8, identity;q=0.5, *;q=0"</js>);

	<jc>// Get the encoder</jc>
	Encoder <jv>encoder</jv> = <jv>encoders</jv>.getEncoder(<jv>matchedCoding</jv>);
	</p>

	<h5 class='topic'>Encoder API</h5>
	<p>
		The {@link org.apache.juneau.encoders.Encoder} interface is used for enabling decompression on requests and compression on responses, such as support for GZIP compression.
		It is used to wrap input and output streams within compression/decompression streams.
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.encoders.Encoder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.encoders.Encoder#getCodings() getCodings()}
			<li class='jm'>{@link org.apache.juneau.encoders.Encoder#getInputStream(InputStream) getInputStream(InputStream)}
			<li class='jm'>{@link org.apache.juneau.encoders.Encoder#getOutputStream(OutputStream) getOutputStream(OutputStream)}
		</ul>
	</ul>
	<p>
		Encoders are registered with <c>RestServlets</c> through the <ja>@Rest(encoders)</ja> annotation.
	</p>
</div>
</div><!-- END: 2.22 - jm.Encoders -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.ObjectTools' id='jm.ObjectTools'>2.23 - Object Tools</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 2.23 - jm.ObjectTools -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.objecttools} package defines convenience utility classes for accessing
		and manipulating POJOs.  It consists of the following classes:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectRest}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectSearcher}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectSorter}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectViewer}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectPaginator}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectIntrospector}
		<li class='jc'>{@link org.apache.juneau.objecttools.ObjectMerger}
	</ul>
	
	<h5 class='topic'>ObjectRest</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectRest} class provides the ability to perform standard REST operations (GET, PUT, POST, DELETE) against nodes in a POJO model.
		Nodes in the POJO model are addressed using URLs.
	</p>
	<p>
		A POJO model is defined as a tree model where nodes consist of consisting of the following:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link java.util.Map Maps} and Java beans representing JSON objects.
		<li>
			{@link java.util.Collection Collections} and arrays representing JSON arrays.
		<li>
			Java beans.
	</ul>
	<p>
		Leaves of the tree can be any type of object.
	</p>
	<p>
		Use {@link org.apache.juneau.objecttools.ObjectRest#get(String) get()} to retrieve an element from a JSON tree.
		<br>Use {@link org.apache.juneau.objecttools.ObjectRest#put(String,Object) put()} to create (or overwrite) an element in a JSON tree.
		<br>Use {@link org.apache.juneau.objecttools.ObjectRest#post(String,Object) post()} to add an element to a list in a JSON tree.
		<br>Use {@link org.apache.juneau.objecttools.ObjectRest#delete(String) delete()} to remove an element from a JSON tree.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Construct an unstructured POJO model</jc>
	JsonMap <jv>map</jv> = JsonMap.<jsm>ofJson</jsm>(<js>""</js>
		+ <js>"{"</js>
		+ <js>"	name:'John Smith', "</js>
		+ <js>"	address:{ "</js>
		+ <js>"		streetAddress:'21 2nd Street', "</js>
		+ <js>"		city:'New York', "</js>
		+ <js>"		state:'NY', "</js>
		+ <js>"		postalCode:10021 "</js>
		+ <js>"	}, "</js>
		+ <js>"	phoneNumbers:[ "</js>
		+ <js>"		'212 555-1111', "</js>
		+ <js>"		'212 555-2222' "</js>
		+ <js>"	], "</js>
		+ <js>"	additionalInfo:null, "</js>
		+ <js>"	remote:false, "</js>
		+ <js>"	height:62.4, "</js>
		+ <js>"	'fico score':' &gt; 640' "</js>
		+ <js>"} "</js>
	);

	<jc>// Wrap Map inside an ObjectRest object</jc>
	ObjectRest <jv>johnSmith</jv> = ObjectRest.<jsm>create</jsm>(<jv>map</jv>);

	<jc>// Get a simple value at the top level</jc>
	<jc>// "John Smith"</jc>
	String <jv>name</jv> = <jv>johnSmith</jv>.getString(<js>"name"</js>);

	<jc>// Change a simple value at the top level</jc>
	<jv>johnSmith</jv>.put(<js>"name"</js>, <js>"The late John Smith"</js>);

	<jc>// Get a simple value at a deep level</jc>
	<jc>// "21 2nd Street"</jc>
	String <jv>streetAddress</jv> = <jv>johnSmith</jv>.getString(<js>"address/streetAddress"</js>);

	<jc>// Set a simple value at a deep level</jc>
	<jv>johnSmith</jv>.put(<js>"address/streetAddress"</js>, <js>"101 Cemetery Way"</js>);

	<jc>// Get entries in a list</jc>
	<jc>// "212 555-1111"</jc>
	String <jv>firstPhoneNumber</jv> = <jv>johnSmith</jv>.getString(<js>"phoneNumbers/0"</js>);

	<jc>// Add entries to a list</jc>
	<jv>johnSmith</jv>.post(<js>"phoneNumbers"</js>, <js>"212 555-3333"</js>);

	<jc>// Delete entries from a model</jc>
	<jv>johnSmith</jv>.delete(<js>"fico score"</js>);

	<jc>// Add entirely new structures to the tree</jc>
	JsonMap <jv>medicalInfo</jv> = JsonMap.<jsm>ofJson</jsm>(<js>""</js>
		+ <js>"{"</js>
		+ <js>"	currentStatus: 'deceased',"</js>
		+ <js>"	health: 'non-existent',"</js>
		+ <js>"	creditWorthiness: 'not good'"</js>
		+ <js>"}"</js>
	);
	<jv>johnSmith</jv>.put(<js>"additionalInfo/medicalInfo"</js>, <jv>medicalInfo</jv>);
	</p>

	<p>
		In the special case of collections/arrays of maps/beans, a special XPath-like selector notation can be used in lieu
		of index numbers on GET requests to return a map/bean with a specified attribute value.
		<br>The syntax is {@code @attr=val}, where attr is the attribute name on the child map, and val is the matching value.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Get map/bean with name attribute value of 'foo' from a list of items</jc>
	Map <jv>map</jv> = <jv>objectRest</jv>.getMap(<js>"/items/@name=foo"</js>);
	</p>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Traversable} REST response converter.
	</ul>
	
	<h5 class='topic'>ObjectSearcher</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectSearcher} class is designed to provide searches across arrays and collections of maps or beans.
		It allows you to quickly filter beans and maps using simple yet sophisticated search arguments.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'> 
	MyBean[] <jv>arrayOfBeans</jv> = ...;
	ObjectSearcher <jv>searcher</jv> = ObjectSearcher.<jsm>create</jsm>();
	
	<jc>// Returns a list of beans whose 'foo' property is 'X' and 'bar' property is 'Y'.</jc>		
	List&lt;MyBean&gt; <jv>result</jv> = <jv>searcher</jv>.run(<jv>arrayOfBeans</jv>, <js>"foo=X,bar=Y"</js>);  
	</p>
	<p>
		The tool can be used against the following data types:
	</p>
	<ul>
		<li>Arrays/collections of maps or beans.
	</ul>
	<p>
		The default searcher is configured with the following matcher factories that provides the capabilities of matching
		against various data types.  This list is extensible:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.objecttools.StringMatcherFactory}
		<li class='jc'>{@link org.apache.juneau.objecttools.NumberMatcherFactory}
		<li class='jc'>{@link org.apache.juneau.objecttools.TimeMatcherFactory}
	</ul>
	<p>
		The {@link org.apache.juneau.objecttools.StringMatcherFactory} class provides searching based on the following patterns:
	</p>
	<ul>
		<li><js>"property=foo"</js> - Simple full word match
		<li><js>"property=fo*"</js>, <js>"property=?ar"</js> - Meta-character matching
		<li><js>"property=foo bar"</js>(implicit), <js>"property=^foo ^bar"</js>(explicit) - Multiple OR'ed patterns
		<li><js>"property=+fo* +*ar"</js> - Multiple AND'ed patterns
		<li><js>"property=fo* -bar"</js> - Negative patterns
		<li><js>"property='foo bar'"</js> - Patterns with whitespace
		<li><js>"property=foo\\'bar"</js> - Patterns with single-quotes
		<li><js>"property=/foo\\s+bar"</js> - Regular expression match
	</ul>
	<p>
		The {@link org.apache.juneau.objecttools.NumberMatcherFactory} class provides searching based on the following patterns:
	</p>
	<ul>
		<li><js>"property=1"</js> - A single number
		<li><js>"property=1 2"</js> - Multiple OR'ed numbers
		<li><js>"property=-1 -2"</js> - Multiple OR'ed negative numbers
		<li><js>"property=1-2"</js>,<js>"property=-2--1"</js>  - A range of numbers (whitespace ignored)
		<li><js>"property=1-2 4-5"</js> - Multiple OR'ed ranges
		<li><js>"property=&lt;1"</js>,<js>"property=&lt;=1"</js>,<js>"property=&gt;1"</js>,<js>"property=&gt;=1"</js> - Open-ended ranges
		<li><js>"property=!1"</js>,<js>"property=!1-2"</js> - Negation
	</ul>
	<p>
		The {@link org.apache.juneau.objecttools.TimeMatcherFactory} class provides searching based on the following patterns:
	</p>
	<ul>
		<li><js>"property=2011"</js> - A single year
		<li><js>"property=2011 2013 2015"</js> - Multiple years
		<li><js>"property=2011-01"</js> - A single month
		<li><js>"property=2011-01-01"</js> - A single day
		<li><js>"property=2011-01-01T12"</js> - A single hour
		<li><js>"property=2011-01-01T12:30"</js> - A single minute
		<li><js>"property=2011-01-01T12:30:45"</js> - A single second
		<li><js>"property=&gt;2011"</js>,<js>"property=&gt;=2011"</js>,<js>"property=&lt;2011"</js>,<js>"property=&lt;=2011"</js> - Open-ended ranges
		<li><js>"property=&gt;2011"</js>,<js>"property=&gt;=2011"</js>,<js>"property=&lt;2011"</js>,<js>"property=&lt;=2011"</js> - Open-ended ranges
		<li><js>"property=2011 - 2013-06-30"</js> - Closed ranges
	</ul>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Queryable} REST response converter.
	</ul>

	<h5 class='topic'>ObjectSorter</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectSorter} class is designed to sort arrays and collections of maps or beans.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'> 
	MyBean[] <jv>arrayOfBeans</jv> = ...;
	ObjectSorter <jv>sorter</jv> = ObjectSorter.<jsm>create</jsm>();
	
	<jc>// Returns a list of beans sorted accordingly.</jc>		
	List&lt;MyBean&gt; <jv>result</jv> = <jv>sorter</jv>.run(<jv>arrayOfBeans</jv>, <js>"foo,bar-"</js>);  
	</p>
	<p>
		The tool can be used against the following data types:
	</p>
	<ul>
		<li>Arrays/collections of maps or beans.
	</ul>
	<p>
		The arguments are a simple comma-delimited list of property names optionally suffixed with <js>'+'</js> and <js>'-'</js> to 
		denote ascending/descending order.
	</p>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Queryable} REST response converter.
	</ul>
	
	<h5 class='topic'>ObjectViewer</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectViewer} class is designed to extract properties from collections of maps or beans.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'> 
	MyBean[] <jv>arrayOfBeans</jv> = ...;
	ObjectViewer <jv>viewer</jv> = ObjectViewer.<jsm>create</jsm>();
	<jc>// Returns the 'foo' and 'bar' properties extracted into a list of maps.</jc>		
	List&lt;Map&gt; <jv>result</jv> = <jv>viewer</jv>.run(<jv>arrayOfBeans</jv>, <js>"foo,bar"</js>);  
	</p>
	<p>
		The tool can be used against the following data types:
	</p>
	<ul>
		<li>Arrays/collections of maps or beans.
		<li>Singular maps or beans.
	</ul>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Queryable} REST response converter.
	</ul>
	
	<h5 class='topic'>ObjectPaginator</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectPaginator} class is designed to extract sublists from arrays/collections of maps or beans.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'> 
	MyBean[] <jv>arrayOfBeans</jv> = ...;
	ObjectPaginator <jv>paginator</jv> = ObjectPaginator.<jsm>create</jsm>();
	
	<jc>// Returns all rows from 100 to 110.</jc>		
	List&lt;MyBean&gt; <jv>result</jv> = <jv>paginator</jv>.run(<jv>arrayOfBeans</jv>, 100, 10);  
	</p>
	<p>
		The tool can be used against the following data types:
	</p>
	<ul>
		<li>Arrays/collections of maps or beans.
	</ul>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Queryable} REST response converter.
	</ul>

	<h5 class='topic'>ObjectIntrospector</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectIntrospector} class is used to invoke methods on {@code Objects} using arguments in serialized form.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	String <jv>string1</jv> = <js>"foobar"</js>;
	String <jv>string2</jv> = ObjectIntrospector
		.create(<jv>string</jv>)
		.invoke(String.<jk>class</jk>, <js>"substring(int,int)"</js>, <js>"[3,6]"</js>);  <jc>// "bar"</jc>
	</p>
	<p>
		The arguments passed to the identified method are POJOs serialized in JSON format.  Arbitrarily complex arguments can be passed
		in as arguments.
	</p>
	<ul class='notes'>
		<li class='note'>This class is used in the {@link org.apache.juneau.rest.converter.Introspectable} REST response converter.
		<li class='warn'>This is an extremely powerful but potentially dangerous tool.  Use wisely.
	</ul>
	
	<h5 class='topic'>ObjectMerger</h5>
	<p>
		The {@link org.apache.juneau.objecttools.ObjectMerger} class is used for merging POJOs behind a single interface.
		This is particularly useful in cases where you want to define beans with 'default' values.
	</p>
	<p>
		For example, given the following bean classes:
	</p>

	<p class='bjava'>
	<jk>public interface</jk> IA {
		String getX();
		<jk>void</jk> setX(String <jv>x</jv>);
	}

	<jk>public class</jk> A <jk>implements</jk> IA {
		<jk>private</jk> String <jf>x</jf>;

		<jk>public</jk> A(String <jv>x</jv>) {
			<jk>this</jk>.<jf>x</jf> = <jv>x</jv>;
		}

		<jk>public</jk> String getX() {
			<jk>return</jk> <jf>x</jf>;
		}

		<jk>public void</jk> setX(String <jv>x</jv>) {
			<jk>this</jk>.<jf>x</jf> = <jv>x</jv>;
		}
	}
	</p>
	<p>
		The getters will be called in order until the first non-null value is returned:
 	</p>
	<p class='bjava'>
	<jv>merge</jv> = ObjectMerger.<jsm>merger</jsm>(IA.<jk>class</jk>, <jk>new</jk> A(<js>"1"</js>), <jk>new</jk> A(<js>"2"</js>));
	<jsm>assertEquals</jsm>(<js>"1"</js>, <jv>merge</jv>.getX());

	<jv>merge</jv> = ObjectMerger.<jsm>merger</jsm>(IA.<jk>class</jk>, <jk>new</jk> A(<jk>null</jk>), <jk>new</jk> A(<js>"2"</js>));
	<jsm>assertEquals</jsm>(<js>"2"</js>, <jv>merge</jv>.getX());

	<jv>merge</jv> = ObjectMerger.<jsm>merger</jsm>(IA.<jk>class</jk>, <jk>new</jk> A(<jk>null</jk>), <jk>new</jk> A(<jk>null</jk>));
	<jsm>assertEquals</jsm>(<jk>null</jk>, <jv>merge</jv>.getX());
	</p>
	
</div>
</div><!-- END: 2.23 - jm.ObjectTools -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.JsonDetails' id='jm.JsonDetails'>2.24 - JSON Details</a></h3>
<div class='topic'><!-- START: 2.24 - jm.JsonDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from JSON using ultra-efficient serializers and parsers.
		The JSON serializer converts POJOs directly to JSON without the need for intermediate DOM objects using a 
		highly-efficient state machine.
		Likewise, the JSON parser creates POJOs directly from JSON without the need for intermediate DOM objects. 
	</p>
	<p>
		The following example shows JSON for a typical bean:
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoInstant.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<h5 class='figure'>Sample Code</h5>
	<p class='bjava'>
	Person <jv>person</jv> = <jk>new</jk> Person()
		.name(<js>"John Smith"</js>)
		.birthDate(<js>"1946-08-12T00:00:00Z"</js>)
		.addresses(
			<jk>new</jk> Address() 
				.street(<js>"100 Main Street"</js>)
				.city(<js>"Anywhereville"</js>)
				.state(<jsf>NY</jsf>)
				.zip(12345)
				.isCurrent(<jk>true</jk>);
		);
	</p>
	<h5 class='figure'>Normal JSON</h5>
	<p class='bjson'>
	{
		<js>"name"</js>: <js>"John Smith"</js>, 
		<js>"birthDate"</js>: <js>"1946-08-12T00:00:00Z"</js>, 
		<js>"addresses"</js>: [
			{
				<js>"street"</js>: <js>"100 Main Street"</js>, 
				<js>"city"</js>: <js>"Anywhereville"</js>, 
				<js>"state"</js>: <js>"NY"</js>, 
				<js>"zip"</js>: 12345, 
				<js>"isCurrent"</js>: <jk>true</jk>
			}
		]
	} 
	</p>
	<h5 class='figure'>Simplified JSON</h5>
	<p class='bjson'>
	{
		name: <js>'John Smith'</js>, 
		birthDate: <js>'1946-08-12T00:00:00Z'</js>, 
		addresses: [
			{
				street: <js>'100 Main Street'</js>, 
				city: <js>'Anywhereville'</js>, 
				state: <js>'NY'</js>, 
				zip: 12345, 
				isCurrent: <jk>true</jk>
			}
		]
	} 
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.JsonMethodology' id='jm.JsonMethodology'>2.24.1 - JSON Methodology</a></h4>
<div class='topic'><!-- START: 2.24.1 - jm.JsonMethodology -->
<div class='topic'>
	<p>
		The JSON data type produced depends on the Java object type being serialized.
	</p>
	<ul class='spaced-list'>
		<li>
			Primitives and primitive objects are converted to JSON primitives.
		<li>
			Beans and Maps are converted to JSON objects.
		<li>
			Collections and arrays are converted to JSON arrays.
		<li>
			Anything else is converted to JSON strings.
	</ul>
	
	<h5 class='figure'>Data type conversions:</h5>
	<table class='styled w800'>
		<tr>
			<th>POJO type</th>
			<th>JSON type</th>
			<th>Example</th>
			<th>Serialized form</th>
		</tr>
		<tr>
			<td>String</td>
			<td>String</td>
			<td><c>serialize(<js>"foobar"</js>);</c></td>
			<td><c><js>'foobar'</js></c>
		</tr>
		<tr>
			<td>Number</td>
			<td>Number</td>
			<td><c>serialize(123);</c></td>
			<td><c>123</c>
		</tr>
		<tr>
			<td>Boolean</td>
			<td>Boolean</td>
			<td><c>serialize(<jk>true</jk>);</c></td>
			<td><c><jk>true</jk></c>
		</tr>
		<tr>
			<td>Null</td>
			<td>Null</td>
			<td><c>serialize(<jk>null</jk>);</c></td>
			<td><c><jk>null</jk></c>
		</tr>
		<tr>
			<td>Beans with properties of any type on this list</td>
			<td>Object</td>
			<td><c>serialize(<jk>new</jk> MyBean());</c></td>
			<td><c>{p1:<js>'val1'</js>,p2:<jk>true</jk>}</c>
		</tr>
		<tr>
			<td>Maps with values of any type on this list</td>
			<td>Object</td>
			<td><c>serialize(<jk>new</jk> TreeMap());</c></td>
			<td><c>{key1:<js>'val1'</js>,key2:<jk>true</jk>}</c>
		</tr>
		<tr>
			<td>Collections and arrays of any type on this list</td>
			<td>Array</td>
			<td><c>serialize(<jk>new</jk> Object[]{1,<js>"foo"</js>,<jk>true</jk>});</c></td>
			<td><c>[1,<js>'foo'</js>,<jk>true</jk>]</c>
		</tr>
	</table>
	<p>
		In addition, swaps can be used to convert non-serializable POJOs into serializable forms, such as converting 
		<c>Calendar</c> object to ISO8601 strings, or <c><jk>byte</jk>[]</c> arrays to Base-64 
		encoded strings.
	</p>
</div>
</div><!-- END: 2.24.1 - jm.JsonMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.JsonSerializers' id='jm.JsonSerializers'>2.24.2 - JSON Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.24.2 - jm.JsonSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.json.JsonSerializer} class is used to serialize POJOs into JSON.
	</p>	
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.json.JsonSerializer.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.json.JsonSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.JsonSerializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.JsonSerializer#DEFAULT_READABLE DEFAULT_READABLE}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.json.Json5Serializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.Json5Serializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.Json5Serializer#DEFAULT_READABLE DEFAULT_READABLE}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.24.2 - jm.JsonSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.Json5' id='jm.Json5'>2.24.3 - JSON 5</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.24.3 - jm.Json5 -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.json.Json5Serializer} class can be used to serialized POJOs into JSON 5 notation.
	</p>
	<p>
		JSON 5 is similar to JSON except for the following:
	</p>
	<ul class='spaced-list'>
		<li>JSON attributes are only quoted when necessary.
		<li>Uses single-quotes for quoting.
	</ul>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Some free-form JSON.</jc>
	JsonMap <jv>map</jv> = JsonMap.<jsm>of</jsm>(
		<js>"foo"</js>, <js>"x1"</js>,
		<js>"_bar"</js>, <js>"x2"</js>,
		<js>" baz "</js>, <js>"x3"</js>,
		<js>"123"</js>, <js>"x4"</js>,
		<js>"return"</js>, <js>"x5"</js>,
		<js>""</js>, <js>"x6"</js>
	);
	</p>
	<p class='bjson'>
	<joc>// Serialized to standard JSON</joc>
	{
		<jok>"foo"</jok>: <jov>"x1"</jov>,
		<jok>"_bar"</jok>: <jov>"x2"</jov>,
		<jok>" baz "</jok>: <jov>"x3"</jov>,
		<jok>"123"</jok>: <jov>"x4"</jov>,
		<jok>"return"</jok>: <jov>"x5"</jov>,
		<jok>""</jok>: <jov>"x6"</jov>
	}
	</p>	 		
	<p class='bjson'>
	<joc>// Serialized to simplified JSON</joc>
	{
		<jok>foo</jok>: <jov>'x1'</jov>,
		<jok>_bar</jok>: <jov>'x2'</jov>,
		<jok>' baz '</jok>: <jov>'x3'</jov>,  <joc>// Quoted due to embedded spaces.</joc>
		<jok>'123'</jok>: <jov>'x4'</jov>,    <joc>// Quoted to prevent confusion with number.</joc>
		<jok>'return'</jok>: <jov>'x5'</jov>, <joc>// Quoted because it's a keyword.</joc>
		<jok>''</jok>: <jov>'x6'</jov>        <joc>// Quoted because it's an empty string.</joc>
	}
	</p>
	<p>
		The advantage to JSON 5 is you can represent it in a Java String in minimal form with minimal escaping.
		This is particularly useful in cases such as unit testing where you can easily validate POJOs by simplifying them to JSON 5 and do a simple string comparison.
	</p>
	<p class='bjava'>
	WriterSerializer <jv>serializer</jv> = Json5Serializer.<jsf>DEFAULT</jsf>;
	<jsm>assertEquals</jsm>(<js>"{foo:'bar',baz:123}"</js>, <jv>serializer</jv>.toString(<jv>myPojo</jv>));
	</p>			
	
	<ul class='seealso'>
		<li class='jc'>{@link org.apache.juneau.json.JsonSerializer.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.json.JsonSerializer.Builder#json5() json5()}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.24.3 - jm.Json5 -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.JsonParsers' id='jm.JsonParsers'>2.24.4 - JSON Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.24.4 - jm.JsonParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.json.JsonParser} class is used to parse JSON into POJOs.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.json.JsonParser.Builder}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.json.JsonParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.json.JsonParser#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.json.JsonParser#DEFAULT_STRICT DEFAULT_STRICT}
			</ul>
		</li>
	</ul>
	<p>
		The JSON parser supports ALL valid JSON, including:
	</p>
	<ul class='spaced-list'>
		<li>
			Javascript comments.
		<li>
			Single or double quoted values.
		<li>
			Quoted (strict) or unquoted (non-strict) attributes.
		<li>
			JSON fragments (such as string, numeric, or boolean primitive values).
		<li>
			Concatenated strings. 
	</ul>	
</div>
</div><!-- END: 2.24.4 - jm.JsonParsers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.JsonAnnotation' id='jm.JsonAnnotation'>2.24.5 - @Json Annotation</a></h4>
<div class='topic'><!-- START: 2.24.5 - jm.JsonAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.json.annotation.Json @Json} annotation
		is used to override the behavior of {@link org.apache.juneau.json.JsonSerializer} on individual bean classes or properties.
	</p>
	<p>
		The annotation can be applied to beans as well as other objects serialized to other types (e.g. strings).
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.json.annotation.Json}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.json.annotation.Json#wrapperAttr() wrapperAttr}
			</ul>
		</li>
	</ul>		
	<p>
		The {@link org.apache.juneau.json.annotation.Json#wrapperAttr() @Json(wrapperAttr)} annotation
		can be used to wrap beans inside a JSON object with a specified attribute name.
	</p>		
	<h5 class='figure'>Example:</h5>
	<p class='bbjavacode w800'>
	<ja>@Json</ja>(wrapperAttr=<js>"personBean"</js>)
	<jk>public class</jk> Person {
		<jk>public</jk> String <jf>name</jf> = <js>"John Smith"</js>;
	}
	</p>
	<p>
		The following shows the JSON representation with and without the annotation present:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	{
		<jok>name</jok>: <jov>'John Smith'</jov>
	}
			</td>
			<td class='code'>
	{
		<jok>personBean</jok>: {
			<jok>name</jok>: <jov>'John Smith'</jov>
		}
	}
			</td>
		</tr>
	</table>
</div>
</div><!-- END: 2.24.5 - jm.JsonAnnotation -->
</div><!-- END: 2.24 - jm.JsonDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.JsonSchemaDetails' id='jm.JsonSchemaDetails'>2.25 - JSON-Schema Support</a></h3>
<div class='topic'><!-- START: 2.25 - jm.JsonSchemaDetails -->
<div class='topic'>
	<p>
		Juneau provides the {@link org.apache.juneau.json.JsonSchemaSerializer} class for generating JSON-Schema 
		documents that describe the output generated by the {@link org.apache.juneau.json.JsonSerializer} class.
		This class shares the same properties as <c>JsonSerializer</c>.
		For convenience the {@link org.apache.juneau.json.JsonSerializer#getSchemaSerializer()} method has been 
		added for creating instances of schema serializers from the regular serializer instance.
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<p>
		The code for creating our POJO model and generating JSON-Schema is shown below:
	</p>
	<p class='bjava'>
	<jc>// Get the one of the default schema serializers.</jc>
	JsonSchemaSerializer <jv>serializer</jv> = JsonSchemaSerializer.<jsf>DEFAULT_SIMPLE_READABLE</jsf>;
	
	<jc>// Get the JSON Schema for the POJO.</jc>
	String <jv>jsonSchema</jv> = <jv>serializer</jv>.serialize(<jk>new</jk> Person());

	<jc>// This also works.</jc>
	<jv>jsonSchema</jv> = <jv>serializer</jv>.serialize(Person.<jk>class</jk>);
	</p>
	
	<h5 class='figure'>JSON Schema</h5>
	<p class='bjson'>
	{
		<jok>type: <jov>'object'</jov>, 
		<jok>description</jok>: <jov>'org.apache.juneau.sample.Person'</jov>, 
		<jok>properties</jok>: {
			<jok>name</jok>: {
				<jok>type</jok>: <jov>'string'</jov>, 
				<jok>description</jok>: <jov>'java.lang.String'</jov>
			}, 
			<jok>birthDate</jok>: {
				<jok>type</jok>: <jov>'string'</jov>, 
				<jok>description</jok>: <jov>'java.util.Calendar'</jov>
			}, 
			<jok>addresses</jok>: {
				<jok>type</jok>: <jov>'array'</jov>, 
				<jok>description</jok>: <jov>'java.util.LinkedList&lt;org.apache.juneau.sample.Address&gt;'</jov>, 
				<jok>items</jok>: {
					<jok>type</jok>: <jov>'object'</jov>, 
					<jok>description</jok>: <jov>'org.apache.juneau.sample.Address'</jov>, 
					<jok>properties</jok>: {
						<jok>street</jok>: {
							<jok>type</jok>: <jov>'string'</jov>, 
							<jok>description</jok>: <jov>'java.lang.String'</jov>
						}, 
						<jok>city</jok>: {
							<jok>type</jok>: <jov>'string'</jov>, 
							<jok>description</jok>: <jov>'java.lang.String'</jov>
						}, 
						<jok>state</jok>: {
							<jok>type</jok>: <jov>'string'</jov>, 
							<jok>description</jok>: <jov>'java.lang.String'</jov>
						}, 
						<jok>zip</jok>: {
							<jok>type</jok>: <jov>'number'</jov>, 
							<jok>description</jok>: <jov>'int'</jov>
						}, 
						<jok>isCurrent</jok>: {
							<jok>type</jok>: <jov>'boolean'</jov>, 
							<jok>description</jok>: <jov>'boolean'</jov>
						}
					}
				}
			}
		}
	}
	</p>
</div>
</div><!-- END: 2.25 - jm.JsonSchemaDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.XmlDetails' id='jm.XmlDetails'>2.26 - XML Details</a></h3>
<div class='topic'><!-- START: 2.26 - jm.XmlDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from XML using ultra-efficient serializers and parsers.
		The XML serializer converts POJOs directly to XML without the need for intermediate DOM objects.
		Likewise, the XML parser uses a STaX parser and creates POJOs directly without intermediate DOM objects. 
	</p>
	<p>
		Unlike frameworks such as JAXB, Juneau does not require POJO classes to be annotated to produce and consume 
		XML.
		However, several XML annotations are provided for handling namespaces and fine-tuning the format of the XML produced.
	</p>
	<p>
		The following example shows XML for a typical bean:
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<ja>@Bean</ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoInstant.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<ja>@Bean</ja>(typeName=<js>"address"</js>)
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<h5 class='figure'>Sample Code</h5>
	<p class='bjava'>
	Person <jv>person</jv> = <jk>new</jk> Person()
		.name(<js>"John Smith"</js>)
		.birthDate(<js>"1946-08-12T00:00:00Z"</js>)
		.addresses(
			<jk>new</jk> Address() 
				.street(<js>"100 Main Street"</js>)
				.city(<js>"Anywhereville"</js>)
				.state(<jsf>NY</jsf>)
				.zip(12345)
				.isCurrent(<jk>true</jk>);
		);
	</p>
	<h5 class='figure'>Normal XML:</h5>
	<p class='bxml'>
	<xt>&lt;person&gt;</xt>
		<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
		<xt>&lt;birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/birthDate&gt;</xt>
		<xt>&lt;addresses&gt;</xt>
			<xt>&lt;address&gt;</xt>
				<xt>&lt;street&gt;</xt>100 Main Street<xt>&lt;/street&gt;</xt>
				<xt>&lt;city&gt;</xt>Anywhereville<xt>&lt;/city&gt;</xt>
				<xt>&lt;state&gt;</xt>NY<xt>&lt;/state&gt;</xt>
				<xt>&lt;zip&gt;</xt>12345<xt>&lt;/zip&gt;</xt>
				<xt>&lt;isCurrent&gt;</xt>true<xt>&lt;/isCurrent&gt;</xt>
			<xt>&lt;/address&gt;</xt>
		<xt>&lt;/addresses&gt;</xt>
	<xt>&lt;/person&gt;</xt>
	</p>
	<p>
		Juneau produces JSON-equivalent XML, meaning any valid JSON document can be losslessly converted into an XML 
		equivalent.
		In fact, all of the Juneau serializers and parsers are built upon this JSON-equivalence.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlMethodology' id='jm.XmlMethodology'>2.26.1 - XML Methodology</a></h4>
<div class='topic'><!-- START: 2.26.1 - jm.XmlMethodology -->
<div class='topic'>
	<p>
		The following examples show how different data types are represented in XML.
		They mirror how the data structures are represented in JSON.
	
	<h5 class='topic'>Simple types</h5>
	<p>
		The representation of loose (not a direct bean property value) simple types are shown below:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>XML</th>
		</tr>
		<tr>
			<td>string</td>
			<td class='code'><js>'foo'</js></td>
			<td class='code'><xt>&lt;string&gt;</xt>foo<xt>&lt;/string&gt;</xt></td>
		</tr>
		<tr>
			<td>boolean</td>
			<td class='code'><jk>true</jk></td>
			<td class='code'><xt>&lt;boolean&gt;</xt>true<xt>&lt;/boolean&gt;</xt></td>
		</tr>
		<tr>
			<td>integer</td>
			<td class='code'>123</td>
			<td class='code'><xt>&lt;number&gt;</xt>123<xt>&lt;/number&gt;</xt></td>
		</tr>
		<tr>
			<td>float</td>
			<td class='code'>1.23</td>
			<td class='code'><xt>&lt;number&gt;</xt>1.23<xt>&lt;/number&gt;</xt></td>
		</tr>
		<tr>
			<td>null</td>
			<td class='code'><jk>null</jk></td>
			<td class='code'><xt>&lt;null/&gt;</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Maps</h5>
	<p>
		Loose maps and beans use the element <xt>&lt;object&gt;</xt> for encapsulation.
	</p>
	<p>
		<xa>_type</xa> attributes are added to bean properties or map entries if the type cannot be inferred 
		through reflection (e.g. an <c>Object</c> or superclass/interface value type).
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,String&gt;
			</td>
			<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>v1</xv>&lt;/k1&gt;
		&lt;k2 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,Number&gt;
			</td>
			<td class='code'>
	{
		k1: 123,
		k2: 1.23,
		k3: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>123</xv>&lt;/k1&gt;
		&lt;k2&gt;<xv>1.23</xv>&lt;/k2&gt;
		&lt;k3 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,Object&gt;
			</td>
			<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: 123,
		k3: 1.23,
		k4: <jk>true</jk>,
		k5: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;k1&gt;<xv>v1</xv>&lt;/k1&gt;
		&lt;k2 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;k3 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>1.23</xv>&lt;/k3&gt;
		&lt;k4 <xa>_type</xa>=<xs>'boolean'</xs>&gt;<xv>true</xv>&lt;/k4&gt;
		&lt;k5 <xa>_type</xa>=<xs>'null'</xs>/&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>

	<h5 class='topic'>Arrays</h5>
	<p>
		Loose collections and arrays use the element <xt>&lt;array&gt;</xt> for encapsulation.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	String[]
			</td>
			<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Number[]
			</td>
			<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Object[]
			</td>
			<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	String[][]
			</td>
			<td class='code'>
	[
		[<js>'foo'</js>, <jk>null</jk>],
		<jk>null</jk>,
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;array&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;null/&gt;
		&lt;/array&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>int</jk>[]
			</td>
			<td class='code'>
	[
		123
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>boolean</jk>[]
			</td>
			<td class='code'>
	[
		<jk>true</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	List&lt;String&gt;
			</td>
			<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	List&lt;Number&gt;
			</td>
			<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	List&lt;Object&gt;
			</td>
			<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;array&gt;
		&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/array&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Beans</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> String <jf>a</jf>;
		<jk>public</jk> <jk>int</jk> <jf>b</jf>;
		<jk>public</jk> Object <jf>c</jf>;  <jc>// String value</jc>
		<jk>public</jk> Object <jf>d</jf>;  <jc>// Integer value</jc>  	
		<jk>public</jk> MyBean2 <jf>e</jf>;  
		<jk>public</jk> String[] <jf>f</jf>;  
	 	<jk>public</jk> <jk>int</jk>[] <jf>g</jf>;  	
	}
	<jk>class</jk> MyBean2 {
		String <jf>h</jf>;  
	}
			</td>
			<td class='code'>
	{
		<jok>a</jok>: <jov>'foo'</jov>,
		<jok>b</jok>: <jov>123</jov>,
		<jok>c</jok>: <jov>'bar'</jov>,
		<jok>d</jok>: <jov>456</jov>,
		<jok>e</jok>: {
			<jok>h</jok>: <jov>'baz'</jov>
		}
		<jok>f</jok>: [<jov>'qux'</jov>]
		<jok>g</jok>: [<jov>789</jov>]
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
		&lt;c&gt;<xv>bar</xv>&lt;/c&gt;
		&lt;d <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>456</xv>&lt;/d&gt;
		&lt;e&gt;
			&lt;h&gt;<xv>baz</xv>&lt;/h&gt;
		&lt;/e&gt;
		&lt;f&gt;
			&lt;string&gt;<xv>qux</xv>&lt;/string&gt;
		&lt;/f&gt;
		&lt;g&gt;
			&lt;number&gt;<xv>789</xv>&lt;/number&gt;
		&lt;/g&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Beans with Map properties</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> Map&lt;String,String&gt; <jf>a</jf>;
		<jk>public</jk> Map&lt;String,Number&gt; <jf>b</jf>;
		<jk>public</jk> Map&lt;String,Object&gt; <jf>c</jf>; 
	}
			</td>
			<td class='code'>
	{
		<jok>a</jok>: {
			<jok>k1</jok>: <jov>'foo'</jov>
		},
		<jok>b</jok>: {
			<jok>k2</jok>: <jov>123</jov>
		},
		<jok>c</jok>: {
			<jok>k3</jok>: <jov>'bar'</jov>,
			<jok>k4</jok>: <jov>456</jov>,
			<jok>k5</jok>: <jov>true</jov>,
			<jok>k6</jok>: <jov>null</jov>
		}
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;<xv>foo</xv>&lt;/k1&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;k2&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;/b&gt;
		&lt;c&gt;
			&lt;k3&gt;<xv>bar</xv>&lt;/k3&gt;
			&lt;k4 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>456</xv>&lt;/k4&gt;
			&lt;k5 <xa>_type</xa>=<xs>'boolean'</xs>&gt;<xv>true</xv>&lt;/k5&gt;
			&lt;k6 <xa>_type</xa>=<xs>'null'</xs>/&gt;
		&lt;/c&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
</div>
</div><!-- END: 2.26.1 - jm.XmlMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlSerializers' id='jm.XmlSerializers'>2.26.2 - XML Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.26.2 - jm.XmlSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.xml.XmlSerializer} class is used to serialize POJOs into XML.
	</p>	
	<p>
		The {@link org.apache.juneau.xml.XmlDocSerializer} class is the same but serializes a <xt>&lt;?xml?&gt;</xt> header 
		at the top of the file.
	</p>
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.xml.XmlSerializer.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.xml.XmlSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_JUNEAU_NAMESPACE DEFAULT_JUNEAU_NAMESPACE}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS DEFAULT_NS}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS_SQ DEFAULT_NS_SQ}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS_SQ_READABLE DEFAULT_NS_SQ_READABLE}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_SQ DEFAULT_SQ}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_SQ_READABLE DEFAULT_SQ_READABLE}
				<li class='jf'>{@link org.apache.juneau.xml.XmlSerializer#DEFAULT_XS_NAMESPACE DEFAULT_XS_NAMESPACE}				
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.26.2 - jm.XmlSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlParsers' id='jm.XmlParsers'>2.26.3 - XML Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.26.3 - jm.XmlParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.xml.XmlParser} class is used to parse XML into POJOs.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.xml.XmlParser.Builder}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.xml.XmlParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.xml.XmlParser#DEFAULT DEFAULT}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.26.3 - jm.XmlParsers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlBeanTypeNameAnnotation' id='jm.XmlBeanTypeNameAnnotation'>2.26.4 - @Bean(typeName) Annotation</a></h4>
<div class='topic'><!-- START: 2.26.4 - jm.XmlBeanTypeNameAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)} annotation can be used to 
		override the Juneau default name on bean elements. 
		Types names serve two distinct purposes:
	</p>
	<ol>
		<li>To override the element name.
		<li>To serve as a class identifier so that the bean class can be inferred during parsing if it
			cannot automatically be inferred through reflection.
	</ol>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String <jf>a</jf>;
		<jk>public int</jk> <jf>b</jf>;
	}	
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
			</td>
			<td class='code'><xt>
&lt;object&gt;
	&lt;a&gt;<xv>foo</xv>&lt;/id&gt;
	&lt;b&gt;<xv>123</xv>&lt;/name&gt;
&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;X&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/id&gt;
		&lt;b&gt;<xv>123</xv>&lt;/name&gt;
	&lt;/X&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		On bean properties, a <xa>_type</xa> attribute will be added if a type name is present and the bean 
		class cannot be inferred through reflection.
	</p>
	<p>
		In the following example, a type attribute is used on property 'b' but not property 'a' since
		'b' is of type <c>Object</c> and therefore the bean class cannot be inferred.
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Java</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> BeanX <jf>a</jf> = <jk>new</jk> BeanX();
		<jk>public</jk> Object <jf>b</jf> = <jk>new</jk> BeanX();
	}
	
	<ja>@Bean</ja>(typeName=<js>"X"</js>)
	<jk>class</jk> BeanX {
		<jk>public</jk> String <jf>fx</jf> = <js>"foo"</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
		&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
		&lt;/a&gt;
		&lt;b <xa>_type</xa>=<xs>'X'</xs>&gt;
			&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
		&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<div class='info'>
		<c>string</c>, <c>number</c>, <c>boolean</c>, <c>object</c>, 
		<c>array</c>, and <c>null</c> are reserved keywords that cannot be used as type names.
	</div>
	<p>
		Beans with type names are often used in conjunction with the 
		{@link org.apache.juneau.annotation.Bean#dictionary() @Bean(dictionary)} and 
		{@link org.apache.juneau.annotation.Beanp#dictionary() @Beanp(dictionary)} 
		annotations so that the beans can be resolved at parse time.  
		These annotations are not necessary during serialization but are needed during parsing in order to 
		resolve the bean types.
	</p>
	<p>
		The following examples show how type names are used under various circumstances.  
	</p>
	<p>
		Pay special attention to when <xa>_type</xa> attributes are and are not used.
	</p>
	
	<h5 class='figure'>Examples</h5>
	<table class='styled w800'>
		<tr>
			<th>Java</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWithArrayPropertiesWithTypeNames {
		<jk>public</jk> BeanX[] <jf>b1</jf> = <jk>new</jk> BeanX[]{ 
			<jk>new</jk> BeanX() 
		};
		<jk>public</jk> Object[] <jf>b2</jf> = <jk>new</jk> BeanX[]{ 
			<jk>new</jk> BeanX() 
		};
		<jk>public</jk> Object[] <jf>b3</jf> = <jk>new</jk> Object[]{ 
			<jk>new</jk> BeanX() 
		};
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b2&gt;
		&lt;b3&gt;
			&lt;X&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/X&gt;
		&lt;/b3&gt;
	&lt;/object&gt;
			</xt></td>				
		</tr>				
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWith2dArrayPropertiesWithTypeNames {
		<jk>public</jk> BeanX[][] <jf>b1</jf> = <jk>new</jk> BeanX[][]{{
			<jk>new</jk> BeanX()
		}};
		<jk>public</jk> Object[][] <jf>b2</jf> = <jk>new</jk> BeanX[][]{{
			<jk>new</jk> BeanX()
		}};
		<jk>public</jk> Object[][] <jf>b3</jf> = <jk>new</jk> Object[][]{{
			<jk>new</jk> BeanX()
		}};
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b2&gt;
		&lt;b3&gt;
			&lt;array&gt;
				&lt;X&gt;
					&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
				&lt;/X&gt;
			&lt;/array&gt;
		&lt;/b3&gt;
	&lt;/object&gt;
			</xt></td>				
		</tr>		
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={BeanX.<jk>class</jk>})
	<jk>class</jk> BeanWithMapPropertiesWithTypeNames {
		<jk>public</jk> Map&lt;String,BeanX&gt; <jf>b1</jf> = <jk>new</jk> HashMap&lt;&gt;() {{ 
			put(<js>"k1"</js>, <jk>new</jk> BeanX()); 
		}};
		<jk>public</jk> Map&lt;String,Object&gt; <jf>b2</jf> = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k2"</js>, <jk>new</jk> BeanX());
		}}
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;b1&gt;
			&lt;k1&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/k1&gt;
		&lt;/b1&gt;
		&lt;b2&gt;
			&lt;k2 <xa>_type</xa>=<xs>'X'</xs>&gt;
				&lt;fx&gt;<xv>foo</xv>&lt;/fx&gt;
			&lt;/k2&gt;
		&lt;/b2&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		Bean type names are also used for resolution when abstract fields are used.
		The following examples show how they are used in a variety of circumstances.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Java</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractFields {
		<jk>public</jk> A <jf>a</jf> = <jk>new</jk> A();
		<jk>public</jk> IA <jf>ia</jf> = <jk>new</jk> A();
		<jk>public</jk> AA <jf>aa</jf> = <jk>new</jk> A();
		<jk>public</jk> Object <jf>o</jf> = <jk>new</jk> A();
	}
	
	<jk>interface</jk> IA {}
	
	<jk>abstract class</jk> AA <jk>implements</jk> IA {}

	<ja>@Bean</ja>(typeName=<js>"A"</js>)
	<jk>class</jk> A <jk>extends</jk> AA {
		<jk>public</jk> String <jf>fa</jf> = <js>"foo"</js>;
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/a&gt;
		&lt;ia <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/ia&gt;
		&lt;aa <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/aa&gt;
		&lt;o <xa>_type</xa>=<xs>'A'</xs>&gt;
			&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
		&lt;/o&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractArrayFields {
		<jk>public</jk> A[] <jf>a</jf> = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> IA[] <jf>ia1</jf> = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> IA[] <jf>ia2</jf> = <jk>new</jk> IA[]{<jk>new</jk> A()};
		<jk>public</jk> AA[] <jf>aa1</jf> = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> AA[] <jf>aa2</jf> = <jk>new</jk> AA[]{<jk>new</jk> A()};
		<jk>public</jk> Object[] <jf>o1</jf> = <jk>new</jk> A[]{<jk>new</jk> A()};
		<jk>public</jk> Object[] <jf>o2</jf> = <jk>new</jk> Object[]{<jk>new</jk> A()};
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/a&gt;
		&lt;ia1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/ia1&gt;
		&lt;ia2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/ia2&gt;
		&lt;aa1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/aa1&gt;
		&lt;aa2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/aa2&gt;
		&lt;o1&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/o1&gt;
		&lt;o2&gt;
			&lt;A&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/A&gt;
		&lt;/o2&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractMapFields {
		<jk>public</jk> Map&lt;String,A&gt; <jf>a</jf> = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k1"</js>, <jk>new</jk> A());
		}};
		<jk>public</jk> Map&lt;String,AA&gt; <jf>b</jf> = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k2"</js>, <jk>new</jk> A());
		}};
		<jk>public</jk> Map&lt;String,Object&gt; <jf>c</jf> = <jk>new</jk> HashMap&lt;&gt;() {{
			put(<js>"k3"</js>, <jk>new</jk> A());
		}};
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k1&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;k2 <xa>_type</xa>=<xs>'A'</xs>&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k2&gt;
		&lt;/b&gt;
		&lt;c&gt;
			&lt;k3 <xa>_type</xa>=<xs>'A'</xs>&gt;
				&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
			&lt;/k3&gt;
		&lt;/c&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(dictionary={A.<jk>class</jk>})
	<jk>class</jk> BeanWithAbstractMapArrayFields {
		<jk>public</jk> Map&lt;String,A[]&gt; <jf>a</jf> = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"a1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,IA[]&gt; <jf>ia</jf> = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"ia1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"ia2"</js>, <jk>new</jk> IA[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,AA[]&gt; <jf>aa</jf> = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"aa1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"aa2"</js>, <jk>new</jk> AA[]{<jk>new</jk> A()});
		}};
		<jk>public</jk> Map&lt;String,Object[]&gt; <jf>o</jf> = <jk>new</jk> LinkedHashMap&lt;&gt;() {{
			put(<js>"o1"</js>, <jk>new</jk> A[]{<jk>new</jk> A()});
			put(<js>"o2"</js>, <jk>new</jk> AA[]{<jk>new</jk> A()});
		}};
	}
			</td>				
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;a1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/a1&gt;
		&lt;/a&gt;
		&lt;ia&gt;
			&lt;ia1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/ia1&gt;
			&lt;ia2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/ia2&gt;
		&lt;/ia&gt;
		&lt;aa&gt;
			&lt;aa1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/aa1&gt;
			&lt;aa2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/aa2&gt;
		&lt;/aa&gt;
		&lt;o&gt;
			&lt;o1&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/o1&gt;
			&lt;o2&gt;
				&lt;A&gt;
					&lt;fa&gt;<xv>foo</xv>&lt;/fa&gt;
				&lt;/A&gt;
			&lt;/o2&gt;
		&lt;/o&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		On a side note, characters that cannot be represented in XML 1.0 are encoded using a simple encoding.
		Note in the examples below, some characters such as <js>'\n'</js>, <js>'\t</js>', and <js>'\r'</js>
		can be represented as XML entities when used in text but not in element names.  Other characters such as
		<js>'\b'</js> and <js>'\f'</js> cannot be encoded in XML 1.0 at all without inventing our own notation.
		Whitespace characters in element names are encoded as well as whitespace end characters in text.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Java</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> BeanWithSpecialCharacters {
		<jk>public</jk> String <jf>a</jf> = <js>"  \b\f\n\t\r  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>_x0020_ _x0008__x000C_&amp;#x000a;&amp;#x0009;&amp;#x000d; _x0020_</xv>&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"  \b\f\n\t\r  "</js>)
	<jk>class</jk> BeanWithNamesWithSpecialCharacters {
		<ja>@Beanp</ja>(name=<js>"  \b\f\n\t\r  "</js>)
		<jk>public</jk> String <jf>a</jf> = <js>"  \b\f\n\t\r  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
		&lt;_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
			<xv>_x0020_ _x0008__x000C_&amp;#x000a;&amp;#x0009;&amp;#x000d; _x0020_</xv>
		&lt;/_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
	&lt;/_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		While it's true that these characters CAN be represented in XML 1.1, it's impossible to parse XML 1.1 
		text in Java without the XML containing an XML declaration.
		Unfortunately, this, and the uselessness of the 
		{@link javax.xml.stream.XMLInputFactory#IS_REPLACING_ENTITY_REFERENCES} setting in Java
		forced us to make some hard design decisions that may not be the most elegant.
	</p>
</div>
</div><!-- END: 2.26.4 - jm.XmlBeanTypeNameAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlChildNameAnnotation' id='jm.XmlChildNameAnnotation'>2.26.5 - @Xml(childName) Annotation</a></h4>
<div class='topic'><!-- START: 2.26.5 - jm.XmlChildNameAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.xml.annotation.Xml#childName() @Xml(childName)} annotation can be used to 
		specify the name of XML child elements for bean properties of type collection or array.
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"X"</js>)
		<jk>public</jk> String[] <jf>a</jf>;
		<ja>@Xml</ja>(childName=<js>"Y"</js>)
		<jk>public int</jk>[] <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: [<js>'foo'</js>,<js>'bar'</js>],
		b: [123,456]
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;number&gt;<xv>123</xv>&lt;/number&gt;
			&lt;number&gt;<xv>456</xv>&lt;/number&gt;
		&lt;/b&gt;
	&lt;/object&gt;
		</xt></td>
		<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;X&gt;<xv>foo</xv>&lt;/X&gt;
			&lt;X&gt;<xv>bar</xv>&lt;/X&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;Y&gt;<xv>123</xv>&lt;/Y&gt;
			&lt;Y&gt;<xv>456</xv>&lt;/Y&gt;
		&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"child"</js>)
		<jk>public int</jk>[] <jf>a</jf>;
	}
			</td>
			<td class='code'>
	{
		a: [123,456]
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;child&gt;<xv>foo</xv>&lt;/child&gt;
			&lt;child&gt;<xv>bar</xv>&lt;/child&gt;
		&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
</div>
</div><!-- END: 2.26.5 - jm.XmlChildNameAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlFormatAnnotation' id='jm.XmlFormatAnnotation'>2.26.6 - @Xml(format) Annotation</a></h4>
<div class='topic'><!-- START: 2.26.6 - jm.XmlFormatAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.xml.annotation.Xml#format() @Xml(format)} annotation can be used to tweak 
		the XML format of a POJO.
		The value is set to an enum value of type {@link org.apache.juneau.xml.annotation.XmlFormat}.
		This annotation can be applied to both classes and bean properties.
	</p>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTR} format can be applied to bean properties to 
		serialize them as XML attributes instead of elements.
		Note that this only supports properties of simple types (e.g. strings, numbers, booleans).
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String <jf>a</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>/&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format can be applied to bean classes to 
		force all bean properties to be serialized as XML attributes instead of child elements.
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String <jf>a</jf>;
		<jk>public int</jk> <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs> <xa>b</xa>=<xs>'123'</xs>/&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENT} format can be applied to bean properties 
		to override the {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format applied on the bean 
		class.
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
	<jk>class</jk> MyBean {
		<jk>public</jk> String <jf>a</jf>;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENT</jsf>)
		<jk>public int</jk> <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>,
		b: 123
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs></xs>&gt;
		&lt;b&gt;<xv>123</xv>&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format can be applied to a single bean 
		property of type <c>Map&lt;String,Object&gt;</c> to denote arbitrary XML attribute values on the 
		element.
		These can be mixed with other {@link org.apache.juneau.xml.annotation.XmlFormat#ATTR} annotated 
		properties but there must not be an overlap in bean property names and map keys. 
	</p>
	
	<h5 class='figure'>Example</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTRS</jsf>)
		<jk>public</jk> Map&lt;String,Object&gt; <jf>a</jf>;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public int</jk> <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		<jok>a</jok>: {
			<jok>k1</jok>: <jov>'foo'</jov>, 
			<jok>k2</jok>: <jov>123</jov>, 
		},
		<jok>b</jok>: <jov>456</jov>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;k1&gt;<xv>foo</xv>&lt;/k1&gt;
			&lt;k2 <xa>_type</xa>=<xs>'number'</xs>&gt;<xv>123</xv>&lt;/k2&gt;
		&lt;/a&gt;
		&lt;b&gt;<xv>456</xv>&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object <xa>k1</xa>=<xs>'foo'</xs> <xa>k2</xa>=<xs>'123'</xs> <xa>b</xa>=<xs>'456'</xs>/&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#COLLAPSED} format can be applied to bean properties
		of type array/Collection.
		This causes the child objects to be serialized directly inside the bean element.
		This format must be used in conjunction with {@link org.apache.juneau.xml.annotation.Xml#childName() @Xml(childName)}
		to differentiate which collection the values came from if you plan on parsing the output back into beans.
		Note that child names must not conflict with other property names.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotation</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(childName=<js>"A"</js>,format=XmlFormat.<jsf>COLLAPSED</jsf>)
		<jk>public</jk> String[] <jf>a</jf>;
		<ja>@Xml</ja>(childName=<js>"B"</js>,format=XmlFormat.<jsf>COLLAPSED</jsf>)
		<jk>public int</jk>[] <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: [<js>'foo'</js>,<js>'bar'</js>],
		b: [123,456]
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;number&gt;<xv>123</xv>&lt;/number&gt;
			&lt;number&gt;<xv>456</xv>&lt;/number&gt;
		&lt;/b&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;A&gt;<xv>foo</xv>&lt;/A&gt;
		&lt;A&gt;<xv>bar</xv>&lt;/A&gt;
		&lt;B&gt;<xv>123</xv>&lt;/B&gt;
		&lt;B&gt;<xv>456</xv>&lt;/B&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENTS} format can be applied to a single bean 
		property of either a simple type or array/Collection.
		It allows free-form child elements to be formed.
		All other properties on the bean MUST be serialized as attributes.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>With annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String <jf>a</jf>;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENTS</jsf>)
		<jk>public</jk> String <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>,
		b: <js>'bar'</js>
	}
			</td>
			<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>&gt;
		&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String <jf>a</jf>;
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ELEMENTS</jsf>)
		<jk>public</jk> Object[] <jf>b</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>,
		b: [
			<js>'bar'</js>, 
			<js>'baz'</js>, 
			123, 
			<jk>true</jk>,
			<jk>null</jk>
		]
	}
			</td>
			<td class='code'><xt>
	&lt;object <xa>a</xa>=<xs>'foo'</xs>&gt;
		&lt;string&gt;<xv>bar</xv>&lt;/string&gt;
		&lt;string&gt;<xv>baz</xv>&lt;/string&gt;
		&lt;number&gt;<xv>123</xv>&lt;/number&gt;
		&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;
		&lt;null/&gt;
	&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} format is similar to 
		{@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENTS} except elements names on primitive types 
		(string/number/boolean/null) are stripped from the output.
		This format particularly useful when combined with bean dictionaries to produce mixed content.  
		The bean dictionary isn't used during serializationbut it is needed during parsing to resolve bean 
		types.
	</p>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED_PWS} format identical to 
		{@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} except whitespace characters are preserved in 
		the output.  
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotations</th>
			<th>With annotations</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<ja>@Beanp</ja>(dictionary={MyBeanX.<jk>class</jk>, MyBeanY.<jk>class</jk>})	
		<jk>public</jk> Object[] <jf>a</jf>;
	}
	
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBeanX {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String <jf>b</jf>;
	}
	
	<ja>@Bean</ja>(typeName=<js>"Y"</js>)	
	<jk>class</jk> MyBeanY {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>ATTR</jsf>)
		<jk>public</jk> String <jf>c</jf>;
	}
			</td>
			<td class='code'>
	{
		a: [
			<js>'foo'</js>,
			{ _type:<js>'X'</js>, b:<js>'bar'</js> }
			<js>'baz'</js>,
			{ _type:<js>'Y'</js>, b:<js>'qux'</js> },
			<js>'quux'</js>
		]
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;
			&lt;string&gt;<xv>foo</xv>&lt;/string&gt;
			&lt;object&gt;
				&lt;b&gt;<xv>bar</xv>&lt;/b&gt;
			&lt;/object&gt;
			&lt;string&gt;<xv>baz</xv>&lt;/string&gt;
			&lt;object&gt;
				&lt;b&gt;<xv>qux</xv>&lt;/b&gt;
			&lt;/object&gt;
			&lt;string&gt;<xv>quux</xv>&lt;/string&gt;
		&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;<xv>foo</xv>&lt;X <xa>b</xa>=<xs>'bar'</xs>/&gt;<xv>baz</xv>&lt;Y <xa>c</xa>=<xs>'qux'</xs>/&gt;<xv>quux</xv>&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		Whitespace (tabs and newlines) are not added to MIXED child nodes in readable-output mode. 
		This helps ensures strings in the serialized output can be losslessly parsed back into their original 
		forms when they contain whitespace characters.
		If the {@link javax.xml.stream.XMLInputFactory#IS_REPLACING_ENTITY_REFERENCES} setting was not useless 
		in Java, we could support lossless readable XML for MIXED content.  
		But as of Java 8, it still does not work. 
	</p>
	<p>
		XML suffers from other deficiencies as well that affect MIXED content.  
		For example, <xt>&lt;X&gt;&lt;/X&gt;</xt> and <xt>&lt;X/&gt;</xt> are equivalent in XML and 
		indistinguishable by the Java XML parsers.  
		This makes it impossible to differentiate between an empty element and an element containing an empty 
		string.  
		This causes empty strings to get lost in translation. 
		To alleviate this, we use the constructs <js>"_xE000_"</js> to represent an empty string, and 
		<js>"_x0020_"</js> to represent leading and trailing spaces.
	</p>
	<p>
		The examples below show how whitespace is handled under various circumstances:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>XML</th>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf> = <jk>null</jk>;
	}
			</td>
			<td class='code'><xt>
	&lt;X/&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>""</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>" "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>"  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020__x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>"  foobar  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_ foobar _x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String <jf>a</jf> = <jk>null</jk>;
	}
			</td>
			<td class='code'><xt>
	&lt;X/&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>""</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>" "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv> </xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>"  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>  </xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT_PWS</jsf>)
		<jk>public</jk> String <jf>a</jf> = <js>"  foobar  "</js>;
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>  foobar  </xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = <jk>null</jk>;
	}
			</td>
			<td class='code'><xt>
	&lt;X/&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>""</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>" "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>"  "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020__x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>"  foobar  "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_x0020_ foobar _x0020_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = <jk>null</jk>;
	}
			</td>
			<td class='code'><xt>
	&lt;X/&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>""</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>_xE000_</xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>" "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv> </xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>"  "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>  </xv>&lt;/X&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<ja>@Bean</ja>(typeName=<js>"X"</js>)	
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>MIXED_PWS</jsf>)
		<jk>public</jk> String[] <jf>a</jf> = {<js>"  foobar  "</js>};
	}
			</td>
			<td class='code'><xt>
	&lt;X&gt;<xv>  foobar  </xv>&lt;/X&gt;
			</xt></td>
		</tr>
	</table>
	
	<p>
		It should be noted that when using <jsf>MIXED</jsf>, you are not guaranteed to parse back the exact 
		same content since side-by-side strings in the content will end up concatenated when parsed.
	</p>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} format is similar to 
		{@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} except it's meant for solitary objects that 
		get serialized as simple child text nodes.
		Any object that can be serialize to a <c>String</c> can be used.
		The {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT_PWS} is the same except whitespace is 
		preserved in the output.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>Without annotations</th>
			<th>With annotations</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>TEXT</jsf>)
		<jk>public</jk> String <jf>a</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'foo'</js>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;
		&lt;a&gt;<xv>foo</xv>&lt;/a&gt;
	&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;<xv>foo</xv>&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		The {@link org.apache.juneau.xml.annotation.XmlFormat#XMLTEXT} format is similar to 
		{@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} except it's meant for strings containing XML 
		that should be serialized as-is to the document.
		Any object that can be serialize to a <c>String</c> can be used.
		During parsing, the element content gets parsed with the rest of the document and then re-serialized to 
		XML before being set as the property value.  
		This process may not be perfect (e.g. double quotes may be replaced by single quotes, etc...).
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>With TEXT annotation</th>
			<th>With XMLTEXT annotation</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<ja>@Xml</ja>(format=XmlFormat.<jsf>XMLTEXT</jsf>)
		<jk>public</jk> String <jf>a</jf>;
	}
			</td>
			<td class='code'>
	{
		a: <js>'Some &lt;b&gt;XML&lt;/b&gt; text'</js>
	}
			</td>
			<td class='code'><xt>
	&lt;object&gt;<xv>Some &amp;lt;b&amp;gt;XML&amp;lt;/b&amp;gt; text</xv>&lt;/object&gt;
			</xt></td>
			<td class='code'><xt>
	&lt;object&gt;<xv>Some <xt>&lt;b&gt;</xt>XML<xt>&lt;/b&gt;</xt> text</xv>&lt;/object&gt;
			</xt></td>
		</tr>
	</table>
</div>
</div><!-- END: 2.26.6 - jm.XmlFormatAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.XmlNamespaces' id='jm.XmlNamespaces'>2.26.7 - Namespaces</a></h4>
<div class='topic'><!-- START: 2.26.7 - jm.XmlNamespaces -->
<div class='topic'>
	<p>
		Let's go back to the example of our original <c>Person</c> bean class but add some namespace annotations:
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<ja>@Xml</ja>(prefix=<js>"per"</js>)
	<ja>@Bean</ja>(typeName=<js>"person"</js>)
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoInstant.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<ja>@Xml</ja>(prefix=<js>"addr"</js>)
	<ja>@Bean</ja>(typeName=<js>"address"</js>)
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public</jk> StateEnum <jf>state</jf>;
		<ja>@Xml</ja>(prefix=<js>"mail"</js>) <jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<p>
		The namespace URLs can either be defined as part of the {@link org.apache.juneau.xml.annotation.Xml @Xml}
		annotation, or can be defined at the package level with the {@link org.apache.juneau.xml.annotation.XmlSchema @XmlSchema}
		annotation.
		Below shows it defined at the package level:
	</p>
	<h5 class='figure'>package-info.java</h5>
	<p class='bjava'>
	<ja>@XmlSchema</ja>(
		prefix=<js>"ab"</js>,  <jc>// Default namespace</jc>
		xmlNs={
			<ja>@XmlNs</ja>(prefix=<js>"ab"</js>, namespaceURI=<js>"http://www.apache.org/addressBook/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"per"</js>, namespaceURI=<js>"http://www.apache.org/person/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"addr"</js>, namespaceURI=<js>"http://www.apache.org/address/"</js>),
			<ja>@XmlNs</ja>(prefix=<js>"mail"</js>, namespaceURI=<js>"http://www.apache.org/mail/"</js>)
		}
	)
	<jk>package</jk> org.apache.juneau.examples.addressbook;
	</p>		
	<h5 class='figure'>Sample Code</h5>
	<p class='bjava'>
	Person <jv>person</jv> = <jk>new</jk> Person()
		.name(<js>"John Smith"</js>)
		.birthDate(<js>"1946-08-12T00:00:00Z"</js>)
		.addresses(
			<jk>new</jk> Address() 
				.street(<js>"100 Main Street"</js>)
				.city(<js>"Anywhereville"</js>)
				.state(<jsf>NY</jsf>)
				.zip(12345)
				.isCurrent(<jk>true</jk>);
		);

	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	<jc>// Note that this is identical to XmlSerializer.DEFAULT_NS_SQ_READABLE.</jc>
	XmlSerializer <jv>serializer</jv> = XmlSerializer.<jsm>create</jsm>().ns().ws().sq().build();
	
	String <jv>xml</jv> = <jv>serializer</jv>.serialize(p);
	</p>
	<p>
		Now when we run this code, we'll see namespaces added to our output:
	</p>
	<p class='bxml'>
	<xt>&lt;per:person&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
		<xt>&lt;per:addresses&gt;</xt>
			<xt>&lt;addr:address&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/per:addresses&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
	</p>
	<p>
		Enabling the <del>XmlSerializer.XML_addNamespaceUrisToRoot</del>setting results
		in the namespace URLs being added to the root node:
	</p>
	<p class='bxml'>
	<xt>&lt;per:person</xt>
			<xa>xmlns</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns:per</xa>=<xs>'http://www.apache.org/person/'</xs>
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs>
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs>
		<xt>&gt;</xt>
		<xt>&lt;per:name&gt;</xt>John Smith<xt>&lt;/per:name&gt;</xt>
		<xt>&lt;per:birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/per:birthDate&gt;</xt>
		<xt>&lt;per:addresses&gt;</xt>
			<xt>&lt;addr:address&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/per:addresses&gt;</xt>
	<xt>&lt;/per:person&gt;</xt>
	</p>
	<p>
		We can simplify the output by setting the default namespace on the serializer so that all the elements do 
		not need to be prefixed:
	</p>
	<p class='bjava'>
	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	XmlSerializer <jv>serializer</jv> = XmlSerializer.<jsm>create</jsm>().ws().sq().ns()
		.defaultNamespaceUri(<js>"http://www.apache.org/person/"</js>)
			.build();
</p>
	<p>
		This produces the following equivalent where the elements don't need prefixes since they're already in the 
		default document namespace:
	</p>
	<p class='bxml'>
	<xt>&lt;person</xt>
			<xa>xmlns:juneau</xa>=<xs>'http://www.apache.org/2013/Juneau'</xs> 
			<xa>xmlns</xa>=<xs>'http://www.apache.org/person/'</xs>
			<xa>xmlns:addr</xa>=<xs>'http://www.apache.org/address/'</xs>
			<xa>xmlns:mail</xa>=<xs>'http://www.apache.org/mail/'</xs>
		<xt>&gt;</xt>
		<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
		<xt>&lt;birthDate&gt;</xt>1946-08-12T04:00:00Z<xt>&lt;/birthDate&gt;</xt>
		<xt>&lt;addresses&gt;</xt>
			<xt>&lt;addr:address&gt;</xt>
				<xt>&lt;mail:street&gt;</xt>100 Main Street<xt>&lt;/mail:street&gt;</xt>
				<xt>&lt;mail:city&gt;</xt>Anywhereville<xt>&lt;/mail:city&gt;</xt>
				<xt>&lt;mail:state&gt;</xt>NY<xt>&lt;/mail:state&gt;</xt>
				<xt>&lt;mail:zip&gt;</xt>12345<xt>&lt;/mail:zip&gt;</xt>
				<xt>&lt;addr:isCurrent&gt;</xt>true<xt>&lt;/addr:isCurrent&gt;</xt>
			<xt>&lt;/addr:address&gt;</xt>
		<xt>&lt;/addresses&gt;</xt>
	<xt>&lt;/person&gt;</xt>
	</p>
	<p>
		By default, the XML serializer class will make a first-pass over the data structure to look for namespaces 
		defined on classes and bean properties.
		In high-performance environments, you may want to consider disabling auto-detection and providing your 
		own explicit list of namespaces to the serializer to avoid this scanning step using 
		{@link org.apache.juneau.xml.XmlSerializer.Builder#disableAutoDetectNamespaces()}.
	</p>
	<p>
		The following code will produce the same output as before but will perform slightly better since it 
		avoids this pre-scan step.
	</p>
	<p class='bjava'>
	<jc>// Create a new serializer with readable output, this time with namespaces enabled.</jc>
	XmlSerializer <jv>serializer</jv> = XmlSerializer.<jsm>create</jsm>()
		.ws()
		.sq()
		.autoDetectNamespaces(<jk>false</jk>)
		.namespaces(<js>"{per:'http://www.apache.org/person/'}"</js>)
		.build();
	</p>
</div>
</div><!-- END: 2.26.7 - jm.XmlNamespaces -->
</div><!-- END: 2.26 - jm.XmlDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.HtmlDetails' id='jm.HtmlDetails'>2.27 - HTML Details</a></h3>
<div class='topic'><!-- START: 2.27 - jm.HtmlDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from HTML.
		Built on top of the existing XML parser, it also uses a STaX parser and creates POJOs directly without intermediate DOM objects.
	</p>
	<p>
		The primary use case for HTML serialization is rendering POJOs in easy-to-read format in REST interfaces.
	</p>		
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlMethodology' id='jm.HtmlMethodology'>2.27.1 - HTML Methodology</a></h4>
<div class='topic'><!-- START: 2.27.1 - jm.HtmlMethodology -->
<div class='topic'>
	<p>
		The following examples show how different data types are represented in HTML.
		They mirror how the data structures are represented in JSON.
	</p>
	
	<h5 class='topic'>Simple types</h5>
	<p>
		The representation for simple types mirror those produced by the XML serializer.
		Tags are added to help differentiate data types when they cannot be inferred through reflection.
		These tags are ignored by browsers and treated as plain text.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td>string</td>
			<td class='code'><js>'foo'</js></td>
			<td class='code'><xt>&lt;string&gt;</xt>foo<xt>&lt;/string&gt;</xt></td>
		</tr>
		<tr>
			<td>boolean</td>
			<td class='code'><jk>true</jk></td>
			<td class='code'><xt>&lt;boolean&gt;</xt>true<xt>&lt;/boolean&gt;</xt></td>
		</tr>
		<tr>
			<td>integer</td>
			<td class='code'>123</td>
			<td class='code'><xt>&lt;number&gt;</xt>123<xt>&lt;/number&gt;</xt></td>
		</tr>
		<tr>
			<td>float</td>
			<td class='code'>1.23</td>
			<td class='code'><xt>&lt;number&gt;</xt>1.23<xt>&lt;/number&gt;</xt></td>
		</tr>
		<tr>
			<td>null</td>
			<td class='code'><jk>null</jk></td>
			<td class='code'><xt>&lt;null/&gt;</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Maps</h5>
	<p>
		Maps and beans are represented as tables.
	</p>
	<p>
		The <xa>_type</xa> attribute is added to differentiate between objects (maps/beans) and arrays 
		(arrays/collections).
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,String&gt;
			</td>
			<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k1</xv>&lt;/td&gt;
			&lt;td&gt;<xv>v1</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k2</xv>&lt;/td&gt;
			&lt;td&gt;&lt;null/&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,Number&gt;
			</td>
			<td class='code'>
	{
		k1: 123,
		k2: 1.23,
		k3: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k1</xv>&lt;/td&gt;
			&lt;td&gt;<xv>123</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k2</xv>&lt;/td&gt;
			&lt;td&gt;<xv>1.23</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k3</xv>&lt;/td&gt;
			&lt;td&gt;&lt;null/&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Map&lt;String,Object&gt;
			</td>
			<td class='code'>
	{
		k1: <js>'v1'</js>
		k2: 123,
		k3: 1.23,
		k4: <jk>true</jk>,
		k5: <jk>null</jk>
	}
			</td>
			<td class='code'><xt>
	&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k1</xv>&lt;/td&gt;
			&lt;td&gt;<xv>v1</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k2</xv>&lt;/td&gt;
			&lt;td&gt;&lt;number&gt;<xv>123</xv>&lt;/number&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k3</xv>&lt;/td&gt;
			&lt;td&gt;&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k4</xv>&lt;/td&gt;
			&lt;td&gt;&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>k5</xv>&lt;/td&gt;
			&lt;td&gt;&lt;null/&gt;&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Arrays</h5>
	<p>
		Collections and arrays are represented as ordered lists.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
	String[]
			</td>
			<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>foo</xv>&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Number[]
			</td>
			<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>123</xv>&lt;/li&gt;
		&lt;li&gt;<xv>1.23</xv>&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	Object[]
			</td>
			<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>foo</xv>&lt;/li&gt;
		&lt;li&gt;&lt;number&gt;<xv>123</xv>&lt;/number&gt;&lt;/li&gt;
		&lt;li&gt;&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;&lt;/li&gt;
		&lt;li&gt;&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	String[][]
			</td>
			<td class='code'>
	[
		[<js>'foo'</js>, <jk>null</jk>],
		<jk>null</jk>,
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;
			&lt;ul&gt;
				&lt;li&gt;<xv>foo</xv>&lt;/li&gt;
				&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>int</jk>[]
			</td>
			<td class='code'>
	[
		123
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>123</xv>&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	<jk>boolean</jk>[]
			</td>
			<td class='code'>
	[
		<jk>true</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>true</xv>&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Collections</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
	List&lt;String&gt;
			</td>
			<td class='code'>
	[
		<js>'foo'</js>
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>foo</xv>&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	List&lt;Number&gt;
			</td>
			<td class='code'>
	[
		123,
		1.23,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>123</xv>&lt;/li&gt;
		&lt;li&gt;<xv>1.23</xv>&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
	List&lt;Object&gt;
			</td>
			<td class='code'>
	[
		<js>'foo'</js>,
		123,
		1.23,
		<jk>true</jk>,
		<jk>null</jk>
	]
			</td>
			<td class='code'><xt>
	&lt;ul&gt;
		&lt;li&gt;<xv>foo</xv>&lt;/li&gt;
		&lt;li&gt;&lt;number&gt;<xv>123</xv>&lt;/number&gt;&lt;/li&gt;
		&lt;li&gt;&lt;number&gt;<xv>1.23</xv>&lt;/number&gt;&lt;/li&gt;
		&lt;li&gt;&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;&lt;/li&gt;
		&lt;li&gt;&lt;null/&gt;&lt;/li&gt;
	&lt;/ul&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Beans</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> String <jf>a</jf>;
		<jk>public</jk> <jk>int</jk> <jf>b</jf>;
		<jk>public</jk> Object <jf>c</jf>;  <jc>// String value</jc>
		<jk>public</jk> Object <jf>d</jf>;  <jc>// Integer value</jc>  	
		<jk>public</jk> MyBean2 <jf>e</jf>;  
		<jk>public</jk> String[] <jf>f</jf>;  
	 	<jk>public</jk> <jk>int</jk>[] <jf>g</jf>;  	
	}
	<jk>class</jk> MyBean2 {
		String <jf>h</jf>;  
	}
			</td>
			<td class='code'>
	{
		<jok>a</jok>: <jov>'foo'</jov>,
		<jok>b</jok>: <jov>123</jov>,
		<jok>c</jok>: <jov>'bar'</jov>,
		<jok>d</jok>: <jov>456</jov>,
		<jok>e</jok>: {
			<jok>h</jok>: <jov>'baz'</jov>
		}
		<jok>f</jok>: [<jov>'qux'</jov>]
		<jok>g</jok>: [<jov>789</jov>]
	}
			</td>
			<td class='code'><xt>
	&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>a</xv>&lt;/td&gt;
			&lt;td&gt;<xv>foo</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>b</xv>&lt;/td&gt;
			&lt;td&gt;<xv>123</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>c</xv>&lt;/td&gt;
			&lt;td&gt;<xv>bar</xv>&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>d</xv>&lt;/td&gt;
			&lt;td&gt;&lt;number&gt;<xv>456</xv>&lt;/number&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>e</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>h</xv>&lt;/td&gt;
						&lt;td&gt;<xv>qux</xv>&lt;/td&gt;
					&lt;/tr&gt;
				&lt;/table&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>f</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;ul&gt;
					&lt;li&gt;<xv>baz</xv>&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>g</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;ul&gt;
					&lt;li&gt;<xv>789</xv>&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
			</xt></td>
		</tr>
	</table>
	
	<h5 class='topic'>Beans with Map properties</h5>
	<table class='styled w800'>
		<tr>
			<th>Data type</th>
			<th>JSON example</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
	<jk>class</jk> MyBean {
		<jk>public</jk> Map&lt;String,String&gt; <jf>a</jf>;
		<jk>public</jk> Map&lt;String,Number&gt; <jf>b</jf>;
		<jk>public</jk> Map&lt;String,Object&gt; <jf>c</jf>; 
	}
			</td>
			<td class='code'>
	{
		<jok>a</jok>: {
			<jok>k1</jok>: <jov>'foo'</jov>
		},
		<jok>b</jok>: {
			<jok>k2</jok>: <jov>123</jov>
		},
		<jok>c</jok>: {
			<jok>k3</jok>: <jov>'bar'</jov>,
			<jok>k4</jok>: <jov>456</jov>,
			<jok>k5</jok>: <jov>true</jov>,
			<jok>k6</jok>: <jov>null</jov>
		}
	}
			</td>
			<td class='code'><xt>
	&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>a</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;table _type='object'&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k1</xv>&lt;/td&gt;
						&lt;td&gt;<xv>foo</xv>&lt;/td&gt;
				&lt;/tr&gt;
				&lt;/table&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>b</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;table _type='object'&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k2</xv>&lt;/td&gt;
						&lt;td&gt;<xv>123</xv>&lt;/td&gt;
					&lt;/tr&gt;
				&lt;/table&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;<xv>c</xv>&lt;/td&gt;
			&lt;td&gt;
				&lt;table <xa>_type</xa>=<xs>'object'</xs>&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k3</xv>&lt;/td&gt;
						&lt;td&gt;<xv>bar</xv>&lt;/td&gt;
					&lt;/tr&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k4</xv>&lt;/td&gt;
						&lt;td&gt;&lt;number&gt;<xv>456</xv>&lt;/number&gt;&lt;/td&gt;
					&lt;/tr&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k5</xv>&lt;/td&gt;
						&lt;td&gt;&lt;boolean&gt;<xv>true</xv>&lt;/boolean&gt;&lt;/td&gt;
					&lt;/tr&gt;
					&lt;tr&gt;
						&lt;td&gt;<xv>k6</xv>&lt;/td&gt;
						&lt;td&gt;&lt;null/&gt;&lt;/td&gt;
					&lt;/tr&gt;
				&lt;/table&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/table&gt;
			</xt></td>
		</tr>
	</table>
</div>
</div><!-- END: 2.27.1 - jm.HtmlMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlSerializers' id='jm.HtmlSerializers'>2.27.2 - HTML Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.27.2 - jm.HtmlSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.HtmlSerializer} class is used to serialize POJOs into HTML.
	</p>	
	<p>
		The {@link org.apache.juneau.html.HtmlDocSerializer} class is the same but wraps the serialized POJO
		inside a document template consisting of header, nav, aside, and footer sections.
	</p>
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.xml.XmlSerializer.Builder}
													<ul>
														<li class='jc'>{@link org.apache.juneau.html.HtmlSerializer.Builder}
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.html.HtmlSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.html.HtmlSerializer#DEFAULT }
				<li class='jf'>{@link org.apache.juneau.html.HtmlSerializer#DEFAULT_SQ }
				<li class='jf'>{@link org.apache.juneau.html.HtmlSerializer#DEFAULT_SQ_READABLE }
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.html.HtmlDocSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.html.HtmlDocSerializer#DEFAULT }
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.27.2 - jm.HtmlSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlParsers' id='jm.HtmlParsers'>2.27.3 - HTML Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.27.3 - jm.HtmlParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.HtmlParser} class is used to parse HTML into POJOs.
		They can also parse the contents produced by {@link org.apache.juneau.html.HtmlDocSerializer}.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.html.HtmlParser.Builder}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.html.HtmlParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.html.HtmlParser#DEFAULT DEFAULT}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.27.3 - jm.HtmlParsers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlAnnotation' id='jm.HtmlAnnotation'>2.27.4 - @Html Annotation</a></h4>
<div class='topic'><!-- START: 2.27.4 - jm.HtmlAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.annotation.Html @Html} annotation can be used to customize how POJOs are serialized to HTML on a per-class/field/method basis.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.html.annotation.Html}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#anchorText() anchorText}
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#format() format}
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#link() link}
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#noTableHeaders() noTableHeaders}
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#noTables() noTables}
				<li class='jma'>{@link org.apache.juneau.html.annotation.Html#render() render}
			</ul>
		</li>
	</ul>		
	<p>
		The {@link org.apache.juneau.html.annotation.Html#link @Html(link)} annotation adds a hyperlink to a bean property when rendered as HTML.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>public class</jk> FileSpace {
		<jc>// Add a hyperlink to this bean property.</jc>
		<ja>@Html</ja>(link=<js>"servlet:/drive/{drive}"</js>)
		<jk>public</jk> String getDrive() {...}
	}			
	</p>
	<p>
		The {@link org.apache.juneau.html.annotation.Html#anchorText @Html(anchorText)} annotation is used to specify the anchor text of a hyperlink.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Produces &lt;a ...&gt;CLICK ME!&lt;/a&gt; when serialized to HTML.</jc>
	<jk>public class</jk> FileSpace {
		<jc>// Add a hyperlink to this bean property.</jc>
		<ja>@Html</ja>(link=<js>"servlet:/drive/{drive}"</js>, anchorText=<js>"CLICK ME!"</js>)
		<jk>public</jk> String getDrive() {...}
	}			
	</p>
	<p>
		The {@link org.apache.juneau.html.annotation.Html#format @Html(format)} annotation is used to specify what format to use for HTML elements.
		For example, the HTML beans defined in the {@link org.apache.juneau.dto.html5} package use <c>format=<jsf>XML</jsf></c> so that
		the beans get serialized as standard XML:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Parent class of all HTML DTO beans.</jc>
	<ja>@Html</ja>(format=<jsf>XML</jsf>)	
	<jk>public abstract class</jk> HtmlElement {...}
	</p>
	<p>
		The {@link org.apache.juneau.html.annotation.Html#noTableHeaders @Html(noTableHeaders)} annotation is used to prevent beans from being serialized with table headers.
	</p>
	<p>
		The {@link org.apache.juneau.html.annotation.Html#noTables @Html(noTables)} annotation is used to force beans to be serialized as trees instead of tables
	</p>
</div>
</div><!-- END: 2.27.4 - jm.HtmlAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlRenderAnnotation' id='jm.HtmlRenderAnnotation'>2.27.5 - @Html(render) Annotation</a></h4>
<div class='topic'><!-- START: 2.27.5 - jm.HtmlRenderAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.annotation.Html#render @Html(render)} annotation allows for custom rendering of bean property values when serialized as HTML. 
		Using this class, you can alter the CSS style and HTML content of the bean property.
	</p>
	<p>
		The following example shows two render classes that customize the appearance of the <c>pctFull</c> and
		<c>status</c> columns in the code below:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;	
			
	<jc>// Our bean class</jc>
	<jk>public class</jk> FileSpace {

		<jk>private final</jk> String <jf>drive</jf>;
		<jk>private final long</jk> <jf>total</jf>, <jf>available</jf>;

		<jk>public</jk> FileSpace(String <jv>drive</jv>, <jk>long</jk> <jv>total</jv>, <jk>long</jk> <jv>available</jv>) {
			<jk>this</jk>.<jf>drive</jf> = <jv>drive</jv>;
			<jk>this</jk>.<jf>total</jf> = <jv>total</jv>;
			<jk>this</jk>.<jf>available</jf> = <jv>available</jv>;
		}

		<ja>@Html</ja>(link=<js>"drive/{drive}"</js>)
		<jk>public</jk> String getDrive() {
			<jk>return</jk> <jf>drive</jf>;
		}

		<jk>public long</jk> getTotal() {
			<jk>return</jk> <jf>total</jf>;
		}

		<jk>public long</jk> getAvailable() {
			<jk>return</jk> <jf>available</jf>;
		}

		<ja>@Html</ja>(render=FileSpacePctRender.<jk>class</jk>)
		<jk>public float</jk> getPctFull() {
			<jk>return</jk> ((100 * <jf>available</jf>) / <jf>total</jf>);
		}

		<ja>@Html</ja>(render=FileSpaceStatusRender.<jk>class</jk>)
		<jk>public</jk> FileSpaceStatus getStatus() {
			<jk>float</jk> <jv>pf</jv> = getPctFull();
			<jk>if</jk> (<jv>pf</jv> &lt; 80)
				<jk>return</jk> FileSpaceStatus.<jsf>OK</jsf>;
			<jk>if</jk> (<jv>pf</jv> &lt; 90)
				<jk>return</jk> FileSpaceStatus.<jsf>WARNING</jsf>;
			<jk>return</jk> FileSpaceStatus.<jsf>SEVERE</jsf>;
		}
	}
	</p>
	<p class='bjava'>
	<jc>// Possible values for the getStatus() method</jc>
	<jk>public enum</jk> FileSpaceStatus {
		<jsf>OK</jsf>, <jsf>WARNING</jsf>, <jsf>SEVERE</jsf>;
	}
	</p>
	<p class='bjava'>
	<jc>// Custom render for getPctFull() method</jc>
	<jk>public class</jk> FileSpacePctRender <jk>extends</jk> HtmlRender&lt;Float&gt; {

		<ja>@Override</ja>
		<jk>public</jk> String getStyle(SerializerSession <jv>session</jv>, Float <jv>value</jv>) {
			<jk>if</jk> (<jv>value</jv> &lt; 80)
				<jk>return</jk> <js>"background-color:lightgreen;text-align:center"</js>;
			<jk>if</jk> (<jv>value</jv> &lt; 90)
				<jk>return</jk> <js>"background-color:yellow;text-align:center"</js>;
			<jk>return</jk> <js>"background-color:red;text-align:center;border:;animation:color_change 0.5s infinite alternate"</js>;
		}

		<ja>@Override</ja>
		<jk>public</jk> Object getContent(SerializerSession <jv>session</jv>, Float <jv>value</jv>) {
			<jk>if</jk> (<jv>value</jv> &gt;= 90)
				<jk>return</jk> <jsm>div</jsm>(
					String.<jsm>format</jsm>(<js>"%.0f%%"</js>, <jv>value</jv>),
					<jsm>style</jsm>(<js>"@keyframes color_change { from { background-color: red; } to { background-color: yellow; }"</js>)
				);
			<jk>return</jk> String.<jsm>format</jsm>(<js>"%.0f%%"</js>, <jv>value</jv>);
		}
	}
	</p>
	<p class='bjava'>
	<jc>// Custom render for getStatus() method</jc>
	<jk>public class</jk> FileSpaceStatusRender <jk>extends</jk> HtmlRender&lt;FileSpaceStatus&gt; {

		<ja>@Override</ja>
		<jk>public</jk> String getStyle(SerializerSession <jv>session</jv>, FileSpaceStatus <jv>value</jv>) {
			<jk>return</jk> <js>"text-align:center"</js>;
		}

		<ja>@Override</ja>
		<jk>public</jk> Object getContent(SerializerSession <jv>session</jv>, FileSpaceStatus <jv>value</jv>) {
			<jk>switch</jk> (<jv>value</jv>) {
				<jk>case</jk> <jsf>OK</jsf>:  <jk>return</jk> <jsm>img</jsm>().src(URI.<jsm>create</jsm>(<js>"servlet:/htdocs/ok.png"</js>));
				<jk>case</jk> <jsf>WARNING</jsf>:  <jk>return</jk> <jsm>img</jsm>().src(URI.<jsm>create</jsm>(<js>"servlet:/htdocs/warning.png"</js>));
				<jk>default</jk>: <jk>return</jk> <jsm>img</jsm>().src(URI.<jsm>create</jsm>(<js>"servlet:/htdocs/severe.png"</js>));
			}
		}
	}
	</p>
</div>
</div><!-- END: 2.27.5 - jm.HtmlRenderAnnotation -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlDocSerializer' id='jm.HtmlDocSerializer'>2.27.6 - HtmlDocSerializer</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.27.6 - jm.HtmlDocSerializer -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.html.HtmlDocSerializer} is an extension of {@link org.apache.juneau.html.HtmlSerializer}
		that wraps serialized POJOs in a complete HTML document. 
	</p>
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.xml.XmlSerializer.Builder}
													<ul>
														<li class='jc'>{@link org.apache.juneau.html.HtmlSerializer.Builder}
															<ul>
																<li class='jc'>{@link org.apache.juneau.html.HtmlStrippedDocSerializer.Builder}
																	<ul>
																		<li class='jc'>{@link org.apache.juneau.html.HtmlDocSerializer.Builder}
																	</ul>
																</li>
															</ul>
														</li>
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		This class is used extensively in the creation of POJO-based user interfaces in the REST API.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	<ja>@Rest</ja>(path=<js>"/helloWorld"</js>)
	<ja>@HtmlDocConfig</ja>(
		navlinks={
			<js>"up: request:/.."</js>,
			<js>"options: servlet:/?method=OPTIONS"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a resource that simply response with a 'Hello world!' message&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;The POJO serialized is a simple String.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		The {@link org.apache.juneau.html.HtmlDocSerializer.Builder#template(Class)} setting defines
		a template for the HTML page being generated.
		The default template is described next.
	</p>
</div>
</div><!-- END: 2.27.6 - jm.HtmlDocSerializer -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.BasicHtmlDocTemplate' id='jm.BasicHtmlDocTemplate'>2.27.7 - BasicHtmlDocTemplate</a></h4>
<div class='topic'><!-- START: 2.27.7 - jm.BasicHtmlDocTemplate -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.BasicHtmlDocTemplate} class defines a default template for HTML documents
		created by {@link org.apache.juneau.html.HtmlDocSerializer}.
	</p>
	<p>
		The HTML document created by this template consists of the following structure:
	</p>
	<p class='bxml'>
	<xt>&lt;html&gt;
		&lt;head&gt;
			&lt;style <xa>type</xa>=<xs>'text/css'</xs>&gt;
				<xv>CSS styles and links to stylesheets</xv>
			&lt;/style&gt;
		&lt;/head&gt;
		&lt;body&gt;
			&lt;header&gt;
				<xv>Page header</xv>
			&lt;/header&gt;
			&lt;nav&gt;
				<xv>Navigation links</xv>
			&lt;/nav&gt;
			&lt;aside&gt;
				<xv>Side-bar text</xv>
			&lt;/aside&gt;
			&lt;article&gt;
				<xv>Contents of serialized object</xv>
			&lt;/article&gt;
			&lt;footer&gt;
				<xv>Footer message</xv>
			&lt;/footer&gt;
		&lt;/body&gt;
	&lt;/html&gt;</xt>
	</p>
</div>
</div><!-- END: 2.27.7 - jm.BasicHtmlDocTemplate -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.HtmlCustomTemplates' id='jm.HtmlCustomTemplates'>2.27.8 - Custom Templates</a></h4>
<div class='topic'><!-- START: 2.27.8 - jm.HtmlCustomTemplates -->
<div class='topic'>
	<p>
		Custom page templates can be created by implementing the {@link org.apache.juneau.html.HtmlDocTemplate}
		interface and associating it with your {@link org.apache.juneau.html.HtmlDocSerializer} using the {@link org.apache.juneau.html.HtmlDocSerializer.Builder#template(Class)}
		setting.
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.html.HtmlDocTemplate}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.html.HtmlDocTemplate#writeTo(HtmlDocSerializerSession,HtmlWriter,Object) writeTo(HtmlDocSerializerSession,HtmlWriter,Object)}
			</ul>
		</li>
	</ul>
	<p>
		The interface implementation is open-ended allowing you to define the contents of the page any way you wish.
	</p>
</div>
</div><!-- END: 2.27.8 - jm.HtmlCustomTemplates -->
</div><!-- END: 2.27 - jm.HtmlDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.HtmlSchema' id='jm.HtmlSchema'>2.28 - HTML-Schema Support</a></h3>
<div class='topic'><!-- START: 2.28 - jm.HtmlSchema -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.HtmlSchemaSerializer} class is the HTML-equivalent to the
		{@link org.apache.juneau.json.JsonSchemaSerializer} class.
		It's used to generate HTML versions of JSON-Schema documents that describe the output generated by the 
		{@link org.apache.juneau.json.JsonSerializer} class.
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<p>
		The code for creating our POJO model and generating HTML-Schema is shown below:
	</p>
	<p class='bjava'>
	<jc>// Get the one of the default schema serializers.</jc>
	HtmlSchemaSerializer <jv>serializer</jv> = HtmlSchemaSerializer.<jsf>DEFAULT_SIMPLE_READABLE</jsf>;
	
	<jc>// Get the HTML Schema for the POJO.</jc>
	String <jv>htmlSchema</jv> = <jv>serializer</jv>.serialize(<jk>new</jk> Person());

	<jc>// This also works.</jc>
	<jv>htmlSchema</jv> = <jv>serializer</jv>.serialize(Person.<jk>class</jk>);
	</p>
	<p>
		The result is the HTML table shown below:
	</p>
	<table class='bordered unstyled w800'>
		<tr>
			<td>type</td>
			<td>object</td>
		</tr>
		<tr>
			<td>properties</td>
			<td>
				<table>
					<tr>
						<td>name</td>
						<td>
							<table>
								<tr>
									<td>type</td>
									<td>string</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<td>birthDate</td>
						<td>
							<table>
								<tr>
									<td>type</td>
									<td>string</td>
								</tr>
							</table>
						</td>
					</tr>
					<tr>
						<td>addresses</td>
						<td>
							<table>
								<tr>
									<td>type</td>
									<td>array</td>
								</tr>
								<tr>
									<td>items</td>
									<td>
										<table>
											<tr>
												<td>type</td>
												<td>object</td>
											</tr>
											<tr>
												<td>properties</td>
												<td>
													<table>
														<tr>
															<td>street</td>
															<td>
																<table>
																	<tr>
																		<td>type</td>
																		<td>string</td>
																	</tr>
																</table>
															</td>
														</tr>
														<tr>
															<td>city</td>
															<td>
																<table>
																	<tr>
																		<td>type</td>
																		<td>string</td>
																	</tr>
																</table>
															</td>
														</tr>
														<tr>
															<td>state</td>
															<td>
																<table>
																	<tr>
																		<td>type</td>
																		<td>string</td>
																	</tr>
																	<tr>
																		<td>enum</td>
																		<td>
																			<ul>
																				<li>AL</li>
																				<li>PA</li>
																				<li>NC</li>
																			</ul>
																		</td>
																	</tr>
																</table>
															</td>
														</tr>
														<tr>
															<td>zip</td>
															<td>
																<table>
																	<tr>
																		<td>type</td>
																		<td>integer</td>
																	</tr>
																	<tr>
																		<td>format</td>
																		<td>int32</td>
																	</tr>
																</table>
															</td>
														</tr>
														<tr>
															<td>isCurrent</td>
															<td>
																<table>
																	<tr>
																		<td>type</td>
																		<td>boolean</td>
																	</tr>
																</table>
															</td>
														</tr>
													</table>
												</td>
											</tr>
										</table>
									</td>
								</tr>
							</table>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
</div>
</div><!-- END: 2.28 - jm.HtmlSchema -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.UonDetails' id='jm.UonDetails'>2.29 - UON Details</a></h3>
<div class='topic'><!-- START: 2.29 - jm.UonDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from UON strings using ultra-efficient serializers 
		and parsers.
		The serializer converts POJOs directly to UON strings without the need for intermediate DOM objects 
		using a highly-efficient state machine.
		Likewise, the parser creates POJOs directly from UON strings without the need for intermediate DOM 
		objects. 
	</p>
	<p>
		Juneau uses UON (URL-Encoded Object Notation) for representing POJOs.  
		The UON specification can be found <a href='doc-files/rfc_uon.txt'>here</a>.
	</p>
	<p>
		The following example shows JSON for a typical bean:
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoInstant.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<h5 class='figure'>Sample Code</h5>
	<p class='bjava'>
	Person <jv>person</jv> = <jk>new</jk> Person()
		.name(<js>"John Smith"</js>)
		.birthDate(<js>"1946-08-12T00:00:00Z"</js>)
		.addresses(
			<jk>new</jk> Address() 
				.street(<js>"100 Main Street"</js>)
				.city(<js>"Anywhereville"</js>)
				.state(<jsf>NY</jsf>)
				.zip(12345)
				.isCurrent(<jk>true</jk>);
		);
	</p>
	<h5 class='figure'>UON</h5>
	<p class='buon'>
	(
		<ua>name</ua>=<us>'John+Smith'</us>,
		<ua>birthDate</ua>=<us>'1946-08-12T00:00:00Z'</us>,
		<ua>addresses</ua>=@(
			(
				<ua>street</ua>=<us>'100 Main Street'</us>,
				<ua>city</ua>=<us>Anywhereville</us>,
				<ua>state</ua>=<us>NY</us>,
				<ua>zip</ua>=<un>12345</un>,
				<ua>isCurrent</ua>=<uk>true</uk>
			)
		)
	) 
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UonMethodology' id='jm.UonMethodology'>2.29.1 - UON Methodology</a></h4>
<div class='topic'><!-- START: 2.29.1 - jm.UonMethodology -->
<div class='topic'>
	<h5 class='figure'>General methodology:</h5>
	<table class='styled w800' style='border-collapse:collapse'>
		<tr><th>Java type</th><th>JSON equivalent</th><th>UON</th></tr>
		<tr>
			<td>Maps/beans</td>
			<td>OBJECT</td>
			<td class='code'>
	<ua>a1</ua>=(<ua>b1</ua>=<us>x1</us>,<ua>b2</ua>=<us>x2</us>)
	<ua>a1</ua>=(<ua>b1</ua>=(<ua>c1</ua>=<us>x1</us>,<ua>c2</ua>=<us>x2</us>))
			</td>
		</tr>
		<tr>
			<td>Collections/arrays</td>
			<td>ARRAY</td>
			<td class='code'>
	<ua>a1</ua>=@(<us>x1</us>,<us>x2</us>)
	<ua>a1</ua>=@(@(<us>x1</us>,<us>x2</us>),@(<us>x3</us>,<us>x4</us>))
	<ua>a1</ua>=@((<ua>b1</ua>=<us>x1</us>,<ua>b2</ua>=<us>x2</us>),(<ua>c1</ua>=<us>x1</us>,<ua>c2</ua>=<us>x2</us>))
			</td>
		</tr>
		<tr>
			<td>Booleans</td>
			<td>BOOLEAN</td>
			<td class='code'>
	<ua>a1</ua>=<uk>true</uk>&amp;<ua>a2</ua>=<uk>false</uk>
			</td>
		</tr>
		<tr>
			<td>int/float/double/...</td>
			<td>NUMBER</td>
			<td class='code'>
	<ua>a1</ua>=<un>123</un>&amp;<ua>a2</ua>=<un>1.23e1</un>
			</td>
		</tr>
		<tr>
			<td>null</td>
			<td>NULL</td>
			<td class='code'>
	<ua>a1</ua>=<uk>null</uk>
			</td>
		</tr>
		<tr>
			<td>String</td>
			<td>STRING</td>
			<td class='code'>
	<ua>a1</ua>=<us>foobar</us>
	<ua>a1</ua>=<us>'true'</us>
	<ua>a1</ua>=<us>'null'</us>
	<ua>a1</ua>=<us>'123'</us>
	<ua>a1</ua>=<us>' string with whitespace '</us>
	<ua>a1</ua>=<us>'string with ~'escaped~' quotes'</us>
			</td>
		</tr>
	</table>
	<p>
		Refer to the <a href='doc-files/rfc_uon.txt'>UON specification</a> for a complete set of syntax rules.		
	</p>
</div>
</div><!-- END: 2.29.1 - jm.UonMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UonSerializers' id='jm.UonSerializers'>2.29.2 - UON Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.29.2 - jm.UonSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.uon.UonSerializer} class is used to serialize POJOs into UON.
	</p>	
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.uon.UonSerializer.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.uon.UonSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.uon.UonSerializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.uon.UonSerializer#DEFAULT_ENCODING DEFAULT_ENCODING}
				<li class='jf'>{@link org.apache.juneau.uon.UonSerializer#DEFAULT_READABLE DEFAULT_READABLE}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.29.2 - jm.UonSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UonParsers' id='jm.UonParsers'>2.29.3 - UON Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.29.3 - jm.UonParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.uon.UonParser} class is used to parse UON into POJOs.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.uon.UonParser.Builder}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.uon.UonParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.uon.UonParser#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.uon.UonParser#DEFAULT_DECODING DEFAULT_DECODING}			
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.29.3 - jm.UonParsers -->
</div><!-- END: 2.29 - jm.UonDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.UrlEncodingDetails' id='jm.UrlEncodingDetails'>2.30 - URL-Encoding Details</a></h3>
<div class='topic'><!-- START: 2.30 - jm.UrlEncodingDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from URL-encoded strings using ultra-efficient serializers 
		and parsers.
		The serializer converts POJOs directly to URL-encoded strings without the need for intermediate DOM objects 
		using a highly-efficient state machine.
		Likewise, the parser creates POJOs directly from URL-encoded strings without the need for intermediate DOM 
		objects. 
	</p>
	<p>
		Juneau uses UON (URL-Encoded Object Notation) for representing POJOs as URL-Encoded values in key-value pairs.  
		The UON specification can be found <a href='doc-files/rfc_uon.txt'>here</a>.
	</p>
	<p>
		The following example shows JSON for a typical bean:
	</p>
	<h5 class='figure'>Sample Beans</h5>
	<p class='bjava'>
	<jk>public class</jk> Person {
		
		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>name</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoInstant.<jk>class</jk>) <jk>public</jk> Calendar <jf>birthDate</jf>;
		<jk>public</jk> List&lt;Address&gt; <jf>addresses</jf>; 
	
		<jc>// Getters/setters omitted</jc>
	}
	
	<jk>public class</jk> Address {

		<jc>// Bean properties</jc>
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
		<jk>public boolean</jk> <jf>isCurrent</jf>;

		<jc>// Getters/setters omitted</jc>
	}	
	</p>
	<h5 class='figure'>Sample Code</h5>
	<p class='bjava'>
	Person <jv>person</jv> = <jk>new</jk> Person()
		.name(<js>"John Smith"</js>)
		.birthDate(<js>"1946-08-12T00:00:00Z"</js>)
		.addresses(
			<jk>new</jk> Address() 
				.street(<js>"100 Main Street"</js>)
				.city(<js>"Anywhereville"</js>)
				.state(<jsf>NY</jsf>)
				.zip(12345)
				.isCurrent(<jk>true</jk>);
		);
	</p>
	<h5 class='figure'>URL-Encoding</h5>
	<p class='burlenc'>
	<ua>name</ua>=<us>'John+Smith'</us>
	&amp;<ua>birthDate</ua>=<us>'1946-08-12T00:00:00Z'</us>
	&amp;<ua>addresses</ua>=@(
		(
			<ua>street</ua>=<us>'100 Main Street'</us>,
			<ua>city</ua>=<us>Anywhereville</us>,
			<ua>state</ua>=<us>NY</us>,
			<ua>zip</ua>=<un>12345</un>,
			<ua>isCurrent</ua>=<uk>true</uk>
		)
	)
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UrlEncMethodology' id='jm.UrlEncMethodology'>2.30.1 - URL-Encoding Methodology</a></h4>
<div class='topic'><!-- START: 2.30.1 - jm.UrlEncMethodology -->
<div class='topic'>
	<h5 class='figure'>General methodology:</h5>
	<table class='styled w800' style='border-collapse:collapse'>
		<tr><th>Java type</th><th>JSON equivalent</th><th>UON</th></tr>
		<tr>
			<td>Maps/beans</td>
			<td>OBJECT</td>
			<td class='code'>
	<ua>a1</ua>=(<ua>b1</ua>=<us>x1</us>,<ua>b2</ua>=<us>x2</us>)
	<ua>a1</ua>=(<ua>b1</ua>=(<ua>c1</ua>=<us>x1</us>,<ua>c2</ua>=<us>x2</us>))
			</td>
		</tr>
		<tr>
			<td>Collections/arrays</td>
			<td>ARRAY</td>
			<td class='code'>
	<ua>a1</ua>=@(<us>x1</us>,<us>x2</us>)
	<ua>a1</ua>=@(@(<us>x1</us>,<us>x2</us>),@(<us>x3</us>,<us>x4</us>))
	<ua>a1</ua>=@((<ua>b1</ua>=<us>x1</us>,<ua>b2</ua>=<us>x2</us>),(<ua>c1</ua>=<us>x1</us>,<ua>c2</ua>=<us>x2</us>))
			</td>
		</tr>
		<tr>
			<td>Booleans</td>
			<td>BOOLEAN</td>
			<td class='code'>
	<ua>a1</ua>=<uk>true</uk>&amp;<ua>a2</ua>=<uk>false</uk>
			</td>
		</tr>
		<tr>
			<td>int/float/double/...</td>
			<td>NUMBER</td>
			<td class='code'>
	<ua>a1</ua>=<un>123</un>&amp;<ua>a2</ua>=<un>1.23e1</un>
			</td>
		</tr>
		<tr>
			<td>null</td>
			<td>NULL</td>
			<td class='code'>
	<ua>a1</ua>=<uk>null</uk>
			</td>
		</tr>
		<tr>
			<td>String</td>
			<td>STRING</td>
			<td class='code'>
	<ua>a1</ua>=<us>foobar</us>
	<ua>a1</ua>=<us>'true'</us>
	<ua>a1</ua>=<us>'null'</us>
	<ua>a1</ua>=<us>'123'</us>
	<ua>a1</ua>=<us>' string with whitespace '</us>
	<ua>a1</ua>=<us>'string with ~'escaped~' quotes'</us>
			</td>
		</tr>
	</table>
	<p>
		Refer to the <a href='doc-files/rfc_uon.txt'>UON specification</a> for a complete set of syntax rules.		
	</p>
</div>
</div><!-- END: 2.30.1 - jm.UrlEncMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UrlEncSerializers' id='jm.UrlEncSerializers'>2.30.2 - URL-Encoding Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.30.2 - jm.UrlEncSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.urlencoding.UrlEncodingSerializer} class is used to serialize POJOs into URL-Encoding.
	</p>	
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.uon.UonSerializer.Builder}
													<ul>
														<li class='jc'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer.Builder}
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer#DEFAULT DEFAULT}
				<li class='jf'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer#DEFAULT_EXPANDED DEFAULT_EXPANDED}
				<li class='jf'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer#DEFAULT_PLAINTEXT DEFAULT_PLAINTEXT}
				<li class='jf'>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer#DEFAULT_READABLE DEFAULT_READABLE}		
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.30.2 - jm.UrlEncSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UrlEncParsers' id='jm.UrlEncParsers'>2.30.3 - URL-Encoding Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.30.3 - jm.UrlEncParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.urlencoding.UrlEncodingParser} class is used to parse URL-Encoding into POJOs.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.uon.UonParser.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.urlencoding.UrlEncodingParser.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.urlencoding.UrlEncodingParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.urlencoding.UrlEncodingParser#DEFAULT DEFAULT}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.30.3 - jm.UrlEncParsers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.UrlEncodingAnnotation' id='jm.UrlEncodingAnnotation'>2.30.4 - @UrlEncoding Annotation</a></h4>
<div class='topic'><!-- START: 2.30.4 - jm.UrlEncodingAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.urlencoding.annotation.UrlEncoding @UrlEncoding} annotation
		is used to override the behavior of {@link org.apache.juneau.urlencoding.UrlEncodingSerializer} on individual bean classes or properties.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.urlencoding.annotation.UrlEncoding}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.urlencoding.annotation.UrlEncoding#expandedParams() expandedParams}
			</ul>
		</li>
	</ul>		
	<p>
		The {@link org.apache.juneau.urlencoding.annotation.UrlEncoding#expandedParams() expandedParams} setting is
		used to force bean properties of type array or Collection to be expanded into multiple key/value pairings.
	</p>
</div>
</div><!-- END: 2.30.4 - jm.UrlEncodingAnnotation -->
</div><!-- END: 2.30 - jm.UrlEncodingDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.MsgPackDetails' id='jm.MsgPackDetails'>2.31 - MessagePack Details</a></h3>
<div class='topic'><!-- START: 2.31 - jm.MsgPackDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from MessagePack using ultra-efficient serializers 
		and parsers.
	</p>
	<p>
		MessagePack is a compact binary form of JSON.
		The serialization support for MessagePack mirrors that of JSON.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.MsgPackSerializers' id='jm.MsgPackSerializers'>2.31.1 - MessagePack Serializers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.31.1 - jm.MsgPackSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.msgpack.MsgPackSerializer} class is used to serialize POJOs into MessagePack.
	</p>	
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.OutputStreamSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.msgpack.MsgPackSerializer.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured serializers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.msgpack.MsgPackSerializer}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.msgpack.MsgPackSerializer#DEFAULT DEFAULT}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.31.1 - jm.MsgPackSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.MsgPackParsers' id='jm.MsgPackParsers'>2.31.2 - MessagePack Parsers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.31.2 - jm.MsgPackParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.msgpack.MsgPackParser} class is used to parse MessagePack into POJOs.
	</p>	
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.InputStreamParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.msgpack.MsgPackParser.Builder}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following pre-configured parsers are provided for convenience:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.msgpack.MsgPackParser}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.msgpack.MsgPackParser#DEFAULT DEFAULT}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 2.31.2 - jm.MsgPackParsers -->
</div><!-- END: 2.31 - jm.MsgPackDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.OpenApiDetails' id='jm.OpenApiDetails'>2.32 - OpenAPI Details</a><span class='update'>updated: 8.2.0</span></h3>
<div class='topic'><!-- START: 2.32 - jm.OpenApiDetails -->
<div class='topic'>
	<p>
		Juneau supports converting arbitrary POJOs to and from strings using OpenAPI-based schema rules. 
	</p>
	<p>
		The relevant classes for using OpenAPI-based serialization are:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.oapi.OpenApiSerializer} - Converts POJOs to strings.
		<li class='jc'>{@link org.apache.juneau.oapi.OpenApiParser} - Converts strings to POJOs.
		<li class='jc'>{@link org.apache.juneau.httppart.HttpPartSchema} - Defines the schema for your POJO.
	</ul>
	<p>
		The {@link org.apache.juneau.httppart.HttpPartSchema} class is used to define the formatting and 
		validations for a POJO.
		It's used in conjunction with the serializer and parser to produce and consume HTTP parts based on 
		OpenAPI rules.
	</p>
	<p>
		Later in the rest-server and rest-client sections, we also describe how the following annotations
		can be applied to method parameters and class types to define the schema for various HTTP parts:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
		<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
	</ul>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.OpenApiMethodology' id='jm.OpenApiMethodology'>2.32.1 - OpenAPI Methodology</a><span class='update'>updated: 8.2.0</span></h4>
<div class='topic'><!-- START: 2.32.1 - jm.OpenApiMethodology -->
<div class='topic'>
	<p>
		Unlike the other Juneau serializers and parsers that convert input and output directly to-and-from POJOs,
		the OpenAPI serializers and parsers use intermediate objects based on the <c>type</c> and <c>format</c>
		of the schema.
	</p>
	<p>
		The following table shows the "natural" intermediate type of the object based on the <c>type/format</c>:
	</p>
	<table class='styled w800'>
		<tr><th>Type</th><th>Format</th><th>Intermediate Java Type</th></tr>
		<tr class='dark bb'>
			<td rowspan='4'><c>string</c> or empty</td>
			<td><c>byte<br>binary<br>binary-spaced</c></td>
			<td><c><jk>byte</jk>[]</c></td>
		</tr>
		<tr class='dark bb'>
			<td><c>date<br>date-time</c></td>
			<td>{@link java.util.Calendar}</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>No intermediate type.<br>(serialized directly to/from POJO)</td>
		</tr>
		<tr class='dark bb'>
			<td>empty</td>
			<td>{@link java.lang.String}</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='1'><c>boolean</c></td>
			<td>empty</td>
			<td>{@link java.lang.Boolean}</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>integer</c></td>
			<td><c>int32</c></td>
			<td>{@link java.lang.Integer}</td>
		</tr>
		<tr class='dark bb'>
			<td><c>int64</c></td>
			<td>{@link java.lang.Long}</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>number</c></td>
			<td><c>float</c></td>
			<td>{@link java.lang.Float}</td>
		</tr>
		<tr class='light bb'>
			<td><c>double</c></td>
			<td>{@link java.lang.Double}</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>array</c></td>
			<td>empty</td>
			<td>Arrays of intermediate types on this list.</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>No intermediate type.<br>(serialized directly to/from POJO)</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>object</c></td>
			<td>empty</td>
			<td><c>Map&lt;String,Object&gt;</c></td>
		</tr>
		<tr class='light bb'>
			<td><c>uon</c></td>
			<td>No intermediate type.<br>(serialized directly to/from POJO)</td>
		</tr>
	</table>
	<p>
		The valid POJO types for serializing/parsing are based on the intermediate types above.
		As a general rule, any POJOs that are the intermediate type or transformable to or from
		the intermediate type are valid POJO types.
	</p>
	<p>
		For example, the following POJO type can be transformed to and from a byte array.
	</p>
	<p class='bjava'>
	<jc>// Sample POJO class convertable to and from a byte[].</jc>
	<jk>public class</jk> MyPojo {
		
		<jc>// Constructor used by parser.</jc>
		<jk>public</jk> MyPojo(<jk>byte</jk>[] <jv>value</jv>) {...}
	
		<jc>// toX method used by serializer.</jc>
		<jk>public byte</jk>[] toBytes() {...}
	}
	</p>
	<p>
		This example shows how that POJO can be converted to a BASE64-encoded string.
	</p>
	<p class='bjava'>
	<jc>// Construct a POJO.</jc>
	MyPojo <jv>myPojo</jv> = ...;
	
	<jc>// Define a schema.</jc>
	HttpPartSchema <jv>schema</jv> = HttpPartSchema.<jsm>tByte</jsm>().build();

	<jc>// Convert POJO to BASE64-encoded string.</jc>
	HttpPartSerializer <jv>serializer</jv> = OpenApiSerializer.<jsf>DEFAULT</jsf>;
	String <jv>httpPart</jv> = <jv>serializer</jv>.serialize(<jv>schema</jv>, <jv>myPojo</jv>);
	
	<jc>// Convert BASE64-encoded string back into a POJO.</jc>
	HttpPartParser <jv>parser</jv> = OpenApiParser.<jsf>DEFAULT</jsf>;
	<jv>myPojo</jv> = <jv>parser</jv>.parse(<jv>schema</jv>, <jv>httpPart</jv>, MyPojo.<jk>class</jk>);
	</p>
	<p>
		In addition to defining format, the schema also allows for validations of the serialized form.
	</p>
	<p class='bjava'>
	<jc>// Construct a POJO.</jc>
	MyPojo <jv>myPojo</jv> = ...;
	
	<jc>// Define a schema.</jc>
	<jc>// Serialized string must be no smaller than 100 characters.</jc>
	HttpPartSchema <jv>schema</jv> = HttpPartSchema.<jsm>tByte</jsm>().minLength(100).build();

	<jc>// Convert POJO to BASE64-encoded string.</jc>
	HttpPartSerializer <jv>serializer</jv> = OpenApiSerializer.<jsf>DEFAULT</jsf>;
	String <jv>httpPart</jv>;
	<jk>try</jk> {
		<jv>httpPart</jv> = <jv>serializer</jv>.serialize(<jv>schema</jv>, <jv>myPojo</jv>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, output too small.</jc>
	}
	
	<jc>// Convert BASE64-encoded string back into a POJO.</jc>
	HttpPartParser <jv>parser</jv> = OpenApiParser.<jsf>DEFAULT</jsf>;
	<jk>try</jk> {
		<jv>myPojo</jv> = <jv>parser</jv>.parse(<jv>schema</jv>, <jv>httpPart</jv>, MyPojo.<jk>class</jk>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, input too small.</jc>
	}
	</p>
	<p>
		It looks simple but the implementation is highly sophisticated being able to serialize and parse and validate using complex schemas.
	</p>
	<p>
		The next sections go more into depth on serializing and parsing various POJO types.
	</p>
</div>
</div><!-- END: 2.32.1 - jm.OpenApiMethodology -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.OpenApiSerializers' id='jm.OpenApiSerializers'>2.32.2 - OpenAPI Serializers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.32.2 - jm.OpenApiSerializers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.oapi.OpenApiSerializer} class is used to convert POJOs to HTTP parts.
	</p>
	<p>
		The class hierarchy for the builder of this serializer is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.BeanTraverseContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
									<ul>
										<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.uon.UonSerializer.Builder}
													<ul>
														<li class='jc'>{@link org.apache.juneau.oapi.OpenApiSerializer.Builder}
													</ul>
												</li>
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		Later we'll describe how to use HTTP-Part annotations to define OpenAPI schemas for serialization and parsing
		of HTTP parts.  
		The following example is a preview showing an HTTP body defined as pipe-delimited list of comma-delimited numbers (e.g. <js>"1,2,3|4,5,6|7,8,9"</js>):
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(<js>"/2dLongArray"</js>)	
	<jk>public void</jk> post2dLongArray(
		<ja>@Content</ja>(
			schema=<ja>@Schema</ja>(
				type=<js>"array"</js>,
				collectionFormat=<js>"pipes"</js>,
				items=<ja>@Items</ja>(
					type=<js>"array"</js>,
					collectionFormat=<js>"csv"</js>,
					items=<ja>@SubItems</ja>(
						type=<js>"integer"</js>, 
						format=<js>"int64"</js>,
						minimum=<js>"0"</js>,
						maximum=<js>"100"</js>
						minLength=1,
						maxLength=10
					)
				)
				minLength=1,
				maxLength=10
			)
		)
		Long[][] body
	) {...}

	<jc>// Alternate shortened format.</jc>
	<ja>@RestPost</ja>(<js>"/2dLongArray"</js>)	
	<jk>public void</jk> post2dLongArray(
		<ja>@Content</ja>(
			schema=<ja>@Schema</ja>(
				t=<js>"array"</js>,
				cf=<js>"pipes"</js>,
				i=<ja>@Items</ja>(
					t=<js>"array"</js>,
					cf=<js>"csv"</js>,
					i=<ja>@SubItems</ja>(
						t=<js>"integer"</js>, 
						f=<js>"int64"</js>,
						min=<js>"0"</js>,
						max=<js>"100"</js>
						minl=1,
						maxl=10
					)
				)
				minl=1,
				maxl=10
			)
		)
		Long[][] body
	) {...}
	</p>
	<p>
		Under-the-covers, this gets converted to the following schema object:
	</p>
	<p class='bjava'>
	HttpPartSchema <jv>schema</jv> = HttpPartSchema.<jsm>create</jsm>()
		.items(
			HttpPartSchema.<jsm>create</jsm>()
				.type(<js>"array"</js>)
				.collectionFormat(<js>"pipes"</js>)
				.items(
					HttpPartSchema.<jsm>create</jsm>()
						.type(<js>"array"</js>)
						.collectionFormat(<js>"csv"</js>)
						.items(
							HttpPartSchema.<jsm>create</jsm>()
								.type(<js>"integer"</js>) 
								.format(<js>"int64"</js>)
								.minimum(0)
								.maximum(100)
								.minLength(1)
								.maxLength(10)
						)
				)
		)
		.build();
	</p>
	<p>
		Various convenience methods exist for shortening this code.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpPartSchema.*;

	HttpPartSchema <jv>schema</jv> = <jsm>tArrayPipes</jsm>(
		<jsm>tArrayCsv</jsm>(
			<jsm>tInt64</jsm>().minimum(0).maximum(100).minLength(1).maxLength(10)
		)
	).build();
	</p>
	<p>
		The following code shows how the schema above can be used to create our pipe+csv list of numbers:
	</p>
	<p class='bjava'>
	<jc>// Our POJO being serialized.</jc>
	Long[][] <jv>input</jv> = ....
	
	<jc>// Convert POJO to a string.</jc>
	<jk>try</jk> {
		String <jv>httpPart</jv> = OpenApi.<jsm>of</jsm>(<jv>schema</jv>, <jv>input</jv>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, one of the restrictions were not met.</jc>
	}
	</p>
	<p>
		As a general rule, any POJO convertible to the intermediate type for the <c>type/format</c> of the schema can
		be serialized using the OpenAPI serializer.
		Here are the rules of POJO types allowed for various type/format combinations:
	</p>
	<table class='styled w800'>
		<tr><th>Type</th><th>Format</th><th>Valid parameter types</th></tr>
		<tr class='dark bb'>
			<td rowspan='4'><c>string</c> or empty</td>
			<td><c>byte<br>binary<br>binary-spaced</c></td>
			<td>
				<ul>
					<li><c><jk>byte</jk>[]</c> (default)
					<li>{@link java.io.InputStream}
					<li>{@link java.io.Reader} - Read into String and then converted using {@link java.lang.String#getBytes()}.
					<li>{@link java.lang.Object} - Converted to String and then converted using {@link java.lang.String#getBytes()}.
					<li>Any POJO transformable to a <c><jk>byte</jk>[]</c> via the following methods:
						<ul>
							<li><c><jk>public byte</jk>[] toBytes() {...}</c>
							<li><c><jk>public byte</jk>[]</jk> toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a <c><jk>byte</jk>[]</c> via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>date<br>date-time</c></td>
			<td>
				<ul>
					<li>{@link java.util.Calendar} (default)
					<li>{@link java.util.Date}
					<li>Any POJO transformable to a {@link java.util.Calendar} via the following methods:
						<ul>
							<li><c><jk>public</jk> Calendar toCalendar() {...}</c>
							<li><c><jk>public</jk> Calendar toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a {@link java.util.Calendar} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Serializable POJO</a> type.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td>empty</td>
			<td>
				<ul>
					<li>{@link java.lang.String} (default)
					<li>Any POJO transformable to a {@link java.lang.String} via the following methods:
						<ul>
							<li><c><jk>public</jk> String toString() {...}</c>
						</ul>
					<li>Any POJO transformable to a {@link java.lang.String} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='1'><c>boolean</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li>{@link java.lang.Boolean} (default)
					<li><jk>boolean</jk>
					<li>{@link java.lang.String} - Converted to a {@link java.lang.Boolean}.
					<li>Any POJO transformable to a {@link java.lang.Boolean} via the following methods:
						<ul>
							<li><c><jk>public</jk> Boolean toBoolean() {...}</c>
							<li><c><jk>public</jk> Boolean toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a {@link java.lang.Boolean} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>integer</c></td>
			<td><c>int32</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Integer} (default)
					<li><jk>int</jk>
					<li>{@link java.lang.String} - Converted to an {@link java.lang.String}.
					<li>Any POJO transformable to an {@link java.lang.Integer} via the following methods:
						<ul>
							<li><c><jk>public</jk> Integer toInteger() {...}</c>
							<li><c><jk>public</jk> Integer toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to an {@link java.lang.Integer} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>int64</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Long} (default)
					<li><jk>long</jk>
					<li>{@link java.lang.String} - Converted to a {@link java.lang.Long}.
					<li>Any POJO transformable to a {@link java.lang.Long} via the following methods:
						<ul>
							<li><c><jk>public</jk> Long toLong() {...}</c>
							<li><c><jk>public</jk> Long toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a {@link java.lang.Long} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>number</c></td>
			<td><c>float</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Float} (default)
					<li><jk>float</jk>
					<li>{@link java.lang.String} - Converted to a {@link java.lang.Float}.
					<li>Any POJO transformable to a {@link java.lang.Float} via the following methods:
						<ul>
							<li><c><jk>public</jk> Float toFloat() {...}</c>
							<li><c><jk>public</jk> Float toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a {@link java.lang.Float} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td><c>double</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Double} (default)
					<li><jk>double</jk>
					<li>{@link java.lang.String} - Converted to a {@link java.lang.Double}.
					<li>Any POJO transformable to a {@link java.lang.Double} via the following methods:
						<ul>
							<li><c><jk>public</jk> Double toDouble() {...}</c>
							<li><c><jk>public</jk> Double toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to a {@link java.lang.Double} via an {@link org.apache.juneau.swap.ObjectSwap}.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>array</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li>Arrays or Collections of any defaults on this list.
					<li>Any POJO transformable to arrays of the default types (e.g. <c>Integer[]</c>, <c>Boolean[][]</c>, etc...).
						<br>For example:
						<ul>
							<li><c><jk>public</jk> Boolean[][] toFoo() {...}</c> (any method name starting with "to")
						</ul>
					<li>Any POJO transformable to arrays of the default types via an {@link org.apache.juneau.swap.ObjectSwap}
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Serializable POJO</a> type.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>object</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li><c>Map&lt;String,Object&gt;</c> (default)
					<li>Beans with properties of anything on this list.
					<li>Any POJO transformable to a map via an {@link org.apache.juneau.swap.ObjectSwap}
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Serializable POJO</a> type.
				</ul>
			</td>
		</tr>
	</table>
	<p>
		For arrays, an example of "Any POJO transformable to arrays of the default types" is:
	</p>
	<p class='bjava'>
	<jc>// Sample POJO class convertable to a Long[][].</jc>
	<jk>public class</jk> MyPojo {
		
		<jc>// toX method used by serializer.</jc>
		<jk>public</jk> Long[][] to2dLongs() {...}
	}
	</p>
	<p>
		In the example above, our POJO class can be used to create our pipe-delimited list of comma-delimited numbers: 
	</p>
	<p class='bjava'>
	<jc>// Our POJO being serialized.</jc>
	MyPojo <jv>input</jv> = ....
	
	<jc>// Convert POJO to a string.</jc>
	<jk>try</jk> {
		String <jv>httpPart</jv> = OpenApi.<jsm>of</jsm>(<jv>schema</jv>, <jv>input</jv>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, one of the restrictions were not met.</jc>
	}
	</p>
	<p>
		The <c>object</c> type is not officially part of the OpenAPI standard.  
		However, Juneau supports serializing Maps and beans to HTTP parts using UON notation.
	</p>
	<p>
		The following shows an example of a bean with several properties of various types.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jk>private static byte</jk>[] <jsf>FOOB</jsf> = <js>"foo"</js>.getBytes();

		<jk>public</jk> String <jf>f1</jf> = <js>"foo"</js>;
		<jk>public byte</jk>[] <jf>f2</jf> = <jsf>FOOB</jsf>;
		<jk>public byte</jk>[] <jf>f3</jf> = <jsf>FOOB</jsf>;
		<jk>public byte</jk>[] <jf>f4</jf> = <jsf>FOOB</jsf>;
		<jk>public</jk> Calendar <jf>f5</jf> = <jsm>parseIsoCalendar</jsm>(<js>"2012-12-21T12:34:56Z"</js>);
		<jk>public</jk> String <jf>f6</jf> = <js>"foo"</js>;
		<jk>public int</jk> <jf>f7</jf> = 1;
		<jk>public</jk> Long <jf>f8</jf> = 2l;
		<jk>public float</jk> <jf>f9</jf> = 1.0;
		<jk>public</jk> Double <jf>f10</jf> = 1.0;
		<jk>public</jk> Boolean <jf>f11</jf> = <jk>true</jk>;
		<jk>public</jk> Object <jf>fExtra</jf> = "1";
	}
	</p>
	<p>
		We define the following schema:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;
	
	HttpPartSchema <jv>schema</jv> = tObject()
		.prop(<js>"f1"</js>, <jsm>tString</jsm>())
		.prop(<js>"f2"</js>, <jsm>tByte</jsm>())
		.prop(<js>"f3"</js>, <jsm>tBinary</jsm>())
		.prop(<js>"f4"</js>, <jsm>tBinarySpaced</jsm>())
		.prop(<js>"f5"</js>, <jsm>tDateTime</jsm>())
		.prop(<js>"f6"</js>, <jsm>tUon</jsm>())
		.prop(<js>"f7"</js>, <jsm>tInteger</jsm>())
		.prop(<js>"f8"</js>, <jsm>tInt64</jsm>())
		.prop(<js>"f9"</js>, <jsm>tNumber</jsm>())
		.prop(<js>"f10"</js>, <jsm>tDouble</jsm>())
		.prop(<js>"f11"</js>, <jsm>tBoolean</jsm>())
		.ap(<jsm>tInteger</jsm>())
		.build();
	</p>
	<p>
		Then we serialize our bean:
	</p>
	<p class='bjava'>
	String <jv>httpPart</jv> = OpenApi.<jsm>of</jsm>(<jv>schema</jv>, <jk>new</jk> MyBean());
	</p>
	<p>
		The results of this serialization is shown below:
	</p>
	<p class='buon'>
	(
		f1=foo,
		f2=Zm9v,
		f3=666F6F,
		f4='66 6F 6F',
		f5=2012-12-21T12:34:56Z,
		f6=foo,
		f7=1,
		f8=2,
		f9=1.0,
		f10=1.0,
		f11=true,
		fExtra=1
	)
	</p>
	<p>
		The following is an example of a bean with various array property types:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jk>private static byte</jk>[] <jsf>FOOB</jsf> = <js>"foo"</js>.getBytes();
	
		<jk>public</jk> String[] <jf>f1</jf> = {<js>"a,b"</js>,<jk>null</jk>}, 
		<jk>public byte</jk>[][] <jf>f2</jf> = <jk>new byte</jk>[][]{<jsf>FOOB</jsf>,<jk>null</jk>}, 
		<jk>public byte</jk>[][] <jf>f3</jf> = <jk>new byte</jk>[][]{<jsf>FOOB</jsf>,<jk>null</jk>},
		<jk>public byte</jk>[][] <jf>f4</jf> = <jk>new byte</jk>[][]{<jsf>FOOB</jsf>,<jk>null</jk>},
		<jk>public</jk> Calendar[] <jf>f5</jf> = <jk>new</jk> Calendar[]{<jsm>parseIsoCalendar</jsm>(<js>"2012-12-21T12:34:56Z"</js>),<jk>null</jk>},
		<jk>public</jk> String[] <jf>f6</jf> = {<js>"a"</js>,<js>"b"</js>,<jk>null</jk>},
		<jk>public int</jk>[] <jf>f7</jf> = <jk>new int</jk>[]{1,2,<jk>null</jk>}, 
		<jk>public</jk> Integer[] <jf>f8</jf> = <jk>new</jk> Integer[]{3,4,<jk>null</jk>}, 
		<jk>public float</jk>[] <jf>f9</jf> = <jk>new float</jk>[]{1f,2f,<jk>null</jk>}, 
		<jk>public</jk> Float[] <jf>f10</jf> = <jk>new</jk> Float[]{3f,4f,<jk>null</jk>}, 
		<jk>public</jk> Boolean[] <jf>f11</jf> = <jk>new</jk> Boolean[]{<jk>true</jk>,<jk>false</jk>,<jk>null</jk>}, 
		<jk>public</jk> Object[] <jf>fExtra</jf> = <jk>new</jk> Object[]{1,<js>"2"</js>,<jk>null</jk>};
	}
	</p>
	<p>
		For this bean, we define the following schema:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;

	HttpPartSchema <jv>schema</jv> = <jsm>tObject</jsm>()
		.prop(<js>"f1"</js>, <jsm>tArray</jsm>(<jsm>tString</jsm>()))
		.prop(<js>"f2"</js>, <jsm>tArray</jsm>(<jsm>tByte</jsm>()))
		.prop(<js>"f3"</js>, <jsm>tArray</jsm>(<jsm>tBinary</jsm>()))
		.prop(<js>"f4"</js>, <jsm>tArray</jsm>(<jsm>tBinarySpaced</jsm>()))
		.prop(<js>"f5"</js>, <jsm>tArray</jsm>(<jsm>tDateTime</jsm>()))
		.prop(<js>"f6"</js>, <jsm>tArray</jsm>(<jsm>tUon</jsm>()))
		.prop(<js>"f7"</js>, <jsm>tArray</jsm>(<jsm>tInteger</jsm>()))
		.prop(<js>"f8"</js>, <jsm>tArray</jsm>(<jsm>tInt64</jsm>()))
		.prop(<js>"f9"</js>, <jsm>tArray</jsm>(<jsm>tNumber</jsm>()))
		.prop(<js>"f10"</js>, <jsm>tArray</jsm>(<jsm>tDouble</jsm>()))
		.prop(<js>"f11"</js>, <jsm>tArray</jsm>(<jsm>tBoolean</jsm>()))
		.ap(<jsm>tArray</jsm>(<jsm>tInteger</jsm>()))
		.build();
	</p>
	<p>
		Serializing this bean produces the following output:
	</p>
	<p class='buon'>
	(
		f1=@('a,b',null),
		f2=@(Zm9v,null),
		f4=@(2012-12-21T12:34:56Z,null),
		f5=@(666F6F,null),
		f6=@('66 6F 6F',null),
		f7=@(a,b,null),
		f8=@(1,2,null),
		f9=@(3,4,null),
		f10=@(1.0,2.0,null),
		f11=@(3.0,4.0,null),
		f12=@(true,false,null),
		fExtra=@(1,2,null)
	)
	</p>
	<ul class='notes'>
		<li class='note'>
			Array properties can also use CSV/SSV/PIPES for array notation.
			<br>Various notations can be mixed throughout.
		<li class='note'>
			Schemas and POJOs can be defined arbitrarily deep.
		<li class='note'>
			Schemas are optional.
			They can be skipped or partially defined.
		<li class='note'>
			We make our best attempt to convert the input to the matching type.  
			However, you will get <c>SerializeExceptions</c> if you attempt an impossible conversion.
			(e.g. trying to serialize the string "foo" as a boolean). 
	</ul>
</div>
</div><!-- END: 2.32.2 - jm.OpenApiSerializers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jm.OpenApiParsers' id='jm.OpenApiParsers'>2.32.3 - OpenAPI Parsers</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 2.32.3 - jm.OpenApiParsers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.oapi.OpenApiParser} class is used to convert HTTP parts back into POJOs.
	</p>
	<p>
		The class hierarchy for the builder of this parser is:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.Context.Builder}
			<ul>
				<li class='jac'>{@link org.apache.juneau.BeanContextable.Builder}
					<ul>
						<li class='jac'>{@link org.apache.juneau.parser.Parser.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.parser.ReaderParser.Builder}
									<ul>
										<li class='jc'>{@link org.apache.juneau.uon.UonParser.Builder}
											<ul>
												<li class='jc'>{@link org.apache.juneau.oapi.OpenApiParser.Builder}
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		Refer to the builder javadocs for configurable settings.
	</p>
	<p>
		The following is the previous example of a schema that defines the format of a pipe-delimited list of comma-delimited numbers (e.g. <js>"1,2,3|4,5,6|7,8,9"</js>):
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;

	HttpPartSchema <jv>schema</jv> = <jsm>tArrayPipes</jsm>(
		<jsm>tArrayCsv</jsm>(
			<jsm>tInt64</jsm>().min(0).max(100).minl(1).maxl(10)
		)
	).build();
	</p>
	<p>
		The following code shows how the schema above can be used to parse our input into a POJO:
	</p>
	<p class='bjava'>
	<jc>// Our input being parsed.</jc>
	String <jv>input</jv> = <js>"1,2,3|4,5,6|7,8,9"</js>
	
	<jc>// Convert string to a POJO.</jc>
	<jk>try</jk> {
		Long[][] <jv>pojo</jv> = OpenApi.<jsm>to</jsm>(<jv>schema</jv>, <jv>input</jv>, Long[][].<jk>class</jk>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, one of the restrictions were not met.</jc>
	}
	</p>
	<p>
		As a general rule, any POJO convertible from the intermediate type for the <c>type/format</c> of the schema can
		be parsed using the OpenAPI parser.
		Here are the rules of POJO types allowed for various type/format combinations:
	</p>
	<table class='styled w800'>
		<tr><th>Type</th><th>Format</th><th>Valid parameter types</th></tr>
		<tr class='dark bb'>
			<td rowspan='4'><c>string</c> or empty</td>
			<td><c>byte<br>binary<br>binary-spaced</c></td>
			<td>
				<ul>
					<li><c><jk>byte</jk>[]</c> (default)
					<li>{@link java.io.InputStream} - Returns a {@link java.io.ByteArrayInputStream}.
					<li>{@link java.io.Reader} - Returns a {@link java.io.InputStreamReader} wrapped around a {@link java.io.ByteArrayInputStream}.
					<li>{@link java.lang.String} - Constructed using {@link java.lang.String#String(byte[])}.
					<li>{@link java.lang.Object} - Returns the default <c><jk>byte</jk>[]</c>.
					<li>Any POJO transformable from a <c><jk>byte</jk>[]</c> (via constructors or static create methods).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>date<br>date-time</c></td>
			<td>
				<ul>
					<li>{@link java.util.Calendar} (default)
					<li>{@link java.util.Date}
					<li>{@link java.util.GregorianCalendar}
					<li>{@link java.lang.String} - Converted using {@link java.util.Calendar#toString()}.
					<li>{@link java.lang.Object} - Returns the default {@link java.util.Calendar}.
					<li>Any POJO transformable from a {@link java.util.Calendar} (via constructors or static create methods).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Parsable POJO</a> type.
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td>empty</td>
			<td>
				<ul>
					<li>{@link java.lang.String} (default)
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.String}.
					<li>Any POJO transformable from a {@link java.lang.String} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='1'><c>boolean</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li>{@link java.lang.Boolean} (default)
					<li><jk>boolean</jk>
					<li>{@link java.lang.String}
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.Boolean}.
					<li>Any POJO transformable from a {@link java.lang.Boolean} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>integer</c></td>
			<td><c>int32</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Integer} (default)
					<li>Any subclass of {@link java.lang.Number} 
					<li>Any primitive number:  (e.g <jk>int</jk>, <jk>float</jk>...)
					<li>{@link java.lang.String}
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.Integer}.
					<li>Any POJO transformable from an {@link java.lang.Integer} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>int64</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Long} (default)
					<li>Any subclass of {@link java.lang.Number} 
					<li>Any primitive number:  (e.g <jk>int</jk>, <jk>float</jk>...)
					<li>{@link java.lang.String}
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.Long}.
					<li>Any POJO transformable from an {@link java.lang.Long} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>number</c></td>
			<td><c>float</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Float} (default)
					<li>Any subclass of {@link java.lang.Number} 
					<li>Any primitive number:  (e.g <jk>int</jk>, <jk>float</jk>...)
					<li>{@link java.lang.String}
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.Float}.
					<li>Any POJO transformable from an {@link java.lang.Float} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td><c>double</c></td>
			<td>
				<ul>
					<li>{@link java.lang.Double} (default)
					<li>Any subclass of {@link java.lang.Number} 
					<li>Any primitive number:  (e.g <jk>int</jk>, <jk>float</jk>...)
					<li>{@link java.lang.String}
					<li>{@link java.lang.Object} - Returns the default {@link java.lang.Double}.
					<li>Any POJO transformable from an {@link java.lang.Double} (via constructors, static create methods, or swaps).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2'><c>array</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li>Arrays or Collections of anything on this list.
					<li>Any POJO transformable from arrays of the default types (e.g. <c>Integer[]</c>, <c>Boolean[][]</c>, etc...).
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Parsable POJO</a> type.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2'><c>object</c></td>
			<td>empty</td>
			<td>
				<ul>
					<li><c>Map&lt;String,Object&gt;</c> (default)
					<li>Beans with properties of anything on this list.
					<li>Maps with string keys.
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td><c>uon</c></td>
			<td>
				<ul>
					<li>Any <a class="doclink" href="#jm.PojoCategories">Parsable POJO</a> type.
				</ul>
			</td>
		</tr>
	</table>
	<p>
		Additionally, any of the type above can also be wrapped as {@link java.util.Optional Optionals}.
	</p>
	
	<p>
		For arrays, an example of "Any POJO transformable from arrays of the default types" is:
	</p>
	<p class='bjava'>
	<jc>// Sample POJO class convertable from a Long[][].</jc>
	<jk>public class</jk> MyPojo {
		
		<jc>// Constructor used by parser.</jc>
		<jk>public</jk> MyPojo(Long[][] <jv>from2dLongs</jv>) {...}
	}
	</p>
	<p>
		In the example above, our POJO class can be constructed from our pipe-delimited list of comma-delimited numbers: 
	</p>
	<p class='bjava'>
	<jc>// Our input being parsed.</jc>
	String <jv>input</jv> = <js>"1,2,3|4,5,6|7,8,9"</js>
	
	<jc>// Convert string to a POJO.</jc>
	<jk>try</jk> {
		MyPojo <jv>pojo</jv> = OpenApi.<jsm>to</jsm>(<jv>schema</jv>, <jv>input</jv>, MyPojo.<jk>class</jk>);
	} <jk>catch</jk> (SchemaValidationException <jv>e</jv>) {
		<jc>// Oops, one of the restrictions were not met.</jc>
	}
	</p>
	<p>
		Just like serialization, the <c>object</c> type is not officially part of the OpenAPI standard but
		Juneau supports parsing HTTP parts in UON notation to Maps and beans.
	</p>
	<p>
		The following shows an example of a bean with several properties of various types.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jk>public</jk> String <jf>f1</jf>;
		<jk>public byte</jk>[] <jf>f2</jf>;
		<jk>public byte</jk>[] <jf>f3</jf>;
		<jk>public byte</jk>[] <jf>f4</jf>;
		<jk>public</jk> Calendar <jf>f5</jf>;
		<jk>public</jk> String <jf>f6</jf>;
		<jk>public int</jk> <jf>f7</jf>;
		<jk>public</jk> Long <jf>f8</jf>;
		<jk>public float</jk> <jf>f9</jf>;
		<jk>public</jk> Double <jf>f10</jf>;
		<jk>public</jk> Boolean <jf>f11</jf>;
		<jk>public</jk> Object <jf>fExtra</jf>;
	}
	</p>
	<p>
		We define the following schema again:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;
	
	HttpPartSchema <jv>schema</jv> = <jsm>tObject</jsm>()
		.prop(<js>"f1"</js>, <jsm>tString</jsm>())
		.prop(<js>"f2"</js>, <jsm>tByte</jsm>())
		.prop(<js>"f3"</js>, <jsm>tBinary</jsm>())
		.prop(<js>"f4"</js>, <jsm>tBinarySpaced</jsm>())
		.prop(<js>"f5"</js>, <jsm>tDateTime</jsm>())
		.prop(<js>"f6"</js>, <jsm>tUon</jsm>())
		.prop(<js>"f7"</js>, <jsm>tInteger</jsm>())
		.prop(<js>"f8"</js>, <jsm>tInt64</jsm>())
		.prop(<js>"f9"</js>, <jsm>tNumber</jsm>())
		.prop(<js>"f10"</js>, <jsm>tDouble</jsm>())
		.prop(<js>"f11"</js>, <jsm>tBoolean</jsm>())
		.ap(<jsm>tInteger</jsm>())
		.build();
	</p>
	<p>
		Then we parse our input into our POJO:
	</p>
	<p class='bjava'>
	String <jv>input</jv> = 
		<js>"(f1=foo,f2=Zm9v,f3=666F6F,f4='66 6F 6F',f5=2012-12-21T12:34:56Z,f6=foo,"</js>
		+ <js>"f7=1,f8=2,f9=1.0,f10=1.0,f11=true,fExtra=1)"</js>;
	
	MyBean <jv>bean</jv> = OpenApi.<jsm>to</jsm>(<jv>schema</jv>, <jv>input</jv>, MyBean.<jk>class</jk>);
	</p>
	<p>
		Note that serializing into generic <c>Object</c> properties would have produced similar results:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyBean {
		<jk>public</jk> Object <jf>f1</jf>;
		<jk>public</jk> Object <jf>f2</jf>;
		<jk>public</jk> Object <jf>f3</jf>;
		<jk>public</jk> Object <jf>f4</jf>;
		<jk>public</jk> Object <jf>f5</jf>;
		<jk>public</jk> Object <jf>f6</jf>;
		<jk>public</jk> Object <jf>f7</jf>;
		<jk>public</jk> Object <jf>f8</jf>;
		<jk>public</jk> Object <jf>f9</jf>;
		<jk>public</jk> Object <jf>f10</jf>;
		<jk>public</jk> Object <jf>f11</jf>;
		<jk>public</jk> Object <jf>fExtra</jf>;
	}
	</p>
	<p>
		We can also parse into Maps as well:
	</p>
	<p class='bjava'>
	String <jv>input</jv> = 
		<js>"(f1=foo,f2=Zm9v,f3=666F6F,f4='66 6F 6F',f5=2012-12-21T12:34:56Z,f6=foo,"</js>
		+ <js>"f7=1,f8=2,f9=1.0,f10=1.0,f11=true,fExtra=1)"</js>;
	
	JsonMap <jv>map</jv> = OpenApi.<jsm>to</jsm>(<jv>schema</jv>, <jv>input</jv>, JsonMap.<jk>class</jk>);
	</p>
	<ul class='notes'>
		<li class='note'>
			Array properties can also use CSV/SSV/PIPES for array notation.
			<br>Various notations can be mixed throughout.
		<li class='note'>
			Schemas and POJOs can be defined arbitrarily deep.
		<li class='note'>
			Schemas are optional.
			They can be skipped or partially defined.
		<li class='note'>
			We make our best attempt to convert the output to the matching type.  
			However, you will get <c>ParseExceptions</c> if you attempt an impossible conversion.
			(e.g. trying to parse the string "foo" into a boolean). 
	</ul>
</div>
</div><!-- END: 2.32.3 - jm.OpenApiParsers -->
</div><!-- END: 2.32 - jm.OpenApiDetails -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jm.BestPractices' id='jm.BestPractices'>2.33 - Best Practices</a></h3>
<div class='topic'><!-- START: 2.33 - jm.BestPractices -->
<div class='topic'>
	<ol class='spaced-list'>
		<li>
			Reuse instances of serializers and parsers whenever possible.
			<br>They are designed to be thread safe and maintain internal caches of bean metadata to increase performance.
		<li>
			The {@link org.apache.juneau.BeanTraverseContext.Builder#detectRecursions()} 
			option can cause a performance penalty of 
			around 20%.  
			<br>Therefore, it's recommended that this option be used only when necessary. 
		<li>
			In general, JSON serialization and parsing is about 20% faster than XML.  
			JSON is also more compact than XML.
			<br>MessagePack is fastest and most compact of all.
		<li>
			The RDF parsers are SLOW.
			<br>RDF simply isn't efficient with node traversal, so creating tree structures out of RDF models
			is highly inefficient.  	
		<li>
			The {@link org.apache.juneau.parser.Parser} methods that take in {@link org.apache.juneau.ClassMeta} 
			parameters are slightly faster than methods that 
			take in {@link java.lang.Class} or {@link java.lang.Object} parameters, since the latter methods involve 
			hash lookups to resolve to {@link org.apache.juneau.ClassMeta} parameters.
	</ol>
</div>
</div><!-- END: 2.33 - jm.BestPractices -->
</div><!-- END: 2 - juneau-marshall -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-marshall-rdf' id='juneau-marshall-rdf'>3 - juneau-marshall-rdf</a></h2>
<div class='topic'><!-- START: 3 - juneau-marshall-rdf -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-marshall-rdf<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-marshall-rdf-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.marshaller.rdf_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	<p>
		The <c>juneau-marshall-rdf</c> library provides additional serializers and parsers for RDF.
		These rely on the Apache Jena library to provide support for the following languages:
	</p>
	<ul>
		<li>RDF/XML
		<li>RDF/XML-Abbrev 	
		<li>N-Triple
		<li>Turtle
		<li>N3
	</ul>				
</div>
</div><!-- END: 3 - juneau-marshall-rdf -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-dto' id='juneau-dto'>4 - juneau-dto</a></h2>
<div class='topic'><!-- START: 4 - juneau-dto -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-dto<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-dto-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.dto_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	<p>
		The <c>juneau-dto</c> library contains several predefined POJOs for generating commonly-used document types.
		This section describes support for these POJOs.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jd.Html5' id='jd.Html5'>4.1 - HTML5</a></h3>
<div class='topic'><!-- START: 4.1 - jd.Html5 -->
<div class='topic'>
	<p>
		The Juneau HTML5 DTOs are simply beans with fluent-style setters that allow you to quickly construct HTML
		fragments as Java objects.  These object can then be serialized to HTML using one of the existing HTML 
		serializers, or to other languages such as JSON using the JSON serializers.
	</p>
	<p>
		The {@link org.apache.juneau.dto.html5.HtmlBuilder} class is a utility class with predefined static methods
		that allow you to easily construct DTO instances in a minimal amount of code. 
	</p>
	<p>
		The following examples show how to create common HTML DOM objects.
	</p>
	<table class='styled w800'>
		<tr>
			<th>Java code</th>
			<th>HTML</th>
		</tr>
		<tr>
			<td class='code'>
		<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
		
		Object <jv>mytable</jv> = 	
			<jsm>table</jsm>(
				<jsm>tr</jsm>(
					<jsm>th</jsm>(<js>"c1"</js>),
					<jsm>th</jsm>(<js>"c2"</js>)
				),
				<jsm>tr</jsm>(
					<jsm>td</jsm>(<js>"v1"</js>),
					<jsm>td</jsm>(<js>"v2"</js>)
				)
			);
	
		String <jv>html</jv> = Html.<jsm>of</jsm>(<jv>mytablE</jv>);
			</td>
			<td class='code'><xt>
		&lt;table&gt;
			&lt;tr&gt;
				&lt;th&gt;<xv>c1</xv>&lt;/th&gt;
				&lt;th&gt;<xv>c2</xv>&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;<xv>v1</xv>&lt;/td&gt;
				&lt;td&gt;<xv>v2</xv>&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/table&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
		<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
			
		Object <jv>mydiv</jv> = 	
			<jsm>div</jsm>().align(<js>"center"</js>).onmouseover(<js>"alert(\"boo!\");"</js>)
			.children(
				<jsm>p</jsm>(<js>"Juneau supports "</js>, <jsm>b</jsm>(<jsm>i</jsm>(<js>"mixed"</js>)), <js>" content!"</js>)
			);
	
		String <jv>html</jv> = Html.<jsm>of</jsm>(<jv>mydiv</jv>);
			</td>
			<td class='code'><xt>
		&lt;div <xa>align</xa>=<xs>'center'</xs> <xa>onmouseover</xa>=<xs>'alert("boo!");'</xs>&gt;
			&lt;p&gt;<xv>Juneau supports </xv>&lt;b&gt;&lt;i&gt;<xv>mixed</xv>&lt;/i&gt;&lt;/b&gt; <xv>content!</xv>&lt;/p&gt;
		&lt;/table&gt;
			</xt></td>
		</tr>
		<tr>
			<td class='code'>
		<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
			
		Object <jv>myform</jv> =
			<jsm>form</jsm>().action(<js>"/submit"</js>).method(<js>"POST"</js>)
			.children(
				<js>"Position (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"pos"</js>).value(1), <jsm>br</jsm>(),
				<js>"Limit (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"limit"</js>).value(100), <jsm>br</jsm>(),
				<jsm>button</jsm>(<js>"submit"</js>, <js>"Submit"</js>),
				<jsm>button</jsm>(<js>"reset"</js>, <js>"Reset"</js>)
			); 	
	
		String <jv>html</jv> = Html.<jsm>of</jsm>(<jv>myform</jv>);
			</td>
			<td class='code'><xt>
			&lt;form <xa>action</xa>=<xs>'/submit'</xs> <xa>method</xa>=<xs>'POST'</xs>&gt;
				<xv>Position (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> 
					<xa>value</xa>=<xs>'1'</xs>/&gt;&lt;br/&gt;
				<xv>Limit (1-10000):</xv> &lt;input <xa>name</xa>=<xs>'pos'</xs> <xa>type</xa>=<xs>'number'</xs> 
					<xa>value</xa>=<xs>'100'</xs>/&gt;&lt;br/&gt;
				&lt;button <xa>type</xa>=<xs>'submit'</xs>&gt;<xv>Submit</xv>&lt;/button&gt;
				&lt;button <xa>type</xa>=<xs>'reset'</xs>&gt;<xv>Reset</xv>&lt;/button&gt;			 
			&lt;/form&gt;
			</xt></td>
		</tr>
	</table>
	<p>
		Using the HTML5 DTOs, you should be able to construct any valid HTML5 from full document bodies
		to any possible fragments.
	</p>
	<p>
		The {@link org.apache.juneau.html.HtmlParser} class can be used convert these HTML documents back
		into POJOs.
	</p>
	<p>
		Other serializers and parsers (e.g. {@link org.apache.juneau.json.JsonSerializer}) can be used to 
		represent these POJOs in languages other than HTML.
	</p>
</div>
</div><!-- END: 4.1 - jd.Html5 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jd.Atom' id='jd.Atom'>4.2 - Atom</a></h3>
<div class='topic'><!-- START: 4.2 - jd.Atom -->
<div class='topic'>
	<p>
		The Juneau ATOM feed DTOs are simply beans with fluent-style setters.
		The following code shows a feed being created programmatically using the 
		{@link org.apache.juneau.dto.atom.AtomBuilder} class.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.atom.AtomBuilder.*;
	
	Feed <jv>feed</jv> = 
		<jsm>feed</jsm>(<js>"tag:juneau.apache.org"</js>, <js>"Juneau ATOM specification"</js>, <js>"2016-01-02T03:04:05Z"</js>)
		.setSubtitle(<jsm>text</jsm>(<js>"html"</js>).setText(<js>"Describes &lt;em&gt;stuff&lt;/em&gt; about Juneau"</js>))
		.setLinks(
			<jsm>link</jsm>(<js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org"</js>).setHreflang(<js>"en"</js>),
			<jsm>link</jsm>(<js>"self"</js>, <js>"application/atom+xml"</js>, <js>"http://juneau.apache.org/feed.atom"</js>)
		)
		.setRights(<js>"Copyright (c) ..."</js>)
		.setGenerator(
			<jsm>generator</jsm>(<js>"Juneau"</js>).setUri(<js>"http://juneau.apache.org/"</js>).setVersion(<js>"1.0"</js>)
		)
		.setEntries(
			<jsm>entry</jsm>(<js>"tag:juneau.sample.com,2013:1.2345"</js>, <js>"Juneau ATOM specification snapshot"</js>, <js>"2016-01-02T03:04:05Z"</js>)
			.setLinks(
				<jsm>link</jsm><js>"alternate"</js>, <js>"text/html"</js>, <js>"http://juneau.apache.org/juneau.atom"</js>),
				<jsm>link</jsm>(<js>"enclosure"</js>, <js>"audio/mpeg"</js>, <js>"http://juneau.apache.org/audio/juneau_podcast.mp3"</js>).setLength(1337)
			)
			.setPublished(<js>"2016-01-02T03:04:05Z"</js>)
			.setAuthors(
				<jsm>person</jsm>(<js>"Jane Smith"</js>).setUri(<js>"http://juneau.apache.org/"</js>).setEmail(<js>"janesmith@apache.org"</js>)
			)
			.setContributors(
				<jsm>person</jsm>(<js>"John Smith"</js>)
			)
			.setContent(
				<jsm>content</jsm>(<js>"xhtml"</js>)
				.setLang(<js>"en"</js>)
				.setBase(<js>"http://www.apache.org/"</js>)
				.setText(<js>"&lt;div&gt;&lt;p&gt;&lt;i&gt;[Update: Juneau supports ATOM.]&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;"</js>)
			)
		);
	</p>
	<p>
		To serialize this to ATOM, use the {@link org.apache.juneau.xml.XmlSerializer} class:
	</p>
	
	<h5 class='figure'>Example with no namespaces</h5>
	<p class='bjava'>
	<jc>// Create a serializer with readable output, no namespaces yet.</jc>
	XmlSerializer <jv>serializer</jv> = XmlSerializer.<jsm>create</jsm>().sq().ws().build();

	<jc>// Serialize to ATOM/XML</jc>
	String <jv>atomXml</jv> = <jv>serializer</jv>.serialize(<jv>feed</jv>);
	</p>
	
	<h5 class='figure'>Results</h5>
	<p class='bxml'>
	<xt>&lt;feed&gt;</xt>
		<xt>&lt;id&gt;</xt>
			tag:juneau.apache.org
		<xt>&lt;/id&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/'</xs> <xa>rel</xa>=<xs>'alternate'</xs> 
			<xa>type</xa>=<xs>'text/html'</xs> <xa>hreflang</xa>=<xs>'en'</xs>/<xt>&gt;</xt>
		<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/feed.atom'</xs> <xa>rel</xa>=<xs>'self'</xs> 
			<xa>type</xa>=<xs>'application/atom+xml'</xs>/<xt>&gt;</xt>
		<xt>&lt;rights&gt;</xt>
			Copyright (c) ...
		<xt>&lt;/rights&gt;</xt>
		<xt>&lt;title</xt> <xa>type</xa>=<xs>'text'</xs>&gt;</xt>
			Juneau ATOM specification
		<xt>&lt;/title&gt;</xt>
		<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
		<xt>&lt;generator</xt> <xa>uri</xa>=<xs>'http://juneau.apache.org/'</xs> <xa>version</xa>=<xs>'1.0'</xs><xt>&gt;</xt>
			Juneau
		<xt>&lt;/generator&gt;</xt>
		<xt>&lt;subtitle</xt> <xa>type</xa>=<xs>'html'</xs><xt>&gt;</xt>
			Describes <xt>&lt;em&gt;</xt>stuff<xt>&lt;/em&gt;</xt> about Juneau
		<xt>&lt;/subtitle&gt;</xt>
		<xt>&lt;entry&gt;</xt>
			<xt>&lt;author&gt;</xt>
				<xt>&lt;name&gt;</xt>Jane Smith<xt>&lt;/name&gt;</xt>
				<xt>&lt;uri&gt;</xt>http://juneau.apache.org/<xt>&lt;/uri&gt;</xt>
				<xt>&lt;email&gt;</xt>janesmith@apache.org<xt>&lt;/email&gt;</xt>
			<xt>&lt;/author&gt;</xt>
			<xt>&lt;contributor&gt;</xt>
				<xt>&lt;name&gt;</xt>John Smith<xt>&lt;/name&gt;</xt>
			<xt>&lt;/contributor&gt;</xt>
			<xt>&lt;id&gt;</xt>
				tag:juneau.apache.org
			<xt>&lt;/id&gt;</xt>
			<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/juneau.atom'</xs> 
				<xa>rel</xa>=<xs>'alternate'</xs> <xa>type</xa>=<xs>'text/html'</xs>/<xt>&gt;</xt>
			<xt>&lt;link</xt> <xa>href</xa>=<xs>'http://juneau.apache.org/audio/juneau_podcast.mp3'</xs> 
				<xa>rel</xa>=<xs>'enclosure'</xs> <xa>type</xa>=<xs>'audio/mpeg'</xs> <xa>length</xa>=<xs>'12345'</xs>/<xt>&gt;</xt>
			<xt>&lt;title&gt;</xt>
				Juneau ATOM specification snapshot
			<xt>&lt;/title&gt;</xt>
			<xt>&lt;updated&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/updated&gt;</xt>
			<xt>&lt;content</xt> <xa>base</xa>=<xs>'http://www.apache.org/'</xs> <xa>lang</xa>=<xs>'en'</xs> 
				<xa>type</xa>=<xs>'xhtml'</xs><xt>&gt;</xt>
				<xt>&lt;div</xt> <xa>xmlns</xa>=<xs>"http://www.w3.org/1999/xhtml"</xs>
					<xt>&gt;&lt;p&gt;&lt;i&gt;</xt>[Update: Juneau supports ATOM.]<xt>&lt;/i&gt;&lt;/p&gt;&lt;/div&gt;</xt>
			<xt>&lt;/content&gt;</xt>
			<xt>&lt;published&gt;</xt>2016-01-02T03:04:05Z<xt>&lt;/published&gt;</xt>
		<xt>&lt;/entry&gt;</xt>
	<xt>&lt;/feed&gt;</xt>		
	</p>
	<p>
		The {@link org.apache.juneau.xml.XmlParser} class can be used convert these Atom documents back into POJOs.
	</p>
	<p>
		Other serializers and parsers (e.g. {@link org.apache.juneau.json.JsonSerializer}) can be used to 
		represent these POJOs in languages other than XML.
	</p>
</div>
</div><!-- END: 4.2 - jd.Atom -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jd.Swagger' id='jd.Swagger'>4.3 - Swagger</a></h3>
<div class='topic'><!-- START: 4.3 - jd.Swagger -->
<div class='topic'>
	<p>
		The Juneau Swagger DTOs are simply beans with fluent-style setters that allow you to quickly construct 
		Swagger documents as Java objects.  
		These object can then be serialized to JSON using one of the existing JSON serializers, or to other 
		languages such as XML or HTML using the other serializers.
	</p>
	<p>
		The {@link org.apache.juneau.dto.swagger.SwaggerBuilder} class is a utility class with predefined static 
		methods that allow you to easily construct DTO instances in a minimal amount of code. 
	</p>
	<p>
		The following is an example Swagger document from the 
		<a href='http://petstore.swagger.io/'>Swagger website</a>.
	</p>
	<p class='bjson'>
	{
		<jok>"swagger"</jok>: <jov>"2.0"</jov>,
		<jok>"info"</jok>: {
			<jok>"title"</jok>: <jov>"Swagger Petstore"</jov>,
			<jok>"description"</jok>: <jov>"This is a sample server Petstore server."</jov>,
			<jok>"version"</jok>: <jov>"1.0.0"</jov>,
			<jok>"termsOfService"</jok>: <jov>"http://swagger.io/terms/"</jov>,
			<jok>"contact"</jok>: {
				<jok>"email"</jok>: <jov>"apiteam@swagger.io"</jov>
			},
			<jok>"license"</jok>: {
				<jok>"name"</jok>: <jov>"Apache 2.0"</jov>,
				<jok>"url"</jok>: <jov>"http://www.apache.org/licenses/LICENSE-2.0.html"</jov>
			}
		},
		<jok>"host"</jok>: <jov>"petstore.swagger.io"</jov>,
		<jok>"basePath"</jok>: <jov>"/v2"</jov>,
		<jok>"tags"</jok>: [
			{
				<jok>"name"</jok>: <jov>"pet"</jov>,
				<jok>"description"</jok>: <jov>"Everything about your Pets"</jov>,
				<jok>"externalDocs"</jok>: {
					<jok>"description"</jok>: <jov>"Find out more"</jov>,
					<jok>"url"</jok>: <jov>"http://swagger.io"</jov>
				}
			}
		],
		<jok>"schemes"</jok>: [
			<jov>"http"</jov>
		],
		<jok>"paths"</jok>: {
			<jok>"/pet"</jok>: {
				<jok>"post"</jok>: {
					<jok>"tags"</jok>: [
						<jov>"pet"</jov>
					],
					<jok>"summary"</jok>: <jov>"Add a new pet to the store"</jov>,
					<jok>"description"</jok>: <jov>""</jov>,
					<jok>"operationId"</jok>: <jov>"addPet"</jov>,
					<jok>"consumes"</jok>: [
						<jov>"application/json"</jov>,
						<jov>"text/xml"</jov>
					],
					<jok>"produces"</jok>: [
						<jov>"application/json"</jov>,
						<jov>"text/xml"</jov>
					],
					<jok>"parameters"</jok>: [
						{
							<jok>"in"</jok>: <jov>"body"</jov>,
							<jok>"name"</jok>: <jov>"body"</jov>,
							<jok>"description"</jok>: <jov>"Pet object that needs to be added to the store"</jov>,
							<jok>"required"</jok>: <jov>true</jov>
						}
					],
					<jok>"responses"</jok>: {
						<jok>"405"</jok>: {
							<jok>"description"</jok>: <jov>"Invalid input"</jov>
						}
					}
				}
			}
		}
	}		
	</p>
	<p>
		This document can be generated by the following Java code:
	</p>
	<p class='bjava'>
	<jk>static import</jk> org.apache.juneau.dto.swagger.SwaggerBuilder.*;

	Swagger <jv>swagger</jv> = <jsm>swagger</jsm>()
		.setSwagger(<js>"2.0"</js>)
		.setInfo(
			<jsm>info</jsm>(<js>"Swagger Petstore"</js>, <js>"1.0.0"</js>)
				.setDescription(<js>"This is a sample server Petstore server."</js>)
				.setTermsOfService(<js>"http://swagger.io/terms/"</js>)
				.setContact(
					<jsm>contact</jsm>().setEmail(<js>"apiteam@swagger.io"</js>)
				)
				.setLicense(
					<jsm>license</jsm>(<js>"Apache 2.0"</js>).setUrl(<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>)
				)
		)
		.setHost(<js>"petstore.swagger.io"</js>)
		.setBasePath(<js>"/v2"</js>)
		.setTags(
			<jsm>tag</jsm>(<js>"pet"</js>).setDescription(<js>"Everything about your Pets"</js>)
				.setExternalDocs(
					<jsm>externalDocumentation</jsm>(<js>"http://swagger.io"</js>, <js>"http://swagger.io"</js>)
				)
		)
		.setSchemes(<js>"http"</js>)
		.setPath(<js>"/pet"</js>, <js>"post"</js>,
			<jsm>operation</jsm>()
				.setTags(<js>"pet"</js>)
				.setSummary(<js>"Add a new pet to the store"</js>)
				.setDescription(<js>""</js>)
				.setOperationId(<js>"addPet"</js>)
				.setConsumes(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.setProduces(MediaType.<jsf>JSON</jsf>, MediaType.<jsf>XML</jsf>)
				.setParameters(
					<jsm>parameterInfo</jsm>(<js>"body"</js>, <js>"body"</js>)
						.setDescription(<js>"Pet object that needs to be added to the store"</js>)
						.setRequired(<jk>true</jk>)
				)
				.setResponse(405, <jsm>responseInfo</jsm>(<js>"Invalid input"</js>))
		);

	<jc>// Serialize using JSON serializer.</jc>
	String <jv>swaggerJson</jv> = Json.<jsm>of</jsm>(<jv>swagger</jv>);
	
	<jc>// Or just use toString().</jc>
	String <jv>swaggerJson</jv> = <jv>swagger</jv>.toString();
	</p>
	<p>
		Methods that take in beans and collections of beans can also take in JSON representations
		of those objects.
	</p>
	<p class='bjava'>
	<jc>// Pass in a JSON object representation of an Info object.</jc>
	<jv>swagger</jv>.info(<js>"{title:'Swagger Petstore',...}"</js>);
	</p>
	<p>
		Properties can also be accessed via the {@link org.apache.juneau.dto.swagger.SwaggerElement#get(String,Class)}
		and {@link org.apache.juneau.dto.swagger.SwaggerElement#set(String,Object)} methods.
		These methods can also be used to set and retrieve non-Swagger attributes such as 
		<js>"$ref"</js> (which is not a part of the Swagger spec but is part of the JSON Schema spec).
	</p>
	<p class='bjava'>
	<jc>// Set a non-standard attribute.</jc>
	<jv>swagger</jv>.set(<js>"$ref"</js>, <js>"http://foo.com"</js>);
	
	<jc>// Retrieve a non-standard attribute.</jc>
	URI <jv>ref</jv> = <jv>swagger</jv>.get(<js>"$ref"</js>, URI.<jk>class</jk>);
	</p>
	<p>
		Swagger docs can be parsed back into Swagger beans using the following code:
	</p>
	<p class='bjava'>
	Swagger <jv>swagger</jv> = JsonParser.<jsf>DEFAULT</jsf>.parse(<jv>swaggerJson</jv>, Swagger.<jk>class</jk>);
	</p>
</div>
</div><!-- END: 4.3 - jd.Swagger -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jd.SwaggerUi' id='jd.SwaggerUi'>4.4 - Swagger UI</a></h3>
<div class='topic'><!-- START: 4.4 - jd.SwaggerUi -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.dto.swagger.ui.SwaggerUI} class is a DTO class for generating Swagger user interfaces
		from {@link org.apache.juneau.dto.swagger.Swagger} beans.
	</p>
	<p>
		The <c>PetStore</c> example described later provides an example of auto-generated Swagger JSON:
	</p>
	<img class='bordered w900' src='doc-files/jd.SwaggerUI.json.png'>
	<p>
		Using {@link org.apache.juneau.dto.swagger.ui.SwaggerUI}, we're able to render that JSON as a Swagger user interface
		when the request is asking for HTML:
	</p>
	<img class='bordered w900' src='doc-files/jd.SwaggerUI.html.png'>
	
	<p>
		The class itself is nothing more than a POJO swap that swaps out {@link org.apache.juneau.dto.swagger.Swagger} beans
		with {@link org.apache.juneau.dto.html5.Div} elements:
	</p>
	<p class='bjava'>
	<jk>public class</jk> SwaggerUI <jk>extends</jk> ObjectSwap&lt;Swagger,Div&gt; {
	
		<ja>@Override</ja>
		<jk>public</jk> MediaType[] forMediaTypes() {
			<jc>// Only use this swap when the Accept type is HTML.</jc>
			<jk>return new</jk> MediaType[] {MediaType.<jsf>HTML</jsf>};
		}
	
		<ja>@Override</ja>
		<jk>public</jk> Div swap(BeanSession <jv>beanSession</jv>, Swagger <jv>swagger</jv>) <jk>throws</jk> Exception {
			...
		}
	}
	</p>
	<p>
		The {@link org.apache.juneau.rest.servlet.BasicRestServlet} class (describe later) shows how this swap is used in the REST interface to 
		generate the Swagger UI shown above:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
	
		<jc>// Allow OPTIONS requests to be simulated using ?method=OPTIONS query parameter.</jc>
		allowedMethodParams=<js>"OPTIONS"</js>,
	
	
		...
	)
	<ja>@BeanConfig</ja>(
		<jc>// POJO swaps to apply to all serializers/parsers.</jc>
		swaps={
			<jc>// Use the SwaggerUI swap when rendering Swagger beans.</jc>
			SwaggerUI.<jk>class</jk>
		}
	)
	<jk>public abstract class</jk> BasicRestServlet <jk>extends</jk> RestServlet <jk>implements</jk> BasicRestConfig {
	
		<jd>/**
		 * [OPTIONS /*] - Show resource options.
		 */</jd>
		<ja>@RestOp</ja>(
			method=<jsf>OPTIONS</jsf>, 
			path=<js>"/*"</js>,
			summary=<js>"Swagger documentation"</js>,
			description=<js>"Swagger documentation for this resource."</js>
		)
		<ja>@HtmlDocConfig</ja>(
			<jc>// Override the nav links for the swagger page.</jc>
			navlinks={
				<js>"back: servlet:/"</js>,
				<js>"json: servlet:/?method=OPTIONS&amp;Accept=text/json&amp;plainText=true"</js>
			},
			<jc>// Never show aside contents of page inherited from class.</jc>
			aside="<js>NONE"</js>
		)
		<jk>public</jk> Swagger getOptions(RestRequest <jv>req</jv>) {
			<jc>// Localized Swagger for this resource is available through the RestRequest object.</jc>
			<jk>return</jk> <jv>req</jv>.getSwagger();
		}
	}
	</p>
</div>
</div><!-- END: 4.4 - jd.SwaggerUi -->
</div><!-- END: 4 - juneau-dto -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-config' id='juneau-config'>5 - juneau-config</a></h2>
<div class='topic'><!-- START: 5 - juneau-config -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-config<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-config-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.config_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.Overview' id='jc.Overview'>5.1 - Overview</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.1 - jc.Overview -->
<div class='topic'>
	<p>
		The <c>juneau-config</c> library contains a powerful API for creating and using INI-style config files.
	</p>
	<h5 class='figure'>Example configuration file:</h5>
	<p class='bini'>
	<cc># A set of entries</cc>
	<cs>[Section1]</cs>

	<cc># An integer</cc>
	<ck>key1</ck> = <cv>1</cv>

	<cc># A boolean</cc>
	<ck>key2</ck> = <cv>true</cv>
	
	<cc># An array</cc>
	<ck>key3</ck> = <cv>1,2,3</cv>

	<cc># A POJO</cc>
	<ck>key4</ck> = <cv>http://bar</cv>
	</p>
	<p>
		Config files are accessed through the {@link org.apache.juneau.config.Config} class which
		are created through the {@link org.apache.juneau.config.Config.Builder} class.
		Builder creator methods are provided on the <c>Config</c> class:
	</p>
	<p class='bjava'>
	<jc>// Create a Config object</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>().name(<js>"MyConfig.cfg"</js>).build();
	
	<jc>// Shortcut</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	</p>
	<p>
		Once instantiated, reading values from the config are simple:
	</p>
	<p class='bjava'>
	<jc>// Read values from section #1</jc>
	<jk>int</jk> <jv>key1</jv> = <jv>config</jv>.get(<js>"Section1/key1"</js>).asInteger().orElse(-1);
	<jk>boolean</jk> <jv>key2</jv> = <jv>config</jv>.get(<js>"Section1/key2"</js>).asBoolean().orElse(<jk>false</jk>);
	<jk>int</jk>[] <jv>key3</jv> = <jv>config</jv>.get(<js>"Section1/key3"</js>).as(<jk>int</jk>[].<jk>class</jk>).orElse(<jk>null</jk>);
	URL <jv>key4</jv> = <jv>config</jv>.get(<js>"Section1/key4"</js>).as(URL.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		The config language may look simple but it is a very powerful feature with many capabilities including:
	</p>
	<ul class='spaced-list'>
		<li>
			Support for storing and retrieving any of the following data types:
			<ul>
				<li>Primitives
				<li>POJOs
				<li>Beans
				<li>Arrays, Maps, and Collections of anything
				<li>Binary data
			</ul>
		<li>
			Transactional modifications with commit/rollback capabilities.
		<li>
			A listener API.
		<li>
			Filesystem watcher integration allowing changes on the file system to be reflected in real-time.
		<li>
			Modifications through the Config class (e.g. add/remove/modify sections and keys, add/remove comments and whitespace, etc...) 
			<b>DO NOT</b> cause loss of formatting in the file.
			<br>All existing whitespace and comments are preserved for you!
		<li>
			Value encoding for added security.
		<li>
			Support for SVL variables.
		<li>
			Directly populate beans from config sections.
		<li>
			Accessing config sections through Java interface proxies.
		<li>
			An extensible storage API allows you to write your own config storage (e.g. storage in databases or the cloud).
	</ul>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.SyntaxRules' id='jc.SyntaxRules'>5.1.1 - Syntax Rules</a></h4>
<div class='topic'><!-- START: 5.1.1 - jc.SyntaxRules -->
<div class='topic'>
	<ul class='spaced-list'>
		<li>
			Each config file contains zero or more sections containing zero or more entries:
			<p class='bini'>
	<cs>[Section1]</cs>
	<ck>key1</ck> = <cv>1</cv>

	<cs>[Section2]</cs>
	<ck>key1</ck> = <cv>2</cv>
			</p>
		<li>
			Unicode escapes can be used in values.
			<p class='bini'>
	<ck>key1</ck> = <cv>\u0070\u0075\u0062\u006c\u0069\u0063</cv>
			</p>
		<li>
			Comment lines start with the <js>'#'</js> character and can be placed on lines before sections and entries:
			<p class='bini'>
	<cc># A comment about this section</cc>
	<cs>[Section1]</cs>
	
	<cc># A comment about this entry</cc>
	<ck>key1</ck> = <cv>1</cv>
			</p>
		<li>
			Comments can also be placed on the same line as entries:
			<p class='bini'>
	<ck>key1</ck> = <cv>1</cv>  <cc># A comment about this entry</cc>
			</p>
		<li>
			Values containing <js>'#'</js> must be escaped to prevent identification as a comment character:
			<p class='bini'>
	<ck>valueContainingPound</ck> = <cv>Value containing \u0023 character</cv>
			</p>
			<br>Likewise, <js>'\'</js> should be escaped to prevent confusion with unicode escapes.
		<li>
			Values containing newlines can span multiple lines.
			<br>Subsequent lines start with a tab character.
			<p class='bini'>
	<ck>multiLineValue</ck> = 
		<cv>line 1,</cv>
		<cv>line 2,</cv>
		<cv>line 3</cv>
			</p>
			<br>When retrieved, the above translates to <js>"line1,\nline2,\nline3"</js>.
		<li>
			Leading and trailing whitespace on values are ignored.
		<li>
			Whitespace is not ignored within multi-line values (except for the leading tab character on each line).
		<li>
			Blank lines can be used anywhere in the file.
			<p class='bini'>
	<cc># A comment line</cc>
	
	<cc># Another comment line</cc>
	<cs>[Section1]</cs>
	...
			</p>
		<li>
			Values located before any sections are considered part of the no-name section, meaning
			they are accessed simply by key and not section/key.
			<p class='bini'>
	<cc># Top of file</cc>
	
	<cc># Use config.getString("key1") to retrieve.</cc>
	<ck>key1</ck> = <cv>val1</cv>
	
	<cc># The first section</cc>
	<cs>[Section1]</cs>

	<cc># Use config.getString("Section1/key2") to retrieve.</cc>
	<ck>key2</ck> = <cv>val2</cv>
			</p>
		<li>
			Section and key names must be at least one character long and not consist of any of the following
			characters:
			<p class='bini'>
	/ \ [ ] = #
			</p>
		<li>
			Whitespace in section and key names is technically allowed but discouraged.
	</ul>
</div>
</div><!-- END: 5.1.1 - jc.SyntaxRules -->
</div><!-- END: 5.1 - jc.Overview -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ReadingEntries' id='jc.ReadingEntries'>5.2 - Reading Entries</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.2 - jc.ReadingEntries -->
<div class='topic'>
	<p>
		Configuration files can contain entries for anything from primitive types up to complex hierarchies of POJOs consisting of maps, collections, and/or beans.
	</p>
	<p>
		Entries are accessed via the {@link org.apache.juneau.config.Config#get(String)} method which returns the following bean:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Entry}
			<ul class='spaced-list'>
				<li>Primary methods
					<ul class='javatreec'>
						<li class='jm'>{@link org.apache.juneau.config.Entry#get() get()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#isNotEmpty() isNotEmpty()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#isPresent() isPresent()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#orElse(String) orElse(String)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#orElseGet(Supplier) orElseGet(Supplier)}
					</ul>
				</li>
				<li>Conversion methods
					<ul class='javatreec'>
						<li class='jm'>{@link org.apache.juneau.config.Entry#as(Class) as(Class)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#as(Parser,Class) as(Parser,Class)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#as(Parser,Type,Type...) as(Parser,Type,Type...)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#as(Type,Type...) as(Type,Type...)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asBoolean() asBoolean()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asBytes() asBytes()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asDouble() asDouble()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asFloat() asFloat()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asInteger() asInteger()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asList() asList()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asList(Parser) asList(Parser)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asLong() asLong()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asMap() asMap()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asMap(Parser) asMap(Parser)}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asString() asString()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#asStringArray() asStringArray()}
					</ul>
				</li>
				<li>Metadata methods
					<ul class='javatreec'>
						<li class='jm'>{@link org.apache.juneau.config.Entry#getComment() getComment()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#getKey() getKey()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#getModifiers() getModifiers()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#getPreLines() getPreLines()}
						<li class='jm'>{@link org.apache.juneau.config.Entry#getValue() getValue()}
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		The most common case for configuration values are primitives.
	</p>
	<p class='bini'>
	<cc># A string</cc>
	<ck>key1</ck> = <cv>foo</cv>

	<cc># A boolean</cc>
	<ck>key2</ck> = <cv>true</cv>

	<cc># An integer</cc>
	<ck>key3</ck> = <cv>123</cv>
	
	<cc># A long</cc>
	<ck>key4</ck> = <cv>10000000000</cv>
	
	<cc># Doubles</cc>
	<ck>key5</ck> = <cv>6.67eâˆ’11</cv>
	<ck>key6</ck> = <cv>Infinity</cv>
	</p>
	<p>
		On integers and longs, <js>"K"</js>, <js>"M"</js>, and <js>"G"</js> can be used to identify kilo, mega, and giga.
	</p>	
	<p class='bini'>
	<ck>key1</ck> = <cv>100K</cv>  <cc># Same as 1024000</cc>
	<ck>key2</ck> = <cv>100M</cv>  <cc># Same as 104857600</cc>
	</p>
	<p>
		Numbers can also use hexadecimal and octal notation:
	</p>	
	<p class='bini'>
	<ck>hex1</ck> = <cv>0x12FE</cv>
	<ck>hex2</ck> = <cv>0X12FE</cv>
	<ck>octal1</ck> = <cv>01234</cv>
	</p>
	<p>
		Strings with newlines are treated as multi-line values that get broken into separate lines:
	</p>
	<p class='bini'>
	<ck>key1</ck> = <cv>This is a particularly long sentence that we want to split</cv>
		<cv>onto separate lines</cv>.
	</p>
	<p>
		Typically, multi-line values are started on the next line for clarity like so:
	</p>
	<p class='bini'>
	<ck>key1</ck> = 
		<cv>This is a particularly long sentence that we want to split</cv>
		<cv>onto separate lines</cv>.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.Pojos' id='jc.Pojos'>5.2.1 - POJOs</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 5.2.1 - jc.Pojos -->
<div class='topic'>
	<p>
		Entries can also be read as POJOs.  In theory, any <a class="doclink" href="#jm.PojoCategories">parsable</a> POJO type can be represented
		as a config value. 
		However in practice, we're typically talking about the following:
	</p>
	<ul>
		<li>Objects convertible from Strings.
		<li>Beans.
	</ul>
	<p>
		An example of an object convertible from a String was already shown in an example above.
		In that case, it was a URL which has a public constructor that takes in a String:
	</p>
	<p class='bini'>
	<cc># A POJO</cc>
	<ck>key4</ck> = <cv>http://bar</cv>
	</p>
	<p class='bjava'>
	<jc>// Read values from section #1</jc>
	URL <jv>key4</jv> = <jv>config</jv>.get(<js>"Section1/key4"</js>).as(URL.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		Beans are represented as <a class="doclink" href="#jm.Json5">JSON 5</a> by default:
	</p>
	<p class='bini'>
	<jc>// Contact information</jc>
	<cs>[ContactInfo]</cs>
	<ck>address</ck> = 
		<cv>{
			street: '123 Main Street',
			city: 'Anywhere',
			state: 'NY',
			zip: 12345
		}</cv>
	</p>
	<p class='bjava'>
	<jc>// Example bean</jc>
	<jk>public class</jk> Address {
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
	}

	<jc>// Example usage</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	Address <jv>myAddress</jv> = <jv>config</jv>.get(<js>"ContactInfo/address"</js>).as(Address.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		The default serializer and parser is registered on the Config through the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#serializer(WriterSerializer) serializer(WriterSerializer)}
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#parser(ReaderParser) parser(ReaderParser)}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 5.2.1 - jc.Pojos -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.Arrays' id='jc.Arrays'>5.2.2 - Arrays</a></h4>
<div class='topic'><!-- START: 5.2.2 - jc.Arrays -->
<div class='topic'>
	<p>
		The <c>asStringArray()</c> method allows you to retrieve comma-delimited lists of values:
	<p class='bini'>
	<ck>key1</ck> = <cv>foo, bar, baz</cv>
	</p>
	<p class='bjava'>
	String[] <jv>key1</jv> = <jv>config</jv>.get(<js>"key1"</js>).asStringArray().orElse(<jk>null</jk>);
	</p>
	<p>
		String arrays can also be represented in JSON when the registered parser is a JSON parser:
	</p>
	<p class='bini'>
	<ck>key1</ck> = <cv>['foo','bar','baz']</cv>
	</p>
	<p class='bjava'>
	String[] <jv>key1</jv> = <jv>config</jv>.get(<js>"key1"</js>).asStringArray().orElse(<jk>null</jk>);
	</p>
	<p>
		Primitive arrays can also be retrieved using the <c>as()</c> and <c>to()</c> methods:
	</p>
	<p class='bini'>
	<ck>key1</ck> = <cv>[1,2,3]</cv>
	</p>
	<p class='bjava'>
	<jk>int</jk>[] <jv>key1</jv> = <jv>config</jv>.get(<js>"key1"</js>).as(<jk>int</jk>[].<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		Arrays of POJOs can also be retrieved using the methods as well:
	</p>
	<p class='bini'>
	<ck>addresses</ck> = 
		<cv>[
			{
				street: '123 Main Street',
				city: 'Anywhere',
				state: 'NY',
				zip: 12345
			}</cv>,
			<cv>{
				street: '456 Main Street',
				city: 'Anywhere',
				state: 'NY',
				zip: 12345
			}
		]</cv>
	</p>
	<p class='bjava'>
	Address[] <jv>addresses</jv> = <jv>config</jv>.get(<js>"addresses"</js>).as(Address[].<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
</div>
</div><!-- END: 5.2.2 - jc.Arrays -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.JCFObjects' id='jc.JCFObjects'>5.2.3 - Java Collection Framework Objects</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 5.2.3 - jc.JCFObjects -->
<div class='topic'>
	<p>
		Entries can also be read as Java Collection Framework objects.
		The <c>Type,Type...</c> arguments allow you to specify the component types for maps and collections.
		<c>List</c> class arguments can be followed by zero or one arguments representing the entry types.
		<c>Map</c> class arguments can be followed by zero or two arguments representing the key and value types.
		The arguments can be chained to produce any data structure consisting of maps, collections, or POJOs.
	</p>
	<p>
		Examples are shown below:
	</p>
	<ul class='spaced-list'>
		<li><c>to(List.<jk>class</jk>)</c>
			<br>Produces: <c>List&lt;?&gt;</c>
		<li><c>to(LinkedList.<jk>class</jk>)</c>
			<br>Produces: <c>LinkedList&lt;?&gt;</c>
		<li><c>to(HashSet.<jk>class</jk>, Integer.<jk>class</jk>)</c>
			<br>Produces: <c>HashSet&lt;Integer&gt;</c>
		<li><c>to(Map.<jk>class</jk>)</c>
			<br>Produces: <c>Map&lt;?,?&gt;</c>
		<li><c>to(HashMap.<jk>class</jk>)</c>
			<br>Produces: <c>HashMap&lt;?,?&gt;</c>
		<li><c>to(LinkedHashMap.<jk>class</jk>, String.<jk>class</jk>, MyBean.<jk>class</jk>)</c>
			<br>Produces: <c>LinkedHashMap&lt;String,MyBean&gt;</c> 
		<li><c>to(HashMap.<jk>class</jk>, Integer.<jk>class</jk>, ArrayList.<jk>class</jk>, MyBean[].<jk>class</jk>)</c>
			<br>Produces: <c>LinkedHashMap&lt;Integer,ArrayList&lt;MyBean[]&gt;&gt;</c> 
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<ck>addresses</ck> = 
		<cv>[
			{
				street: '123 Main Street',
				city: 'Anywhere',
				state: 'NY',
				zip: 12345
			}</cv>,
			<cv>{
				street: '456 Main Street',
				city: 'Anywhere',
				state: 'NY',
				zip: 12345
			}
		]</cv>
	</p>
	<p class='bjava'>
	List&lt;Address&gt; <jv>addresses</jv> = <jv>config</jv>.get(<js>"addresses"</js>).as(ArrayList.<jk>class</jk>, Address.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		Oftentimes, it might be useful to parse into the {@link org.apache.juneau.collections.JsonList} and {@link org.apache.juneau.collections.JsonMap}
		classes that provide the various convenience methods for working with JSON-like data structures:
	</p>
	<p class='bjava'>
	JsonMap <jv>map</jv> = <jv>config</jv>.get(<js>"key1"</js>).asMap().orElse(<jk>null</jk>);
	JsonList <jv>list</jv> = <jv>config</jv>.get(<js>"key2"</js>).asList().orElse(<jk>null</jk>);
	</p>
</div>
</div><!-- END: 5.2.3 - jc.JCFObjects -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.BinaryData' id='jc.BinaryData'>5.2.4 - Binary Data</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 5.2.4 - jc.BinaryData -->
<div class='topic'>
	<p>
		Entries can also be accessed as binary data.
		Binary data can be represented in 3 formats:
	</p>
	<ul class='spaced-list'>
		<li>BASE-64 (default)
			<br>Example: <c><js>"Zm9vYmFycw=="</js></c>
		<li>Hexadecimal
			<br>Example: <c><js>"666F6F62617273"</js></c>
		<li>Spaced hexadecimal
			<br>Example: <c><js>"66 6F 6F 62 61 72 73"</js></c>
	</ul>
	<p>
		The binary data format is controlled via the following setting:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#binaryFormat(BinaryFormat) binaryFormat(BinaryFormat)}
			</ul>
		</li>
	</ul>
	<p>
		For example:
	</p>
	<p class='bini'>
	<ck>key</ck> = <cv>Zm9vYmFycw==</cv>
	</p>
	<p class='bjava'>
	<jk>byte</jk>[] <jv>bytes</jv> = <jv>config</jv>.get(<js>"key"</js>).asBytes().orElse(<jk>null</jk>);
	</p>
	<p>
		Binary lines can be split up into separate lines for readability:
	</p>
	<p class='bini'>
	<ck>key</ck> = 
		<cv>Zm9vYm
		Fycw==</cv>
	</p>
	<p>
		Binary data line wrapping can be controlled via the following setting:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#binaryLineLength(int) binaryLineLength(int)}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 5.2.4 - jc.BinaryData -->
</div><!-- END: 5.2 - jc.ReadingEntries -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.Variables' id='jc.Variables'>5.3 - Variables</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.3 - jc.Variables -->
<div class='topic'>
	<p>
		Config files can contain variables that get resolved dynamically using the previously-described {@link org.apache.juneau.svl.VarResolver} API.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<cc>#--------------------------</cc>
	<cc># My section</cc>
	<cc>#--------------------------</cc>
	<cs>[MySection]</cs>
	
	<cc># A system property</cc>
	<ck>locale</ck> = <cv>$S{java.locale, en_US}</cv>
	
	<cc># An environment variable</cc>
	<ck>path</ck> = <cv>$E{PATH, unknown}</cv>
	
	<cc># Another value in this config file</cc>
	<ck>anotherLocale</ck> = <cv>$C{MySection/locale}</cv>
	
	<cc># Look for system property, or env var if that doesn't exist, or a default value if that doesn't exist.</cc>
	<ck>nested</ck> = <cv>$S{mySystemProperty,$E{MY_ENV_VAR,$C{MySection/anotherLocale}}}</cv>

	<cc># A POJO with embedded variables</cc>
	<ck>aBean</ck> = <cv>{foo:'$S{foo}',baz:$C{MySection/anInt}}</cv>
	</p>
	<p class='bjava'>
	Config <jv>config</jv> = Config.<jsm>create</jsm>().build();
	
	Locale <jv>locale</jv> = <jv>config</jv>.get(<js>"MySection/locale"</js>).as(Locale.<jk>class</jk>).orElse(<jk>null</jk>); 
	String <jv>path</jv> = <jv>config</jv>.get(<js>"MySection/path"</js>).asString().orElse(<jk>null</jk>); 
	<jk>int</jk> <jv>sameAsAnInt</jv> = <jv>config</jv>.get(<js>"MySection/sameAsAnInt"</js>).asInteger().orElse(<jk>null</jk>); 
	ABean <jv>bean</jv> = <jv>config</jv>.get(<js>"MySection/aBean"</js>).as(ABean.<jk>class</jk>).orElse(<jk>null</jk>); 
	</p>
	<p>
		By default, <c>Configs</c> use the {@link org.apache.juneau.svl.VarResolver#DEFAULT} variable resolver
		which provides support for the following variables and constructs:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.vars.SystemPropertiesVar} - <c>$S{key[,default]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.EnvVariablesVar} - <c>$E{key[,default]}</c>
		<li class='jc'>{@link org.apache.juneau.config.vars.ConfigVar} - <c>$C{key[,default]}</c>
	</ul>
	<p>
		The variable resolver is controlled via the following setting:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#varResolver(VarResolver) varResolver(VarResolver)}
			</ul>
		</li>
	</ul>
	<p>
		Additionally, the following method can be used to retrieve a <c>Config</c> with a different variable resolver:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#resolving(VarResolverSession) resolving(VarResolverSession)}
			</ul>
		</li>
	</ul>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.LogicVariables' id='jc.LogicVariables'>5.3.1 - Logic Variables</a></h4>
<div class='topic'><!-- START: 5.3.1 - jc.LogicVariables -->
<div class='topic'>
	<p>
		The default variable resolver also provides the following logic variables for performing simple logical operations:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.svl.vars.IfVar} - <c>$IF{arg,then[,else]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.SwitchVar} - <c>$SW{arg,pattern1:then1[,pattern2:then2...]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.CoalesceVar} - <c>$CO{arg1[,arg2...]}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.PatternMatchVar} - <c>$PM{arg,pattern}</c> 
		<li class='jc'>{@link org.apache.juneau.svl.vars.NotEmptyVar} - <c>$NE{arg}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.UpperCaseVar} - <c>$UC{arg}</c>
		<li class='jc'>{@link org.apache.juneau.svl.vars.LowerCaseVar} - <c>$LC{arg}</c>
	</ul>
	<p>
		The <c>$IF</c> variable can be used for simple if/else logic:
	</p>
	<p class='bini'>
	<cc># Value set to 'foo' if myBooleanProperty is true</cc>
	<ck>key1</ck> = 
		<cv>$IF{		
			$S{myBooleanProperty},
			foo
		}</cv>		
			
	<cc># Value set to 'foo' if myBooleanProperty is true, 'bar' if false.</cc>
	<ck>key2</ck> = 
		<cv>$IF{		
			$S{myBooleanProperty},
			foo,
			bar
		}</cv>		

	<cc># Value set to key1 value if myBooleanProperty is true, key2 value if false.</cc>
	<ck>key3</ck> = 
		<cv>$IF{		
			$S{myBooleanProperty},
			$C{key1},
			$C{key2}
		}</cv>		
	</p>
	<p>
		The <c>$SW</c> variable can be used for switch blocks based on pattern matching:
	</p>
	<p class='bini'>
	<cc># Shell command depends on the OS</cc>
	<ck>shellCommand</ck> = 
		<cv>$SW{		
			$LC{$S{os.name}},
			*win*: bat,
			linux: bash,
			*: sh
		}</cv>		
	</p>
	<p>
		The <c>$CO</c> variable can be used for coalescing of values (finding the first non-null/empty match):
	</p>
	<p class='bini'>
	<cc># Debug flag can be enabled by system property or environment variable.</cc>
	<ck>debug</ck> = 
		<cv>$CO{		
			$S{debug},
			$E{DEBUG},
			false
		}</cv>		
	</p>
	<p>
		The <c>$PM</c> variable can be used for calculating boolean values:
	</p>
	<p class='bini'>
	<cc># Debug flag can be enabled by system property or environment variable.</cc>
	<ck>isWindows</ck> = 
		<cv>$PM{		
			$LC{$S{os.name}},
			*win*
		}</cv>		
	</p>
</div>
</div><!-- END: 5.3.1 - jc.LogicVariables -->
</div><!-- END: 5.3 - jc.Variables -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ModdedEntries' id='jc.ModdedEntries'>5.4 - Modded/Encoded Entries</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.4 - jc.ModdedEntries -->
<div class='topic'>
	<p>
		The following method can be used to associates entry modifiers to a config:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#mods(Mod...) mods(Mod...)}
			</ul>
		</li>
	</ul>
	<p>
		Mods are used to modify values before being persisted.  This can be used to
		replace or encode sensitive information.  They are denoted by a single
		character that gets appended between angle brackets on the property name (e.g. <ck>key&lt;X&gt;</ck>).
		Multiple modifiers can be denoted by multiple characters (e.g. <ck>key&lt;XYZ&gt;</ck>) and
		are applied/removed in the order denoted.
	</p>
	<p>
		The framework comes built-in with a simple {@link org.apache.juneau.config.mod.XorEncodeMod xor-encode} mod tied
		to the <js>'*'</js> character.  The following shows how it is used:
	</p>
	<p class='bini'>
	<cs>[MyHost]</cs>
	<ck>url</ck> = <cv>http://localhost:9080/foo</cv>
	<ck>user</ck> = <cv>me</cv>
	<ck>password&lt;*&gt;</ck> = <cv>{AwwJVhwUQFZEMg==}</cv>
	</p>
	<p>
		Custom encoders can be used to provide your own encoding support by implementing the {@link org.apache.juneau.config.mod.Mod} class.
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.config.mod.Mod}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.mod.Mod#apply(String) apply(String)}
				<li class='jm'>{@link org.apache.juneau.config.mod.Mod#remove(String) remove(String)}
				<li class='jm'>{@link org.apache.juneau.config.mod.Mod#isApplied(String) isApplied(String)}
			</ul>
		</li>
	</ul>
	<p>
		Unmodified values are encoded when the file is saved using the {@link org.apache.juneau.config.Config#commit()} method.
		They can also be encoded immediately by calling {@link org.apache.juneau.config.Config#applyMods()} which can typically
		be done during JVM startup to immediately encode any unencoded passwords in the file.
	</p>
</div>
</div><!-- END: 5.4 - jc.ModdedEntries -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.Sections' id='jc.Sections'>5.5 - Sections</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.5 - jc.Sections -->
<div class='topic'>
	<p>
		Config sections can be retrieved in-bulk using the
		{@link org.apache.juneau.config.Config#getSection(String)} method.  It returns the following bean:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Section}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Section#asBean(Class) asBean(Class)}
				<li class='jm'>{@link org.apache.juneau.config.Section#asBean(Class,boolean) asBean(Class,boolean)}
				<li class='jm'>{@link org.apache.juneau.config.Section#asInterface(Class) asInterface(Class)}
				<li class='jm'>{@link org.apache.juneau.config.Section#asMap() asMap()}
				<li class='jm'>{@link org.apache.juneau.config.Section#isPresent() isPresent()}
				<li class='jm'>{@link org.apache.juneau.config.Section#writeToBean(Object,boolean) writeToBean(Object,boolean)}
			</ul>
		</li>
	</ul>
	<p>	
		The {@link org.apache.juneau.config.Section#asMap() asMap()} 
		method allows you to access a section as simple key/value pairs. 
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<jc>// Example config file</jc>
	<cs>[MyAddress]</cs>
	<ck>street</ck> = <cv>123 Main Street</cv>
	<ck>city</ck> = <cv>Anywhere</cv>
	<ck>state</ck> = <cv>NY</cv>
	<ck>zip</ck> = <cv>12345</cv>
	</p>
	<p class='bjava'>
	<jc>// Example usage</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	
	JsonMap <jv>map</jv> = <jv>config</jv>.getSection(<js>"MyAddress"</js>).asMap().get();
	
	String <jv>street</jv> = <jv>map</jv>.getString(<js>"street"</js>);
	String <jv>city</jv> = <jv>map</jv>.getString(<js>"city"</js>);
	String <jv>state</jv> = <jv>map</jv>.getString(<js>"state"</js>);
	<jk>int</jk> <jv>zip</jv> = <jv>map</jv>.getInt(<js>"zip"</js>);
	</p>
	<p>
		Maps created this way are snapshot copies of the section at the time of the method call.
	</p>
	<p>
		Config files can also be used to directly populate beans using 
		{@link org.apache.juneau.config.Section#asBean(Class) asBean()} or {@link org.apache.juneau.config.Section#writeToBean(Object,boolean) writeToBean()}.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<jc>// Example config file</jc>
	<cs>[MyAddress]</cs>
	<ck>street</ck> = <cv>123 Main Street</cv>
	<ck>city</ck> = <cv>Anywhere</cv>
	<ck>state</ck> = <cv>NY</cv>
	<ck>zip</ck> = <cv>12345</cv>
	</p>
	<p class='bjava'>
	<jc>// Example bean</jc>
	<jk>public class</jk> Address {
		<jk>public</jk> String <jf>street</jf>, <jf>city</jf>;
		<jk>public</jk> StateEnum <jf>state</jf>;
		<jk>public int</jk> <jf>zip</jf>;
	}

	<jc>// Example usage</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	Address <jv>myAddress</jv> = <jv>config</jv>.getSection(<js>"MyAddress"</js>).as(Address.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		Like maps, beans created this way are snapshot copies of the section at the time of the method call.
	</p>
	<p>
		Config sections can also be accessed via interface proxies using 
		{@link org.apache.juneau.config.Section#asInterface(Class)}.
	</p>
	<p>
		While section maps and beans retrieve copies of the configuration data at the time of the method
		call, section interfaces can also be use to set values in the underlying configuration.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<jc>// Example config file</jc>
	<cs>[MySection]</cs>
	<ck>string</ck> = <cv>foo</cv>
	<ck>int</ck> = <cv>123</cv>
	<ck>enum</ck> = <cv>ONE</cv>
	<ck>bean</ck> = <cv>{foo:'bar',baz:123}</cv>
	<ck>int3dArray</ck> = <cv>[[[123,null],null],null]</cv>
	<ck>bean1d3dListMap</ck> = <cv>{key:[[[[{foo:'bar',baz:123}]]]]}</cv>
	</p>
	<p class='bjava'>
	<jc>// Example interface.</jc>
	<jc>// Setters are optional.</jc>
	<jk>public interface</jk> MyConfigInterface {

		String getString();
		<jk>void</jk> setString(String <jv>value</jv>);

		<jk>int</jk> getInt();
		<jk>void</jk> setInt(<jk>int</jk> <jv>value</jv>);

		MyEnum getEnum();
		<jk>void</jk> setEnum(MyEnum <jv>value</jv>);

		MyBean getBean();
		<jk>void</jk> setBean(MyBean <jv>value</jv>);

		<jk>int</jk>[][][] getInt3dArray();
		<jk>void</jk> setInt3dArray(<jk>int</jk>[][][] <jv>value</jv>);
		
		Map&lt;String,List&lt;MyBean[][][]&gt;&gt; getBean1d3dListMap();
		<jk>void</jk> setBean1d3dListMap(Map&lt;String,List&lt;MyBean[][][]&gt;&gt; <jv>value</jv>);
	}
	
	<jc>// Example usage.</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	MyConfigInterface <jv>intf</jv> = <jv>config</jv>.getSection(<js>"MySection"</js>).asInterface(MyConfigInterface.<jk>class</jk>).get();
	
	<jc>// Read a value.</jc>
	<jk>int</jk> <jv>myInt</jv> = <jv>intf</jv>.getInt();

	<jc>// Write a value.</jc>
	<jv>intf</jv>.setBean(<jk>new</jk> MyBean());

	<jc>// Commit your changes to the store.</jc>
	<jv>config</jv>.commit();
	</p>
	
</div>
</div><!-- END: 5.5 - jc.Sections -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.SettingValues' id='jc.SettingValues'>5.6 - Setting Values</a></h3>
<div class='topic'><!-- START: 5.6 - jc.SettingValues -->
<div class='topic'>
	<p>
		The following methods allow you to add, remove, and modify entries and sections in a config file:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#set(String,Object) set(String,Object)}
				<li class='jm'>{@link org.apache.juneau.config.Config#set(String,Object,Serializer) set(String,Object,Serializer)}
				<li class='jm'>{@link org.apache.juneau.config.Config#set(String,Object,Serializer,String,String,List) set(String,Object,Serializer,String,String,List)}
				<li class='jm'>{@link org.apache.juneau.config.Config#set(String,String) set(String,String)}
				<li class='jm'>{@link org.apache.juneau.config.Config#remove(String) remove(String)}
				<li class='jm'>{@link org.apache.juneau.config.Config#setSection(String,List) setSection(String,List)}
				<li class='jm'>{@link org.apache.juneau.config.Config#setSection(String,List,Map) setSection(String,List,Map)}
				<li class='jm'>{@link org.apache.juneau.config.Config#removeSection(String) removeSection(String)}
			</ul>
		</li>
	</ul>
	<p class='bjava'>
	<jc>// Construct the sample config file programmatically</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build()
		.set(<js>"key1"</js>, 1)
		.set(<js>"key2"</js>, <jk>true</jk>)
		.set(<js>"key3"</js>, <jk>new int</jk>[]{1,2,3})
		.set(<js>"key4"</js>, <jk>new</jk> URI(<js>"http://foo"</js>))
		.set(<js>"Section1/key1"</js>, 2)
		.set(<js>"Section1/key2"</js>, <jk>false</jk>)
		.set(<js>"Section1/key3"</js>, <jk>new int</jk>[]{4,5,6})
		.set(<js>"Section1/key4"</js>, <jk>new</jk> URI(<js>"http://bar"</js>))
		.commit();
	</p>
	<p>
		The method {@link org.apache.juneau.config.Config#set(String,Object,Serializer,String,String,List)} can be used
		for adding comments and pre-lines to entries, and specifying encoded values.
	</p>
	<p class='bjava'>
	<jc>// Set an encoded value with some comments.</jc>
	<jv>config</jv>.set(<js>"key1"</js>, 1, <jk>null</jk>, <js>"*"</js>, <js>"Same-line comment"</js>, 
		Arrays.asList(
			<js>"# Comment 1"</js>, <js>""</js>, <js>"# Comment 2"</js>
		)
	);
	</p>
	<p class='bini'>
	<cc># Comment 1</cc>
	
	<cc># Comment 2</cc>
	<ck>key1</ck> = <cv>1</cv> <cc># Same-line comment</cc>
	</p>	
	<p>
		The last 4 arguments in {@link org.apache.juneau.config.Config#set(String,Object,Serializer,String,String,List)} 
		are optional in that if you pass <jk>null</jk>, the current value will not be overwritten.
		To unset the same-line comment, you should pass in a blank string.
		To remove pre-lines, you should pass in an empty list.
	</p>	
	<p>
		Sections can be added with optional pre-lines using the <c>setSection</c> methods:
	</p>
	<p class='bjava'>
	<jc>// Set an encoded value with some comments.</jc>
	<jv>config</jv>.setSection(<js>"NewSection"</js>, 
		Arrays.asList(
			<js>"# Section comment 1"</js>, <js>""</js>, <js>"# Section comment 2"</js>
		)
	);
	</p>
	<p class='bini'>
	<cc># Section comment 1</cc>
	
	<cc># Section comment 2</cc>
	<cs>[NewSection]</cs>
	</p>		
	<p>
		Changes made to the configuration are transactional in nature.  
		They are kept in memory until you call the {@link org.apache.juneau.config.Config#commit()} method.
		Until then, you still see the modified values when you call any of the getters but the modified values
		exist only in memory.
	</p>
	<p>
		Changes can be rolled back using the {@link org.apache.juneau.config.Config#rollback()} method.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.FileSystemChanges' id='jc.FileSystemChanges'>5.6.1 - File System Changes</a></h4>
<div class='topic'><!-- START: 5.6.1 - jc.FileSystemChanges -->
<div class='topic'>
	<p>
		In general, external file modifications will be detected immediately in the <c>Config</c>
		object when a watcher thread is enabled (explained later).
		Otherwise, they are detected when a commit is performed.
	</p>
	<p>
		The <c>Config</c> object maintains an in-memory record of all changes that have been applied to it
		through getters and setters.
		When the underlying file changes, the new contents are loaded and the in-memory changes are then 
		applied to the new configuration.
		This provides the benefits of real-time updates of configurations while not losing any changes made in the JVM.
	</p>
	<p>
		If the <c>commit()</c> method is called on the <c>Config</c> objects after the file system
		contents have been modified, we will then reload the configuration from the file system, apply the
		changes, and then try to save to the file system again (up to 10 times).
	</p>
	<p>
		If the same entry is both internally and externally modified, the external modification will be 
		overwritten (although both change events will be seen by listeners).
	</p>
</div>
</div><!-- END: 5.6.1 - jc.FileSystemChanges -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.CustomEntrySerialization' id='jc.CustomEntrySerialization'>5.6.2 - Custom Entry Serialization</a></h4>
<div class='topic'><!-- START: 5.6.2 - jc.CustomEntrySerialization -->
<div class='topic'>
	<p>
		Setter methods that take in a <c>Serializer</c> can be used to provide custom serialization of entries
		instead of using the predefined serializer.
	</p>
	<p class='bjava'>
	<jc>// Set an XML value instead of JSON.</jc>
	<jv>config</jv>.set(<js>"key1"</js>, <jv>myAddress</jv>, XmlSerializer.<jsf>DEFAULT_SQ_READABLE</jsf>);
	</p>
	<p class='bini'>
	<ck>key1</ck> = 
		<cv>&lt;address&gt;	
			&lt;street&gt;123 Main Street&lt;/street&gt;
			&lt;city&gt;Anywhere&lt;/city&gt;
			&lt;state&gt;NY&lt;/state&gt;
			&lt;zip&gt;12345&lt;/zip&gt;
		&lt;/address&gt;</cv>
	</p>		
	<p>
		The value can then be retrieved using the equivalent parser:
	</p>
	<p class='bjava'>
	Address <jv>myAddress</jv> = <jv>config</jv>.get(<js>"key1"</js>).as(XmlParser.<jsf>DEFAULT</jsf>, Address.<jk>class</jk>).orElse(<jk>null</jk>);			
	</p>
</div>
</div><!-- END: 5.6.2 - jc.CustomEntrySerialization -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.BulkSettingValues' id='jc.BulkSettingValues'>5.6.3 - Setting Values in Bulk</a></h4>
<div class='topic'><!-- START: 5.6.3 - jc.BulkSettingValues -->
<div class='topic'>
	<p>
		The following methods can be used to bulk-load configuration values:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#setSection(String,List,Map) setSection(String,List,Map)}
				<li class='jm'>{@link org.apache.juneau.config.Config#load(Map) load(Map)}
				<li class='jm'>{@link org.apache.juneau.config.Config#load(Reader,boolean) load(Reader,boolean)}
				<li class='jm'>{@link org.apache.juneau.config.Config#load(String,boolean) load(String,boolean)}
			</ul>
		</li>
	</ul>
	<p>
		Changes can then be committed using the {@link org.apache.juneau.config.Config#commit()} method.
	</p>
</div>
</div><!-- END: 5.6.3 - jc.BulkSettingValues -->
</div><!-- END: 5.6 - jc.SettingValues -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.Listeners' id='jc.Listeners'>5.7 - Listeners</a></h3>
<div class='topic'><!-- START: 5.7 - jc.Listeners -->
<div class='topic'>
	<p>
		Configuration change events can be listened for using the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#addListener(ConfigEventListener) addListener(ConfigEventListener)}
				<li class='jm'>{@link org.apache.juneau.config.Config#removeListener(ConfigEventListener) removeListener(ConfigEventListener)}
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.config.event.ConfigEventListener} interface consists of the following method:
	</p>		
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.config.event.ConfigEventListener}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEventListener#onConfigChange(ConfigEvents) onConfigChange(ConfigEvents)}
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.config.event.ConfigEvent} class provides access to all the information about the updated entry:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.event.ConfigEvent}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getType() getType()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getSection() getSection()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getKey() getKey()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getValue() getValue()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getModifiers() getModifiers()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getComment() getComment()}
				<li class='jm'>{@link org.apache.juneau.config.event.ConfigEvent#getPreLines() getPreLines}
			</ul>
		</li>
	</ul>
	<p>
		The listener method is triggered:
	</p>
	<ul class='spaced-list'>
		<li>After {@link org.apache.juneau.config.Config#commit()} is called.
		<li>When the file changes on the file system. 
	</ul>
	<p>
		In both cases, the listener is triggered after the changes have been committed.
	</p>
	<p class='bjava'>
	<jk>final</jk> Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	
	<jc>// Add a listener for changes to MySection/key1</jc>
	<jv>config</jv>.addListener(
		<jk>new</jk> ConfigEventListener() {
			<ja>@Override</ja>
			<jk>public void</jk> onConfigChange(ConfigEvents <jv>events</jv>) {
				<jk>for</jk> (ConfigEvent <jv>event</jv> : <jv>events</jv>) {
					<jk>if</jk> (<jv>event</jv>.getType() == <jsf>SET_ENTRY</jsf>) {
						
						String <jv>section</jv> = <jv>event</jv>.getSection();
						String <jv>key</jv> = <jv>event</jv>.getKey();
					
						<jk>if</jk> (<jv>section</jv>.equals(<js>"MySection"</js>) &amp;&amp; <jv>key</jv>.equals(<js>"key1"</js>)) {
		
							<jc>// Get the new value from the event.</jc>
							String <jv>newVal</jv> = <jv>event</jv>.getValue();
							
							<jc>// Or get the new value from the config (since the change has already been committed).</jc>
							<jv>newVal</jv> = <jv>config</jv>.getString(<js>"MySection/key1"</js>);
						}
					}
				}
			}
		}
	)
	</p>
</div>
</div><!-- END: 5.7 - jc.Listeners -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.SerializingConfigs' id='jc.SerializingConfigs'>5.8 - Serializing</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.8 - jc.SerializingConfigs -->
<div class='topic'>
	<p>
		The following methods are used for serializing <c>Config</c> objects back into INI files:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#writeTo(Writer) writeTo(Writer)}
				<li class='jm'>{@link org.apache.juneau.config.Config#toString() toString()}
			</ul>
		</li>
	</ul>
	<p>
		Both methods are thread safe.
	</p>
</div>
</div><!-- END: 5.8 - jc.SerializingConfigs -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ConfigImports' id='jc.ConfigImports'>5.9 - Imports</a><span class='update'>updated: 8.1.0</span></h3>
<div class='topic'><!-- START: 5.9 - jc.ConfigImports -->
<div class='topic'>
	<p>
		Configurations can import values from other configurations using the following syntax: 
	</p>
	<p class='bini'>
	<cc># Import values from configuration 'ParentConfig'</cc>
	<ci>&lt;ParentConfig&gt;</ci>

	<cc># Our normal section</cc>
	<cs>[Section1]</cs>
	...
	</p>
	<p>
		A configuration can contain zero or more imports anywhere in the file.
		However, for clarity, imports should normally be placed in the default section of the configuration file.
		The resolved configuration is retrieved from the configuration store used for the child configuration.
	</p>
	<p>
		Configuration imports can be nested arbitrarily deep.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<cc># MyConfig contents</cc>
	<ci>&lt;ParentConfig1&gt;</ci>
	</p>
	<p class='bini'>
	<cc># ParentConfig1 contents</cc>
	<ci>&lt;ParentConfig2&gt;</ci>
	</p>
	<p class='bini'>
	<cc># ParentConfig2 contents</cc>
	<cs>[Foo]</cs>
	<ck>bar</ck> = <cv>baz</cv>
	</p>
	<p class='bjava'>
	<jc>// Java code</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig"</js>).build();
	String <jv>foo</jv> = <jv>config</jv>.get(<js>"Foo/bar"</js>).get();  <jc>// == "baz"</jc>
	</p>
	<p>
		Values can be overridden by child configurations.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<cc># MyConfig contents</cc>
	<ci>&lt;ParentConfig1&gt;</ci>
	
	<cs>[Foo]</cs>
	<ck>bar</ck> = <cv>baz</cv>
	</p>
	<p class='bini'>
	<cc># ParentConfig1 contents</cc>
	<ci>&lt;ParentConfig2&gt;</ci>
	
	<cs>[Foo]</cs>
	<ck>bar</ck> = <cv>qux</cv>
	</p>
	<p class='bini'>
	<cc># ParentConfig2 contents</cc>
	<cs>[Foo]</cs>
	<ck>bar</ck> = <cv>quux</cv>
	</p>
	<p class='bjava'>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig"</js>).build();
	String <jv>foo</jv> = <jv>config</jv>.get(<js>"Foo/bar"</js>).get();  <jc>// == "baz"</jc>
	</p>
	
	<p>
		Changes made to imported configurations are automatically reflected in the child configuration and
		partake in the listener API as if the entries were part of the child configuration.
		Only non-overridden values trigger listener events.  For example, if an imported configuration
		defines a value for <js>"Foo/bar"</js> and the child configuration does not, modifications to 
		<js>"Foo/bar"</js> value in the parent configuration will trigger a listener event in the child config.
		However, if the child configuration does also specify a value for <js>"Foo/bar"</js>, a change to the parent
		<js>"Foo/bar"</js> will NOT trigger a listener event because the value ends up not being changed from
		the perspective of the child configuration.
	</p>
	<p>
		Values can be overwritten in child configurations but the values will only be set in that configuration
		and not the imported configuration.  
	</p>
	<p>
		Dynamically adding an import will cause change events to be generated for imported values.
	</p>
	<p class='bini'>
	<cc># MyConfig contents starting empty</cc>
	</p>
	<p class='bini'>
	<cc># ParentConfig contents</cc>
	<cs>[Foo]</cs>
	<ck>bar</ck> = <cv>baz</cv>
	</p>
	<p class='bjava'>
	<jc>// Create our configuration.</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig"</js>).build();
	
	<jc>// Create a listener that sets a flag if "Foo/bar" is set.</jc>	
	<jk>final boolean</jk>[] <jv>triggered</jv> = <jk>new boolean</jk>[1];
	ConfigEventListener <jv>listener</jv> = <jk>new</jk> ConfigEventListener() {
		<jk>public void</jk> onConfigChange(ConfigEvents <jv>events</jv>) {
			<jv>triggered</jv>[0] = <jv>events</jv>.isKeyModified(<js>"Foo"</js>, <js>"bar"</js>));
		}
	};
	<jv>config</jv>.addListener(<jv>listener</jv>);
	
	<jc>// Dynamically add an import to ParentConfig in the default section.</jc>
	<jv>config</jv>.setImport(<js>""</js>, <js>"ParentConfig"</js>);
	<jv>config</jv>.commit();
	
	<jc>// The new import statement should have triggered a config changes for imported values.</jc>
	<jsm>assertTrue</jsm>(<jv>triggered</jv>[0]);	
	</p>
	<p>
		Dynamically removing an import has the same effect as removing keys and generates <jsf>REMOVE_ENTRY</jsf> events.
	</p>
	<p>
		Note that when dynamically adding or removing imports, overridden keys in the child config will be filtered
		from the change events.
	</p>
</div>
</div><!-- END: 5.9 - jc.ConfigImports -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ConfigStores' id='jc.ConfigStores'>5.10 - Config Stores</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.10 - jc.ConfigStores -->
<div class='topic'>
	<p>
		Configuration files are stored in entities called Stores.
	</p>
	<p>
		The methods that need to be implemented on a store are:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.config.store.ConfigStore}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#read(String) read(String)}
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#write(String,String,String) write(String,String,String)}
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#update(String,String) update(String,String)}
			</ul>
		</li>
	</ul>
	<p>
		Read is self-explanatory:
	</p>
	<p class='bjava'>
	<jk>public</jk> String read(String <jv>name</jv>) {
		<jc>// Return the contents of the specified configuration.</jc>
	}
	</p>
	<p>
		Write is slightly trickier:
	</p>
	<p class='bjava'>
	<jk>public</jk> String write(String <jv>name</jv>, String <jv>oldContents</jv>, String <jv>newContents</jv>) {
			
		<jc>// If the old contents match the current stored contents, the new contents will get stored, 
		//	and the method returns null indicating success.
			
		// If the old contents DO NOT match the current stored contents (i.e. it was modified in some way), 
		//	the new contents are NOT stored, and the method returns the current stored contents.
			
		// If the old contents are null, then just always write the new contents.</jc>
	}
	</p>
	<p>
		The update method is called whenever the stored file gets modified externally:
	</p>		
	<p class='bjava'>
	<jk>public</jk> String update(String <jv>name</jv>, String <jv>newContents</jv>) {
		<jc>// Do something with the updated contents.</jc>
	}
	</p>
	<p>
		Two configuration stores are provided by default:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.store.FileStore} - File-system storage.
		<li class='jc'>{@link org.apache.juneau.config.store.MemoryStore} - In-memory storage.
	</ul>
	<p>
		The store is defined on the <c>Config</c> object via the following setting:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#store(ConfigStore) store(ConfigStore)}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a config with in-memory storage.</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).store(ConfigMemoryStore.<jsf>DEFAULT</jsf>).build();
	</p>
	<p>
		The default store used is {@link org.apache.juneau.config.store.FileStore#DEFAULT} which defines
		the execution directory as the file system directory to store and retrieve files. 
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.MemoryStore' id='jc.MemoryStore'>5.10.1 - MemoryStore</a></h4>
<div class='topic'><!-- START: 5.10.1 - jc.MemoryStore -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.config.store.MemoryStore} class is simply an in-memory storage
		location for configuration files.
		There is no hard persistence and is used primarily for testing purposes.
	</p>
	<p>
		However, the implementation provides a good idea on how stores work (especially the write method):
	</p>
	<p class='bjava'>
	<jk>public class</jk> MemoryStore <jk>extends</jk> ConfigStore {
	
		<jc>// Some methods ommitted.</jc>
		
		<jk>private final</jk> ConcurrentHashMap&lt;String,String&gt; <jf>cache</jf> = <jk>new</jk> ConcurrentHashMap&lt;&gt;();
		
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> String read(String <jv>name</jv>) {
			<jk>return</jk> <jsm>emptyIfNull</jsm>(<jf>cache</jf>.get(<jv>name</jv>));
		}
	
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> String write(String <jv>name</jv>, String <jv>expectedContents</jv>, String <jv>newContents</jv>) {
	
			<jc>// This is a no-op.</jc>
			<jk>if</jk> (<jsm>isEquals</jsm>(<jv>expectedContents</jv>, <jv>newContents</jv>))
				<jk>return null</jk>;
			
			String <jv>currentContents</jv> = read(<jv>name</jv>);
			
			<jk>if</jk> (<jv>expectedContents</jv> != <jk>null</jk> &amp;&amp; ! <jsm>isEquals</jsm>(<jv>currentContents</jv>, <jv>expectedContents</jv>)) 
				<jk>return</jk> currentContents;
			
			update(<jv>name</jv>, <jv>newContents</jv>);
			
			<jc>// Success!</jc>
			<jk>return null</jk>;
		}
	
		
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> MemoryStore update(String <jv>name</jv>, String <jv>newContents</jv>) {
			<jf>cache</jf>.put(<jv>name</jv>, <jv>newContents</jv>);
			<jk>super</jk>.update(<jv>name</jv>, <jv>newContents</jv>);  <jc>// Trigger any listeners.</jc>
			<jk>return this</jk>;
		}
	}
	</p>
</div>
</div><!-- END: 5.10.1 - jc.MemoryStore -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.FileStore' id='jc.FileStore'>5.10.2 - FileStore</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 5.10.2 - jc.FileStore -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.config.store.FileStore} is the typical store used for configuration files.
		It provides the following configurable settings:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.store.FileStore.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.store.FileStore.Builder#charset(Charset) charset(Charset)}
				<li class='jm'>{@link org.apache.juneau.config.store.FileStore.Builder#directory(File) directory(File)}
				<li class='jm'>{@link org.apache.juneau.config.store.FileStore.Builder#updateOnWrite() updateOnWrite()}
				<li class='jm'>{@link org.apache.juneau.config.store.FileStore.Builder#enableWatcher() enableWatcher()}
				<li class='jm'>{@link org.apache.juneau.config.store.FileStore.Builder#watcherSensitivity(WatcherSensitivity) watcherSensitivity(WatcherSensitivity)}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a config store with a watcher thread and high sensitivity.</jc>
	FileStore <jv>fileStore</jv> = FileStore
		.<jsm>create</jsm>()
		.directory(<js>"configs"</js>)
		.useWatcher()
		.watcherSensitivity(<jsf>HIGH</jsf>)
		.build();
	
	<jc>// Create a config using the store defined above.</jc>
	Config <jv>config</jv> = Config
		.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>)
		.store(<jv>fileStore</jv>)
		.build();
	</p>
</div>
</div><!-- END: 5.10.2 - jc.FileStore -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.CustomStores' id='jc.CustomStores'>5.10.3 - Custom ConfigStores</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 5.10.3 - jc.CustomStores -->
<div class='topic'>
	<p>
		The <c>ConfigStore</c> API has been written to allow easy development of custom configuration storage classes.
	</p>
	<p>
		The example below shows a starting point for an implementation based on polling a relational database.
		The source can be found here: {@link org.apache.juneau.examples.core.config.store.SqlStore}.
		Completing it is left as an exercise:
	</p>
	<h5 class='figure'>Example Store Class:</h5>
	<p class='bjava'>
	<jk>public class</jk> SqlStore <jk>extends</jk> ConfigStore {
	
		<jk>private final</jk> String <jf>jdbcUrl</jf>;
		<jk>private final</jk> String <jf>tableName</jf>, <jf>nameColumn</jf>, <jf>valueColumn</jf>;
		<jk>private final</jk> Timer <jf>watcher</jf>;
		<jk>private final</jk> ConcurrentHashMap&lt;String,String&gt; <jf>cache</jf> = <jk>new</jk> ConcurrentHashMap&lt;&gt;();
	
		<jk>protected</jk> SqlStore(ConfigStore.Builder <jv>builder</jv>) {
			<jk>super</jk>(<jv>builder</jv>);
			<jk>this</jk>.<jf>jdbcUrl</jf> = <jv>builder</jv>.<jf>jdbcUrl</jf>;
			<jk>this</jk>.<jf>tableName</jf> = <jv>builder</jv>.<jf>tableName</jf>;
			<jk>this</jk>.<jf>nameColumn</jf> = <jv>builder</jv>.<jf>nameColumn</jf>;
			<jk>this</jk>.<jf>valueColumn</jf> = <jv>builder</jv>.<jf>valueColumn</jf>;
	
			<jk>int</jk> <jv>pollInterval</jv> = <jv>builder</jv>.<jf>pollInterval</jf>;
	
			TimerTask <jv>timerTask</jv> = <jk>new</jk> TimerTask() {
				<ja>@Override</ja>
				<jk>public void</jk> run() {
					SqlStore.<jk>this</jk>.poll();
				}
			};
	
			<jk>this</jk>.<jf>watcher</jf> = <jk>new</jk> Timer(<js>"MyTimer"</js>);
			<jf>watcher</jf>.scheduleAtFixedRate(<jv>timerTask</jv>, 0, <jv>pollInterval</jv> * 1000);
		}
	
		<jk>synchronized void</jk> poll() {
			<jc>// Loop through all our entries and find the latest values.</jc>
			<jk>for</jk> (Map.Entry&lt;String,String&gt; <jv>e</jv> : <jf>cache</jf>.entrySet()) {
				String <jv>name</jv> = <jv>e</jv>.getKey();
				String <jv>cacheContents</jv> = <jv>e</jv>.getValue();
				String <jv>newContents</jv> = getDatabaseValue(<jv>name</jv>);
	
				<jc>// Change detected!</jc>
				<jk>if</jk> (! <jv>cacheContents</jv>.equals(<jv>newContents</jv>))
					update(<jv>name</jv>, <jv>newContents</jv>);
			}
		}
	
		<jc>// Reads the value from the database.</jc>
		<jk>protected</jk> String getDatabaseValue(String <jv>name</jv>) {
			<jc>// Implement me!</jc>
			<jk>return null</jk>;
		}
	
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public boolean</jk> exists(String <jv>name</jv>) {
			<jc>// Implement me!</jc>
			<jk>return false</jk>;
		}
	
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> String read(String <jv>name</jv>) {
			String <jv>contents</jv> = <jf>cache</jf>.get(<jv>name</jv>);
			<jk>if</jk> (<jv>contents</jv> == <jk>null</jk>) {
				<jv>contents</jv> = getDatabaseValue(<jv>name</jv>);
				update(<jv>name</jv>, <jv>contents</jv>);
			}
			<jk>return</jk> <jv>contents</jv>;
		}
	
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> String write(String <jv>name</jv>, String <jv>expectedContents</jv>, String <jv>newContents</jv>) {
	
			<jc>// This is a no-op.</jc>
			<jk>if</jk> (StringUtils.<jsm>eq</jsm>(<jv>expectedContents</jv>, <jv>newContents</jv>))
				<jk>return null</jk>;
	
			String <jv>currentContents</jv> = read(<jv>name</jv>);
	
			<jk>if</jk> (<jv>expectedContents</jv> != <jk>null</jk> &amp;&amp; StringUtils.<jsm>ne</jsm>(<jv>currentContents</jv>, <jv>expectedContents</jv>))
				<jk>return</jk> <jv>currentContents</jv>;
	
			update(<jv>name</jv>, <jv>newContents</jv>);
	
			<jc>// Success!</jc>
			<jk>return null</jk>;
		}
	
		<ja>@Override</ja> <jc>/* ConfigStore */</jc>
		<jk>public synchronized</jk> SqlStore update(String <jv>name</jv>, String <jv>newContents</jv>) {
			<jf>cache</jf>.put(<jv>name</jv>, <jv>newContents</jv>);
			<jk>super</jk>.update(<jv>name</jv>, <jv>newContents</jv>);  <jc>// Trigger any listeners.</jc>
			<jk>return this</jk>;
		}
	
		<ja>@Override</ja> <jc>/* Closeable */</jc>
		<jk>public synchronized void</jk> close() {
			<jk>if</jk> (<jf>watcher</jf> != <jk>null</jk>)
				<jf>watcher</jf>.cancel();
		}
	}
	</p>
</div>
</div><!-- END: 5.10.3 - jc.CustomStores -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jc.StoreListeners' id='jc.StoreListeners'>5.10.4 - ConfigStore Listeners</a></h4>
<div class='topic'><!-- START: 5.10.4 - jc.StoreListeners -->
<div class='topic'>
	<p>
		The <c>ConfigStore</c> class has the following listener methods:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.config.store.ConfigStore}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#register(String,ConfigStoreListener) register(String,ConfigStoreListener)}
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#unregister(String,ConfigStoreListener) unregister(String,ConfigStoreListener)}
			</ul>
		</li>
	</ul>
	<p>
		Note that this is a different listener than {@link org.apache.juneau.config.event.ConfigEventListener}.
		In this case, we're just listening for changed files:
	</p>		
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.config.store.ConfigStoreListener}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.store.ConfigStoreListener#onChange(String) onChange(String)}
			</ul>
		</li>
	</ul>
	<p>
		This listener is used by the <c>Config</c> class to listen for changes on the file system so that it can be
		updated in real-time.
	</p>
</div>
</div><!-- END: 5.10.4 - jc.StoreListeners -->
</div><!-- END: 5.10 - jc.ConfigStores -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ReadOnlyConfigs' id='jc.ReadOnlyConfigs'>5.11 - Read-only Configs</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 5.11 - jc.ReadOnlyConfigs -->
<div class='topic'>
	<p>
		The following settings can be used to create read-only <c>Config</c> objects:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config.Builder#readOnly() readOnly()}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a read-only config</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).readOnly().build();
	</p>
	<p>
		This causes all methods that make modifications to throw {@link java.lang.UnsupportedOperationException}.
	</p>
</div>
</div><!-- END: 5.11 - jc.ReadOnlyConfigs -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.ClosingConfigs' id='jc.ClosingConfigs'>5.12 - Closing Configs</a></h3>
<div class='topic'><!-- START: 5.12 - jc.ClosingConfigs -->
<div class='topic'>
	<p>
		In general, it's good practice to close Config if you're only creating them temporarily so that
		their listeners get unregistered from the underlying storage APIs.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a transient config.</jc>
	Config <jv>config</jv> = Config.<jsm>create</jsm>(<js>"MyConfig.cfg"</js>).build();
	
	<jc>// Do stuff with it.</jc>
	
	<jc>// Then close the config to unregister the listeners.</jc>
	<jv>config</jv>.close();
	</p>
</div>
</div><!-- END: 5.12 - jc.ClosingConfigs -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jc.SystemDefaultConfig' id='jc.SystemDefaultConfig'>5.13 - System Default Config</a><span class='update'>created: 8.0.0, updated: 8.1.0</span></h3>
<div class='topic'><!-- START: 5.13 - jc.SystemDefaultConfig -->
<div class='topic'>
	<p>
		Each JVM has a system default config.  This is a configuration file that serves as the default
		configuration for the system.  It's accessed using the following static methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.config.Config}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.config.Config#getSystemDefault() getSystemDefault()}
				<li class='jm'>{@link org.apache.juneau.config.Config#setSystemDefault(Config) setSystemDefault(Config)}
			</ul>
		</li>
	</ul>
	<p>
		If you do not specify a system default config, one will be automatically searched for.
		The search is done in the following order:
	</p>
	<ol class='spaced-list'>
		<li>
			If the system property <js>"juneau.configFile"</js> is set, we search for this file in first the home
			directory and then the classpath.
		<li>
			In the home directory:
			<ol>
				<li><c>&lt;jar-name&gt;.cfg</c>
				<li>Any file that end with <c>.cfg</c>.  First one matched alphabetically is used.
			</ol>
		<li>
			In the context classpath root package (i.e. inside the jar itself):
			<ol>
				<li><c>&lt;jar-name&gt;.cfg</c>
				<li><c>juneau.cfg</c>
				<li><c>default.cfg</c>
				<li><c>application.cfg</c>
				<li><c>app.cfg</c>
				<li><c>settings.cfg</c>
				<li><c>application.properties</c>
			</ol>
	</ol>
	<p>
		Later in the section on REST resources, we describe how to associate configurations with REST resources
		using the {@link org.apache.juneau.rest.annotation.Rest#config() @Rest(config)} annotation.
		The system default configuration can be referenced with the keyword <c>SYSTEM_DEFAULT</c> like so:
	</p>
	<p class='bjava'>
	<jc>// Always use system default.</jc>
	<ja>@Rest</ja>(config=<js>"SYSTEM_DEFAULT"</js>)

	<jc>// Use system property if set or the system default if not.</jc>
	<ja>@Rest</ja>(config=<js>"$S{juneau.configFile,SYSTEM_DEFAULT}"</js>)
	</p>
	<p>
		By default, all properties in the system default configuration are automatically set as system properties.
		This can be disabled by setting the system property <js>"juneau.disableAutoSystemProps"</js> to <js>"true"</js>.
	</p>
</div>
</div><!-- END: 5.13 - jc.SystemDefaultConfig -->
</div><!-- END: 5 - juneau-config -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-assertions' id='juneau-assertions'>6 - juneau-assertions</a><span class='update'>created: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 6 - juneau-assertions -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-assertions<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-assertions-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.assertions_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The {@link org.apache.juneau.assertions} package in Juneau is a powerful API for performing fluent style assertions.
		It is used to implement built-in assertion methods on both the server and client side APIs.
		But it can also be used standalone for testing.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#ja.Overview' id='ja.Overview'>6.1 - Overview</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 6.1 - ja.Overview -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.assertions} package in Juneau is a powerful API for performing fluent style assertions.
		It is used throughout the REST client and server APIs for performing inline assertions on REST requests and responses.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON support and download a bean.</jc>
	MyBean <jv>bean</jv> = RestClient.<jsm>create</jsm>()
		.json5()
		.build()
		.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(200)
		.assertHeader(<js>"Content-Type"</js>).isMatches(<js>"application/json*"</js>)
		.getContent().assertValue().asString().isContains(<js>"OK"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
	<ul class='notes'>
		<li class='note'>The REST API is described later in the documentation.</i>
	</ul>
	<p>
		The assertions API is designed to be used in both code (as it's done in the REST APIs) or for standalone
		use in unit tests.
	</p>
	<p>
		The {@link org.apache.juneau.assertions.Assertions} class provides various static methods for invoking assertions on a variety
		of object types for simplified unit testing.
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.assertions.Assertions}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertAny(Object) assertAny(T)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertArray(Object[]) assertArray(E[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBean(Object) assertBean(V)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBeanList(List) assertBeanList(List)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBoolean(Boolean) assertBoolean(Boolean)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBooleanArray(boolean[]) assertBooleanArray(boolean[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertByteArray(byte[]) assertByteArray(byte[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBytes(byte[]) assertBytes(byte[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertBytes(InputStream) assertBytes(InputStream)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertCharArray(char[]) assertCharArray(char[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertCollection(Collection) assertCollection(Collection)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertComparable(Comparable) assertComparable(T)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertDate(Date) assertDate(Date)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertDoubleArray(double[]) assertDoubleArray(double[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertFloatArray(float[]) assertFloatArray(float[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertIntArray(int[]) assertIntArray(int[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertInteger(Integer) assertInteger(Integer)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertList(List) assertList(List)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertLong(Long) assertLong(Long)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertLongArray(long[]) assertLongArray(long[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertMap(Map) assertMap(Map)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertObject(Object) assertObject(T)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertOptional(Optional) assertOptional(Optional)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertReader(Reader) assertReader(Reader)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertShortArray(short[]) assertShortArray(short[])}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertString(Object) assertString(Object)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertStringList(List) assertStringList(List)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertThrowable(Throwable) assertThrowable(V)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertThrown(Snippet) assertThrown(Snippet)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertVersion(Version) assertVersion(Version)}
				<li class='jm'>{@link org.apache.juneau.assertions.Assertions#assertZonedDateTime(ZonedDateTime) assertZonedDateTime(ZonedDateTime)}
			</ul>
		</li>
	</ul>
	<p>
		Assertions have 3 categories of methods:
	</p>
	<ul>
		<li>Testing methods (<c>isX</c> methods)
		<li>Transform methods (<c>asX</c> methods)
		<li>Configuration methods (<c>setX</c> methods)
	</ul>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.assertions.Assertions.*;
	<jk>import static</jk> org.apache.juneau.assertions.AssertionPredicates.*;
	
	<jc>// Check the contents of a string.</jc>
	<jsm>assertString</jsm>(<js>"foo, bar"</js>)
		.asSplit(<js>","</js>)
		.asTrimmed()
		.isHas(<js>"foo"</js>, <js>"bar"</js>);

	<jc>// Extract a subset of properties from a list of beans and compare using Simplified JSON.</jc>
	List&lt;MyBean&gt; <jv>myListOfBeans</jv> = ...;
	<jsm>assertBeanList</jsm>(<jv>myListOfBeans</jv>)
		.asPropertyMap(<js>"a,b"</js>)
		.asJson().is(<js>"[{a:1,b:'foo'}]"</js>);
	
	<jc>// Perform an arbitrary Predicate check against a bean.</jc>
	MyBean <jv>myBeans</jv> = ...;
	<jsm>assertBean</jsm>(<jv>myBeans</jv>)
		.is(<jv>x</jv> -&gt; <jsm>isValidCheck</jsm>(<jv>x</jv>))
	
	<jc>// Check that a list of strings has less than 10 entries and the first</jc>
	<jc>// 3 entries are [foo, bar*, null] using assertion predicates.</jc>
	List&lt;String&gt; <jv>myListOfStrings</jv> = ...;
	<jsm>assertStringList</jsm>(<jv>myListOfStrings</jv>)
		.asSize().isLt(10)
		.asFirst(3)
			.isEach(<jsm>eq</jsm>(<js>"foo"</js>),<jsm>match</jsm>(<js>"bar*"</js>),<jsm>isNull</jsm>())
	
	<jc>// Check that an exception is thrown and is the specified type and has the specified message.</jc>
	<jsm>assertThrown</jsm>(()-&gt;<jv>myBean</jv>.runBadMethod())
		.exists()
		.isExactType(RuntimeException.<jk>class</jk>)
		.asMessage().is(<js>"foo"</js>);
	</p>
	<p>
		Testing methods (<c>isX</c> methods) perform an assertion on the specified value and throws a {@link java.lang.AssertionError} if
		the test fails.  Otherwise, the method returns the original assertion object to allow you to chain the command.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Test a string.</jc>
	<jsm>assertString</jsm>(<jv>myString</jv>)
		.isNotNull()  <jc>// Perform test and returns original FluentStringAssertion.</jc>
		.isNotEmpty();  <jc>// Perform test and returns original FluentStringAssertion.</jc>
	</p>	
	<p>
		Transform methods (<c>asX</c> methods) allow you to convert assertions of one type to another type or to convert the tested value to
		some other form wrapped in another assertion.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Customize the behavior of an assertion.</jc>
	<jsm>assertString</jsm>(<jv>myString</jv>)
		.asString()  <jc>// Converts to a FluentIntegerAssertion.</jc>
			.isLt(100)  <jc>// Runs test and returns original FluentStringAssertion.</jc>
		.asUc()  <jc>// Converts string to uppercase and returns a new FluentStringAssertion.</jc>
			.isContains(<js>"FOO"</js>);  <jc>// Runs test and returns original FluentStringAssertion.</jc>
	</p>	
	<p>
		Configuration methods (<c>setX</c> methods) allow you to tailor the behavior of assertions when they fail.  They always return the same assertion object.
		Transformed assertions inherit the configurations of the created-by assertions.  Configuration methods start with <c>set</c>.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Customize the behavior of an assertion.</jc>
	<jsm>assertString</jsm>(<jv>myString</jv>)
		.setMsg(<js>"My string was null.  Value was {VALUE}."</js>)  <jc>// Custom error message when error occurs.</jc>
		.setOut(<jv>myPrintWriter</jv>)  <jc>// Print error message to a separate writer.</jc>
		.setThrowable(MyAssertionThrowable.<jk>class</jk>)  <jc>// Throw a customized assertion exception.</jc>
		.isNotNull();
	</p>	
	<p>
		The following shows the class hierarchy for the {@link org.apache.juneau.assertions.IntegerAssertion IntegerAssertion} class showing the general
		design pattern for assertion classes:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.assertions.Assertion Assertion} - Base class for all assertion objects containing common configuration methods.
			<ul>
				<li class='jac'>{@link org.apache.juneau.assertions.FluentAssertion FluentAssertion&lt;R&gt;} - Parent class for all fluent assertions.
					<ul>
						<li class='jac'>{@link org.apache.juneau.assertions.FluentObjectAssertion FluentObjectAssertion&lt;T,R&gt;} - Tests and transforms for general POJOs.
							<ul>
								<li class='jac'>{@link org.apache.juneau.assertions.FluentComparableAssertion FluentComparableAssertion&lt;T <jk>extends</jk> Comparable,R&gt;} - Tests and transforms for Comparables.
									<ul>
										<li class='jac'>{@link org.apache.juneau.assertions.FluentIntegerAssertion FluentIntegerAssertion&lt;R&gt;} - Tests and transforms for Integers.
											<ul>
												<li class='jac'>{@link org.apache.juneau.assertions.IntegerAssertion IntegerAssertion} - Assertion that returns itself.
											</ul>
										</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		In the design, the "Fluent" classes (e.g. {@link org.apache.juneau.assertions.FluentIntegerAssertion}) allow you to specify the object
		that gets returned when the test method is executed.  When used in the <c>RestClient</c> class for example, the return
		object is the {@link org.apache.juneau.rest.client.RestResponse} object so that you can perform multiple fluent operations against that object.
		The "Normal" classes (e.g. {@link org.apache.juneau.assertions.IntegerAssertion}) are simply subclasses of the fluent equivalent
		which return the assertion itself, meaning the test method returns the original {@link org.apache.juneau.assertions.IntegerAssertion}
		so that multiple tests can be performed per assertion.
	</p>
	<p>
		For more information about the capabilities of the Assertions API, refer to the methods on the {@link org.apache.juneau.assertions.Assertions} methods
		above.
	</p>
</div>
</div><!-- END: 6.1 - ja.Overview -->
</div><!-- END: 6 - juneau-assertions -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-rest-common' id='juneau-rest-common'>7 - juneau-rest-common</a><span class='update'>created: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 7 - juneau-rest-common -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-rest-common<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-rest-common-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.rest.common_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The {@link org.apache.juneau.http} package contains a slew of useful extensions to the Apache HttpComponents libraries
		and define APIs used extensively in the REST server and client APIs.
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.http} - Utility classes used for HTTP parts/headers/entities.
		<li class='jp'>{@link org.apache.juneau.http.annotation} - Swagger-based annotations used on both server-side APIs and client-side proxy interfaces.
		<li class='jp'>{@link org.apache.juneau.http.entity} - HTTP entity classes.
		<li class='jp'>{@link org.apache.juneau.http.header} - HTTP header classes.
		<li class='jp'>{@link org.apache.juneau.http.part} - HTTP query/form-data/path classes.
		<li class='jp'>{@link org.apache.juneau.http.remote} - Remote proxy interface API
		<li class='jp'>{@link org.apache.juneau.http.resource} - HTTP resource classes.
		<li class='jp'>{@link org.apache.juneau.http.response} - HTTP response classes.
	</ul>
	
	<p>
		These APIs extend from the Apache HttpComponents libraries and can be used with libraries based on it such
		as Apache HttpClient.  The REST Client API described later is built on top of Apache HttpClient and many
		of the classes defined in this package make up integral components of that API.  Likewise, the APIs
		defined here are also used in the REST Server APIs also described later.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.HelperClasses' id='jrc.HelperClasses'>7.1 - Helper Classes</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.1 - jrc.HelperClasses -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.header} package contains various convenience classes for creating
		standard HTTP components using static imports.
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.http.HttpHeaders} - Utility class for standard HTTP headers.
		<li class='jc'>{@link org.apache.juneau.http.HttpParts} - Utility class for standard HTTP parts.
		<li class='jc'>{@link org.apache.juneau.http.HttpEntities} - Utility class for standard HTTP entities.
		<li class='jc'>{@link org.apache.juneau.http.HttpResources} - Utility class for standard HTTP resources.
		<li class='jc'>{@link org.apache.juneau.http.HttpResponses} - Utility class for standard HTTP resources.
	</ul>
	
	<h5 class='topic'>HttpHeaders</h5>
	<p>
		The {@link org.apache.juneau.http.HttpHeaders} class contains many convenience static methods and fields for working with standard HTTP request and response headers
		and header lists.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpHeaders.*;

	HeaderList <jv>headers</jv> = 
		<jsm>headerList</jsm>(  <jc>// Arbitrary list of headers</jc>
	
			<jsf>CONTENTTYPE_TEXT_XML</jsf>,   <jc>// Static constants</jc>
		
			<jsm>contentType</jsm>(<js>"text/xml"</js>)   <jc>// Predefined headers</jc>
		
			<jsm>contentType</jsm>(() -&gt; <js>"text/xml"</js>)   <jc>// Predefined headers with supplied values</jc>
		
			<jsm>stringHeader</jsm>(<js>"Content-Type"</js>, <js>"text/xml"</js>)   <jc>// Freeform headers</jc>
		
			<jsm>stringHeader</jsm>(<js>"Content-Type"</js>, () -&gt; <js>"text/xml"</js>)   <jc>// Freeform headers with supplied values</jc>
		);
	</p>
	<p>
		This class is vast in scope and covers all request and response headers defined in RFC2616.
	</p>
	<p>
		In addition to the predefined headers, various methods are provided for free-form headers.  Each accepts
		either static values or values from {@link java.util.function.Supplier Suppliers}:
	</p>
	<ul class='javatreec'>
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#basicHeader(String,Object) basicHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#booleanHeader(String,String) booleanHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#csvHeader(String,String) csvHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#dateHeader(String,String) dateHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#entityTagsHeader(String,String) entityTagsHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#entityTagHeader(String,String) entityTagHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#integerHeader(String,String) integerHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#longHeader(String,String) longHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#mediaRangesHeader(String,String) mediaRangesHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#mediaTypeHeader(String,String) mediaTypeHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#stringHeader(String,String) stringHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#serializedHeader(String,Object) serializedHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#stringRangesHeader(String,String) stringRangesHeader}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#uriHeader(String,String) uriHeader}
	</ul>
	<p>
		The {@link org.apache.juneau.http.HttpHeaders#serializedHeader(String,Object) serializedHeader} methods allows for headers 
		serialized using schema-based serializers such as the OpenAPI serializer. 
	</p>
	
	<p>
		Static methods are also provided for instantiating {@link org.apache.juneau.http.annotation.Header}-annotated or
		other HttpComponent-defined header classes:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#header(Class,String,Object) header(Class,String,Object)}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#header(Class,Object) header(Class,String,Object)}
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpHeaders.*;

	ContentType <jv>contentType</jv> = <jsm>header</jsm>(ContentType.<jk>class</jk>, <js>"text/xml"</js>);
	</p>
	<p>
		Lists of headers can be produced with the following methods:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#headerList() headerList()}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#headerList(Header...) headerList(Header...)}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#headerList(List) headerList(List&lt;Header&gt;)}
		<li class='jm'>{@link org.apache.juneau.http.HttpHeaders#headerList(String...) headerList(String...)}
	</ul>
	<p>
		The capabilities of the {@link org.apache.juneau.http.header.HeaderList} class is described later.
	</p>
		
	<h5 class='topic'>HttpParts</h5>
	<p>
		The {@link org.apache.juneau.http.HttpParts} class contains convenience static methods for generating query/form-data/path parts and part lists.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpParts.*;

	PartList <jv>formData</jv> = 
		<jsm>partList</jsm>(  <jc>// Arbitrary list of parts</jc>
			<jsm>stringPart</jsm>(<js>"Name"</js>, <js>"Bill"</js>)   <jc>// Freeform part</jc>
			<jsm>integerPart</jsm>(<js>"Age"</js>, () -&gt; <jsm>calculateAge</jsm>())   <jc>// Freeform part with supplied value</jc>
		);
	</p>
	<p>
		The following methods are provided for creating parts.  Each accepts
		either static values or values from {@link java.util.function.Supplier Suppliers}:
	</p>
	<ul class='javatreec'>
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#basicPart(String,Object) basicPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#booleanPart(String,Boolean) booleanPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#csvArrayPart(String,String...) csvArrayPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#datePart(String,ZonedDateTime) datePart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#integerPart(String,Integer) integerPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#longPart(String,Long) longPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#serializedPart(String,Object) serializedPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#stringPart(String,String) stringPart}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#uriPart(String,URI) uriPart}
	</ul>
	<p>
		The {@link org.apache.juneau.http.HttpParts#serializedPart(String,Object) serializedPart} methods allows for parts 
		serialized using schema-based serializers such as the OpenAPI serializer. 
	</p>
	<p>
		Lists of parts can be produced with the following methods:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#partList() partList()}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#partList(List) partList(List&lt;NameValuePair&gt;)}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#partList(NameValuePair...) partList(NameValuePair...)}
		<li class='jm'>{@link org.apache.juneau.http.HttpParts#partList(String...) partList(String...)}
	</ul>
	<p>
		The capabilities of the {@link org.apache.juneau.http.part.PartList} class is described later.
	</p>
	
	<h5 class='topic'>HttpEntities</h5>
	<p>
		The {@link org.apache.juneau.http.HttpEntities} class contains convenience static methods for generating HTTP message entities.
		Returned objects extend from  {@code org.apache.http.HttpEntity} but provides the following additional features:
	</p>
	<ul class='spaced-list'>
		<li>
			Caching.
		<li>
			Fluent setters.
		<li>
			Fluent assertions.
		<li>
			Externally-supplied/dynamic content.
	</ul>
	<p>
		The following methods are provided for creating entities.  Each accepts
		either static values or values from {@link java.util.function.Supplier Suppliers} and returns builders:
	</p>
	<ul class='javatreec'>
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#byteArrayEntity(byte[]) byteArrayEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#fileEntity(File) fileEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#readerEntity(Reader) readerEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#serializedEntity(Object, Serializer) serializedEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#streamEntity(InputStream) streamEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpEntities#stringEntity(String) stringEntity}
	</ul>
	<p>
		HTTP entities are automatically supported in both the server and client REST APIs for requests and responses.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpResources.*;
	
	<ja>@RestDelete</ja>(path=<js>"/{id}"</js>)
	<jk>public</jk> HttpEntity helloWold(...) {
		<jk>return</jk> <jsm>stringEntity</jsm>(<js>"Hello!"</js>).contentType(<js>"text/plain"</js>);
	}
	</p>
	
	<h5 class='topic'>HttpResources</h5>
	<p>
		The {@link org.apache.juneau.http.HttpResources} class contains convenience static methods for generating HTTP message resources.
		Returned objects extend from {@link org.apache.juneau.http.resource.HttpResource} which extends from {@link org.apache.http.HttpEntity} but with
		additional arbitrary headers.
	</p>
	<p>
		The following methods are provided for creating entities.  Each accepts
		either static values or values from {@link java.util.function.Supplier Suppliers} and are in the form of builders.
	</p>
	<ul class='javatreec'>
		<li class='jm'>{@link org.apache.juneau.http.HttpResources#byteArrayResource(byte[]) byteArrayResource}
		<li class='jm'>{@link org.apache.juneau.http.HttpResources#fileResource(File) fileResource}
		<li class='jm'>{@link org.apache.juneau.http.HttpResources#readerResource(Reader) readerResource}
		<li class='jm'>{@link org.apache.juneau.http.HttpResources#streamResource(InputStream) streamResource}
		<li class='jm'>{@link org.apache.juneau.http.HttpResources#stringResource(String) stringResource}
	</ul>
	<p>
		The most common location where resources are used are as returned types of REST operation methods described later.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpResources.*;
	
	<ja>@RestDelete</ja>(path=<js>"/{id}"</js>)
	<jk>public</jk> HttpResource helloWold(...) {
		<jk>return</jk> <jsm>stringResource</jsm>(<js>"Hello!"</js>).contentType(<js>"text/plain"</js>).header(<js>"Cache-Control"</js>, <js>"none"</js>);
	}
	</p>
	
	
	<h5 class='topic'>HttpResponses</h5>
	<p>
		The {@link org.apache.juneau.http.HttpResponses} class contains convenience static methods for standard HTTP responses.
		Returned objects extend from {@code org.apache.http.HttpResponse} and are in the form of builders.
	</p>
	<p>
		The following methods are provided for creating entities:
	</p>
	<ul class='javatreec'>
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#_continue() _continue}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#accepted() accepted}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#alreadyReported() alreadyReported}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#badRequest() badRequest}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#conflict() conflict}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#created() created}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#earlyHints() earlyHints}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#expectationFailed() expectationFailed}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#failedDependency() failedDependency}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#forbidden() forbidden}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#found(String) found}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#gone() gone}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#httpVersionNotSupported() httpVersionNotSupported}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#imUsed() imUsed}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#insufficientStorage() insufficientStorage}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#internalServerError() internalServerError}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#lengthRequired() lengthRequired}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#locked() locked}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#loopDetected() loopDetected}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#methodNotAllowed() methodNotAllowed}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#misdirectedRequest() misdirectedRequest}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#movedPermanently(String) movedPermanently}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#multipleChoices() multipleChoices}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#multiStatus() multiStatus}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#networkAuthenticationRequired() networkAuthenticationRequired}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#noContent() noContent}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#nonAuthoritiveInformation() nonAuthoritiveInformation}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#notAcceptable() notAcceptable}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#notExtended() notExtended}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#notFound() notFound}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#notImplemented() notImplemented}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#notModified() notModified}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#ok() ok}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#partialContent() partialContent}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#payloadTooLarge() payloadTooLarge}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#permanentRedirect(String) permanentRedirect}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#preconditionFailed() preconditionFailed}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#preconditionRequired() preconditionRequired}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#processing() processing}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#rangeNotSatisfiable() rangeNotSatisfiable}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#requestHeaderFieldsTooLarge() requestHeaderFieldsTooLarge}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#resetContent() resetContent}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#seeOther(String) seeOther}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#serviceUnavailable() serviceUnavailable}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#switchingProtocols() switchingProtocols}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#temporaryRedirect(String) temporaryRedirect}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#tooManyRequests() tooManyRequests}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#unauthorized() unauthorized}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#unavailableForLegalReasons() unavailableForLegalReasons}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#unprocessableEntity() unprocessableEntity}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#unsupportedMediaType() unsupportedMediaType}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#upgradeRequired() upgradeRequired}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#uriTooLong() uriTooLong}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#useProxy() useProxy}
		<li class='jm'>{@link org.apache.juneau.http.HttpResponses#variantAlsoNegotiates() variantAlsoNegotiates}
	</ul>
	<p>
		The most common location where these responses are used are in REST operation methods described later.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpResponses.*;
	<jk>import static</jk> org.apache.juneau.http.HttpHeaders.*;
 
	<ja>@RestDelete</ja>(path=<js>"/{id}"</js>)
	<jk>public</jk> Ok doDelete(...) <jk>throws</jk> Unauthorized {
		<jk>if</jk> (<jc>/* user not authorized*/</jc>)
			<jk>throw</jk> <jsm>unauthorized</jsm>();
		<jk>return</jk> <jsm>ok</jsm>().content(<js>"Delete was successful"</js>);
	}
	</p>
</div>
</div><!-- END: 7.1 - jrc.HelperClasses -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.Annotations' id='jrc.Annotations'>7.2 - Annotations</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.2 - jrc.Annotations -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation} package contains annotations for defining both server and client side 
		APIs.  The server-side APIs also use it for producing auto-generated Swagger documentation through
		the REST API itself.
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Contact}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
		<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
		<li class='ja'>{@link org.apache.juneau.http.annotation.HasFormData}
		<li class='ja'>{@link org.apache.juneau.http.annotation.HasQuery}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<li class='ja'>{@link org.apache.juneau.http.annotation.License}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
		<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Tag}
	</ul>
	<p>
		These annotations are used in a variety of places in the server and client side REST interfaces, especially for
		remote proxies.  These will be described later in those sections.
	</p>
</div>
</div><!-- END: 7.2 - jrc.Annotations -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.HttpHeaders' id='jrc.HttpHeaders'>7.3 - HTTP Headers</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.3 - jrc.HttpHeaders -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.header} package contains implementations of <c>org.apache.http.Header</c> for all common HTTP
		headers.
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.http.header.Accept}
		<li class='jc'>{@link org.apache.juneau.http.header.AcceptCharset}
		<li class='jc'>{@link org.apache.juneau.http.header.AcceptEncoding}
		<li class='jc'>{@link org.apache.juneau.http.header.AcceptLanguage}
		<li class='jc'>{@link org.apache.juneau.http.header.AcceptRanges}
		<li class='jc'>{@link org.apache.juneau.http.header.Age}
		<li class='jc'>{@link org.apache.juneau.http.header.Allow}
		<li class='jc'>{@link org.apache.juneau.http.header.Authorization}
		<li class='jc'>{@link org.apache.juneau.http.header.CacheControl}
		<li class='jc'>{@link org.apache.juneau.http.header.ClientVersion}
		<li class='jc'>{@link org.apache.juneau.http.header.Connection}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentDisposition}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentEncoding}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentLanguage}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentLength}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentLocation}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentRange}
		<li class='jc'>{@link org.apache.juneau.http.header.ContentType}
		<li class='jc'>{@link org.apache.juneau.http.header.Date}
		<li class='jc'>{@link org.apache.juneau.http.header.Debug}
		<li class='jc'>{@link org.apache.juneau.http.header.ETag}
		<li class='jc'>{@link org.apache.juneau.http.header.Expect}
		<li class='jc'>{@link org.apache.juneau.http.header.Expires}
		<li class='jc'>{@link org.apache.juneau.http.header.Forwarded}
		<li class='jc'>{@link org.apache.juneau.http.header.From}
		<li class='jc'>{@link org.apache.juneau.http.header.Host}
		<li class='jc'>{@link org.apache.juneau.http.header.IfMatch}
		<li class='jc'>{@link org.apache.juneau.http.header.IfModifiedSince}
		<li class='jc'>{@link org.apache.juneau.http.header.IfNoneMatch}
		<li class='jc'>{@link org.apache.juneau.http.header.IfRange}
		<li class='jc'>{@link org.apache.juneau.http.header.IfUnmodifiedSince}
		<li class='jc'>{@link org.apache.juneau.http.header.LastModified}
		<li class='jc'>{@link org.apache.juneau.http.header.Location}
		<li class='jc'>{@link org.apache.juneau.http.header.MaxForwards}
		<li class='jc'>{@link org.apache.juneau.http.header.NoTrace}
		<li class='jc'>{@link org.apache.juneau.http.header.Origin}
		<li class='jc'>{@link org.apache.juneau.http.header.Pragma}
		<li class='jc'>{@link org.apache.juneau.http.header.ProxyAuthenticate}
		<li class='jc'>{@link org.apache.juneau.http.header.ProxyAuthorization}
		<li class='jc'>{@link org.apache.juneau.http.header.Range}
		<li class='jc'>{@link org.apache.juneau.http.header.Referer}
		<li class='jc'>{@link org.apache.juneau.http.header.RetryAfter}
		<li class='jc'>{@link org.apache.juneau.http.header.Server}
		<li class='jc'>{@link org.apache.juneau.http.header.TE}
		<li class='jc'>{@link org.apache.juneau.http.header.Thrown}
		<li class='jc'>{@link org.apache.juneau.http.header.Trailer}
		<li class='jc'>{@link org.apache.juneau.http.header.TransferEncoding}
		<li class='jc'>{@link org.apache.juneau.http.header.Upgrade}
		<li class='jc'>{@link org.apache.juneau.http.header.UserAgent}
		<li class='jc'>{@link org.apache.juneau.http.header.Vary}
		<li class='jc'>{@link org.apache.juneau.http.header.Via}
		<li class='jc'>{@link org.apache.juneau.http.header.Warning}
		<li class='jc'>{@link org.apache.juneau.http.header.WwwAuthenticate}
	</ul>
	<p>
		These headers extend from the following classes that provide data-type specific functionality:
	</p>
	<ul class='javatree'>
		<li class='jic'>{@code org.apache.http.NameValuePair}
		<ul>
			<li class='jic'>{@code org.apache.http.Header}
			<ul>
				<li class='jc'>{@link org.apache.juneau.http.header.BasicHeader}
				<ul class='javatreec'>
					<li class='jc'>{@link org.apache.juneau.http.header.BasicBooleanHeader}	
					<li class='jc'>{@link org.apache.juneau.http.header.BasicCsvHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicDateHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicEntityTagHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicEntityTagsHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicIntegerHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicLongHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicMediaRangesHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicMediaTypeHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicStringHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicStringRangesHeader}
					<li class='jc'>{@link org.apache.juneau.http.header.BasicUriHeader}
				</ul>
			</ul>
		</ul>
	</ul>
	<p>
		These subclasses provide various convenience methods to allow for easy fluent-style coding.
	</p>
	<h5 class='figure'>Examples</h5>
	<p class='bjava'>
	<jc>// Validates the response body content is not expired.</jc>
	<jv>restClient</jv>
		.get(<jsf>URL</jsf>)
		.run()
		.getHeader(<js>"Expires"</js>).asDateHeader().assertZonedDateTime().isLessThan(<jk>new</jk> Date());
	</p>
	
	<h5 class='topic'>HeaderList</h5>
	<p>
		The {@link org.apache.juneau.http.header.HeaderList} class is a list of HTTP headers.
	</p>

	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// Construct using builder.</jc>
	HeaderList <jv>headers</jv> = HeaderList
		.<jsm>create</jsm>()
		.append(Accept.<jsm>of</jsm>(<js>"text/xml"</js>))
		.append(<js>"Content-Type"</js>, ()-&gt;<jsm>getDynamicContentTypeFromSomewhere</jsm>());
	
	<jc>// Construct using convenience creator.</jc>
	HeaderList <jv>headers</jv> = HeaderList.<jsm>of</jsm>(Accept.<jsf>TEXT_XML</jsf>, ContentType.<jsf>TEXT_XML</jsf>);
	</p>
	<p>
		Static methods are provided on {@link org.apache.juneau.http.HttpHeaders} to further simplify creation of header lists.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpHeaders.*;

	HeaderList <jv>headers</jv> = <jsm>headerList</jsm>(<jsm>accept</jsm>(<js>"text/xml"</js>), <jsm>contentType</jsm>(<js>"text/xml"</js>));
	</p>
	<p>
		The builder class supports setting default header values (i.e. add a header to the list if it isn't otherwise in the list).
		Note that this is different from simply setting a value twice as using default values will not overwrite existing
		headers.
		<br>The following example notes the distinction:
	</p>
	<p class='bjava'>
	<jv>headers</jv> = HeaderList
		.<jsm>create</jsm>()
		.set(Accept.<jsf>TEXT_PLAIN</jsf>)
		.set(Accept.<jsf>TEXT_XML</jsf>);
	<jsm>assertObject</jsm>(<jv>headers</jv>).isString(<js>"[Accept: text/xml]"</js>);

	<jv>headers</jv> = HeaderList
		.create()
		.set(Accept.<jsf>TEXT_PLAIN</jsf>)
		.setDefault(Accept.<jsf>TEXT_XML</jsf>);
	<jsm>assertObject</jsm>(<jv>headers</jv>).isString(<js>"[Accept: text/plain]"</js>);
	</p>

	<p>
		Various methods are provided for iterating over the headers in this list to avoid array copies.
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.http.header.HeaderList#forEach(Consumer) forEach(Consumer)} / {@link org.apache.juneau.http.header.HeaderList#forEach(String,Consumer) forEach(String,Consumer)} / {@link org.apache.juneau.http.header.HeaderList#forEach(Predicate,Consumer) forEach(Predicate,Consumer)} - Use consumers to process headers.
		<li class='jm'>{@link org.apache.juneau.http.header.HeaderList#headerIterator() headerIterator()} / {@link org.apache.juneau.http.header.HeaderList#headerIterator(String) headerIterator(String)} - Use an {@link org.apache.http.HeaderIterator} to process headers.
		<li class='jm'>{@link org.apache.juneau.http.header.HeaderList#stream() stream()} / {@link org.apache.juneau.http.header.HeaderList#stream(String) stream(String)} - Use a stream.
	</ul>
	<p>
		In general, try to use these over the {@link org.apache.juneau.http.header.HeaderList#getAll() getAll()} / {@link org.apache.juneau.http.header.HeaderList#getAll(String) getAll(String)} methods that require array copies.
	</p>
	<p>
		The {@link org.apache.juneau.http.header.HeaderList#get(String) get(String)} method is special in that it will collapse multiple headers with the same name into
		a single comma-delimited list (see <a href='https://tools.ietf.org/html/rfc2616#section-4.2'>RFC 2616 Section 4.2</a> for rules).
	</p>
	<p>
		The {@link org.apache.juneau.http.header.HeaderList#get(Class) get(Class)} and {@link org.apache.juneau.http.header.HeaderList#get(String,Class) get(String,Class)} methods are provided for working with {@link org.apache.juneau.http.annotation.Header}-annotated
		beans.
	</p>
	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	HeaderList headers = HeaderList.of(Accept.TEXT_JSON, Accept.TEXT_XML);

	<jc>// Returns "text/json, text/xml"</jc>
	Accept <jv>accept</jv> = <jv>headers</jv>.get(Accept.<jk>class</jk>);
	</p>

	<p>
		By default, header names are treated as case-insensitive.  This can be changed using the {@link org.apache.juneau.http.header.HeaderList#caseSensitive(boolean) caseSensitive(boolean)}
		method.
	</p>

	<p>
		A {@link org.apache.juneau.svl.VarResolver} can be associated with this builder to create header values with embedded variables that
		are resolved at runtime.
	</p>

	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// Create a header list with dynamically-resolving values pulled from a system property.</jc>

	System.<jsm>setProperty</jsm>(<js>"foo"</js>, <js>"bar"</js>);

	HeaderList <jv>headers</jv> = HeaderList
		.<jsm>create</jsm>()
		.resolving()
		.append(<js>"X1"</js>, <js>"$S{foo}"</js>)
		.append(<js>"X2"</js>, ()-&gt;<js>"$S{foo}"</js>);

	<jsm>assertObject</jsm>(<jv>headers</jv>).isString(<js>"[X1: bar, X2: bar]"</js>);
	</p>

	<p>
		The {@link org.apache.juneau.http.header.HeaderList} object can be extended to defined pre-packaged lists of headers which can be used in various
		annotations throughout the framework.
	</p>
	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// A predefined list of headers.</jc>
	<jk>public class</jk> MyHeaderList <jk>extends</jk> HeaderList {
		<jk>public</jk> MyHeaderList() {
			<jk>super</jk>(Accept.<jsf>TEXT_XML</jsf>, ContentType.<jsf>TEXT_XML</jsf>);
		}
	}

	<jc>// Use it on a remote proxy to add headers on all requests.</jc>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>, headerList=MyHeaderList.<jk>class</jk>)
	<jk>public interface</jk> PetStore {

		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		Pet addPet(
			<ja>@Content</ja> CreatePet <jv>createPet</jv>,
			<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>,
			<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
		);
	}
	</p>
</div>
</div><!-- END: 7.3 - jrc.HttpHeaders -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.HttpParts' id='jrc.HttpParts'>7.4 - HTTP Parts</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.4 - jrc.HttpParts -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.part} package contains implementations of <c>org.apache.http.NameValuePair</c> to 
		be used for query/form-data/path parts and part lists.
	</p>
	<ul class='javatree'>
		<li class='jic'>{@code org.apache.http.NameValuePair}
		<ul>
			<li class='jc'>{@link org.apache.juneau.http.part.BasicPart}
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.http.part.BasicBooleanPart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicCsvArrayPart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicDatePart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicIntegerPart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicLongPart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicPartIterator}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicStringPart}
				<li class='jc'>{@link org.apache.juneau.http.part.BasicUriPart}
			</ul>
		</ul>
	</ul>

	<h5 class='topic'>PartList</h5>
	<p>
		The {@link org.apache.juneau.http.part.PartList} class is a list of HTTP parts (form-data, query-parameters, path-parameters).
	</p>
	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	PartList <jv>parts</jv> = PartList
		.<jsm>create</jsm>()
		.append(MyPart.<jsm>of</jsm>(<js>"foo"</js>))
		.append(<js>"Bar"</js>, ()-&gt;<jsm>getDynamicValueFromSomewhere</jsm>());
	</p>

	<p>
		Convenience creators are provided for creating lists with minimal code:
	</p>
	<p class='bjava'>
	PartList <jv>parts</jv> = PartList.<jsm>of</jsm>(BasicIntegerPart.<jsm>of</jsm>(<js>"foo"</js>, 1));
	</p>

	<p>
		Static methods are provided on {@link org.apache.juneau.http.HttpParts} to further simplify creation of part lists.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpParts.*;

	PartList <jv>parts</jv> = <jsm>partList</jsm>(<jsm>integerPart</jsm>(<js>"foo"</js>, 1), <jsm>booleanPart</jsm>(<js>"bar"</js>, <jk>false</jk>));
	</p>

	<p>
		The builder class supports setting default part values (i.e. add a part to the list if it isn't otherwise in the list).
		Note that this is different from simply setting a value twice as using default values will not overwrite existing
		parts.
		<br>The following example notes the distinction:
	</p>

	<p class='bjava'>
	<jv>parts</jv> = PartList
		.<jsm>create</jsm>()
		.set(<js>"Foo"</js>, <js>"bar"</js>)
		.set(<js>"Foo"</js>, <js>"baz"</js>);
	<jsm>assertObject</jsm>(<jv>parts</jv>).isString(<js>"foo=baz"</js>);

	<jv>parts</jv> = PartList
		.create()
		.set(<js>"Foo"</js>, <js>"bar"</js>)
		.setDefault(<js>"Foo"</js>, <js>"baz"</js>);
	<jsm>assertObject</jsm>(<jv>parts</jv>).isString(<js>"foo=bar"</js>);
	</p>

	<p>
		Various methods are provided for iterating over the parts in this list to avoid array copies.
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.http.part.PartList#forEach(Consumer) forEach(Consumer)} / {@link org.apache.juneau.http.part.PartList#forEach(String,Consumer) forEach(String,Consumer)} / {@link org.apache.juneau.http.part.PartList#forEach(Predicate,Consumer) forEach(Predicate,Consumer)} - Use consumers to process parts.
		<li class='jm'>{@link org.apache.juneau.http.part.PartList#partIterator() partIterator()} / {@link org.apache.juneau.http.part.PartList#partIterator(String) partIterator(String)} - Use an {@link org.apache.juneau.http.part.PartIterator} to process parts.
		<li class='jm'>{@link org.apache.juneau.http.part.PartList#stream() stream()} / {@link org.apache.juneau.http.part.PartList#stream(String) stream(String)} - Use a stream.
	</ul>
	<p>
		In general, try to use these over the {@link org.apache.juneau.http.part.PartList#getAll() getAll()} / {@link org.apache.juneau.http.part.PartList#getAll(String) getAll(String)} methods that require array copies.
	</p>

	<p>
		Similar to the way multiple headers can be collapsed into a single value, the {@link org.apache.juneau.http.part.PartList#get(String) get(String)} method is special in that it will collapse multiple parts with the same name into
		a single comma-delimited list.
	</p>

	<p>
		The {@link org.apache.juneau.http.part.PartList#get(Class) get(Class)} and {@link org.apache.juneau.http.part.PartList#get(String,Class) get(String,Class)} methods are provided for working with {@link org.apache.juneau.http.annotation.FormData} / {@link org.apache.juneau.http.annotation.Query} / {@link org.apache.juneau.http.annotation.Path}-annotated
		beans.
	</p>

	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	MyQueryBean <jv>foo</jv> = <jv>parts</jv>.get(MyQueryBean.<jk>class</jk>);
	</p>

	<p>
		A {@link org.apache.juneau.svl.VarResolver} can be associated with this builder to create part values with embedded variables that
		are resolved at runtime.
	</p>

	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// Create a part list with dynamically-resolving values pulled from a system property.</jc>

	System.<jsm>setProperty</jsm>(<js>"foo"</js>, <js>"bar"</js>);

	PartList <jv>parts</jv> = PartList
		.<jsm>create</jsm>()
		.resolving()
		.append(<js>"X1"</js>, <js>"$S{foo}"</js>)
		.append(<js>"X2"</js>, ()-&gt;<js>"$S{foo}"</js>);

	<jsm>assertObject</jsm>(<jv>parts</jv>).isString(<js>"X1=bar&amp;X2=bar"</js>);
	</p>

	<p>
		The {@link org.apache.juneau.http.part.PartList} object can be extended to defined pre-packaged lists of parts which can be used in various
		annotations throughout the framework.
	</p>

	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// A predefined list of parts.</jc>
	<jk>public class</jk> MyPartList <jk>extends</jk> PartList {
		<jk>public</jk> MyPartList() {
			<jk>super</jk>(BasicIntegerPart.<jsm>of</jsm>(<js>"foo"</js>,1), BasicBooleanPart.<jsm>of</jsm>(<js>"bar"</js>,<jk>false</jk>));
		}
	}
	</p>
</div>
</div><!-- END: 7.4 - jrc.HttpParts -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#HttpEntitiesAndResources' id='HttpEntitiesAndResources'>7.5 - HTTP Entities and Resources</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.5 - HttpEntitiesAndResources -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.entity} package contains implementations of <c>org.apache.http.HttpEntity</c>.  These are
		entities that can be sent or received with an HTTP message.  They consist of a message body and the headers
		<c>Content-Type</c>, <c>Content-Length</c>, and <c>Content-Encoding</c>.  
	</p>
	<p>
		The {@link org.apache.juneau.http.resource} package contains implementations of {@link org.apache.juneau.http.resource.HttpResource} which are extensions of <c>org.apache.http.HttpEntity</c> with 
		arbitrary headers added beyond the standard content headers.
	</p>
	<ul class='javatree'>
		<li class='jic'>{@code org.apache.http.HttpEntity}
		<ul>
			<li class='jc'>{@link org.apache.juneau.http.entity.BasicHttpEntity}
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.http.entity.ByteArrayEntity}
				<li class='jc'>{@link org.apache.juneau.http.entity.FileEntity}
				<li class='jc'>{@link org.apache.juneau.http.entity.StreamEntity}
				<li class='jc'>{@link org.apache.juneau.http.entity.ReaderEntity}
				<li class='jc'>{@link org.apache.juneau.http.entity.SerializedEntity}
				<li class='jc'>{@link org.apache.juneau.http.entity.StringEntity}
			</ul>
			<li class='jic'>{@link org.apache.juneau.http.resource.HttpResource}
			<ul>
				<li class='jc'>{@link org.apache.juneau.http.resource.BasicResource}
				<ul class='javatreec'>
					<li class='jc'>{@link org.apache.juneau.http.resource.ByteArrayResource}
					<li class='jc'>{@link org.apache.juneau.http.resource.FileResource}
					<li class='jc'>{@link org.apache.juneau.http.resource.StreamResource}
					<li class='jc'>{@link org.apache.juneau.http.resource.ReaderResource}
					<li class='jc'>{@link org.apache.juneau.http.resource.StringResource}
				</ul>
			</ul>
		</ul>
	</ul>
	
	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.http.HttpEntities.*;

	<jk>byte</jk>[] <jv>payload</jv> = {...};

	<jc>// Create via type builder.</jc>
	HttpEntity <jv>entity</jv> = ByteArrayEntity
		.<jsm>create</jsm>()
		.content(<jv>payload</jv>)
		.contentType(ContentType.<jsf>APPLICATION_OCTET_STREAM</jsf>);

	<jc>// Create via HttpEntities.</jc>
	HttpEntity <jv>entity</jv> = <jsm>byteArrayEntity</jsm>(<jv>payload</jv>, ContentType.<jsf>APPLICATION_OCTET_STREAM</jsf>);
	</p>
	
	<p>
		HTTP entities and resources can be used by both the server and client side APIs described in later sections.
	</p>
	<h5 class='figure'>Server-side example:</h5>
	<p class='bjava'>
	<jc>// REST endpoint that simply echos an HTTP entity.</jc>
	<ja>@RestPost</ja>(path=<js>"/entity"</js>)
	<jk>public</jk> HttpEntity echoMyEntity(HttpEntity <jv>entity</jv>) {
		<jk>return</jk> <jv>entity</jv>;
	}
 
	<jc>// REST endpoint that serves up a static file.</jc>
	<ja>@RestGet</ja>(path=<js>"/resource/{fileName}"</js>)
	<jk>public</jk> HttpResource getStaticFile(<ja>@Path</ja> String <jv>fileName</jv>, Locale <jv>locale</jv>) {
		getContext().getStaticFiles().resolve(<jv>fileName</jv>, <jv>locale</jv>).orElseThrow(NotFound::<jk>new</jk>);
	}
	</p>
	
	
	<h5 class='figure'>Client-side example:</h5>
	<p class='bjava'>
	<jc>// REST client that uses the echo REST endpoint above.</jc> 
	
	HttpEntity <jv>entity</jv> = <jsm>byteArrayEntity</jsm>(...);
	
	<jv>entity</jv> = RestClient.<jsm>create</jsm>()
		.build()
		.rootUrl(<jsf>URI</jsf>)
		.post(<js>"/entity"</js>, <jv>entity</jv>)
		.run()
		.assertStatus().asCode().is(200)
		.getContent().as(ByteArrayEntity.<jk>class</jk>);
	</p>
</div>
</div><!-- END: 7.5 - HttpEntitiesAndResources -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.HttpResponses' id='jrc.HttpResponses'>7.6 - HTTP Responses</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.6 - jrc.HttpResponses -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.response} package contains predefined <c>org.apache.http.HttpResponse</c> implementations for most standard HTTP
		responses. 
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.http.response.Accepted}
		<li class='jc'>{@link org.apache.juneau.http.response.AlreadyReported}
		<li class='jc'>{@link org.apache.juneau.http.response.BadRequest}
		<li class='jc'>{@link org.apache.juneau.http.response.Conflict}
		<li class='jc'>{@link org.apache.juneau.http.response.Continue}
		<li class='jc'>{@link org.apache.juneau.http.response.Created}
		<li class='jc'>{@link org.apache.juneau.http.response.EarlyHints}
		<li class='jc'>{@link org.apache.juneau.http.response.ExpectationFailed}
		<li class='jc'>{@link org.apache.juneau.http.response.FailedDependency}
		<li class='jc'>{@link org.apache.juneau.http.response.Forbidden}
		<li class='jc'>{@link org.apache.juneau.http.response.Found}
		<li class='jc'>{@link org.apache.juneau.http.response.Gone}
		<li class='jc'>{@link org.apache.juneau.http.response.HttpVersionNotSupported}
		<li class='jc'>{@link org.apache.juneau.http.response.IMUsed}
		<li class='jc'>{@link org.apache.juneau.http.response.InsufficientStorage}
		<li class='jc'>{@link org.apache.juneau.http.response.InternalServerError}
		<li class='jc'>{@link org.apache.juneau.http.response.LengthRequired}
		<li class='jc'>{@link org.apache.juneau.http.response.Locked}
		<li class='jc'>{@link org.apache.juneau.http.response.LoopDetected}
		<li class='jc'>{@link org.apache.juneau.http.response.MethodNotAllowed}
		<li class='jc'>{@link org.apache.juneau.http.response.MisdirectedRequest}
		<li class='jc'>{@link org.apache.juneau.http.response.MovedPermanently}
		<li class='jc'>{@link org.apache.juneau.http.response.MultipleChoices}
		<li class='jc'>{@link org.apache.juneau.http.response.MultiStatus}
		<li class='jc'>{@link org.apache.juneau.http.response.NetworkAuthenticationRequired}
		<li class='jc'>{@link org.apache.juneau.http.response.NoContent}
		<li class='jc'>{@link org.apache.juneau.http.response.NonAuthoritiveInformation}
		<li class='jc'>{@link org.apache.juneau.http.response.NotAcceptable}
		<li class='jc'>{@link org.apache.juneau.http.response.NotExtended}
		<li class='jc'>{@link org.apache.juneau.http.response.NotFound}
		<li class='jc'>{@link org.apache.juneau.http.response.NotImplemented}
		<li class='jc'>{@link org.apache.juneau.http.response.NotModified}
		<li class='jc'>{@link org.apache.juneau.http.response.Ok}
		<li class='jc'>{@link org.apache.juneau.http.response.PartialContent}
		<li class='jc'>{@link org.apache.juneau.http.response.PayloadTooLarge}
		<li class='jc'>{@link org.apache.juneau.http.response.PermanentRedirect}
		<li class='jc'>{@link org.apache.juneau.http.response.PreconditionFailed}
		<li class='jc'>{@link org.apache.juneau.http.response.PreconditionRequired}
		<li class='jc'>{@link org.apache.juneau.http.response.Processing}
		<li class='jc'>{@link org.apache.juneau.http.response.RangeNotSatisfiable}
		<li class='jc'>{@link org.apache.juneau.http.response.RequestHeaderFieldsTooLarge}
		<li class='jc'>{@link org.apache.juneau.http.response.ResetContent}
		<li class='jc'>{@link org.apache.juneau.http.response.SeeOther}
		<li class='jc'>{@link org.apache.juneau.http.response.ServiceUnavailable}
		<li class='jc'>{@link org.apache.juneau.http.response.SwitchingProtocols}
		<li class='jc'>{@link org.apache.juneau.http.response.TemporaryRedirect}
		<li class='jc'>{@link org.apache.juneau.http.response.TooManyRequests}
		<li class='jc'>{@link org.apache.juneau.http.response.Unauthorized}
		<li class='jc'>{@link org.apache.juneau.http.response.UnavailableForLegalReasons}
		<li class='jc'>{@link org.apache.juneau.http.response.UnprocessableEntity}
		<li class='jc'>{@link org.apache.juneau.http.response.UnsupportedMediaType}
		<li class='jc'>{@link org.apache.juneau.http.response.UpgradeRequired}
		<li class='jc'>{@link org.apache.juneau.http.response.UriTooLong}
		<li class='jc'>{@link org.apache.juneau.http.response.UseProxy}
		<li class='jc'>{@link org.apache.juneau.http.response.VariantAlsoNegotiates}
	</ul>	
	
	<p>
		These are built upon existing HttpComponents APIs:
	</p>
	<ul class='javatree'>
		<li class='jic'>{@code org.apache.http.HttpMessage}
		<ul>
			<li class='jic'>{@code org.apache.http.HttpResponse}
			<ul>
				<li class='jc'>{@link org.apache.juneau.http.response.BasicHttpResponse} - 100-399 response codes
				<li class='jc'>{@link org.apache.juneau.http.response.BasicHttpException} - 400+ response codes
			</ul>
		</ul>
	</ul>
	
	<p>
		The most common location where these responses are used are in REST operation methods described later.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestDelete</ja>(path=<js>"/{id}"</js>)
	<jk>public</jk> Ok doDelete(<ja>@Path</ja> <jk>int</jk> <jv>id</jv>) <jk>throws</jk> NotFound, Unauthorized {
		<jf>pojoService</jf>.delete(<jf>pojoService</jf>.find(<jv>id</jv>).orElseThrow(NotFound::<jk>new</jk>));
		<jk>return</jk> Ok.OK;
	}
	</p>
	
	<p>
		The following classes are also provided for constructing your own custom responses:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.http.response.BasicHttpException}
		<li class='jc'>{@link org.apache.juneau.http.response.BasicHttpResponse}
	</ul>	
</div>
</div><!-- END: 7.6 - jrc.HttpResponses -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.RemoteProxyInterfaces' id='jrc.RemoteProxyInterfaces'>7.7 - Remote Proxy Interfaces</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 7.7 - jrc.RemoteProxyInterfaces -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.remote} package contains the annotations used for defining client-side remote proxies.
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.remote.Remote}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteGet}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemotePut}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemotePost}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteDelete}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteOp}
	</ul>
	<p>
		See <a class="doclink" href="#jrc.Proxies">Proxies</a> for more information on use of these annotations.
	</p>
</div>
</div><!-- END: 7.7 - jrc.RemoteProxyInterfaces -->
</div><!-- END: 7 - juneau-rest-common -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-rest-server' id='juneau-rest-server'>8 - juneau-rest-server</a><span class='update'>updated: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 8 - juneau-rest-server -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-rest-server<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-rest-server-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.rest.server_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The <l>juneau-rest-server</l> library allows you to quickly wrap POJOs and expose them as full-fledged REST 
		resources served up in a servlet container using a bare-minimum amount of code.
		The primary goal for Juneau was to make it as easy as possible to implement easy-to-read and self-documenting 
		REST resources using very little code.
	</p>
	<p>
		One of the biggest advantages of the Juneau REST framework over similar architectures is that it hides the 
		serialization layer from the developer.  
		The developer can work entirely with POJOs and let the Juneau framework handle all the serialization and 
		parsing work.  
		The developer need never know what the <l>Accept</l> or <l>Content-Type</l> or <l>Accept-Encoding</l> (etc...) 
		header values are because those details are all handled by the framework. 
	</p>
	<p> 
		The API builds upon the existing JEE Servlet API.  
		The root class, {@link org.apache.juneau.rest.servlet.RestServlet} is nothing but a specialized 
		{@link javax.servlet.http.HttpServlet}, and the {@link org.apache.juneau.rest.RestRequest} and 
		{@link org.apache.juneau.rest.RestResponse} classes are nothing more than specialized 
		{@link javax.servlet.http.HttpServletRequest} and {@link javax.servlet.http.HttpServletResponse} objects.  
		This allows maximum flexibility for the developer since you can let Juneau handle operations such as 
		serialization, or you can revert to the existing servlet APIs to do low-level processing of requests yourself.	
		It also means you need nothing more than a Servlet container such as Jetty to use the REST framework.
	</p>
	
	<h5 class='topic'>Features</h5>
	<ul class='spaced-list'>
		<li>
			Deployable in standard Servlet containers.
		<li>
			Deployable in Spring Boot environments with full support for injected beans.
		<li>
			Serializes POJOs to JSON, XML, HTML, URL-Encoding, UON, RDF/XML, N-Triple, Turtle, N3, SOAP, or 
			Java-serialized-object based on value of <l>Accept</l> header.  
			<br>No user code is required to handle these types.
			<ul>
				<li>Extensible design that provides ability to override existing content type handlers, or add the 
					ability to handle other kinds of content types.
			</ul>
		<li>
			Parses content of POST/PUT request bodies to POJOs.
		<li>
			Automatic built-in ability to serialize POJO metadata to JSON+SCHEMA, XML+SCHEMA, or HTML+SCHEMA based on 
			<l>Accept</l> header.
		<li>
			Automatic negotiation of output Writer based on HTTP headers.
			<ul>
				<li>Automatic handling of <l>Accept-Charset</l> header for all character sets supported by the JVM.
				<li>Automatic handling of <l>Accept-Encoding</l> header with registered encoders.
			</ul>
		<li>
			Automatic error handling.
			<ul>
				<li>Automatic 401 errors (Unauthorized) on failed guards.
				<li>Automatic 404 errors (Not Found) on unmatched path patterns.
				<li>Automatic 405 errors (Method Not Implemented) on unimplemented methods.
				<li>Automatic 406 errors (Not Acceptable) when no matching serializer was found to handle the 
					<l>Accept</l> header.
				<li>Automatic 412 errors (Precondition Failed) when all matchers failed to match.
				<li>Automatic 415 errors (Unsupported Media Type) when no matching parser was found was found to handle 
					the <l>Content-Type</l> header.
				<li>Automatic 500 errors on uncaught exceptions.
			</ul>
		<li>
			Support for parsing all HTTP parts (headers, query, formData, path variables) using Swagger formatting rules and validations.
			<br>Not limited to simple POJOs but rather you can represent arbitrarily-complex POJOs in any HTTP part using UON notation.
		<li>
			Auto-created Swagger JSON and Swagger UI available through OPTIONS requests of resources.
		<li>
			Various useful debugging features that make debugging using a browser extremely simple...
			<ul>
				<li>Ability to pass HTTP header values as URL GET parameters (e.g. <l>&amp;Accept=text/xml</l>).
				<li>Ability to pass HTTP content on PUT/POST requests as a URL GET parameter 
					(e.g. <l>&amp;content=(foo=bar)</l>).
				<li>Ability to simulate non-GET requests using a <l>&amp;method</l> GET parameter 
					(e.g. <l>&amp;method=POST</l>).
				<li>Ability to force <js>"text/plain"</js> on response using GET parameter <l>&amp;plainText=true</l>.
			</ul>
		<li>
			Ability to implement overloaded HTTP methods through the use of the <l>&amp;method</l> attribute 
			(e.g. <l>&amp;method=FOO</l>).
		<li>
			Ability to match URL patterns (e.g. <l>/foo/{fooId}/bar/{barId}</l>) against URLs 
			(e.g. <l>/foo/123/bar/456/bing</l>).
		<li>
			Ability to associate guards at the resource or method levels through annotations.
			<br>Typically useful for security but can be used for a variety of purposes.
		<li>
			Ability to associate converters at the resource or method levels through annotations.
			<br>Typically useful for performing conversions on input and output, such as for supporting older input and 
			output formats.
	</ul>
	<p>
		Many of the examples in this document are pulled directly from <l>juneau-examples-rest</l>.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Overview' id='jrs.Overview'>8.1 - Overview</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.1 - jrs.Overview -->
<div class='topic'>
	<p>
		A REST resource is simply a Java class annotated with {@link org.apache.juneau.rest.annotation.Rest @Rest}.
		The most common case is a class that extends {@link org.apache.juneau.rest.servlet.BasicRestServlet}, which itself is simply an 
		extension of {@link javax.servlet.http.HttpServlet} which allows it to be deployed as a servlet.  
	</p>
	<p>
		Juneau has two sample applications for demonstrating how to use the REST API, one using Jetty and one using
		Spring Boot:
	</p>
	<ul class='javatree'>
		<li class='jp'><c>org.apache.juneau.examples.rest.jetty</c>
		<li class='jp'><c>org.apache.juneau.examples.rest.springboot</c>
	</ul>
	<p>
		The <c>org.apache.juneau.examples.rest.springboot</c> application is described in the section <a class="doclink" href="#jrss.Overview">SpringBoot Overview</a>.
	</p>
	<p>
		The Jetty application consists of the following application class that registers our top-level servlet:
	</p>
	<p class='bjava'>
	<jk>public class</jk> App {
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) <jk>throws</jk> Exception {
			JettyMicroservice
				.<jsm>create</jsm>()
				.args(<jv>args</jv>)
				.servlet(RootResources.<jk>class</jk>)
				.build()
				.start()
				.startConsole()
				.join();
		}
	}
	</p>
	<p>
		The root resources class is an example of a router page that is used to attach children to:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		title=<js>"Root resources"</js>,
		description=<js>"Example of a router resource page."</js>,
		children={
			HelloWorldResource.<jk>class</jk>,
			DtoExamples.<jk>class</jk>,
			UtilityBeansResource.<jk>class</jk>,
			HtmlBeansResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"api: servlet:/api"</js>,
			<js>"stats: servlet:/stats"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/RootResources.java"</js>
		},
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This is an example of a 'router' page that serves as a jumping-off point to child resources.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Resources can be nested arbitrarily deep through router pages.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Note the &lt;span class='link'&gt;API&lt;/span&gt; link provided that lets you see the generated swagger doc for this page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;STATS&lt;/span&gt; link to view runtime statistics on this page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;SOURCE&lt;/span&gt; link to view the source code for the page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;All content on pages in the UI are serialized POJOs.  In this case, it's a serialized array of beans with 2 properties, 'name' and 'description'.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Other features (such as this aside) are added through annotations.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		},
		asideFloat=<js>"RIGHT"</js>
	)
	<ja>@SerializerConfig</ja>(
		<jc>// For testing purposes, we want to use single quotes in all the serializers so it's easier to do simple
		// String comparisons.
		// You can apply any of the Serializer/Parser/BeanContext settings this way.</jc>
		quoteChar=<js>"'"</js>
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L;
	}	
	</p>
	<p>
		This is what it looks like in a browser:
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.Overview.RootResources.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.Overview.RootResources.json.png'>
	
	<p>
		The {@link org.apache.juneau.examples.rest.HelloWorldResource} class is our basic example of a child REST resource:
	</p>
	
	<p class='bjava'>
	<ja>@Rest</ja>(
		title=<js>"Hello World"</js>,
		description=<js>"An example of the simplest-possible resource"</js>,
		path=<js>"/helloWorld"</js>
	)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a resource that simply response with a 'Hello world!' message&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;The POJO serialized is a simple String.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestObject {
	
		<ja>@RestGet</ja>(path=<js>"/*"</js>, summary=<js>"Responds with \"Hello world!\""</js>)
		<jk>public</jk> String sayHello() {
			<jk>return</jk> <js>"Hello world!"</js>;
		}
	}
	</p>

	<p>
		This is what it looks like in a browser:
	</p>

	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.Overview.HelloWorldResource.png'>
	
	<p>
		It doesn't much simpler than that.  
		In this case, we're simply returning a string that will be converted to any of the supported languages (e.g. 
		JSON, XML, HTML, ...).
		However, we could have returned any POJO consisting of beans, maps, collections, etc...
	</p>
</div>
</div><!-- END: 8.1 - jrs.Overview -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.AnnotatedClasses' id='jrs.AnnotatedClasses'>8.2 - @Rest-Annotated Classes</a><span class='update'>updated: 8.1.2,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.2 - jrs.AnnotatedClasses -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.annotation.Rest @Rest} annotation is the primary way of defining
		and configuring REST resource classes.
		The functionality of the class itself is covered in detail in the topics below.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#allowedHeaderParams() allowedHeaderParams}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#allowedMethodHeaders() allowedMethodHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#allowedMethodParams() allowedMethodParams}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#beanStore() beanStore}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#callLogger() callLogger}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#children() children}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#clientVersionHeader() clientVersionHeader}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#config() config}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#consumes() consumes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#converters() converters}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#debug() debug}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#debugEnablement() debugEnablement}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#debugOn() debugOn}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultAccept() defaultAccept}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultCharset() defaultCharset}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultContentType() defaultContentType}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultRequestAttributes() defaultRequestAttributes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultRequestHeaders() defaultRequestHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultResponseHeaders() defaultResponseHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#description() description}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#disableContentParam() disableContentParam}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#encoders() encoders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#guards() guards}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#maxInput() maxInput}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#messages() messages}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#on() on}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#onClass() onClass}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#parsers() parsers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#partParser() partParser}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#partSerializer() partSerializer}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#path() path}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#produces() produces}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#renderResponseStackTraces() renderResponseStackTraces}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#responseProcessors() responseProcessors}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#restChildrenClass() restChildrenClass}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#restOpArgs() restOpArgs}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#restOperationsClass() restOperationsClass}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#roleGuard() roleGuard}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#rolesDeclared() rolesDeclared}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#serializers() serializers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#siteName() siteName}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#staticFiles() staticFiles}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#swagger() swagger}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#swaggerProvider() swaggerProvider}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#title() title}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#uriAuthority() uriAuthority}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#uriContext() uriContext}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#uriRelativity() uriRelativity}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#uriResolution() uriResolution}
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.rest.annotation.Rest @Rest} annotation in inheritable from parents and interfaces of resource classes.
		When multiple annotations are defined at different levels, the annotation values are combined.
		This is a particularly useful feature because it allows you to define your own configured parent
		resource classes that can be extended by all your child resources so that they all share common
		settings.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.PredefinedClasses' id='jrs.PredefinedClasses'>8.2.1 - Predefined Classes</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.2.1 - jrs.PredefinedClasses -->
<div class='topic'>
	<p>
		The following example represents the bare-minimum needed
		for deploying a top-level REST endpoint with basic JSON marshalling support:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/mypath"</js>,
		serializers=JsonSerializer.<jk>class</jk>,
		parsers=JsonParser.<jk>class</jk>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServlet {
	
		<ja>@RestGet</ja>(path=<js>"/"</js>)
		<jk>public</jk> Object getPojo() {
			...
		}
	}
	</p>
	<p>
		The {@link org.apache.juneau.rest.servlet.RestServlet} class provides all the logic for starting up your REST
		application when the servlet container calls {@link org.apache.juneau.rest.servlet.RestServlet#init(ServletConfig) init(ServletConfig)}.  
		On startup, it scans your class for annotations and sets up 
		all of your serializers and parsers.  It then does this recursively for all child resources.
	</p>
	<p>
		Users will typically not extend directly from {@link org.apache.juneau.rest.servlet.RestServlet}.  Instead, several classes are provided by the framework to provide additional
		functionality and to handle different use-cases.  Users will typically extend from one of these <c>Basic*</c> classes:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link javax.servlet.http.HttpServlet} 
			<ul>
				<li class='jac'>{@link org.apache.juneau.rest.servlet.RestServlet}
					<ul>
						<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestServlet} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicRestOperations}, {@link org.apache.juneau.rest.config.BasicUniversalConfig}
							<ul>
								<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestServletGroup} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicGroupOperations}
							</ul>
						</li>
						<li class='jac'>{@link org.apache.juneau.rest.springboot.SpringRestServlet}
							<ul>
								<li class='jac'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicRestOperations}, {@link org.apache.juneau.rest.config.BasicUniversalConfig}
									<ul>
										<li class='jac'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicGroupOperations}
									</ul>
								</li>
							</ul>
						</li>
					</ul>
				</li>
			</ul>
		</li>
		<li class='jac'>{@link org.apache.juneau.rest.servlet.RestObject}
			<ul>
				<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestObject} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicRestOperations}, {@link org.apache.juneau.rest.config.BasicJsonConfig}
					<ul>
						<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestObjectGroup} <jk>implements</jk> {@link org.apache.juneau.rest.servlet.BasicGroupOperations}
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.rest.servlet.RestServlet}
		class itself is not configured with any serializers or parsers.  However, it does
		provide several convenience methods to be aware of:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.rest.servlet.RestServlet}
			<ul class='spaced-list'>
				<li>Logging methods:
					<ul class='javatreec'>
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#log(Level,String,Object...) log(Level,String,Object...)}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#log(Level,Throwable,String,Object...) log(Level,Throwable,String,Object...)}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#log(String) log(String)}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#log(String,Throwable) log(String,Throwable)}
					</ul>
				</li>
				<li>Other methods:
					<ul class='javatreec'>
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#getContext() getContext()}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#getPath() getPath()}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#getRequest() getRequest()}
						<li class='jm'>{@link org.apache.juneau.rest.servlet.RestServlet#getResponse() getResponse()}
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		The <c>Basic*</c> classes implement the {@link org.apache.juneau.rest.servlet.BasicRestOperations} interface
		which defines common endpoints for swagger documentation, statistics, and serving static files:
	</p>
	<p class='bjava'>
	<jk>public interface</jk> BasicRestOperations {

		<ja>@RestGet</ja>(path=<js>"/api/*"</js>)
		<jk>public</jk> {@link org.apache.juneau.dto.swagger.Swagger} {@link org.apache.juneau.rest.servlet.BasicRestOperations#getSwagger(RestRequest) getSwagger}({@link org.apache.juneau.rest.RestRequest} <jv>req</jv>);

		<ja>@RestGet</ja>(path=<js>"/htdocs/*"</js>)
		<jk>public</jk> {@link org.apache.juneau.http.resource.HttpResource} {@link org.apache.juneau.rest.servlet.BasicRestOperations#getHtdoc(String,Locale) getHtdoc}(<ja>@Path</ja> String <jv>path</jv>, Locale <jv>locale</jv>);

		<ja>@RestGet</ja>(path=<js>"favicon.ico"</js>)
		<jk>public</jk> {@link org.apache.juneau.http.resource.HttpResource} {@link org.apache.juneau.rest.servlet.BasicRestOperations#getFavIcon() getFavIcon}();

		<ja>@RestGet</ja>(path=<js>"/stats"</js>)
		<jk>public</jk> {@link org.apache.juneau.rest.stats.RestContextStats} {@link org.apache.juneau.rest.servlet.BasicRestOperations#getStats(RestRequest) getStats}({@link org.apache.juneau.rest.RestRequest} <jv>req</jv>);

		<ja>@RestOp</ja>(method=<jsf>ANY</jsf>, path=<js>"/error"</js>)
		<jk>public void</jk> {@link org.apache.juneau.rest.servlet.BasicRestOperations#error() error}();
	}
	</p>
	<p>
		The <c>Basic*</c> classes also implement {@link org.apache.juneau.rest.config.BasicJsonConfig} interface which
		provides basic JSON marshalling support.  Other config interfaces are available as
		well to quickly provide different types of marshalling support.  Note that these interfaces
		do not define any methods but rather simply provide a set of commonly-used annotations so that
		you don't need to define them on all your classes.
	</p>
	<ul class='javatreec'>
		<li class='jic'>{@link org.apache.juneau.rest.config.BasicJsonConfig}
		<li class='jic'>{@link org.apache.juneau.rest.config.BasicJsonHtmlConfig}
		<li class='jic'>{@link org.apache.juneau.rest.config.BasicJson5Config}
		<li class='jic'>{@link org.apache.juneau.rest.config.BasicOpenApiConfig}
		<li class='jic'>{@link org.apache.juneau.rest.config.BasicUniversalConfig}
	</ul>
	<p>
		For example, if you want to provide a resource that supports all languages in Juneau, 
		simply add the {@link org.apache.juneau.rest.config.BasicUniversalConfig} interface like so:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyResource <jk>extends</jk> RestServlet <jk>implements</jk> BasicUniversalConfig {
		...
	}
	</p>
	<p>
		The <c>*Group</c> classes implement the {@link org.apache.juneau.rest.servlet.BasicGroupOperations} interface which provides an additional REST endpoint for listing and navigating child resources:
	</p>
	<p class='bjava'>
	<jk>public interface</jk> BasicGroupOperations {

		<ja>@RestGet</ja>(path=<js>"/"</js>)
		<jk>public</jk> {@link org.apache.juneau.rest.beans.ChildResourceDescriptions} {@link org.apache.juneau.rest.servlet.BasicGroupOperations#getChildren(RestRequest) getChildren}({@link org.apache.juneau.rest.RestRequest} <jv>req</jv>);
	}
	</p>
	<p>
		The <c>*Spring*</c> classes are meant to be used in Spring Boot environments so that you can
		take full advantage of the Spring Framework for injecting dependencies on child resources
		and helper classes.
	</p>
	<p>
		The <c>*Object*</c> classes provide the same functionality as the servlet
		classes but do not extend from {@link javax.servlet.http.HttpServlet}.  
		This becomes important in Spring Boot environments where you may want to 
		define child resources as Spring Beans but don't want Spring Boot to auto-detect
		them as servlets to be deployed as top-level resources.  This is less important
		in standard servlet containers that don't auto-deploy servlets.  In those
		environments, you can also use servlet classes for child resources.
	</p>
	<p>
		The following is a breakdown of which classes you will use in different cases:
	</p>
	<ul class='spaced-list'>
		<li>Top level resources in a servlet container:
			<ul class='javatreec'>
				<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestServlet}
				<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestServletGroup}
			</ul>
		</li>
		<li>Top level resources in a Spring Boot environment:
			<ul class='javatreec'>
				<li class='jac'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServlet}
				<li class='jac'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup}
			</ul>
		</li>
		<li>Child resources:
			<ul class='javatreec'>
				<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestObject}
				<li class='jac'>{@link org.apache.juneau.rest.servlet.BasicRestObjectGroup}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.2.1 - jrs.PredefinedClasses -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.ChildResources' id='jrs.ChildResources'>8.2.2 - Child Resources</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.2.2 - jrs.ChildResources -->
<div class='topic'>
	<p>
		Child Resources are REST servlets or objects that are linked to parent resources through the 
		{@link org.apache.juneau.rest.annotation.Rest#children() @Rest(children)} annotation.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jd>/** Parent Resource */</jd>
	<ja>@Rest</ja>(
		path=<js>"/parent"</js>,
		children={MyChildResource.<jk>class</jk>}
	)
	<jk>public</jk> MyRootResources <jk>extends</jk> BasicRestServletGroup {...}
	</p>
	<p class='bjava'>
	<jd>/** Child Resource */</jd>
	<ja>@Rest</ja>(
		path=<js>"/child"</js>  <jc>// Path relative to parent resource.</jc>
	)
	<jc>// Note that we don't need to extend from RestServlet.</jc>
	<jk>public</jk> MyChildResource <jk>extends</jk> BasicRestObject {...} 
	</p>
	<p>
		The path of the child resource gets appended to the path of the parent resource. 
		So in the example above, the child resource is accessed through the URL <l>/parent/child</l>.
	</p>
	<p>
		One advantage of using child resources is that they do not need to be declared in the JEE <l>web.xml</l> 
		file.
		Initialization of and access to the child resources occurs through the parent resource.
		Children can be nested arbitrary deep to create complex REST interfaces with a single top-level REST servlet.
	</p>
	<p>
		As explained earlier, child REST objects typically extend from {@link org.apache.juneau.rest.servlet.BasicRestObject} or {@link org.apache.juneau.rest.servlet.BasicRestObjectGroup}
		and not from one of the servlet classes.  They also technically don't even need to extend from those classes
		and can instead just be a normal class annotated with the bare-minimum {@link org.apache.juneau.rest.annotation.Rest @Rest} and {@link org.apache.juneau.rest.annotation.RestOp @RestOp}
		annotations.
	</p>
</div>
</div><!-- END: 8.2.2 - jrs.ChildResources -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.PathVariables' id='jrs.PathVariables'>8.2.3 - Path Variables</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.2.3 - jrs.PathVariables -->
<div class='topic'>
	<p>
		The path can contain variables that get resolved to {@link org.apache.juneau.http.annotation.Path @Path} parameters
		or access through the {@link org.apache.juneau.rest.RestRequest#getPathParams()} method.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/myResource/{foo}/{bar}"</js>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestServlet {

		<ja>@RestPost</ja>(<js>"/{baz}"</js>)
		<jk>public void</jk> String doX(<ja>@Path</ja> String <jv>foo</jv>, <ja>@Path</ja> <jk>int</jk> <jv>bar</jv>) {
			...
		}
	}
	</p>
	<p>
		Variables can be used on either top-level or child resources and can be defined on multiple levels.
		Path variables resolved in parent resource paths are also available to the child resources.
	</p>
	<div class='info'>
		All variables in the path must be specified or else the target will not resolve and a <c>404</c> will result.
	</div>
</div>
</div><!-- END: 8.2.3 - jrs.PathVariables -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.Deployment' id='jrs.Deployment'>8.2.4 - Deployment</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.2.4 - jrs.Deployment -->
<div class='topic'>
	<p>
		REST resources are deployed in the following ways:
	</p>
	<ul class='spaced-list'>
		<li>Deployed in a J2EE container as a servlet.
		<li>Deployed in a Spring Boot environment as a servlet.
		<li>Deployed as a child of another REST resource.
	</ul>
	<p>
		When deployed in a J2EE container, you MUST extend from one of the servlet classes.
	</p>
	<ul class='notes'>
		<li class='note'>
			When deployed as a child of another resource, you MAY extend from one of the servlet classes but it's 
			not necessary.</b>
			The only requirement is that the class be annotated with <ja>@Rest</ja> and have one of the following constructors
			if they aren't already Spring Beans:
			<ul class='javatreec'>
				<li class='jm'><c><jk>public</jk> T()</c>
				<li class='jm'><c><jk>public</jk> T(RestContext.Builder)</c>
			</ul>
		</li>
	</ul>
	<p>
		Deployment in a servlet container is typically done by adding a servlet entry for the top-level resources to the JEE <l>web.xml</l>.
	</p>
	<p>
		Deployment in a Spring Boot environment involves defining your top-level resources as Spring Beans.  
		Top-level resources must extend from {@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} or {@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup}
		so that Juneau can hook into the injection framework provided by Spring.  Child resource CAN be defined as injected Spring Beans
		as well but it is not a requirement.  
	</p>
	<h5 class='figure'>Example Spring Boot Configuration</h5>
	<p class='bjava'>
	<ja>@SpringBootApplication</ja>
	<ja>@Controller</ja>
	<jk>public class</jk> SpringBootAppConfig {
			
		<ja>@Bean</ja>
		<jk>public</jk> MyRootResources getRootResources() {
			...
		}
	
		<ja>@Bean</ja>
		<jk>public</jk> MyChildResource getMyChildResource() {
			...
		}
	
		<ja>@Bean</ja>
		<jk>public</jk> ServletRegistrationBean&lt;Servlet&gt; getRootServlet(RootResources <jv>rootResources</jv>) {
			<jk>return new</jk> ServletRegistrationBean&lt;&gt;(<jv>rootResources</jv>, <js>"/*"</js>);
		}
	}
	</p>	
</div>
</div><!-- END: 8.2.4 - jrs.Deployment -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.LifecycleHooks' id='jrs.LifecycleHooks'>8.2.5 - Lifecycle Hooks</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.2.5 - jrs.LifecycleHooks -->
<div class='topic'>
	<p>
		Lifecycle hooks allow you to hook into lifecycle events of the servlet/resource creation and REST calls.
	</p>
	<p>
		For example, if you want to add an initialization method to your resource:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestObject {

		<jc>// Our database.</jc>
		<jk>private</jk> Map&lt;Integer,Object&gt; <jf>myDatabase</jf>;

		<ja>@RestInit</ja>
		<jk>public void</jk> initMyDatabase(RestContext.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			<jf>myDatabase</jf> = <jk>new</jk> LinkedHashMap&lt;&gt;();
		}
	}
	</p>
	<p>
		Or if you want to intercept REST calls:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestObject {

		<jc>// Add a request attribute to all incoming requests.</jc>
		<ja>@RestPreCall</ja>
		<jk>public void</jk> onPreCall(RestRequest <jv>req</jv>) {
			<jv>req</jv>.setAttribute(<js>"foo"</js>, <js>"bar"</js>);
		}
	}
	</p>
	<p>
		The following lifecycle annotations are provided.
	</p>
	<ul class='javatree'>
		<li>Resource lifecycle events:
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestInit} - Right before initialization.
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPostInit} - Right after initialization.
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestDestroy} - Right before servlet destroy.
			</ul>
		</li>
		<li>REST call lifecycle events:
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestStartCall} - At the beginning of a REST call.
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPreCall} - Right before the <ja>@RestOp</ja> method is invoked.
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPostCall} - Right after the <ja>@RestOp</ja> method is invoked.
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestEndCall} - At the end of the REST call after the response has been flushed.
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.2.5 - jrs.LifecycleHooks -->
</div><!-- END: 8.2 - jrs.AnnotatedClasses -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.RestOpAnnotatedMethods' id='jrs.RestOpAnnotatedMethods'>8.3 - @RestOp-Annotated Methods</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.3 - jrs.RestOpAnnotatedMethods -->
<div class='topic'>
	<p>
		REST Java methods are identified on REST servlets using the 
		{@link org.apache.juneau.rest.annotation.RestOp @RestOp} annotation. 
		The annotation allows the framework to identify the available REST methods through reflection.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#clientVersion() clientVersion}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#consumes() consumes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#converters() converters}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#debug() debug}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultAccept() defaultAccept}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultCharset() defaultCharset}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultContentType() defaultContentType}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestAttributes() defaultRequestAttributes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestFormData() defaultRequestFormData}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestHeaders() defaultRequestHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestQueryData() defaultRequestQueryData}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultResponseHeaders() defaultResponseHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#description() description}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#encoders() encoders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#guards() guards}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#matchers() matchers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#maxInput() maxInput}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#method() method}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#on() on}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#parsers() parsers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#path() path}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#produces() produces}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#roleGuard() roleGuard}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#rolesDeclared() rolesDeclared}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#serializers() serializers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#summary() summary}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#swagger() swagger}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#value() value}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestOp</ja>(method=<jsf>GET</jsf>, path=<js>"/"</js>)
	<jk>public</jk> String sayHello() {
		<jk>return</jk> <js>"Hello world!"</js>;
	}
	</p>
	
	<p>
		The following specialized annotations are also provided for specific HTTP methods:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestGet}
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPut}
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPost}
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestDelete}
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(path=<js>"/"</js>)
	<jk>public</jk> String sayHello() {
		<jk>return</jk> <js>"Hello world!"</js>;
	}
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.InferredHttpMethodsAndPaths' id='jrs.InferredHttpMethodsAndPaths'>8.3.1 - Inferred HTTP Methods and Paths</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.1 - jrs.InferredHttpMethodsAndPaths -->
<div class='topic'>
	<p>
		When the <c>name</c> and/or <c>path</c> values are not specified, their values are inferred
		from the Java method name. 
	</p>
	<p>
		The HTTP method can be inferred from the Java method by starting the method name with any of the following:
	</p>
	<ul>
		<li><c>get</c>
		<li><c>put</c>
		<li><c>post</c>
		<li><c>delete</c>
		<li><c>options</c>
		<li><c>head</c>
		<li><c>trace</c>
		<li><c>patch</c>
	</ul>
	<p>
		If <c>path</c> is not defined, it's inferred from the Java method name (minus the prefix above).
	</p>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Method="GET", path="/foo"</jc>
	<ja>@RestOp</ja>
	<jk>public</jk> String getFoo() {...}
	</p>
	<p class='bjava'>
	<jc>// Method="DELETE", path="/foo"</jc>
	<ja>@RestOp</ja>
	<jk>public</jk> String deleteFoo() {...}
	</p>
	<p class='bjava'>
	<jc>// Method="GET", path="/foo"</jc>
	<jc>// "GET" is default</jc>
	<ja>@RestOp</ja>
	<jk>public</jk> String foo() {...}
	</p>
	<p class='bjava'>
	<jc>// Method="GET", path="/"</jc>
	<ja>@RestOp</ja>(path=<js>"/"</js>)
	<jk>public</jk> String foo() {...}
	</p>
	<p class='bjava'>
	<jc>// Method="GET", path="/"</jc>
	<ja>@RestOp</ja>
	<jk>public</jk> String get() {...}
	</p>
	<p class='bjava'>
	<jc>// Method="POST", path="/"</jc>
	<ja>@RestOp</ja>
	<jk>public</jk> String post() {...}
	</p>
	
	<p>
		If <c>name</c> and <c>path</c> are both specified, the Java method name can be anything.
	</p>
</div>
</div><!-- END: 8.3.1 - jrs.InferredHttpMethodsAndPaths -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.JavaMethodParameters' id='jrs.JavaMethodParameters'>8.3.2 - Java Method Parameters</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.2 - jrs.JavaMethodParameters -->
<div class='topic'>
	<p>
		Java methods can contain any of the following parameters in any order:
	</p>
	<ul class='spaced-list'>
		<li>
			<b>Parameters based on class types:</b>
			<ul class='spaced-list'>
				<li>Request objects:
					<ul class='javatreec'>
						<li class='jic'>{@code AsyncContext}
						<li class='jc'>{@link org.apache.juneau.rest.arg.CookieList}
						<li class='je'>{@code DispatcherType}
						<li class='jc'>{@link org.apache.juneau.httppart.HttpPartParserSession}
						<li class='jc'>{@link org.apache.juneau.httppart.HttpPartSerializerSession}
						<li class='jic'>{@code HttpServletRequest}
						<li class='jc'>{@link java.io.InputStream}
						<li class='jac'>{@link org.apache.juneau.parser.InputStreamParser}
						<li class='jc'>{@link java.util.Locale}
						<li class='jc'>{@link org.apache.juneau.cp.Messages}
						<li class='jac'>{@link org.apache.juneau.parser.Parser}
						<li class='jic'>{@link java.security.Principal}
						<li class='jc'>{@link java.io.Reader}
						<li class='jac'>{@link org.apache.juneau.parser.ReaderParser}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestAttributes}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestContent}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestFormParams}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestHeaders}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestPathParams}
						<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestQueryParams}
						<li class='jc'>{@link java.util.ResourceBundle}
						<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
						<li class='jic'>{@code ServletInputStream}
						<li class='jc'>{@link org.apache.juneau.dto.swagger.Swagger}
						<li class='jc'>{@link java.util.TimeZone}
						<li class='jc'>{@link org.apache.juneau.UriContext}
						<li class='jc'>{@link org.apache.juneau.UriResolver}
						<li class='jc'>{@link org.apache.juneau.svl.VarResolverSession}
					</ul>
				</li>
				<li>Response objects:
					<ul class='javatreec'>
						<li class='jic'>{@code HttpServletResponse}
						<li class='jc'>{@link java.io.OutputStream}
						<li class='jc'>{@link org.apache.juneau.rest.RestResponse}
						<li class='jic'>{@code ServletOutputStream}
						<li class='jc'>{@link java.io.Writer}
					</ul>
				</li>
				<li>Session objects:
					<ul class='javatreec'>
						<li class='jic'>{@code HttpSession}
						<li class='jc'>{@link org.apache.juneau.rest.RestSession}
						<li class='jc'>{@link org.apache.juneau.rest.util.UrlPath}
						<li class='jc'>{@link org.apache.juneau.rest.util.UrlPathMatch}
						<li class='jc'>{@link org.apache.juneau.cp.BeanStore}
						<li class='jc'>{@link org.apache.juneau.rest.RestOpSession}
					</ul>				
				</li>
				<li>Parsed request header values:
					<ul class='javatreec'>
						<li class='jc'>{@link org.apache.juneau.http.header.Accept}
						<li class='jc'>{@link org.apache.juneau.http.header.AcceptCharset}
						<li class='jc'>{@link org.apache.juneau.http.header.AcceptEncoding}
						<li class='jc'>{@link org.apache.juneau.http.header.AcceptLanguage}
						<li class='jc'>{@link org.apache.juneau.http.header.AcceptRanges}
						<li class='jc'>{@link org.apache.juneau.http.header.Authorization}
						<li class='jc'>{@link org.apache.juneau.http.header.CacheControl}
						<li class='jc'>{@link org.apache.juneau.http.header.ClientVersion}
						<li class='jc'>{@link org.apache.juneau.http.header.Connection}
						<li class='jc'>{@link org.apache.juneau.http.header.ContentDisposition}
						<li class='jc'>{@link org.apache.juneau.http.header.ContentEncoding}
						<li class='jc'>{@link org.apache.juneau.http.header.ContentLength}
						<li class='jc'>{@link org.apache.juneau.http.header.ContentType}
						<li class='jc'>{@link org.apache.juneau.http.header.Date}
						<li class='jc'>{@link org.apache.juneau.http.header.Debug}
						<li class='jc'>{@link org.apache.juneau.http.header.Expect}
						<li class='jc'>{@link org.apache.juneau.http.header.Forwarded}
						<li class='jc'>{@link org.apache.juneau.http.header.From}
						<li class='jc'>{@link org.apache.juneau.http.header.Host}
						<li class='jc'>{@link org.apache.juneau.http.header.IfMatch}
						<li class='jc'>{@link org.apache.juneau.http.header.IfModifiedSince}
						<li class='jc'>{@link org.apache.juneau.http.header.IfNoneMatch}
						<li class='jc'>{@link org.apache.juneau.http.header.IfRange}
						<li class='jc'>{@link org.apache.juneau.http.header.IfUnmodifiedSince}
						<li class='jc'>{@link org.apache.juneau.http.header.MaxForwards}
						<li class='jc'>{@link org.apache.juneau.http.header.NoTrace}
						<li class='jc'>{@link org.apache.juneau.http.header.Origin}
						<li class='jc'>{@link org.apache.juneau.http.header.Pragma}
						<li class='jc'>{@link org.apache.juneau.http.header.ProxyAuthorization}
						<li class='jc'>{@link org.apache.juneau.http.header.Range}
						<li class='jc'>{@link org.apache.juneau.http.header.Referer}
						<li class='jc'>{@link org.apache.juneau.http.header.TE}
						<li class='jc'>{@link org.apache.juneau.http.header.Thrown}
						<li class='jc'>{@link org.apache.juneau.http.header.Upgrade}
						<li class='jc'>{@link org.apache.juneau.http.header.UserAgent}
						<li class='jc'>{@link org.apache.juneau.http.header.Warning}
					</ul>
				</li>
				<li>Context values:
					<ul class='javatreec'>
						<li class='jc'>{@link org.apache.juneau.BeanContext}
						<li class='jc'>{@link org.apache.juneau.rest.logger.CallLogger}
						<li class='jc'>{@link org.apache.juneau.config.Config}
						<li class='jic'>{@link org.apache.juneau.rest.debug.DebugEnablement}
						<li class='jc'>{@link org.apache.juneau.encoders.EncoderSet}
						<li class='jic'>{@link org.apache.juneau.cp.FileFinder}
						<li class='jc'>{@link org.apache.juneau.jsonschema.JsonSchemaGenerator}
						<li class='jc'>{@link java.util.logging.Logger}
						<li class='jc'>{@link org.apache.juneau.rest.stats.MethodExecStore}
						<li class='jc'>{@link org.apache.juneau.parser.ParserSet}
						<li class='jc'>{@link org.apache.juneau.rest.RestChildren}
						<li class='jc'>{@link org.apache.juneau.rest.RestContext}
						<li class='jc'>{@link org.apache.juneau.rest.stats.RestContextStats}
						<li class='jc'>{@link org.apache.juneau.rest.RestOpContext}
						<li class='jc'>{@link org.apache.juneau.rest.RestOperations}
						<li class='jc'>{@link org.apache.juneau.serializer.SerializerSet}
						<li class='jic'>{@link org.apache.juneau.rest.staticfile.StaticFiles}
						<li class='jc'>{@link org.apache.juneau.rest.stats.ThrownStore}
					</ul>
				</li>
			</ul>
		<li><b>Annotated parameters (either on the parameter or parameter type):</b>
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.rest.annotation.Attr}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
				<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasFormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasQuery}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
				<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.Method}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
			</ul>
		</li>
	</ul>
	<p>
		In Spring Boot environments, any available Spring Beans can also be passed in as parameters.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/example1/{a1}/{a2}/{a3}/*"</js>)
	<jk>public</jk> String doGetExample1(
		RestRequest <jv>req</jv>,
		RestResponse <jv>res</jv>,
		<ja>@Method</ja> String <jv>method</jv>,
		<ja>@Path</ja>(<js>"a1"</js>) String <jv>a1</jv>,
		<ja>@Path</ja>(<js>"a2"</js>) <jk>int</jk> <jv>a2</jv>,
		<ja>@Path</ja>(<js>"a3"</js>) UUID <jv>a3</jv>,
		<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> <jv>p1</jv>,
		<ja>@Query</ja>(<js>"p2"</js>) String <jv>p2</jv>,
		<ja>@Query</ja>(<js>"p3"</js>) UUID <jv>p3</jv>,
		<ja>@HasQuery</ja>(<js>"p3"</js>) boolean <jv>hasP3</jv>,
		<ja>@Path</ja>(<js>"/*"</js>) String <jv>remainder</jv>,
		<ja>@Header</ja>(<js>"Accept-Language"</js>) String <jv>lang</jv>,
		<ja>@Header</ja>(<js>"Accept"</js>) String <jv>accept</jv>,
		<ja>@Header</ja>(<js>"DNT"</js>) <jk>int</jk> <jv>doNotTrack</jv>,
		RequestAttributes <jv>attributes</jv>,
		ResourceBundle <jv>nls</jv>
	) {
		<jc>// Do something with all of those</jc>
	}
	</p>
	<p>
		Additional parameter types can be defined via the annotation {@link org.apache.juneau.rest.annotation.Rest#restOpArgs()} or by calling {@link org.apache.juneau.rest.RestContext.Builder#restOpArgs(Class...)}.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		restOpArgs={ MyOpArg.<jk>class</jk> }  <jc>// Option #1 - Via annotation</jc>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestObject {
	
		// Option #2 - Programmatically
		<ja>@RestInit</ja>
		<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) {
			<jv>builder</jv>.restOpArgs(MyOpArg.<jk>class</jk>);
		}
	}
	</p>
</div>
</div><!-- END: 8.3.2 - jrs.JavaMethodParameters -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.JavaMethodReturnTypes' id='jrs.JavaMethodReturnTypes'>8.3.3 - Java Method Return Types</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.3 - jrs.JavaMethodReturnTypes -->
<div class='topic'>
	<p>
		The return type of the Java method can be any serializable POJO as defined in <a class="doclink" href="#jm.PojoCategories">POJO Categories</a>.
		It can also be <jk>void</jk> if the method is not sending any output (e.g. a request redirect) or is 
		setting the output using the {@link org.apache.juneau.rest.RestResponse#setContent(Object)} method.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>
	<jk>public</jk> String doGet() {
		<jk>return</jk> <js>"Hello World!"</js>;
	}
	</p>
	<p>
		In addition to POJOs, the following return types are also supported:
	</p>
	<ul class='spaced-list'>
		<li>
			<b>Parameters based on class types:</b>
			<ul class='spaced-list'>
				<li>Direct streams:
					<ul class='javatreec'>
						<li class='jc'>{@link java.io.InputStream}
						<li class='jc'>{@link java.io.Reader}
					</ul>
				</li>
				<li>Apache HttpComponent beans:
					<ul class='javatreec'>
						<li class='jic'>{@link org.apache.http.HttpEntity}
						<li class='jic'>{@link org.apache.juneau.http.resource.HttpResource}
						<li class='jic'>{@link org.apache.http.HttpResponse}
					</ul>
				</li>
				<li>Standard HTTP response beans:
					<ul class='javatreec'>
						<li class='jc'>{@link org.apache.juneau.http.response.Accepted}
						<li class='jc'>{@link org.apache.juneau.http.response.AlreadyReported}
						<li class='jc'>{@link org.apache.juneau.http.response.BadRequest}
						<li class='jc'>{@link org.apache.juneau.http.response.Conflict}
						<li class='jc'>{@link org.apache.juneau.http.response.Continue}
						<li class='jc'>{@link org.apache.juneau.http.response.Created}
						<li class='jc'>{@link org.apache.juneau.http.response.EarlyHints}
						<li class='jc'>{@link org.apache.juneau.http.response.ExpectationFailed}
						<li class='jc'>{@link org.apache.juneau.http.response.FailedDependency}
						<li class='jc'>{@link org.apache.juneau.http.response.Forbidden}
						<li class='jc'>{@link org.apache.juneau.http.response.Found}
						<li class='jc'>{@link org.apache.juneau.http.response.Gone}
						<li class='jc'>{@link org.apache.juneau.http.response.HttpVersionNotSupported}
						<li class='jc'>{@link org.apache.juneau.http.response.IMUsed}
						<li class='jc'>{@link org.apache.juneau.http.response.InsufficientStorage}
						<li class='jc'>{@link org.apache.juneau.http.response.InternalServerError}
						<li class='jc'>{@link org.apache.juneau.http.response.LengthRequired}
						<li class='jc'>{@link org.apache.juneau.http.response.Locked}
						<li class='jc'>{@link org.apache.juneau.http.response.LoopDetected}
						<li class='jc'>{@link org.apache.juneau.http.response.MethodNotAllowed}
						<li class='jc'>{@link org.apache.juneau.http.response.MisdirectedRequest}
						<li class='jc'>{@link org.apache.juneau.http.response.MovedPermanently}
						<li class='jc'>{@link org.apache.juneau.http.response.MultipleChoices}
						<li class='jc'>{@link org.apache.juneau.http.response.MultiStatus}
						<li class='jc'>{@link org.apache.juneau.http.response.NetworkAuthenticationRequired}
						<li class='jc'>{@link org.apache.juneau.http.response.NoContent}
						<li class='jc'>{@link org.apache.juneau.http.response.NonAuthoritiveInformation}
						<li class='jc'>{@link org.apache.juneau.http.response.NotAcceptable}
						<li class='jc'>{@link org.apache.juneau.http.response.NotExtended}
						<li class='jc'>{@link org.apache.juneau.http.response.NotFound}
						<li class='jc'>{@link org.apache.juneau.http.response.NotImplemented}
						<li class='jc'>{@link org.apache.juneau.http.response.NotModified}
						<li class='jc'>{@link org.apache.juneau.http.response.Ok}
						<li class='jc'>{@link org.apache.juneau.http.response.PartialContent}
						<li class='jc'>{@link org.apache.juneau.http.response.PayloadTooLarge}
						<li class='jc'>{@link org.apache.juneau.http.response.PermanentRedirect}
						<li class='jc'>{@link org.apache.juneau.http.response.PreconditionFailed}
						<li class='jc'>{@link org.apache.juneau.http.response.PreconditionRequired}
						<li class='jc'>{@link org.apache.juneau.http.response.Processing}
						<li class='jc'>{@link org.apache.juneau.http.response.RangeNotSatisfiable}
						<li class='jc'>{@link org.apache.juneau.http.response.RequestHeaderFieldsTooLarge}
						<li class='jc'>{@link org.apache.juneau.http.response.ResetContent}
						<li class='jc'>{@link org.apache.juneau.http.response.SeeOther}
						<li class='jc'>{@link org.apache.juneau.http.response.ServiceUnavailable}
						<li class='jc'>{@link org.apache.juneau.http.response.SwitchingProtocols}
						<li class='jc'>{@link org.apache.juneau.http.response.TemporaryRedirect}
						<li class='jc'>{@link org.apache.juneau.http.response.TooManyRequests}
						<li class='jc'>{@link org.apache.juneau.http.response.Unauthorized}
						<li class='jc'>{@link org.apache.juneau.http.response.UnavailableForLegalReasons}
						<li class='jc'>{@link org.apache.juneau.http.response.UnprocessableEntity}
						<li class='jc'>{@link org.apache.juneau.http.response.UnsupportedMediaType}
						<li class='jc'>{@link org.apache.juneau.http.response.UpgradeRequired}
						<li class='jc'>{@link org.apache.juneau.http.response.UriTooLong}
						<li class='jc'>{@link org.apache.juneau.http.response.UseProxy}
						<li class='jc'>{@link org.apache.juneau.http.response.VariantAlsoNegotiates}
					</ul>
				</li>
				<li>Other:
					<ul class='javatreec'>
						<li class='jc'>{@link org.apache.juneau.rest.beans.ChildResourceDescriptions}
						<li class='jc'>{@link org.apache.juneau.rest.beans.ResourceDescriptions}
						<li class='jc'>{@link org.apache.juneau.rest.beans.SeeOtherRoot}
						<li class='jc'>{@link java.lang.Throwable}
					</ul>
				</li>
			</ul>		
		<li><b>Annotated parameters (either on the parameter or parameter type):</b>
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
			</ul>
		</li>
	</ul>		
	<p>
		REST Java methods can also generate a response via the following:
	</p>
	<ul class='spaced-list'>
		<li>
			By calling {@link org.apache.juneau.rest.RestResponse#setContent(Object)} with any of the types above.
		<li>
			By accessing the {@link java.io.Writer} directly by calling 
			{@link org.apache.juneau.rest.RestResponse#getNegotiatedWriter()} and writing the output yourself.
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Equivalent method 1</jc>
	<ja>@RestGet</ja>(<js>"/example1/{personId}"</js>)
	<jk>public</jk> Person doGet1(<ja>@Path</ja>(<js>"personId"</js>) UUID <jv>personId</jv>) {
		Person <jv>person</jv> = <jsm>getPersonById</jsm>(<jv>personId</jv>);
		<jk>return</jk> <jv>person</jv>;
	}

	<jc>// Equivalent method 2</jc>
	<ja>@RestGet</ja>(<js>"/example2/{personId}"</js>)
	<jk>public void</jk> doGet2(RestResponse <jv>res</jv>, <ja>@Path</ja>(<js>"personId"</js>) UUID <jv>personId</jv>) {
		Person <jv>person</jv> = <jsm>getPersonById</jsm>(<jv>personId</jv>);
		<jv>res</jv>.setContent(<jv>person</jv>);
	}
	</p>
	<p>
		Additional parameter types can be defined via the annotation {@link org.apache.juneau.rest.annotation.Rest#responseProcessors()} or by calling {@link org.apache.juneau.rest.RestContext.Builder#responseProcessors(Class...)}.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		responseProcessors={ MyResponseProcessor.<jk>class</jk> }  <jc>// Option #1 - Via annotation</jc>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestObject {
	
		// Option #2 - Programmatically
		<ja>@RestInit</ja>
		<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) {
			<jv>builder</jv>.responseProcessors(MyResponseProcessor.<jk>class</jk>);
		}
	}
	</p>
	
</div>
</div><!-- END: 8.3.3 - jrs.JavaMethodReturnTypes -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.JavaMethodThrowableTypes' id='jrs.JavaMethodThrowableTypes'>8.3.4 - Java Method Throwable Types</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.4 - jrs.JavaMethodThrowableTypes -->
<div class='topic'>
	<p>
		Annotated Java methods can throw any of the following:
	</p>
	<ul class='spaced-list'>
		<li>Standard HTTP response beans:
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.http.response.BadRequest}
				<li class='jc'>{@link org.apache.juneau.http.response.Conflict}
				<li class='jc'>{@link org.apache.juneau.http.response.ExpectationFailed}
				<li class='jc'>{@link org.apache.juneau.http.response.FailedDependency}
				<li class='jc'>{@link org.apache.juneau.http.response.Forbidden}
				<li class='jc'>{@link org.apache.juneau.http.response.Gone}
				<li class='jc'>{@link org.apache.juneau.http.response.HttpVersionNotSupported}
				<li class='jc'>{@link org.apache.juneau.http.response.InsufficientStorage}
				<li class='jc'>{@link org.apache.juneau.http.response.InternalServerError}
				<li class='jc'>{@link org.apache.juneau.http.response.LengthRequired}
				<li class='jc'>{@link org.apache.juneau.http.response.Locked}
				<li class='jc'>{@link org.apache.juneau.http.response.LoopDetected}
				<li class='jc'>{@link org.apache.juneau.http.response.MethodNotAllowed}
				<li class='jc'>{@link org.apache.juneau.http.response.MisdirectedRequest}
				<li class='jc'>{@link org.apache.juneau.http.response.NetworkAuthenticationRequired}
				<li class='jc'>{@link org.apache.juneau.http.response.NotAcceptable}
				<li class='jc'>{@link org.apache.juneau.http.response.NotExtended}
				<li class='jc'>{@link org.apache.juneau.http.response.NotFound}
				<li class='jc'>{@link org.apache.juneau.http.response.NotImplemented}
				<li class='jc'>{@link org.apache.juneau.http.response.PayloadTooLarge}
				<li class='jc'>{@link org.apache.juneau.http.response.PreconditionFailed}
				<li class='jc'>{@link org.apache.juneau.http.response.PreconditionRequired}
				<li class='jc'>{@link org.apache.juneau.http.response.RangeNotSatisfiable}
				<li class='jc'>{@link org.apache.juneau.http.response.RequestHeaderFieldsTooLarge}
				<li class='jc'>{@link org.apache.juneau.http.response.ServiceUnavailable}
				<li class='jc'>{@link org.apache.juneau.http.response.TooManyRequests}
				<li class='jc'>{@link org.apache.juneau.http.response.Unauthorized}
				<li class='jc'>{@link org.apache.juneau.http.response.UnavailableForLegalReasons}
				<li class='jc'>{@link org.apache.juneau.http.response.UnprocessableEntity}
				<li class='jc'>{@link org.apache.juneau.http.response.UnsupportedMediaType}
				<li class='jc'>{@link org.apache.juneau.http.response.UpgradeRequired}
				<li class='jc'>{@link org.apache.juneau.http.response.UriTooLong}
				<li class='jc'>{@link org.apache.juneau.http.response.VariantAlsoNegotiates}
			</ul>
		</li>
		<li>Annotated throwables:
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
			</ul>
		</li>
	</ul>
	<p>
		All other throwables get processed as follows:
	</p>
	<ul class='spaced-list'>
		<li>Processed as 400/Bad Request:
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.parser.ParseException}
				<li class='jc'>{@link org.apache.juneau.InvalidDataConversionException}
			</ul>
		</li>
		<li>Processed as 401/Unauthorized:
			<ul>
				<li>Any class named <js>"*AccessDenied*"</js> or  <js>"*Unauthorized*"</js>
			</ul>
		</li>
		<li>Processed as 404/Not Found:
			<ul>
				<li>Any class named <js>"*Empty*"</js> or  <js>"*NotFound*"</js>
			</ul>
		</li>
		<li>Anything else processed as 500/Internal Server Error.
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/user/login"</js>)
	<jk>public</jk> Ok login(
		<ja>@FormData</ja>(<js>"username"</js>) String <jv>username</jv>, 
		<ja>@FormData</ja>(<js>"password"</js>) String <jv>password</jv>
	) <jk>throws</jk> Unauthorized 
	{
		<jk>if</jk> (! <jsm>isOK</jsm>(<jv>username</jv>, <jv>password</jv>))
			<jk>throw new</jk> Unauthorized(<js>"You're not welcome!"</js>);
			
		<jk>return</jk> Ok.<jsf>OK</jsf>;
	}
	</p>
</div>
</div><!-- END: 8.3.4 - jrs.JavaMethodThrowableTypes -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.PathPatterns' id='jrs.PathPatterns'>8.3.5 - Path Patterns</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.5 - jrs.PathPatterns -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.annotation.RestOp#path() @RestOp(path)} annotation allows 
		you to define URL path patterns to match against.
		These patterns can contain variables of the form <l>"{xxx}"</l> that can be passed in directly to the
		Java methods as extra parameters.
	</p>
	<p>
		In the following example, 3 separate GET request handlers are defined with different path patterns.
		Note how the variables are passed in as additional arguments on the method, and how those arguments are 
		automatically converted to the specified class type...
	</p>
	<p class='bjava'>
	<jc>// Default method</jc>
	<ja>@RestGet</ja>(path=<js>"/*"</js>)
	<jk>public void</jk> doGetDefault() {
		...
	}

	<jc>// Method with path pattern</jc>
	<ja>@RestGet</ja>(path=<js>"/xxx"</js>)
	<jk>public void</jk> doGetNoArgs(...) {
		...
	}

	<jc>// Method with path pattern with arguments</jc>
	<ja>@RestGet</ja>(path=<js>"/xxx/{foo}/{bar}/{baz}/{bing}"</js>)
	<jk>public void</jk> doGetWithArgs(
			<ja>@Path</ja>(<js>"foo"</js>) String <jv>foo</jv>, 
			<ja>@Path</ja>(<js>"bar"</js>) <jk>int</jk> <jv>bar</jv>, 
			<ja>@Path</ja>(<js>"baz"</js>) MyEnum <jv>baz</jv>, 
			<ja>@Path</ja>(<js>"bing"</js>) UUID <jv>qux</jv>
	) {
		...
	}
	</p>
	<p>
		By default, path patterns are matched using a best-match heuristic. 
		When overlaps occur, URLs are matched from most-specific to most-general order:
	</p>
	<p class='bjava'>
	<jc>// Try first </jc>
	<ja>@RestGet</ja>(<js>"/foo/bar"</js>)
	<jk>public void</jk> method1() {
		...
	}

	<jc>// Try second</jc>
	<ja>@RestGet</ja>(<js>"/foo/{bar}"</js>)
	<jk>public void</jk> method2(...) {
		...
	}

	<jc>// Try third</jc>
	<ja>@RestGet</ja>(<js>"/foo/*"</js>)
	<jk>public void</jk> method3(...) {
		...
	}

	<jc>// Try last</jc>
	<ja>@RestGet</ja>(<js>"/*"</js>)
	<jk>public void</jk> method4(...) {
		...
	}
	</p>
	<p>
		Paths that end with <js>"/*"</js> will do a prefix match on the incoming URL.  
		Any remainder after the match can be accessed through 
		{@link org.apache.juneau.rest.httppart.RequestPathParams#getRemainder()} or parameters with the 
		<c><ja>@Path</ja>(<js>"/*"</js>)</c> annotation.
		On the other hand, paths that don't end with <js>"/*"</js> (e.g. <js>"/"</js> or <js>"/foo"</js>) will 
		require an exact URL match, and if any remainder exists, a 404 (not found) error will be thrown.
	</p>
	<p>
		The following example shows the distinction.
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/*"</js>)
	<jk>public void</jk> doGet(<ja>@Path</ja>(<js>"/*"</js>) String <jv>remainder</jv>) {
		<jc>// URL path pattern can have remainder accessible through req.getRemainder().</jc>
	}

	<ja>@RestPut</ja>(<js>"/"</js>)
	<jk>public void</jk> doPut() {
		<jc>// URL path pattern must match exactly and will cause a 404 error if a remainder exists.</jc>
	}
	</p>
</div>
</div><!-- END: 8.3.5 - jrs.PathPatterns -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.Matchers' id='jrs.Matchers'>8.3.6 - Matchers</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.6 - jrs.Matchers -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.rest.matcher.RestMatcher RestMatchers} are used to allow multiple Java methods to be 
		tied to the same HTTP method and path but differentiated by some request attribute such as a specific 
		header value.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// GET method that gets invoked for administrators</jc>
	<ja>@RestGet</ja>(path=<js>"/*"</js>, matchers=IsAdminMatcher.<jk>class</jk>)
	<jk>public</jk> Object doGetForAdmin() {
		...
	}

	<jc>// GET method that gets invoked for everyone else</jc>
	<ja>@RestGet</ja>(<js>"/*"</js>)
	<jk>public</jk> Object doGetForEveryoneElse() {
		...
	}
	</p>
	<p>
		The interface for matchers is simple:
	</p>
	<p class='bjava'>
	<jk>public class</jk> IsAdminMatcher <jk>extends</jk> RestMatcher {

		<ja>@Override</ja> <jc>/* RestMatcher */</jc>
		<jk>public boolean</jk> matches(RestRequest <jv>req</jv>) {
			<jk>return</jk> <jv>req</jv>.isUserInRole(<js>"ADMINS_GROUP"</js>);
		}
	}
	</p>
	
	<ul class='notes'>
		<li class='note'>
			If no methods are found with a matching matcher, a <l>412 Precondition Failed</l> status is returned.
		<li class='note'>
			If multiple matchers are specified on the same method, ONLY ONE matcher needs to match for the 
			method to be invoked.
		<li class='note'>
			Note that you CANNOT define identical paths on different methods UNLESS you use matchers.
			<br>That includes paths that are only different in variable names (e.g. <l>"/foo/{bar}"</l> and 
			<l>"/foo/{baz}"</l>).
			<br>If you try to do so, a <l>ServletException</l> will be thrown on startup.
		<li class='note'>
			Methods with matchers take precedence over methods without.
			<br>Otherwise, methods are attempted in the order they appear in the class.
	</ul>
	
	<ul class='seealso'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp#matchers RestOp(matchers)}
		<li class='jc'>{@link org.apache.juneau.rest.matcher.MultipartFormDataMatcher}
		<li class='jc'>{@link org.apache.juneau.rest.matcher.UrlEncodedFormMatcher}
	</ul>
</div>
</div><!-- END: 8.3.6 - jrs.Matchers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.OverloadingHttpMethods' id='jrs.OverloadingHttpMethods'>8.3.7 - Overloading HTTP Methods</a></h4>
<div class='topic'><!-- START: 8.3.7 - jrs.OverloadingHttpMethods -->
<div class='topic'>
	<p>
		Through the use of the built-in <l>"method"</l> GET parameter, you can implement requests beyond the basic 
		REST http method types.
	</p>
	<p>
		For example, the URL <l>"/sample/foo?method=BAR"</l> will cause the following method to be invoked...
	</p>
	<p class='bjava'>
	<ja>@RestOp</ja>(method=<js>"BAR"</js>)
	<jk>public void</jk> doBar(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) {
		<jc>// Handle BAR requests</jc>
	}
	</p>
	<p>
		To support overloaded methods, the {@link org.apache.juneau.rest.annotation.Rest#allowedMethodParams() @Rest(allowedMethodParams)} 
		setting must be enabled on your servlet.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		<jc>// Allow &amp;method parameter on BAR requests</jc>
		allowedMethodParams=<js>"BAR"</js>
	)
	</p>
</div>
</div><!-- END: 8.3.7 - jrs.OverloadingHttpMethods -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.AdditionalInformation' id='jrs.AdditionalInformation'>8.3.8 - Additional Information</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.3.8 - jrs.AdditionalInformation -->
<div class='topic'>
	<p>
		Refer to the following Javadocs for more information:
	</p>
	<ul class='javatreec w900'>
		<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
		<li class='jc'>{@link org.apache.juneau.rest.RestResponse}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestContent}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestHeaders}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestQueryParams}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestFormParams}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestPathParams}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestAttributes}
	</ul>
</div>
</div><!-- END: 8.3.8 - jrs.AdditionalInformation -->
</div><!-- END: 8.3 - jrs.RestOpAnnotatedMethods -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.HttpParts' id='jrs.HttpParts'>8.4 - HTTP Parts</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.4 - jrs.HttpParts -->
<div class='topic'>
	<p>
		In previous examples we showed the ability to pass in annotated parameters on {@link org.apache.juneau.rest.annotation.RestOp}-annotated methods
		to parse standard HTTP parts:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/example1/{a1}/*"</js>)
	<jk>public</jk> String doGetExample1(
		<ja>@Path</ja>(<js>"a1"</js>) String <jv>a1</jv>,
		<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> <jv>p1</jv>,
		<ja>@HasQuery</ja>(<js>"p2"</js>) <jk>boolean</jk> <jv>hasP3</jv>,
		<ja>@Path</ja>(<js>"/*"</js>) String <jv>remainder</jv>,
		<ja>@Header</ja>(<js>"Accept-Language"</js>) String <jv>lang</jv>
	) {
		<jc>// Do something with all of those</jc>
	}
	</p>
	<p>
		Annotations are provided for both request and response HTTP parts.
	</p>
	<p>
		The annotations used for defining the schema for request HTTP parts are:
	</p>
	<ul class='spaced-list'>
		<li>HTTP request parts:
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
				<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasFormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasQuery}
			</ul>
		</li>
		<li>HTTP response parts:
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
				<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode}
			</ul>
		</li>
	</ul>
	<p>
		These annotation can be used on method parameters or on the parameter types themselves, or a combination
		of both.  
	</p>
	<ul class='notes'>
		<li class='note'>When defined on types, annotations are aggregated from parent to child with child values
			taking precedence.  When defined on both, annotations are aggregated with values on parameters
			taking precedence.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.PartMarshallers' id='jrs.PartMarshallers'>8.4.1 - Part Marshallers</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.1 - jrs.PartMarshallers -->
<div class='topic'>
	<p>
		Juneau comes with three basic marshaller types for serializing and parsing Header, Query, Form, and Path parts:
	</p>
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.httppart.HttpPartSerializer}
			<ul>
				<li class='jc'>{@link org.apache.juneau.httppart.SimplePartSerializer} - Serializes directly to strings.
				<li class='jc'>{@link org.apache.juneau.uon.UonSerializer} - Serializes to UON notation.
					<ul>
						<li class='jc'>{@link org.apache.juneau.oapi.OpenApiSerializer} - Serializes using Open-API schema rules.
					</ul>
				</li>
			</ul>
		</li>
		<li class='jic'>{@link org.apache.juneau.httppart.HttpPartParser}
			<ul>
				<li class='jc'>{@link org.apache.juneau.httppart.SimplePartParser} - Parses directly from strings.
				<li class='jc'>{@link org.apache.juneau.uon.UonParser} - Parses from UON notation.
					<ul>
						<li class='jc'>{@link org.apache.juneau.oapi.OpenApiParser} - Parses using Open-API schema rules.
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p>
		By default, the REST API uses the OpenAPI serializer and parser which allows for schema-based
		marshalling.  You also have the option to use UON marshalling which is schema-less but allows
		for JSON-equivalent data structures (object/array/primitives/...) using URL-encoding notation.  
		This can be done by overriding the part marshallers through the following APIs:
	</p>
	<ul class='spaced-list'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#partSerializer() partSerializer}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#partParser() partParser}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jmp'>{@link org.apache.juneau.rest.RestContext.Builder#partSerializer(HttpPartSerializer) partSerializer(HttpPartSerializer)}
				<li class='jmp'>{@link org.apache.juneau.rest.RestContext.Builder#partParser(HttpPartParser) partParser(HttpPartParser)}
			</ul>
		</li>
	</ul>
	<p>
		The OpenAPI marshallers themselves also have the ability to support UON notation for individual
		parts via the schema itself:
	</p>
	<p class='bjava'>
	<ja>@Query</ja>(..., schema=<ja>@Schema</ja>(format=<js>"uon"</js>)) Map&lt;Integer,MyBean&gt; <jv>myMap</jv>
	</p>
</div>
</div><!-- END: 8.4.1 - jrs.PartMarshallers -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HttpPartAnnotations' id='jrs.HttpPartAnnotations'>8.4.2 - HTTP Part Annotations</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.2 - jrs.HttpPartAnnotations -->
<div class='topic'>
	<p>
		The following annotations allow for defining part schemas based on the OpenAPI standard.
	</p>
	<ul class='spaced-list'>
		<li><b>Request annotations:</b>
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Request#on() on}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Request#onClass() onClass}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Request#parser() parser}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#name() name}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#parser() parser}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#value() value}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Query#name() name}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Query#parser() parser}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Query#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Query#value() value}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.FormData#name() name}
						<li class='jma'>{@link org.apache.juneau.http.annotation.FormData#parser() parser}
						<li class='jma'>{@link org.apache.juneau.http.annotation.FormData#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.FormData#value() value}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Path#name() name}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Path#parser() parser}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Path#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Path#value() value}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Content#schema() schema}
					</ul>
				</li>
			</ul>
		</li>
		<li><b>Response annotations:</b>
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#examples() examples}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#headers() headers}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#on() on}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#onClass() onClass}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Response#serializer() serializer}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#name() name}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#schema() schema}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#serializer() serializer}
						<li class='jma'>{@link org.apache.juneau.http.annotation.Header#value() value}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.Content#schema() schema}
					</ul>
				</li>
				<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.http.annotation.StatusCode#value() value}
					</ul>
				</li>
			</ul>
		</li>
		<li><b>Common schema annotation:</b>
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.annotation.Schema}
					<ul class='javatreec'>
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#_default() _default}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#_enum() _enum}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#$ref() $ref}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#additionalProperties() additionalProperties}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#aev() aev}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#allOf() allOf}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#allowEmptyValue() allowEmptyValue}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#cf() cf}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#collectionFormat() collectionFormat}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#d() d}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#description() description}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#df() df}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#discriminator() discriminator}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#e() e}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#emax() emax}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#emin() emin}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#exclusiveMaximum() exclusiveMaximum}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#exclusiveMinimum() exclusiveMinimum}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#externalDocs() externalDocs}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#f() f}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#format() format}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#ignore() ignore}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#items() items}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#max() max}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxi() maxi}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maximum() maximum}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxItems() maxItems}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxl() maxl}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxLength() maxLength}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxp() maxp}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#maxProperties() maxProperties}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#min() min}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#mini() mini}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minimum() minimum}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minItems() minItems}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minl() minl}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minLength() minLength}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minp() minp}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#minProperties() minProperties}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#mo() mo}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#multipleOf() multipleOf}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#on() on}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#onClass() onClass}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#p() p}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#pattern() pattern}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#properties() properties}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#r() r}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#readOnly() readOnly}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#required() required}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#ro() ro}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#sie() sie}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#skipIfEmpty() v}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#t() t}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#title() title}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#type() type}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#ui() ui}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#uniqueItems() uniqueItems}
						<li class='jma'>{@link org.apache.juneau.annotation.Schema#xml() xml}
					</ul>
				</li>
			</ul>
		</li>	
	</ul>
	<p>
		The {@link org.apache.juneau.http.annotation.Header @Header}/{@link org.apache.juneau.http.annotation.Query @Query}/
		{@link org.apache.juneau.http.annotation.FormData @FormData}/{@link org.apache.juneau.http.annotation.Path @Path} annotations 
		can be used on parameters of {@link org.apache.juneau.rest.annotation.RestOp @RestOp}-annotated methods to 
		get access to request headers, query parameters, form-data parameters, and path parts.
	</p>
	<p>
		The most typical scenario is to simply use the <c>value</c> field to define parameter names:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(
		<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> <jv>p1</jv>, 
		<ja>@Query</ja>(<js>"p2"</js>) String <jv>p2</jv>, 
		<ja>@Query</ja>(<js>"p3"</js>) UUID <jv>p3</jv>) {...}
	</p>
	<p>
		This is functionally equivalent to the following code:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(RestRequest <jv>req</jv>) {
		RequestQueryParams <jv>query</jv> = <jv>req</jv>.getQueryParams();
		<jk>int</jk> <jv>p1</jv> = <jv>query</jv>.get(<js>"p1"</js>).asInteger().orElse(0);
		String <jv>p2</jv> = <jv>query</jv>.get(<js>"p2"</js>).orElse(<jk>null</jk>);
		UUID <jv>p3</jv> = <jv>query</jv>.get(<js>"p3"</js>).as(UUID.<jk>class</jk>).orElse(<jk>null</jk>);
	}
	</p>
	<p>
		The special name <js>"*"</js> (or blank) can be used to represent all values.
		When used, the data type must be a <c>Map</c> or bean.
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Multiple values passed as a map.</jc>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(<ja>@Query</ja>(<js>"*"</js>) Map&lt;String,Object&gt; <jv>map</jv>) {...}
	</p>
	<p class='bjava'>
	<jc>// Same but name "*" is inferred.</jc>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(<ja>@Query</ja> Map&lt;String,Object&gt; <jv>map</jv>) {...}
	</p>
	<p class='bjava'>
	<jc>// Multiple values passed as a bean.</jc>
	<ja>@RestGet</ja>
	<jk>public void</jk> doGet(<ja>@Query</ja> MyQueryBean <jv>bean</jv>) {...}
	</p>
	<p>
		The {@link org.apache.juneau.http.annotation.Content @Content} annotation is used to identify POJOs to be used as the body of an HTTP request.
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Defined on parameter</jc>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(<ja>@Content</ja> Pet <jv>pet</jv>) {...}
	</p>
	<p class='bjava'>
	<jc>// Defined on POJO class</jc>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(Pet <jv>pet</jv>) {...}
	
	<ja>@Content</ja>
	<jk>public class</jk> Pet {...}
	</p>
	<p>
		This is functionally equivalent to the following code:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(RestRequest <jv>req</jv>) {
		Pet <jv>pet</jv> = <jv>req</jv>.getContent().as(Pet.<jk>class</jk>);
		...
	}
	</p>
	<p>
		In addition to {@link org.apache.juneau.http.annotation.Content @Content}-annotated parameters/types, the body of an HTTP request
		can be retrieved by passing in parameters of the following types (matched in the specified order):
	</p>
	<ol class='spaced-list'>
		<li>
			{@link java.io.Reader}
			<br><ja>@Content</ja> annotation is optional.
			<br><c>Content-Type</c> is ignored.
		<li>
			{@link java.io.InputStream}
			<br><ja>@Content</ja> annotation is optional.
			<br><c>Content-Type</c> is ignored.
		<li>
			Any <a class="doclink" href="#jm.PojoCategories">Parseable POJO</a> type.
			<br><c>Content-Type</c> is required to identify correct parser.
		<li>
			Objects convertible from {@link java.io.Reader} by having one of the following non-deprecated methods:
			<ul>
				<li><c><jk>public</jk> T(Reader in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>create</jsm>(Reader in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>fromReader</jsm>(Reader in) {...}</c>
			</ul>
			<c>Content-Type</c> must not be present or match an existing parser so that it's not parsed as a POJO.
		<li>
			Objects convertible from {@link java.io.InputStream} by having one of the following non-deprecated methods:
			<ul>
				<li><c><jk>public</jk> T(InputStream in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>create</jsm>(InputStream in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>fromInputStream</jsm>(InputStream in) {...}</c>
			</ul>
			<c>Content-Type</c> must not be present or match an existing parser so that it's not parsed as a POJO.
		<li>
			Objects convertible from {@link java.lang.String} by having one of the following non-deprecated methods:
			<ul>
				<li><c><jk>public</jk> T(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>create</jsm>(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>fromString</jsm>(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>parse</jsm>(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>parseString</jsm>(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>forName</jsm>(String in) {...}</c>
				<li><c><jk>public static</jk> T <jsm>forString</jsm>(String in) {...}</c>
			</ul>
			Note that this also includes all enums.
		<li>
			Any {@link java.util.Optional} of anything on this list.
	</ol>
	<p>
		When used in combination with the mutable {@link org.apache.juneau.Value} object, the {@link org.apache.juneau.http.annotation.StatusCode @StatusCode} and {@link org.apache.juneau.http.annotation.Header @Header} annotations 
		can be used on parameters {@link org.apache.juneau.rest.annotation.RestOp @RestOp}-annotated methods to 
		to define to response codes and headers.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/user/login"</js>)
	<jk>public void</jk> login(
		<ja>@FormData</ja>(<js>"username"</js>) String <jv>username</jv>, 
		<ja>@FormData</ja>(<js>"password"</js>) String <jv>password</jv>,
		<ja>@StatusCode</ja> Value&lt;Integer&gt; <jv>status</jv>,
		<ja>@Header</ja>(<js>"My-Response-Header"</js>) Value&lt;String&gt; <jv>myResponseHeader</jv>
	) {
		<jk>if</jk> (<jsm>isValid</jsm>(<jv>username</jv>, <jv>password</jv>)) {
			<jv>status</jv>.set(200);
			<jv>myResponseHeader</jv>.set(<js>"Welcome "</js> + <jv>username</jv> + <js>"!"</js>);
		} <jk>else</jk> {
			<jv>status</jv>.set(401);
		}
	}
	</p>
	<p>
		This is functionally equivalent to the following code:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/user/login"</js>)
	<jk>public void</jk> doGet(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) {
		RequestFormParams <jv>form</jv> = <jv>req</jv>.getFormParams();
		String <jv>username</jv> = <jv>form</jv>.get(<js>"username"</js>).orElse(<jk>null</jk>);
		String <jv>password</jv> = <jv>form</jv>.get(<js>"password"</js>).orElse(<jk>null</jk>);
		<jk>if</jk> (<jsm>isValid</jsm>(<jv>username</jv>, <jv>password</jv>) {
			<jv>res</jv>.setStatus(200);
			<jv>res</jv>.setHeader(<js>"My-Response-Header"</js>, <js>"Welcome "</js> + <jv>username</jv> + <js>"!"</js>);
		} else {
			<jv>res</jv>.setStatus(401);
		}
	}
	</p>
	<p>
		The default registered part marshallers, {@link org.apache.juneau.oapi.OpenApiSerializer} and {@link org.apache.juneau.oapi.OpenApiParser}, are used to 
		marshall POJOs using schemas defined via the {@link org.apache.juneau.annotation.Schema @Schema} annotation.
	</p>
	<p>
		For example, the following shows how a pipe-delimited list of comma-delimited numbers (e.g. <js>"1,2,3|4,5,6|7,8,9"</js>) can be converted to a 2-dimensional array of <c>Longs</c>:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/testQuery1"</js>)	
	<jk>public void</jk> testQuery1(
		<ja>@Query</ja>(<js>"queryParamName"</js>)
		<ja>@Schema</ja>(
			collectionFormat=<js>"pipes"</js>,
			items=<ja>@Items</ja>(
				collectionFormat=<js>"csv"</js>,
				type=<js>"integer"</js>, 
				format=<js>"int64"</js>,
				minimum=<js>"0"</js>,
				maximum=<js>"100"</js>
				minLength=1,
				maxLength=10
			),
			minLength=1,
			maxLength=10
		)
		Long[][] <jv>queryParameter</jv>
	) {...}

	<jc>// Same but using condensed notation.</jc>
	<ja>@RestGet</ja>(<js>"/testQuery2"</js>)	
	<jk>public void</jk> testQuery2(
		<ja>@Query</ja>(<js>"queryParamName"</js>)
		<ja>@Schema</ja>(
			cf=<js>"pipes"</js>, minl=1, maxl=10,
			i=<ja>@Items</ja>(cf=<js>"csv"</js>, t=<js>"integer"</js>, f=<js>"int64"</js>, min=<js>"0"</js>, max=<js>"100"</js>, minl=1, maxl=10)
		)
		Long[][] <jv>queryParameter</jv>
	) {...}
	</p>
	<p>
		Schema-based marshalling works for both request and response parts.
		Input will be converted based on the types and formats defined in the schema definition.
		Input validations such as <c>minLength/maxLength</c> that don't match the input will result in automatic <c>400 Bad Request</c> responses.
	</p>
	
	<p>
		The part and schema annotations are also used for supplying swagger information about the HTTP part.
		This information is used to populate the auto-generated Swagger documentation and UI.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Query</ja>(<js>"name"</js>)
	<ja>@Schema</ja>(
		description=<js>"Pet name"</js>,
		required=<jk>true</jk>
	)
	</p>
	<p>
		<a class="doclink" href="#jrs.SvlVariables">SVL Variables</a> (e.g. "$L{my.localized.variable}") are supported on annotation fields as well.
		Among other things, this allow for annotation values to be defined externally and the ability to produce localized swagger documents
		based on the <c>Accept-Language</c> on a request.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Schema</ja>(
		description=<js>"$L{PetNameDescription}"</js>
	)
	</p>
	<p>
		The {@link org.apache.juneau.http.annotation.Content @Content} annotation can also be used to parse HTTP request bodies using OpenAPI schemas 
		when the body content type matches the {@link org.apache.juneau.oapi.OpenApiParser} parser via the header <c>Content-Type: text/openapi</c>.
	</p>
	<p>
		The following shows the same for a request body:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(<js>"/testContent"</js>)	
	<jk>public void</jk> testContent(
		<ja>@Content</ja>
		<ja>@Schema</ja>(
			items=<ja>@Items</ja>(
				collectionFormat=<js>"pipes"</js>,
				items=<ja>@SubItems</ja>(
					collectionFormat=<js>"csv"</js>,
					type=<js>"integer"</js>, 
					format=<js>"int64"</js>,
					minimum=<js>"0"</js>,
					maximum=<js>"100"</js>
					minLength=1,
					maxLength=10
				)
			),
			minLength=1,
			maxLength=10
		)
		Long[][] <jv>content</jv>
	) {...}
	</p>
	<p>
		The list of valid POJO types for parameters depends on type and format of the value or items/entries of the value.
		For example, instead of <c>Longs</c> in the example above, we could also define a 2-dimensional array of POJOs convertible from <c>Longs</c>:
	</p>
	<p class='bjava'>
	<jc>// Content is a 2-dimensional array of POJOs convertible from Longs:</jc>
	<ja>@RestPost</ja>(<js>"/example1"</js>)	
	<jk>public void</jk> testContent(<ja>@Content</ja>(...) MyPojo1[][] <jv>content</jv>) {...}
	
	<jk>public class</jk> MyPojo1 {
		<jk>public</jk> MyPojo1(Long <jv>input</jv>) {...}
	}
	</p>
	<p class='bjava'>
	<jc>// Content is a POJO that takes in a Long array:</jc>
	<ja>@RestPost</ja>(<js>"/example2"</js>)	
	<jk>public void</jk> testContent(<ja>@Content</ja>(...) MyPojo2[] <jv>content</jv>) {...}
	
	<jk>public class</jk> MyPojo2 {
		<jk>public</jk> MyPojo2(Long[] <jv>input</jv>) {...}
	}
	</p>
	<p class='bjava'>
	<jc>// Content is a POJO that takes in the whole 2-dimensional array:</jc>
	<ja>@RestPost</ja>(<js>"/example3"</js>)	
	<jk>public void</jk>testContent<ja>@Content</ja>(...) MyPojo3 <jv>content</jv>) {...}
	
	<jk>public class</jk> MyPojo3 {
		<jk>public</jk> MyPojo3(Long[][] <jv>input</jv>) {...}
	}
	</p>
	<p>
		As you can see, the complexity of possible input types expands significantly.
		For more information about valid parameter types, see <a class="doclink" href="#jm.OpenApiParsers">OpenAPI Parsers</a>.
	</p>
</div>
</div><!-- END: 8.4.2 - jrs.HttpPartAnnotations -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.DefaultParts' id='jrs.DefaultParts'>8.4.3 - Default Parts</a><span class='update'>created: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.3 - jrs.DefaultParts -->
<div class='topic'>
	<p>
		By default, HTTP parts that don't have value (such as missing query parameters) end up with null
		values:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(<js>"/example"</js>)
	<jk>public</jk> String doGetExample1(
		<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> <jv>p1</jv>,
		<ja>@FormData</ja>(<js>"f1"</js>) MyBean <jv>f1</jv>,
		<ja>@Header</ja>(<js>"Accept-Language"</js>) AcceptLanguage <jv>h1</jv>
	) {
		<jk>if</jk> (<jv>p1</jv> == <jk>null</jk>) <jv>p1</jv> = -1;
		<jk>if</jk> (<jv>f1</jv> == <jk>null</jk>) <jv>f1</jv> = <jsf>DEFAULT_BEAN</jsf>;
		<jk>if</jk> (<jv>h1</jv> == <jk>null</jk>) <jv>h1</jv> = AcceptLanguage.<jsm>of</jsm>(<js>"en"</js>);
	}
	</p>
	<p>
		You have several options to provide default values for HTTP parts.  The most common is to simply
		use {@link java.util.Optional} parameters and handle default values programmatically:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(<js>"/example"</js>)
	<jk>public</jk> String doGetExample1(
		<ja>@Query</ja>(<js>"p1"</js>) Optional&lt;Integer&gt; <jv>p1</jv>,
		<ja>@FormData</ja>(<js>"f1"</js>) Optional&lt;MyBean&gt; <jv>f1</jv>,
		<ja>@Header</ja>(<js>"Accept-Language"</js>) Optional&lt;AcceptLanguage&gt; <jv>h1</jv>
	) {
		<jk>int</jk> <jv>_p1</jv> = <jv>p1</jv>.orElse(-1);
		Bean <jv>_f1</jv> = <jv>f1</jv>.orElse(<jsf>DEFAULT_BEAN</jsf>);
		AcceptLanguage <jv>_h1</jv> = <jv>h1</jv>.orElse(AcceptLanguage.<jsm>of</jsm>(<js>"en"</js>));
	}
	</p>
	<p>
		You can also specify default values on the annotations:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(<js>"/example"</js>)
	<jk>public</jk> String doGetExample1(
		<ja>@Query</ja>(name=<js>"p1"</js>, def=<js>"-1"</js>) <jk>int</jk> <jv>p1</jv>,
		<ja>@FormData</ja>(name=<js>"f1"</js>, def=<js>"foo=bar,baz=qux"</js>) MyBean <jv>f1</jv>,
		<ja>@Header</ja>(name=<js>"Accept-Language"</js>, def=<js>"en"</js>) AcceptLanguage <jv>lang</jv>
	) {
		...
	}
	</p>
	<p>
		A third option is to specify default values via the {@link org.apache.juneau.rest.annotation.Rest} and
		{@link org.apache.juneau.rest.annotation.RestOp} annotations. 
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultAccept() defaultAccept}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultCharset() defaultCharset}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultContentType() defaultContentType}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultRequestAttributes() defaultRequestAttributes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultRequestHeaders() defaultRequestHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#defaultResponseHeaders() defaultResponseHeaders}
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultAccept() defaultAccept}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultCharset() defaultCharset}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultContentType() defaultContentType}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestAttributes() defaultRequestAttributes}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestFormData() defaultRequestFormData}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestHeaders() defaultRequestHeaders}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultRequestQueryData() defaultRequestQueryData}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#defaultResponseHeaders() defaultResponseHeaders}
			</ul>
		</li>
	</ul>		
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Servlet with default headers</jc>
	<ja>@Rest</ja>(

		<jc>// Assume "text/json" Accept value when Accept not specified</jc>
		defaultRequestHeaders={<js>"Accept: text/json"</js>},

		<jc>// Add a version header attribute to all responses</jc>
		defaultResponseHeaders={<js>"X-Version: 1.0"</js>}
	)
	<jk>public</jk> MyRestServlet <jk>extends</jk> BasicRestServlet {
		...
	}			
	</p>
	<p>
		Default parts can also be specified programmatically through any of the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultAccept(String) defaultAccept(String)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultCharset(Charset) defaultCharset(Charset)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultContentType(String) defaultContentType(String)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestAttributes() defaultRequestAttributes()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestAttributes(NamedAttribute...) defaultRequestAttributes(NamedAttribute...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestHeaders() defaultRequestHeaders()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestHeaders(Header...) defaultRequestHeaders(Header...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultResponseHeaders() defaultResponseHeaders()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultResponseHeaders(Header...) defaultResponseHeaders(Header...)}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestOpContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestAttributes() defaultRequestAttributes()}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestAttributes(NamedAttribute...) defaultRequestAttributes(NamedAttribute...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestFormData() defaultRequestFormData()}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestFormData(NameValuePair...) defaultRequestFormData(NameValuePair...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestHeaders() defaultRequestHeaders()}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestHeaders(Header...) defaultRequestHeaders(Header...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestQueryData() defaultRequestQueryData()}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestQueryData(NameValuePair...) defaultRequestQueryData(NameValuePair...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultResponseHeaders() defaultResponseHeaders()}
				<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultResponseHeaders(Header...) defaultResponseHeaders(Header...)}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.4.3 - jrs.DefaultParts -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.RequestBeans' id='jrs.RequestBeans'>8.4.4 - @Request Beans</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.4 - jrs.RequestBeans -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Request @Request} annotation can used to define proxy interfaces against 
		HTTP requests in combination with the following annotations used on methods:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
		<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
		<li class='ja'>{@link org.apache.juneau.annotation.Schema}
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestPut</ja>(<js>"/pets/{petId}"</js>)
	<jk>public void</jk> addPet(UpdatePetBean <jv>updatePet</jv>) {...}

	<ja>@Request</ja>
	<jk>public interface</jk> UpdatePetBean {

		<ja>@Path</ja> <jc>// {petId} inferred.</jc>
		<jk>int</jk> getPetId();

		<ja>@Query</ja>(<js>"verbose"</js>)
		<jk>boolean</jk> isDebug();

		<ja>@Header</ja>(<js>"*"</js>)
		Map&lt;String,Object&gt; getAllHeaders();

		<ja>@Content</ja>
		Pet getPet();
	}
	</p>
	<p>
		The example above is identical in behavior to specifying individual annotated parameters on the <ja>@RestOp</ja>-annotated method:
	</p>
	<p class='bjava'>
	<ja>@RestPut</ja>(<js>"/pets/{petId}"</js>)
	<jk>public void</jk> addPet(
		<ja>@Path</ja>(<js>"petId"</js>) <jk>int</jk> <jv>petId</jv>,
		<ja>@Query</ja>(<js>"verbose"</js>) <jk>boolean</jk> <jv>debug</jv>,
		<ja>@Header</ja>(<js>"*"</js>) Map&lt;String,Object&gt; <jv>allHeaders</jv>,
		<ja>@Content</ja> UpdatePetBean <jv>pet</jv>
	) 
	{...}
	</p>
	<p>
		The return types of the getters must be the supported parameter types for the HTTP-part annotation used.
		Schema-based serialization and parsing is used just as if used as individual parameter types.
		Annotations used are the exact same used on REST parameters and have all the
		same feature support including automatic Swagger validation and documentation.  
		Part names can either be explicitly specified or automatically inferred from the getter names.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Request</ja>
	<jk>public interface</jk> MyRequest {

		<jc>// Schema-based query parameter "pipedCdlInts":  
		// Pipe-delimited list of comma-delimited lists of integers.</jc>
		<ja>@Query</ja>
		<ja>@Schema</ja>(
			collectionFormat=<js>"pipes"</js>
			items=<ja>@Items</ja>(
				items=<ja>@SubItems</ja>(
					collectionFormat=<js>"csv"</js>
					type=<js>"integer"</js>,
					minimum=1,
					maximum=100
				),
				maximumLength=10
			)
		)
		<jk>int</jk>[][] <jv>getPipedCdlInts</jv>();
	}
	</p>
	<p>
		For clarity, the <ja>@Request</ja> annotation can be defined on the parameter, class, or both.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestPut</ja>(<js>"/pets/{petId}"</js>)
	<jk>public void</jk> addPet(<ja>@Request</ja> UpdatePetBean <jv>updatePet</jv>) {...}

	<ja>@Request</ja>
	<jk>public interface</jk> UpdatePetBean {...}
	</p>
</div>
</div><!-- END: 8.4.4 - jrs.RequestBeans -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.ResponseBeans' id='jrs.ResponseBeans'>8.4.5 - @Response Beans</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.5 - jrs.ResponseBeans -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Response} annotation can be used to define beans that return HTTP response
		parts via annotations and methods.  They are used in combination with the following annotations:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode} 
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header} 
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content} 
		<li class='ja'>{@link org.apache.juneau.annotation.Schema} 
	</ul>
	
	<p>
		Response beans can either be returned or thrown from {@link org.apache.juneau.rest.annotation.RestOp @RestOp}-annotated methods.
	</p>
	<ul class='notes'>
		<li class='note'>
		As a general convention, response beans with return codes <c>&lt;400</c> should be defined as regular classes and
		 <c>&gt;=400</c> should be defined as exceptions.
	</ul>
	<p>
		The following example shows the <ja>@Response</ja> annotation used to define an exception for an invalid login attempt:
	</p>
	<p class='bjava'>
	<jc>// Our annotated normal response.</jc>
	<ja>@Response</ja>
	<ja>@StatusCode</ja>(200)
	<ja>@Schema</ja>(
		description=<js>"User was good."</js> <jc>// Description show in Swagger</jc>
	)
	<jk>public class</jk> ValidLogin {
		<jk>public</jk> ValidLogin() {
			...
		}
		
		<jc>// Response bean converted to output based on Accept header.</jc>
		<ja>@Content</ja>
		<jk>public</jk> WelcomeMessageBean getContent() {
			<jk>return new</jk> WelcomeMessageBean();
		}
	}
	</p>
	<p class='bjava'>
	<jc>// Our annotated exception.</jc>
	<ja>@Response</ja>
	<ja>@StatusCode</ja>(401)
	<ja>@Schema</ja>(
		description=<js>"Invalid username or password provided"</js> <jc>// Description show in Swagger</jc>
	)
	<jk>public class</jk> InvalidLogin <jk>extends</jk> Exception {
		<jk>public</jk> InvalidLogin() {
			<jk>super</jk>(<js>"Invalid username or password."</js>);  <jc>// Message sent in response</jc>
		}
		
		<ja>@Header</ja>(<js>"My-Message"</js>)
		<jk>public</jk> String getMyMessage() {
			<jk>return</jk> <js>"Nope!"</js>;
		}
	}
	</p>
	<p class='bjava'>
	<jc>// Our REST method that throws an annotated exception.</jc>
	<ja>@RestGet</ja>(<js>"/user/login"</js>)
	<jk>public</jk> ValidLogin login(
		<ja>@FormData</ja>(<js>"username"</js>) String <jv>username</jv>, 
		<ja>@FormData</ja>(<js>"password"</js>) String <jv>password</jv>
	) <jk>throws</jk> InvalidLogin 
	{
		<jk>if</jk> (<jsm>isValid</jsm>(<jv>username</jv>, <jv>password</jv>)) {
			<jk>return new</jk> ValidLogin();
		} 
		<jk>throw new</jk> InvalidLogin();
	}
	</p>
	<p>
		Custom exceptions can also extend from one of the predefined HTTP exceptions such as the {@link org.apache.juneau.http.response.Unauthorized} exception:
	</p>
	<p class='bjava'>
	<jc>// Our annotated exception.</jc>
	<ja>@Response</ja>
	<ja>@Schema</ja>(
		description=<js>"Invalid username or password provided"</js> <jc>// Overridden from parent class</jc>
	) 
	<jk>public class</jk> InvalidLogin <jk>extends</jk> Unauthorized {
		<jk>public</jk> InvalidLogin() {
			<jk>super</jk>(<js>"Invalid username or password."</js>); 
		}
	}

	<jc>// Parent predefined exception class.</jc>
	<ja>@Response</ja>
	<ja>@StatusCode</ja>(401)
	<ja>@Schema</ja>(
		description=<js>"Unauthorized"</js>
	)
	<jk>public class</jk> Unauthorized <jk>extends</jk> RestException {...}
	</p>
</div>
</div><!-- END: 8.4.5 - jrs.ResponseBeans -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HttpPartApis' id='jrs.HttpPartApis'>8.4.6 - HTTP Part APIs</a><span class='update'>created: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.4.6 - jrs.HttpPartApis -->
<div class='topic'>
	<p>
		Request HTTP parts can also be retrieved programmatically through the following classes that
		can be passed in as parameters or access through {@link org.apache.juneau.rest.RestRequest} bean:
	</p>
	<ul class='javatreec'>
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestHeaders}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestQueryParams}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestFormParams}
		<li class='jc'>{@link org.apache.juneau.rest.httppart.RequestPathParams}
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestPost</ja>(...)
	<jk>public</jk> Object myMethod(RequestHeaders <jv>headers</jv>) {
	
		<jc>// Add a default value.</jc>
		<jv>headers</jv>.addDefault(<js>"ETag"</js>, <jsf>DEFAULT_UUID</jsf>);
	
		<jc>// Get a header value as a POJO.</jc>
		UUID <jv>etag</jv> = <jv>headers</jv>.get(<js>"ETag"</js>).as(UUID.<jk>class</jk>).get();
	
		<jc>// Get a header as a standard HTTP part.</jc>
		ContentType <jv>contentType</jv> = <jv>headers</jv>.get(ContentType.<jk>class</jk>).orElse(ContentType.<jsf>TEXT_XML</jsf>);
	}
	</p>
	<p>
		Built in to these APIs are various convenience methods such as converting parts to 
		different types or inline fluent assertions:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Inline fluent assertion and retrieval.</jc>
	String <jv>foo</jv> = <jv>request</jv>
		.getHeader(<js>"Foo"</js>)
		.assertString().contains(<js>"bar"</js>)
		.get();
	</p>
</div>
</div><!-- END: 8.4.6 - jrs.HttpPartApis -->
</div><!-- END: 8.4 - jrs.HttpParts -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Marshalling' id='jrs.Marshalling'>8.5 - Marshalling</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.5 - jrs.Marshalling -->
<div class='topic'>
	<p>
		Juneau uses {@link org.apache.juneau.parser.Parser Parsers} and {@link org.apache.juneau.serializer.Serializer Serializers} for marshalling
		HTTP request and response bodies to POJOs using the <c>Content-Type</c> header to match the best
		parser and the <c>Accept</c> header to match the best serializer.
	</p>
	
	<p>
		Serializers and parsers can be associated with REST servlets using the following annotations:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#serializers() serializers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#serializers() parsers}
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#serializers() serializers}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#serializers() parsers}
			</ul>
		</li>
	</ul>
	<p>
		Request bodies are parsed and passed in via {@link org.apache.juneau.http.annotation.Content @Content}-annotated parameters,
		and response bodies are returned or thrown by {@link org.apache.juneau.rest.annotation.RestOp @RestOp}-annotated methods
		and serialized.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		serializers={JsonParser.<jk>class</jk>, HtmlSerializer.<jk>class</jk>},
		parsers={JsonParser.<jk>class</jk>, HtmlParser.<jk>class</jk>}
	)
	<jk>public class</jk> MyResource {

		<jc>// Override at the method level.</jc>
		<ja>@RestPost</ja>(parsers={XmlParser.<jk>class</jk>})
		<jk>public</jk> MyPojo myMethod(<ja>@Content</ja> MyPojo <jv>myPojo</jv>) {
			<jc>// Do something with your parsed POJO.</jc>
			<jc>// Then return it and serialize the POJO.</jc>
		}
	}
	</p>
	<p>
		The following classes provide common default serializers and parsers that can be
		used as-is or augmented by child classes:
	<p>
	<ul class='javatree'>
		<li>Classes:
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestServlet}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestServletGroup}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestObject}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestObjectGroup}
			</ul>
		</li>
		<li>Interfaces:
			<ul class='javatreec'>
				<li class='jic'>{@link org.apache.juneau.rest.config.BasicJsonConfig}
				<li class='jic'>{@link org.apache.juneau.rest.config.BasicJsonHtmlConfig}
				<li class='jic'>{@link org.apache.juneau.rest.config.BasicJson5Config}
				<li class='jic'>{@link org.apache.juneau.rest.config.BasicOpenApiConfig}
				<li class='jic'>{@link org.apache.juneau.rest.config.BasicUniversalConfig}
			</ul>
		</li>
	</ul>
	<p>
		Serializers and parsers can also be defined programmatically using an INIT hook method like shown below:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>
	<jk>public class</jk> MyResource {

		<ja>@RestInit</ja>
		<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) {
			<jv>builder</jv>.serializers().add(JsonSerializer.<jk>class</jk>, HtmlSerializer.<jk>class</jk>);
			<jv>builder</jv>.parsers().add(JsonParser.<jk>class</jk>, HtmlParser.<jk>class</jk>);
		}
	}
	</p>
	<p>
		They can also be defined through <a class="doclink" href="#jrs.RestContext">custom REST contexts and builders</a>.
	</p>
	
	<p>
		Config annotations allow you to define serializer and parser properties using specialized annotations
		at either the class or operation levels:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		...
	)
	<ja>@BeanConfig</ja>(sortProperties=<js>"true"</js>)
	<ja>@SerializerConfig</ja>(trimNulls=<js>"true"</js>)
	<ja>@JsonConfig</ja>(escapeSolidus=<js>"true"</js>)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestServlet {
		
		<ja>@RestPost</ja>
		<ja>@BeanConfig</ja>(sortProperties=<js>"false"</js>)
		<ja>@SerializerConfig</ja>(trimNulls=<js>"false"</js>)
		<jk>public</jk> MyPojo myMethod(<ja>@Content</ja> MyPojo <jv>myPojo</jv>) {
			...
		}
	}
	</p>
	<p>
		Swaps are associated serializers and parsers registered on a REST resource via the {@link org.apache.juneau.annotation.BeanConfig} annotation
		on either the class or method level:
	</p>
	<p class='bjava'>
	<jc>// Servlet with transforms applied</jc>
	<ja>@Rest</ja>(
		...
	)
	<ja>@BeanConfig</ja>(
		swaps={
			<jc>// Calendars should be serialized/parsed as ISO8601 date-time strings</jc>
			TemporalCalendarSwap.IsoInstant.<jk>class</jk>,

			<jc>// Byte arrays should be serialized/parsed as BASE64-encoded strings</jc>
			ByteArraySwap.Base64.<jk>class</jk>
		},
		beanFilters={
			<jc>// Subclasses of MyInterface will be treated as MyInterface objects.</jc>
			<jc>// Bean properties not defined on that interface will be ignored.</jc>
			MyInterface.<jk>class</jk>
		}
	)
	<jk>public</jk> MyResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		Config annotations are defined for all serializers and parsers:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.annotation.BeanConfig BeanConfig}
		<li class='ja'>{@link org.apache.juneau.csv.annotation.CsvConfig CsvConfig}
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlConfig HtmlConfig}
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlDocConfig HtmlDocConfig}
		<li class='ja'>{@link org.apache.juneau.json.annotation.JsonConfig JsonConfig}
		<li class='ja'>{@link org.apache.juneau.jsonschema.annotation.JsonSchemaConfig JsonSchemaConfig}
		<li class='ja'>{@link org.apache.juneau.msgpack.annotation.MsgPackConfig MsgPackConfig}
		<li class='ja'>{@link org.apache.juneau.oapi.annotation.OpenApiConfig OpenApiConfig}
		<li class='ja'>{@link org.apache.juneau.parser.annotation.ParserConfig ParserConfig}
		<li class='ja'>{@link org.apache.juneau.plaintext.annotation.PlainTextConfig PlainTextConfig}
		<li class='ja'>{@link org.apache.juneau.serializer.annotation.SerializerConfig SerializerConfig}
		<li class='ja'>{@link org.apache.juneau.soap.annotation.SoapXmlConfig SoapXmlConfig}
		<li class='ja'>{@link org.apache.juneau.uon.annotation.UonConfig UonConfig}
		<li class='ja'>{@link org.apache.juneau.urlencoding.annotation.UrlEncodingConfig UrlEncodingConfig}
		<li class='ja'>{@link org.apache.juneau.xml.annotation.XmlConfig XmlConfig}
	</ul>
	
	<ul class='seealso'>
		<li class='jc'>{@link org.apache.juneau.examples.rest.PhotosResource} - An example of a REST resource that uses a custom serializer and parser.
	</ul>
</div>
</div><!-- END: 8.5 - jrs.Marshalling -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.HandlingFormPosts' id='jrs.HandlingFormPosts'>8.6 - Form Posts</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.6 - jrs.HandlingFormPosts -->
<div class='topic'>
	<p>
		HTTP form posts can be handled two ways:
	</p>
	<ol class='spaced-list'>
		<li>By parsing the entire HTTP body into a POJO using the registered {@link org.apache.juneau.urlencoding.UrlEncodingParser}
		<li>By access the form post entries as HTTP parts.
	</ol>
	<p>
		The following example shows the first approach of handling an <c>application/x-www-form-urlencoded</c>
		request of the form <l>"aString=foo&amp;aNumber=123&amp;aDate=2001-07-04T15:30:45Z"</l> and 
		loading it into a simple bean.
	</p>
	<p class='bjava'>				
	<jc>// A simple bean.</jc>
	<jk>public static class</jk> FormInputBean {
		<jk>public</jk> String <jf>aString</jf>;
		<jk>public int</jk> <jf>aNumber</jf>;
		<ja>@Swap</ja>(TemporalCalendarSwap.IsoLocalDateTime.<jk>class</jk>)
		<jk>public</jk> Calendar <jf>aDate</jf>;
	}
	</p>
	<p class='bjava'>				
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyRestResource <jk>extends</jk> BasicRestServlet {
	
		<jc>// Our form input endpoint.</jc>
		<ja>@RestPost</ja>(<js>"/"</js>)
		<jk>public</jk> Object doPost(<ja>@Content</ja> FormInputBean <jv>input</jv>) {
			<jc>// Just mirror back the request</jc>
			<jk>return</jk> <jv>input</jv>;
		}
	}		
	</p>	
	<p>
		The next example shows handling it as individual parts:	
	</p>	
	<p class='bjava'>
	<jc>// Our form input endpoint.</jc>
	<ja>@RestPost</ja>(<js>"/"</js>)
	<jk>public</jk> Object doPost(
		<ja>@FormData</ja>(<js>"aString"</js>) String <jv>aString</jv>, 
		<ja>@FormData</ja>(<js>"aNumber"</js>) <jk>int</jk> <jv>aNumber</jv>,
		<ja>@FormData</ja>(<js>"aDate"</js>) Calendar <jv>aDate</jv>) {
		...
	}
	</p>
	<p>
		The advantage to the form input bean is that it can handle any of the parsable types (e.g. JSON, XML...) 
		in addition to URL-Encoding while the latter approach only supports URL-Encoding.
	</p>
	<div class='warn'>
		If you're using form input beans, DO NOT use the <l>@FormData</l> attribute or 
		{@link javax.servlet.http.HttpServletRequest#getParameter(String)} method since this will cause the 
		underlying JEE servlet to parse the HTTP body as a form post.
		<br>Your input bean will end up being null since there won't be any content left after the servlet 
		has parsed the body of the request.
		<br>This applies to WHENEVER you use <l>@Content</l> or {@link org.apache.juneau.rest.RestRequest#getContent()}
	</div>
	<div class='warn'>
		If you want to be able to consume url-encoded form post bodies as POJOs in Spring Boot, you'll need to 
		add the following Spring Bean to your configuration to prevent Spring Boot from automatically 
		consuming the body itself:
		<p class='bjava' style='max-width:700px'>
	<ja>@SpringBootApplication</ja>
	<ja>@Controller</ja>
	<jk>public class</jk> SpringBootAppConfig {
			
		<ja>@Bean</ja>
		<jk>public</jk> FilterRegistrationBean&lt;HiddenHttpMethodFilter&gt; registration(HiddenHttpMethodFilter <jv>filter</jv>) {
			FilterRegistrationBean&lt;HiddenHttpMethodFilter&gt; <jv>reg</jv> = <jk>new</jk> FilterRegistrationBean&lt;&gt;(<jv>filter</jv>);
			<jv>reg</jv>.setEnabled(<jk>false</jk>);
			<jk>return</jk> <jv>reg</jv>;
		}
	}
		</p>	
	</div>
	
	<h5 class='topic'>Multi-part Form Posts</h5>
	<p>
		The Juneau framework does not natively support multipart form posts.  
		However, it can be done in conjunction with the Apache Commons File Upload library or through the Servlet 3.0 API directly.
	</p>	
	<p>
		The following is an example that uses the File Upload library to allow files to be uploaded as multipart form posts.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/tempDir"</js>
	)
	<jk>public class</jk> TempDirResource <jk>extends</jk> DirectoryResource {

		<ja>@RestPost</ja>(path=<js>"/upload"</js>, matchers=TempDirResource.MultipartFormDataMatcher.<jk>class</jk>)
		<jk>public</jk> Redirect uploadFile(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			ServletFileUpload <jv>upload</jv> = <jk>new</jk> ServletFileUpload();
			FileItemIterator <jv>iter</jv> = <jv>upload</jv>.getItemIterator(<jv>req</jv>);
			<jk>while</jk> (<jv>iter</jv>.hasNext()) {
				FileItemStream <jv>item</jv> = <jv>iter</jv>.next();
				<jk>if</jk> (<jv>item</jv>.getFieldName().equals(<js>"contents"</js>)) { 
					File <jv>file</jv> = <jk>new</jk> File(getRootDir(), <jv>item</jv>.getName());
					IOPipe.<jsm>create</jsm>(<jv>item</jv>.openStream(), <jk>new</jk> FileOutputStream(<jv>file</jv>)).closeOut().run();
				}
			}
			<jk>return new</jk> Redirect(); <jc>// Redirect to the servlet root.</jc>
		}

		<jd>/** Causes a 404 if POST isn't multipart/form-data */</jd>
		<jk>public static class</jk> MultipartFormDataMatcher <jk>extends</jk> RestMatcher {

			<ja>@Override</ja> <jc>/* RestMatcher */</jc>
			<jk>public boolean</jk> matches(RestRequest <jv>req</jv>) {
				String <jv>contentType</jv> = <jv>req</jv>.getContentType();
				<jk>return</jk> <jv>contentType</jv> != <jk>null</jk> &amp;&amp; <jv>contentType</jv>.startsWith(<js>"multipart/form-data"</js>); 
			}
		}
	</p>
	<p>
		The following shows using the <l>HttpServletRequest.getParts()</l> method to retrieve multi-part form posts when using Jetty.
		This example is pulled from the PetStore application.
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>
	<jk>public</jk> SeeOtherRoot uploadFile(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {

		<jc>// Required for Jetty.</jc>
		MultipartConfigElement <jv>mce</jv> = <jk>new</jk> MultipartConfigElement((String)<jk>null</jk>);
		<jv>req</jv>.setAttribute(<js>"org.eclipse.jetty.multipartConfig"</js>, <jv>mce</jv>);  

		String <jv>id</jv> = UUID.<jsm>randomUUID</jsm>().toString();
		BufferedImage <jv>img</jv> = <jk>null</jk>;
		<jk>for</jk> (Part <jv>part</jv> : <jv>req</jv>.getParts()) {
			<jk>switch</jk> (<jv>part</jv>.getName()) {
				<jk>case</jk> <js>"id"</js>:
					<jv>id</jv> = IOUtils.<jsm>read</jsm>(<jv>part</jv>.getInputStream());
					<jk>break</jk>;
				<jk>case</jk> <js>"file"</js>:
					<jv>img</jv> = ImageIO.<jsm>read</jsm>(<jv>part</jv>.getInputStream());
			}
		}
		<jsm>addPhoto</jsm>(<jv>id</jv>, <jv>img</jv>);
		<jk>return new</jk> SeeOtherRoot(); <jc>// Redirect to the servlet root.</jc>
	}
	</p>
</div>
</div><!-- END: 8.6 - jrs.HandlingFormPosts -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Guards' id='jrs.Guards'>8.7 - Guards</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.7 - jrs.Guards -->
<div class='topic'>
	<p>
		Guards control access to REST classes and methods.
		When guards are associated at the class-level, it's equivalent to associating guards on all Java methods on 
		the servlet.
		If multiple guards are present, ALL guards must pass.  (Note that this is different in behavior to <a class="doclink" href="#jrs.Matchers">Matchers</a>
		which require only one matcher to pass.)
	</p>
	<p>
		Guards are associated with resource classes and methods via the following:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#guards() guards} 
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#guards() guards} 
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Define a guard that only lets Billy make a request</jc>
	<jk>public</jk> BillyGuard <jk>extends</jk> RestGuard {

		<ja>@Override</ja> <jc>/* RestGuard */</jc>
		<jk>public boolean</jk> isRequestAllowed(RestRequest <jv>req</jv>) {
			<jk>return</jk> <jv>req</jv>.getUserPrincipal().getName().equals(<js>"Billy"</js>);
		}
	}

	<jc>// Servlet with class-level guard applied</jc>
	<ja>@Rest</ja>(guards=BillyGuard.<jk>class</jk>)
	<jk>public</jk> MyRestServlet <jk>extends</jk> BasicRestServlet {

		<jc>// Delete method that only Billy is allowed to call.</jc>
		<ja>@RestDelete</ja>
		<jk>public</jk> doDelete(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) <jk>throws</jk> Exception {...}
	}
	</p>
	<p>
		A common use for guards is to only allow admin access to certain Java methods...
	</p>
	<p class='bjava'>
	<jc>// DELETE method</jc>
	<ja>@RestDelete</ja>(guards={AdminGuard.<jk>class</jk>})
	<jk>public void</jk> doDelete(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) <jk>throws</jk> Exception {...}
	</p>
	<p class='bjava'>
	<jk>public class</jk> AdminGuard <jk>extends</jk> RestGuard {

		<ja>@Override</ja> <jc>/* RestGuard */</jc>
		<jk>public boolean</jk> isRequestAllowed(RestRequest <jv>req</jv>) {
			<jk>return</jk> <jv>req</jv>.getUserPrincipal().isUserInRole(<js>"ADMIN"</js>);
		}
	}
	</p>
	<p>
		A guard failure results in an <l>HTTP 401 Unauthorized</l> response.
		However, this can be configured by overriding 
		{@link org.apache.juneau.rest.guard.RestGuard#guard(RestRequest,RestResponse)} and processing the response 
		yourself.
	</p>
	<p class='bjava'>
	<jk>public class</jk> AdminGuard <jk>extends</jk> RestGuard {

		<ja>@Override</ja> <jc>/* RestGuard */</jc>
		<jk>public boolean</jk> guard(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) <jk>throws</jk> BasicHttpException {
			<jk>if</jk> (! <jsm>isOkay</jsm>(<jv>req</jv>))
				<jk>throw new</jk> Forbidden(<js>"Access denied!!!"</js>);
			<jk>return true</jk>;
		}
	}
	</p>
	<p>
		A simplified format is available for matching based on the user role on the request using the following:
	</p>
	
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#roleGuard() roleGuard} 
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#roleGuard() roleGuard} 
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/foo"</js>,
		roleGuard=<js>"ROLE_ADMIN || (ROLE_READ_WRITE &amp;&amp; ROLE_SPECIAL)"</js>
	)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestServlet {
		...
	}
	</p>
</div>
</div><!-- END: 8.7 - jrs.Guards -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Converters' id='jrs.Converters'>8.8 - Converters</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.8 - jrs.Converters -->
<div class='topic'>
	<p>
		Converters can be thought of as "post-processors" for response POJOs before they get passed to the serializer.
	</p>
	<p>
		Converters are associated with resource classes and methods via the following:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#converters() converters} 
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp} 
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#converters() converters} 
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// GET person request handler.</jc>
	<jc>// Traversable conversion enabled to allow nodes in returned POJO tree to be addressed.</jc>
	<jc>// Queryable conversion enabled to allow returned POJO to be searched/viewed/sorted.</jc>
	<ja>@RestGet</ja>(
		path=<js>"/people/{id}/*"</js>,
		converters={Traversable.<jk>class</jk>,Queryable.<jk>class</jk>}
	)
	<jk>public</jk> Person getPerson(<ja>@Path</ja>(<js>"id"</js>) <jk>int</jk> <jv>id</jv>) {
		<jk>return</jk> findPerson(<jv>id</jv>);
	}
	</p>	
	<p>
		Juneau defines the following converters out-of-the-box:
	</p>
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.rest.converter.RestConverter}
			<ul class='spaced-list'>
				<li class='jc'>
					{@link org.apache.juneau.rest.converter.Queryable}
					<br>Provides query parameters that can be used to transform the response (i.e. search/view/sort the 
					POJO response before being serialized).
				<li class='jc'>
					{@link org.apache.juneau.rest.converter.Traversable}
					<br>Allows nodes in the POJO response tree to be individually accessed through additional path info on 
					the request.
				<li class='jc'>
					{@link org.apache.juneau.rest.converter.Introspectable}
					<br>Allows method calls to be made on the response POJO, and for the result of that method call to be 
					serialized as the response.
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.8 - jrs.Converters -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.LocalizedMessages' id='jrs.LocalizedMessages'>8.9 - Localized Messages</a><span class='update'>updated: 8.2.0,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.9 - jrs.LocalizedMessages -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.annotation.Rest#messages @Rest(messages)} annotation identifies the location of the resource bundle 
		for a <ja>@Rest</ja>-annotated class if it's different from the class name.
	</p>
	<p>
		By default, the resource bundle name is assumed to match the class name.  For example, given the class
		<c>MyClass.java</c>, the resource bundle is assumed to be <c>MyClass.properties</c>.  This property
		allows you to override this setting to specify a different location such as <c>MyMessages.properties</c> by
		specifying a value of <js>"MyMessages"</js>.
	</p>
	<p>
	Resource bundles are searched using the following base name patterns:
	</p>
	<ul>
		<li><js>"{package}.{name}"</js>
		<li><js>"{package}.i18n.{name}"</js>
		<li><js>"{package}.nls.{name}"</js>
		<li><js>"{package}.messages.{name}"</js>
	</ul>
	
	<p>
		This annotation is used to provide request-localized (based on <c>Accept-Language</c>) messages for the following method:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getMessage(String,Object...) getMessage(String,Object)}
			</ul>
	</ul>
	
	<p>
		Request-localized messages are also available by passing either of the following args into your Java method:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link java.util.ResourceBundle} - Basic Java resource bundle.
		<li class='jc'>{@link org.apache.juneau.cp.Messages} - Extended resource bundle with several convenience methods.
	</ul>
	<p>
		The value can be a relative path like <js>"nls/Messages"</js>, indicating to look for the resource bundle
		<js>"com.foo.sample.nls.Messages"</js> if the resource class is in <js>"com.foo.sample"</js>, or it can be an
		absolute path like <js>"com.foo.sample.nls.Messages"</js>
	</p>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bini'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of org/apache/foo/nls/MyMessages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>HelloMessage</ck> = <cv>Hello {0}!</cv>
	</p>
	<p class='bjava'>
	<jc>// Contents of org/apache/foo/MyResource.java</jc>

	<ja>@Rest</ja>(messages=<js>"nls/MyMessages"</js>)
	<jk>public class</jk> MyResource {

		<ja>@RestGet</ja>(<js>"/hello/{you}"</js>)
		<jk>public</jk> Object helloYou(RestRequest <jv>req</jv>, Messages <jv>messages</jv>, <ja>@Path</ja>(<js>"name"</js>) String <jv>you</jv>) {
			String <jv>msg</jv>;

			<jc>// Get it from the RestRequest object.</jc>
			<jv>msg</jv> = <jv>req</jv>.getMessage(<js>"HelloMessage"</js>, <jv>you</jv>);

			<jc>// Or get it from the method parameter.</jc>
			<jv>msg</jv> = <jv>messages</jv>.getString(<js>"HelloMessage"</js>, <jv>you</jv>);

			<jc>// Or get the message in a locale different from the request.</jc>
			<jv>msg</jv> = <jv>messages</jv>.forLocale(Locale.<jsf>UK</jsf>).getString(<js>"HelloMessage"</js>, <jv>you</jv>);

			<jk>return</jk> <jv>msg</jv>;
		}
	}
	</p>
	<p>
		When using shared resource bundles, keys can be prefixed by class names like so and still retrieve by simple
		key names:
	</p>
	<p class='bini'>
	<cc>#--------------------------------------------------------------------------------
	# Contents of shared org/apache/foo/nls/MyMessages.properties
	#--------------------------------------------------------------------------------</cc>
	<ck>MyResource.HelloMessage</ck> = <cv>Hello {0}!</cv>
	</p>
	
	<p>
		Messages are automatically inherited from super classes.  If a string cannot be found in the bundle of the current
		class, it will be searched for up the class hierarchy.
	</p>
</div>
</div><!-- END: 8.9 - jrs.LocalizedMessages -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Encoders' id='jrs.Encoders'>8.10 - Encoders</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.10 - jrs.Encoders -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.annotation.Rest#encoders @Rest(encoders)} annotation can 
		be used to associate character encoders with a servlet class.
		Encoders can be used to enable various kinds of compression (e.g. <l>"gzip"</l>) on requests and responses 
		based on the request <l>Accept-Encoding</l> and <l>Content-Encoding</l> headers.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Servlet with automated support for GZIP compression</jc>
	<ja>@Rest</ja>(encoders={GzipEncoder.<jk>class</jk>})
	<jk>public</jk> MyRestServlet <jk>extends</jk> BasicRestServlet {
		...
	}
	</p>
	<p>
		Juneau defines the following encoders out-of-the-box:
	</p>
	<ul class='javatreec'>
		<li class='jc'>
			{@link org.apache.juneau.encoders.GzipEncoder}
		<li class='jc'>
			{@link org.apache.juneau.encoders.IdentityEncoder}
	</ul>
</div>
</div><!-- END: 8.10 - jrs.Encoders -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.ConfigurationFiles' id='jrs.ConfigurationFiles'>8.11 - Configuration Files</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.11 - jrs.ConfigurationFiles -->
<div class='topic'>
	<p>
		The Server API provides methods for associating configuration files with REST servlets so that 
		configuration properties can be defined in external files.  It uses the following annotation:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#config() config}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		<jc>// Config file is located at ./config_dir/myconfig.cfg</jc>
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		In recap, the Configuration API provides support for INI-style configuration files with embedded string variables:
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bini'>
	<cc>#--------------------------</cc>
	<cc># Examples </cc>
	<cc>#--------------------------</cc>
	<cs>[MyProperties]</cs>
	<ck>path</ck> = <cv>$E{PATH}</cv>
	<ck>javaHome</ck> = <cv>$S{java.home}</cv>
	<ck>customMessage</ck> = <cv>Java home is $C{MyProperties/javaHome} and the 
		environment path is $C{MyProperties/path}.</cv>
	</p>
	<p>
		These properties are then accessible through the {@link org.apache.juneau.config.Config} class.
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/"</js>)
	<jk>public</jk> String sample(Config <jv>config</jv>) {
		String <jv>path</jv> = <jv>config</jv>.get(<js>"MyProperties/path"</js>).get();
		File <jv>javaHome</jv> = <jv>config</jv>.get(<js>"MyProperties/javaHome"</js>).as(File.<jk>class</jk>).orElse(<jv>null</jv>);
		String <jv>customMessage</jv> = <jv>config</jv>.get(<js>"MyProperties/customMessage"</js>).orElse(<js>"Hello"</js>);
		...
	}
	</p>
	<p>
		The annotation itself can contain string variables.  
		For example, the Microservice API {@link org.apache.juneau.rest.servlet.BasicRestServlet} class defines the 
		location of the config file as a system property <l>"juneau.configFile"</l>:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		<jc>// Config file location is defined as a system property</jc>
		config=<js>"$S{juneau.configFile}"</js>,
		...
	)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		Spring Boot applications typically define an <c>application.properties</c> file.  You can reuse it
		as a config file like so:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		config=<js>"application.properties"</js>,
		...
	)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		Note that properties files are a subset of functionality of INI files (they're basically just INI files with a single default section).  
		It's therefore possible to use INI-style syntax such as sections in your <c>application.properties</c> file.  
	</p>
	<p>
		Once a config file has been associated with a REST resource, it can be accessed through one of the following:
		{@link org.apache.juneau.rest.RestContext.Builder#getConfig()} method.  It can also be access by passing in a {@link org.apache.juneau.config.Config} bean to any of your
		REST OP methods.
	</p>
	<p>
		A common usage is to use this method to initialize fields in your servlet.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		<jc>// Config file is located at ./config_dir/myconfig.cfg</jc>
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public class</jk> MyResource {
		<jk>private final</jk> String <jf>path</jf>;
		<jk>private final</jk> File <jf>javaHome</jf>;
	
		<jk>public</jk> MyResource(RestContext.Builder <jv>builder</jv>) {
			Config <jv>config</jv> = <jv>builder</jv>.getConfig();
			<jf>path</jf> = <jv>config</jv>.get(<js>"MyProperties/path"</js>).orElse(<js>"mypath"</js>);
			<jf>javaHome</jf> = <jv>config</jv>.get(<js>"MyProperties/javaHome"</js>).as(File.<jk>class</jk>).orElse(<jv>null</jv>);
		}
	</p>
	<p>
		Another common usage is to refer to config properties through <ck>$C</ck> variables in your annotations:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>
	<jc>// Get stylesheet from myconfig.cfg but default to devops.css if it's not specified</jc>
	<ja>@HtmlDoc</ja>(
		stylesheet=<js>"$C{MyServlet/stylesheet,servlet:/styles/devops.css}"</js>,
	)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		It's even possible to reference request-level variables in your config file if you use 
		{@link org.apache.juneau.rest.RestRequest#getConfig()} to access the config file:
	</p>
	<p class='bini'>
	<cc>#-------------------------------------</cc>
	<cc># Contents of config_dir/myconfig.cfg </cc>
	<cc>#-------------------------------------</cc>
	<cs>[HelloWorldResource]</cs>
	<ck>message</ck> = <cv>Hello $RQ{person}!</cv>
	</p>
	<p class='bjava'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	<ja>@Rest</ja>(
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {
		
		<jd>/** 
		 * GET request handler.
		 * Specify the GET parameter "?person=X" for a specialized message! 
		 */</jd>
		<ja>@RestGet</ja>(<js>"/"</js>)
		<jk>public</jk> String sayHello(Config <jv>config</jv>) {
			<jk>return</jk> <jv>config</jv>.get(<js>"HelloWorldResource/message"</js>).get();
		}
	}
	</p>
	<p>
		You can even add resource bundles into the mix:
	</p>
	<p class='bini'>
	<cc>#-------------------------------------</cc>
	<cc># Contents of config_dir/myconfig.cfg </cc>
	<cc>#-------------------------------------</cc>
	<cs>[HelloWorldResource]</cs>
	<ck>message</ck> = <cv>$L{localizedMessage,$RQ{person}}</cv>
	</p>
	<p class='bini'>
	<cc>#-------------------------------------------</cc>
	<cc># Contents of HelloWorldResource.properties </cc>
	<cc>#-------------------------------------------</cc>
	<ck>localizedMessage</ck> = <cv>Hello {0}!</cv>
	</p>
	<p class='bjava'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	<ja>@Rest</ja>(
		messages=<js>"HelloWorldResources"</js>,
		config=<js>"config_dir/myconfig.cfg"</js>,
		...
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {
		
		<jd>/** 
		 * GET request handler.
		 * Specify the GET parameter "?person=X" for a specialized message! 
		 */</jd>
		<ja>@RestGet</ja>(<js>"/"</js>)
		<jk>public</jk> String sayHello(Config <jv>config</jv>) {
			<jk>return</jk> <jv>config</jv>.get(<js>"HelloWorldResource/message"</js>).get();
		}
	}
	</p>
	
	<ul class='seealso'>
		<li><a class="doclink" href="#juneau-config">juneau-config</a>
	</ul>
</div>
</div><!-- END: 8.11 - jrs.ConfigurationFiles -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.SvlVariables' id='jrs.SvlVariables'>8.12 - SVL Variables</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.12 - jrs.SvlVariables -->
<div class='topic'>
	<p>	
		In the previous examples, there were several cases where embedded variables were contained within
		annotation values:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		title=<js>"$L{my.label}"</js>
	)
	</p>
	<p>
		Variables take the form <l>$X{contents}</l> where <l>X</l> can consist of zero or more ASCII characters and <l>contents</l> can be virtually anything.
		This is called Simple Variable Language, or SVL, and is defined here: <a class="doclink" href="#jm.SimpleVariableLanguage">Simple Variable Language</a>.
	</p>
	<h5 class='topic'>Features</h5>
	<ul class='spaced-list'>
		<li>
			Variables can be nested arbitrarily deep (e.g. <l>"$X{$Y{foo}}"</l>).
		<li>
			Variables can contain arguments (e.g. <l>"$L{my.label,arg1,arg2}"</l>).
		<li>
			Variables are recursively resolved. 
			<br>i.e., if a variable results to a value with another variable in it, that variable will also be 
			resolved (restricted for security reasons on variables that involve user input).
	</ul>
	<p>
		There are two distinct groups of variables:
	</p>
	<ul class='spaced-list'>
		<li><l>Initialization-time variables</l>
			<br>These are variables that can be used in many of the annotations in {@link org.apache.juneau.rest.annotation.Rest @Rest}. 
			<br>The {@link org.apache.juneau.rest.RestContext#getVarResolver()} method returns initialization-time variables only.
		<li><l>Request-time variables</l>
			<br>These are variables that are available during HTTP-requests and can be used on annotation such as <del>HtmlDoc @HtmlDoc</del>. 
			<br>{@link org.apache.juneau.rest.RestRequest#getVarResolverSession()} method returns initialization and request-time variables.
	</ul>
	<p>
		The following is the default list of supported variables.
	</p>
	<h5 class='figure'><a href='#DefaultRestSvlVariables' id='DefaultRestSvlVariables'>Default REST SVL Variables:</a></h5>
	<table class='styled w800'>
		<tr>
			<th>Module</th><th>Class</th><th>Pattern</th><th>Initialization<br>time</th><th>Request<br>time</th><th>Examples</th>
		</tr>
		<tr class='dark'>
			<td rowspan='11' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-svl</td>
			<td>{@link org.apache.juneau.svl.vars.EnvVariablesVar}</td>
			<td class='code'>$E{key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$E{PATH}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.SystemPropertiesVar}</td>
			<td class='code'>$S{key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$S{java.home}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.ArgsVar}</td>
			<td class='code'>$A{key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$A{foo,null}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.ManifestFileVar}</td>
			<td class='code'>$MF{key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$MF{Main-Class}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.IfVar}</td>
			<td class='code'>$IF{arg,then[,else]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$IF{$S{my.boolean.property},foo,bar}</td>
		</tr>
		<tr class='dark dd'>
			<td>{@link org.apache.juneau.svl.vars.SwitchVar}</td>
			<td class='code'>$SW{arg,p1:then1[,p2:then2...]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$SW{$S{os.name},*win*:Windows,*:Something else}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.CoalesceVar}</td>
			<td class='code'>$CO{arg1[,arg2...]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$CO{$S{my.property},$E{my.property},n/a}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.PatternMatchVar}</td>
			<td class='code'>$PM{arg,pattern}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$PM{$S{os.name},*win*}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.NotEmptyVar}</td>
			<td class='code'>$NE{arg}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$NE{$S{foo}}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.UpperCaseVar}</td>
			<td class='code'>$UC{arg}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$UC{$S{foo}}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.svl.vars.LowerCaseVar}</td>
			<td class='code'>$LC{arg}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$LC{$S{foo}}</td>
		</tr>
		<tr class='light dd'>
			<td rowspan='1' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-config</td>
			<td>{@link org.apache.juneau.config.vars.ConfigVar}</td>
			<td class='code'>$C{key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$C{REST/staticFiles}</td>
		</tr>
		<tr class='dark'>
			<td rowspan='14' style='text-align:center;font-weight:bold;padding:20px;' class='code'>juneau-rest-server</td>
			<td>{@link org.apache.juneau.rest.vars.FileVar}</td>
			<td class='code'>$F{path[,default]}}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$F{resources/MyAsideMessage.html, Oops not found!}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.ServletInitParamVar}</td>
			<td class='code'>$I{name[,default]}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$I{my.param}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.LocalizationVar}</td>
			<td class='code'>$L{key[,args...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$L{MyMessage,foo,bar}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestAttributeVar}</td>
			<td class='code'>$RA{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RA{attrName}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestFormDataVar}</td>
			<td class='code'>$RF{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RF{paramName}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestHeaderVar}</td>
			<td class='code'>$RH{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RH{Header-Name}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestPathVar}</td>
			<td class='code'>$RP{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RP{pathVAr}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestQueryVar}</td>
			<td class='code'>$RQ{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RQ{paramName}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestSwaggerVar}</td>
			<td class='code'>$RS{key}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$RS{title}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.RequestVar}</td>
			<td class='code'>$R{key1[,key2...]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$R{contextPath}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.SerializedRequestAttrVar}</td>
			<td class='code'>$SA{contentType,key[,default]}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$SA{application/json,$RA{foo}}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.UrlVar}</td>
			<td class='code'>$U{uri}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$U{servlet:/foo}</td>
		</tr>
		<tr class='dark'>
			<td>{@link org.apache.juneau.rest.vars.UrlEncodeVar}</td>
			<td class='code'>$UE{uriPart}</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$U{servlet:/foo?bar=$UE{$RA{bar}}</td>
		</tr>
		<tr class='dark dd'>
			<td>{@link org.apache.juneau.rest.widget.Widget}</td>
			<td class='code'>$W{name}</td>
			<td style='text-align:center;font-weight:bold'>no</td>
			<td style='text-align:center;font-weight:bold'>yes</td>
			<td class='code'>$W{MenuItemWidget}</td>
		</tr>
	</table>
	<p>
		Custom variables can be defined on resources via the following API:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#varResolver() varResolver()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#vars(Class...) vars(Class...)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#vars(Var...) vars(Var...)}
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Defined a variable that simply wrapps all strings inside [] brackets.</jc>
	<jc>// e.g. "$BRACKET{foobar}" -&gt; "[foobar]"</jc>
	<jk>public class</jk> BracketVar <jk>extends</jk> SimpleVar {
		
		<jk>public</jk> BracketVar() {
			<jk>super</jk>(<js>"BRACKET"</js>);
		}
			
		<ja>@Override</ja> <jc>/* Var */</jc>
		<jk>public</jk> String resolve(VarResolverSession <jv>session</jv>, String <jv>arg</jv>) {
			<jk>return</jk> <js>'['</js> + <jv>arg</jv> + <js>']'</js>;
		}
	}

	<jc>// Register it with our resource.</jc>
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyResource <jk>extends</jk> BasicRestObject {
	
		<ja>@RestInit</ja>
		<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) {
			<jv>builder</jv>.vars(BracketVar.<jk>class</jk>);
		}
	}
	</p>
	<p>
		The methods involved with variables are:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext#getVarResolver() getVarResolver()}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getVarResolverSession() getVarResolverSession()}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.12 - jrs.SvlVariables -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.StaticFiles' id='jrs.StaticFiles'>8.13 - Static files</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.13 - jrs.StaticFiles -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestObject} classes come with built-in support
		for serving up static files through the following REST operation:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(path=<js>"/htdocs/*"</js>)
	<jk>public</jk> HttpResource getHtdoc(<ja>@Path</ja>("/*") String <jv>path</jv>, Locale <jv>locale</jv>) <jk>throws</jk> NotFound {
		<jk>return</jk> getContext().getStaticFiles().resolve(<jv>path</jv>, <jv>locale</jv>).orElseThrow(NotFound::<jk>new</jk>);
	}
	</p>
	<p>
		The static file finder can be accessed through the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext#getStaticFiles() getStaticFiles()}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getStaticFiles() getStaticFiles()}
			</ul>
		</li>
	</ul>
	<p>
		By default, the {@link org.apache.juneau.rest.staticfile.StaticFiles} bean is configured as follows:
	</p>
	<p class='bjava'>
	StaticFiles
		.<jsm>create</jsm>()
		.beanStore(<jv>beanStore</jv>)  <jc>// Allow injected beans in constructor.</jc>
		.type(BasicStaticFiles.<jk>class</jk>)  <jc>// Default implementation class.</jc>
		.dir(<js>"static"</js>)  <jc>// Look in working /static directory.</jc>
		.dir(<js>"htdocs"</js>)  <jc>// Look in working /htdocs directory.</jc>
		.cp(<jv>resourceClass</jv>, <js>"htdocs"</js>, <jk>true</jk>)  <jc>// Look in htdocs subpackage.</jc>
		.cp(<jv>resourceClass</jv>, <js>"/htdocs"</js>, <jk>true</jk>)  <jc>// Look in htdocs package.</jc>
		.caching(1_000_000)  <jc>// Cache files in memory up to 1MB.</jc>
		.exclude(<js>"(?i).*\\.(class|properties)"</js>)  <jc>// Ignore class/properties files.</jc>
		.headers(<jsm>cacheControl</jsm>(<js>"max-age=86400, public"</js>));  <jc>// Add cache control.</jc>
	</p>
	<p>
		Static files can be configured programmatically through the following APIs:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jmp'>{@link org.apache.juneau.rest.RestContext.Builder#staticFiles(StaticFiles) staticFiles(StaticFiles)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#staticFiles() staticFiles()}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.13 - jrs.StaticFiles -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.ClientVersioning' id='jrs.ClientVersioning'>8.14 - Client Versioning</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.14 - jrs.ClientVersioning -->
<div class='topic'>
	<p>
		Client version headers are used to support backwards compatibility for breaking REST interface changes.
		Using them, you're able to return different responses based on which client is making a request.
	</p>
	<p>
		The APIs involved with defining client version headers are:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#clientVersionHeader() clientVersionHeader}
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#clientVersion() clientVersion}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#clientVersionHeader(String) clientVersionHeader(String)}
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Option #1 - Defined via annotation resolving to a config file setting with default value.</jc>
	<ja>@Rest</ja>(clientVersionHeader=<js>"Client-Version"</js>)
	<jk>public class</jk> MyResource {

		<jc>// Call this method if Client-Version is at least 2.0.
		// Note that this also matches 2.0.1.</jc>
		<ja>@RestGet</ja>(path=<js>"/foobar"</js>, clientVersion=<js>"2.0"</js>)
		<jk>public</jk> Object method1() {
			...
		}
	
		<jc>// Call this method if Client-Version is at least 1.1 but less than 2.0.</jc>
		<ja>@RestGet</ja>(path=<js>"/foobar"</js>, clientVersion=<js>"[1.1,2.0)"</js>)
		<jk>public</jk> Object method2() {
			...
		}
	
		<jc>// Call this method if Client-Version is less than 1.1.</jc>
		<ja>@RestGet</ja>(path=<js>"/foobar"</js>, clientVersion=<js>"[0,1.1)"</js>)
		<jk>public</jk> Object method3() {
			...
		}
	</p>
</div>
</div><!-- END: 8.14 - jrs.ClientVersioning -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.Swagger' id='jrs.Swagger'>8.15 - Swagger</a></h3>
<div class='topic'><!-- START: 8.15 - jrs.Swagger -->
<div class='topic'>
	<p>
		One of the most useful features of Juneau is the ability to generate Swagger-based OPTIONS pages for self-documenting designs 
		(i.e. REST interfaces that document themselves).
	</p>
	<p>
		As described previously, the <c>PetStore</c> example provides an example of auto-generated Swagger JSON:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.1.png'>
	<p>
		Using {@link org.apache.juneau.dto.swagger.ui.SwaggerUI}, we're able to render that JSON as a Swagger user interface:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.2.png'>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.BasicRestServletSwagger' id='jrs.BasicRestServletSwagger'>8.15.1 - BasicRestServlet/BasicRestObject</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.15.1 - jrs.BasicRestServletSwagger -->
<div class='topic'>
	<p>
		Any subclass of {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestObject} gets an auto-generated Swagger UI when performing an <c>OPTIONS</c>
		request with <c>Accept:text/html</c> due to the following method:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/api/*"</js>,
		summary=<js>"Swagger documentation"</js>,
		description=<js>"Swagger documentation for this resource."</js>
	)
	<ja>@HtmlDocConfig</ja>(
		<jc>// Should override config annotations defined on class.</jc>
		rank=10,
		<jc>// Override the nav links for the swagger page.</jc>
		navlinks={
			<js>"back: servlet:/"</js>,
			<js>"json: servlet:/?Accept=text/json&amp;plainText=true"</js>
		},
		<jc>// Never show aside contents of page inherited from class.</jc>
		aside=<js>"NONE"</js>
	)
	<ja>@BeanConfig</ja>(
		<jc>// POJO swaps to apply to all serializers/parsers on this method.</jc>
		swaps={
			<jc>// Use the SwaggerUI swap when rendering Swagger beans.
			// This is a per-media-type swap that only applies to text/html requests.</jc>
			SwaggerUI.class
		}
	)
	<ja>@Override</ja> <jc>/* BasicRestOperations */</jc>
	<jk>public</jk> Swagger getSwagger(RestRequest <jv>req</jv>) {
		<jk>return</jk> <jv>req</jv>.getSwagger().orElseThrow(NotFound::<jk>new</jk>);
	}
	</p>
	<p>
		The underlying mechanics are simple.  
		The {@link org.apache.juneau.rest.servlet.BasicRestServlet#getSwagger(RestRequest)} method returns a {@link org.apache.juneau.dto.swagger.Swagger} bean
		consisting of information gathered from annotations and other sources.
		Then that bean is swapped for a {@link org.apache.juneau.dto.swagger.ui.SwaggerUI} bean when rendered as HTML.
	</p>
	<p>
		Note that to have your resource create Swagger UI, you must either extend from one of the basic resource classes or provide
		your own <ja>@RestOp</ja>-annotated method that returns a {@link org.apache.juneau.dto.swagger.Swagger} object and a {@link org.apache.juneau.dto.swagger.ui.SwaggerUI} swap.
	</p>
</div>
</div><!-- END: 8.15.1 - jrs.BasicRestServletSwagger -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.BasicSwaggerInfo' id='jrs.BasicSwaggerInfo'>8.15.2 - Basic Swagger Info</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.15.2 - jrs.BasicSwaggerInfo -->
<div class='topic'>
	<p>
		Let's look at the various parts of the <c>Petstore</c> application Swagger UI to see how they are defined.
	</p>
	<p>
		The top part of the page shows general information about the REST interface:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.3.png'>
	<p>
		The information is pulled from the {@link org.apache.juneau.rest.annotation.Rest#swagger() @Rest(swagger)} annotation.
	</p>
	<h5 class='figure'>org.apache.juneau.examples.rest.petstore.PetStoreResource</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		...
		swagger=<ja>@Swagger</ja>(<js>"$F{PetStoreResource.json}"</js>),
		...
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		In this particular case, the Swagger is pulled in from a localized Swagger JSON file located in the 
		<c>org.apache.juneau.examples.rest.petstore</c> package using the {@link org.apache.juneau.rest.vars.FileVar $F} variable.
	</p>
	<h5 class='figure'>PetStoreResource.json</h5>
	<p class='bjson'>
	{
		<jok>"swagger"</jok>: <jov>"2.0"</jov>,
		<jok>"info"</jok>: {
			<jok>"version"</jok>: <jov>"1.0.0"</jov>,
			<jok>"title"</jok>: <jov>"Swagger Petstore"</jov>,
			<jok>"termsOfService"</jok>: <jov>"You are on your own."</jov>,
			<jok>"contact"</jok>: {
				<jok>"name"</jok>: <jov>"Juneau Development Team"</jov>,
				<jok>"email"</jok>: <jov>"dev@juneau.apache.org"</jov>,
				<jok>"url"</jok>: <jov>"http://juneau.apache.org"</jov>
			},
			<jok>"license"</jok>: {
				<jok>"name"</jok>: <jov>"Apache 2.0"</jov>,
				<jok>"url"</jok>: <jov>"http://www.apache.org/licenses/LICENSE-2.0.html"</jov>
			}
		},
		<jok>"externalDocs"</jok>: {
			<jok>"description"</jok>: <jov>"Find out more about Juneau"</jov>,
			<jok>"url"</jok>: <jov>"http://juneau.apache.org"</jov>
		},
		...
	}
	</p>
	<p>
		Note that the {@link org.apache.juneau.rest.vars.FileVar $F} variable allows for request-locale-sensitive name matching so that you can provide
		localized Swagger information.
	</p>
	<p>
		The {@link org.apache.juneau.rest.vars.FileVar $F} variable simply expands to a string to fill the {@link org.apache.juneau.rest.annotation.Swagger#value() @Swagger(value)}
		annotation.  
		You could equivalently embed JSON directly into your annotation like so:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		...
		swagger=<ja>@Swagger</ja>(
			<jc>// Raw Simplified JSON.</jc>
			<jc>// Values are concatenated.</jc>
			<js>"{"</js>,
				<js>"swagger: '2.0',"</js>,
				<js>"version: '1.0.0',"</js>,
				...
			<js>"}"</js>
		),
		...
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		However, a more typical (and less error-prone) scenario is to define all of your Swagger as annotations:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		...
		swagger=<ja>@Swagger</ja>(
			version=<js>"1.0.0"</js>,
			title=<js>"Swagger Petstore"</js>,
			termsOfService=<js>"You are on your own."</js>,
			contact=<ja>@Contact</ja>(
				name=<js>"Juneau Development Team"</js>,
				email=<js>"dev@juneau.apache.org"</js>,
				url=<js>"http://juneau.apache.org"</js>
			),
			license=<ja>@License</ja>(
				name=<js>"Apache 2.0"</js>,
				url=<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			),
			externalDocs=<ja>@ExternalDocs</ja>(
				description=<js>"Find out more about Juneau"</js>,
				url=<js>"http://juneau.apache.org"</js>
			)
		),
		...
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		All annotations support <a class="doclink" href="#jrs.SvlVariables">SVL Variables</a>, so you could for example
		pull localized strings from resource bundles using {@link org.apache.juneau.rest.vars.LocalizationVar $L} variables.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		messages=<js>"nls/MyMessages"</js>,
		...
		swagger=<ja>@Swagger</ja>(
			version=<js>"1.0.0"</js>,
			title=<js>"$L{myTitle}"</js>,
			termsOfService=<js>"$L{myTermsOfService}"</js>,
			contact=<ja>@Contact</ja>(
				name=<js>"$L{myTeam}"</js>,
				email=<js>"dev@juneau.apache.org"</js>,
				url=<js>"http://juneau.apache.org"</js>
			),
			license=<ja>@License</ja>(
				name=<js>"Apache 2.0"</js>,
				url=<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			),
			externalDocs=<ja>@ExternalDocs</ja>(
				description=<js>"$L{myExternalDocsDescription}"</js>,
				url=<js>"http://juneau.apache.org"</js>
			)
		),
		...
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		A third option is to define your Swagger information in your {@link org.apache.juneau.rest.annotation.Rest#messages @Rest(messages)} resource
		bundle using predefined Swagger keywords:
	</p>
	<p class='bini'>
	<mk>PetStoreResource.version</mk> = <mv>1.0.0</mv>
	<mk>PetStoreResource.title</mk> = <mv>Swagger Petstore</mv>
	<mk>PetStoreResource.termsOfService</mk> = <mv>You are on your own.</mv>
	<mk>PetStoreResource.contact</mk> = <mv>{name:'Juneau Development Team', email:'dev@juneau.apache.org',...}</mv>
	<mk>PetStoreResource.license</mk> = <mv>{name:'Apache 2.0',...}</mv>
	<mk>PetStoreResource.externalDocs</mk> = <mv>{description:'Find out more about Juneau',...}</mv>
	</p>
	<p>
		Information defined in multiple locations are merged into a single set of data.  
		When the same information is provided in multiple locations, the following order-of-precedence is used:
	</p>
	<ol>
		<li>Java annotations
		<li>Resource bundle
		<li>Swagger JSON file
	</ol>
</div>
</div><!-- END: 8.15.2 - jrs.BasicSwaggerInfo -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerTags' id='jrs.SwaggerTags'>8.15.3 - Tags</a></h4>
<div class='topic'><!-- START: 8.15.3 - jrs.SwaggerTags -->
<div class='topic'>
	<p>
		Tags allow you to group operations into general categories.
		In the user interface, these can be expanded/collapsed by clicking on the tag sections.
		In the example below, the <c>pet</c> and <c>store</c> tag sections are collapsed
		and the <c>user</c> section is not:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.4.png'>
	<p>
		Tags are also defined in the <ja>@Swagger</ja> annotation
	</p>
	<h5 class='figure'>PetStoreResource.json</h5>
	<p class='bjson'>
	<jok>"tags"</jok>: [
		{
			<jok>"name"</jok>: <jov>"pet"</jov>,
			<jok>"description"</jok>: <jov>"Everything about your Pets"</jov>,
			<jok>"externalDocs"</jok>: {
				<jok>"description"</jok>: <jov>"Find out more"</jov>,
				<jok>"url"</jok>: <jov>"http://juneau.apache.org"</jov>
			}
		},
		{
			<jok>"name"</jok>: <jov>"store"</jov>,
			<jok>"description"</jok>: <jov>"Access to Petstore orders"</jov>
		},
		{
			<jok>"name"</jok>: <jov>"user",
			<jok>"description"</jok>: <jov>"Operations about user"</jov>,
			<jok>"externalDocs"</jok>: {
				<jok>"description"</jok>: <jov>"Find out more about our store"</jov>,
				<jok>"url"</jok>: <jov>"http://juneau.apache.org"</jov>
			}
		}
	],
	</p>
	<p>
		The annotation-only approach is shown here:
	</p>
	<h5 class='figure'>org.apache.juneau.examples.rest.petstore.PetStoreResource</h5>
	<p class='bjava'>
	swagger=<ja>@Swagger</ja>(
		...
		tags={
			<ja>@Tag</ja>(
				name=<js>"pet"</js>,
				description=<js>"Everything about your Pets"</js>,
				externalDocs=<ja>@ExternalDocs</ja>(
					description=<js>"Find out more"</js>,
					url=<js>"http://juneau.apache.org"</js>
				)
			),
			<ja>@Tag</ja>(
				name=<js>"store"</js>,
				description=<js>"Access to Petstore orders"</js>
			),
			<ja>@Tag</ja>(
				name=<js>"user"</js>,
				description=<js>"Operations about user"</js>,
				externalDocs=<ja>@ExternalDocs</ja>(
					description=<js>"Find out more about our store"</js>,
					url=<js>"http://juneau.apache.org"</js>
				)
			)
		}
	),
	</p>
	<p>
		Tags are associated with operations using the {@link org.apache.juneau.rest.annotation.OpSwagger#tags() @OpSwagger(tags)} annotation:
	</p>
	
	<h5 class='figure'>GET /user operation</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/user"</js>,
		summary=<js>"Petstore users"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"user"</js>
		)
	)
	<jk>public</jk> Collection&lt;User&gt; getUsers() <jk>throws</jk> NotAcceptable {...}
	</p>
	<p>
		Operations can be mapped to multiple tags.
	</p>
	<p>
		Tags are optional.
		Operations not mapped to tags are listed in the UI before tagged operations.
	</p>
	<p>
		For example, the <c>getTopPage()</c> method in <c>PetStoreResource</c> is not tagged, 
		as well as the <c>getOptions()</c> method inherited from <c>BaseRestServlet</c>, so these
		show up at the top of the page:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.5.png'>
</div>
</div><!-- END: 8.15.3 - jrs.SwaggerTags -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerOperations' id='jrs.SwaggerOperations'>8.15.4 - Operations</a></h4>
<div class='topic'><!-- START: 8.15.4 - jrs.SwaggerOperations -->
<div class='topic'>
	<p>
		<ja>@RestOp</ja>-annotated methods automatically get rendered as Swagger operations:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Operations.1.png'>
	<p>
		The following shows the annotations defined on the <c>GET /pet</c> operation:
	</p>
	<h5 class='figure'>PetStoreResource.getPets()</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/pet"</js>,
		summary=<js>"All pets in the store"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>,
			...
		),
		...
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable {
		<jk>return</jk> <jsf>store</jsf>.getPets();
	}
	</p> 
	<p>
		Methods marked as deprecated will show up as deprecated in the Swagger UI:	
	</p>
	<h5 class='figure'>PetStoreResource.findPetsByTag()</h5>
	<p class='bjava'>	
	<ja>@RestGet</ja>(
		path=<js>"/pet/findByTags"</js>,
		summary=<js>"Finds Pets by tags"</js>,
		...
	)
	<ja>@Deprecated</ja>
	<jk>public</jk> Collection&lt;Pet&gt; findPetsByTags(...) {
		...
	}
	</p>
</div>
</div><!-- END: 8.15.4 - jrs.SwaggerOperations -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerParameters' id='jrs.SwaggerParameters'>8.15.5 - Parameters</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.15.5 - jrs.SwaggerParameters -->
<div class='topic'>
	<p>
		Expanding operations shows you a list of parameters:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Operations.2.png'> 
	<p>
		Parameter information can be defined in a couple of ways.  The typical way is through annotations on parameters
		being passed to your <ja>@RestOp</ja>-annotated method, like so:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>
	<jk>public</jk> Collection&lt;Pet&gt; getPets(
			<ja>@Query</ja>(
				name=<js>"s"</js>,
				schema=<ja>@Schema</ja>(	
					description={
						<js>"Search."</js>,
						<js>"Key/value pairs representing column names and search tokens."</js>,
						<js>"'*' and '?' can be used as meta-characters in string fields."</js>,
						<js>"'&gt;', '&gt;=', '&lt;', and '&lt;=' can be used as limits on numeric and date fields."</js>,
						<js>"Date fields can be matched with partial dates (e.g. '2018' to match any date in the year 2018)."</js>
					},
					type=<js>"array"</js>,
					collectionFormat=<js>"csv"</js>
				)	
			) 
			String[] <jv>s</jv>,
			<ja>@Query</ja>(
				name=<js>"v"</js>,
				schema=<ja>@Schema</ja>(
					description={
						<js>"View."</js>,
						<js>"Column names to display."</js>
					},
					type=<js>"array"</js>,
					collectionFormat=<js>"csv"</js>
				)
			) 
			String[] <jv>v</jv>,
			...
		) <jk>throws</jk> NotAcceptable {
		...
	}
	</p>
	<ul class='notes'>
		<li class='note'>The {@link org.apache.juneau.annotation.Schema @Schema} annotation can also be attached
			directly to the parameter or parameter type as well.
		<li class='note'>The {@link org.apache.juneau.annotation.Schema#type() type} and {@link org.apache.juneau.annotation.Schema#collectionFormat() collectionFormat} values above are optional and auto-detected based on the
			parameter class type if omitted.  They're included here for clarity.
			The examples will be explained in the next section.
	</ul>
	<p>
		Another option is to specify your parameter information in the <c>parameters</c> annotation as free-form JSON 5.
		In the case of the <c>PetStoreResource.getPets()</c> method, we pull this information from a static field
		defined in the {@link org.apache.juneau.rest.converter.Queryable} class:
	</p>
	<h5 class='figure'>PetStoreResource.getPets()</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/pet"</js>,
		summary=<js>"All pets in the store"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>,
			parameters={
				Queryable.<jsf>SWAGGER_PARAMS</jsf>
			}
		),
		...
		converters={Queryable.<jk>class</jk>}
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable {
		<jk>return</jk> <jf>store</jf>.getPets();
	}
	</p>
	<h5 class='figure'>Queryable</h5>
	<p class='bjava'>
	<jk>public class</jk> Queryable <jk>implements</jk> RestConverter {
	
		<jk>public static final</jk> String <jsf>SWAGGER_PARAMS</jsf>=<js>""</js>
			+ <js>"{"</js>
				+ <js>"in:'query',"</js>
				+ <js>"name:'s',"</js>
				+ <js>"description:'"</js>
					+ <js>"Search.\n"</js>
					+ <js>"Key/value pairs representing column names and search tokens.\n"</js>
					+ <js>"\\'*\\' and \\'?\\' can be used as meta-characters in string fields.\n"</js>
					+ <js>"\\'&gt;\\', \\'&gt;=\\', \\'&lt;\\', and \\'&lt;=\\' can be used as limits on numeric and date fields.\n"</js>
					+ <js>"Date fields can be matched with partial dates (e.g. \\'2018\\' to match any date in the year 2018)."</js>
				+ <js>"',"</js>
				+ <js>"type:'array',"</js>
				+ <js>"collectionFormat:'csv',"</js>
				+ <js>"x-examples:{example:'?s=Bill*,birthDate&gt;2000'}"</js>
			+ <js>"},"</js>
			+ <js>"{"</js>
				+ <js>"in:'query',"</js>
				+ <js>"name:'v',"</js>
				+ <js>"description:'"</js>
					+ <js>"View.\n"</js>
					+ <js>"Column names to display."</js>
				+ <js>"',"</js>
				+ <js>"type:'array',"</js>
				+ <js>"collectionFormat:'csv',"</js>
				+ <js>"x-examples:{example:'?v=name,birthDate'}"</js>
			+ <js>"},"</js>
			...
		;
	}
	</p>
	<p>
		This information could have also been defined in the Swagger JSON for the resource as well.
	</p>
	<p>
		The parameter section contains information about the request body as well for PUT and POST methods, as shown here:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Parameters.2.png'> 
	<p>
		The definition of this method is shown here:
	</p>
	<p class='bjava'>
	<ja>@RestPost</ja>(
		summary=<js>"Add a new pet to the store"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>
		)
	)
	<jk>public</jk> Ok postPet(
			<ja>@Content</ja> 
			<ja>@Schema</ja>(description=<js>"Pet object to add to the store"</js>) 
			PetCreate <jv>pet</jv>
		) <jk>throws</jk> IdConflict, NotAcceptable, UnsupportedMediaType {

		<jf>store</jf>.create(<jv>pet</jv>);
		<jk>return</jk> <jsf>OK</jsf>;
	}
	</p>
	<p>
		Note that the schema information on the body parameter is automatically detected if not provided.
	</p>
</div>
</div><!-- END: 8.15.5 - jrs.SwaggerParameters -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerResponses' id='jrs.SwaggerResponses'>8.15.6 - Responses</a></h4>
<div class='topic'><!-- START: 8.15.6 - jrs.SwaggerResponses -->
<div class='topic'>
	<p>
		Under the input parameters are listed the possible responses for the resource:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Operations.3.png'> 
	<p>
		The <c>200</c> response is determined by the return type on the method, in this case a collection of <c>Pet</c> objects:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/pet"</js>,
		summary=<js>"All pets in the store"</js>,
		...
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable {
		<jk>return</jk> <jf>store</jf>.getPets();
	}
	</p>
	<p>
		Note that additional responses can be specified by throwing exceptions annotated with the {@link org.apache.juneau.http.annotation.Response @Response} annotation such
		as this one:
	</p>
	<p class='bjava'>
	<ja>@Response</ja>
	<ja>@StatusCode</ja>(406)
	<ja>@Schema</ja>(description=<js>"Not Acceptable"</js>)
	<jk>public class</jk> NotAcceptable <jk>extends</jk> BasicHttpException {...}
	</p>
	<p>
		Like input parameters, the Swagger for responses can be define in multiple locations such as:
	</p>
	<ul>
		<li>{@link org.apache.juneau.http.annotation.Response @Response} annotated classes, methods, and parameters.
		<li>{@link org.apache.juneau.rest.annotation.Rest#swagger() @Rest(swagger)} / {@link org.apache.juneau.rest.annotation.RestOp#swagger() @RestOp(swagger)} annotations.
	</ul>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jrs.ResponseBeans">Response Beans</a>
	</ul>
</div>
</div><!-- END: 8.15.6 - jrs.SwaggerResponses -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerModels' id='jrs.SwaggerModels'>8.15.7 - Models</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.15.7 - jrs.SwaggerModels -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.jsonschema.JsonSchemaGenerator.Builder#useBeanDefs()} setting can be used to reduce the size of your
		generated Swagger JSON files by creating model definitions for beans and referencing those definitions through <c>$ref</c> attributes.
	</p>
	<p>
		This setting is disabled by default but can be set on the {@link org.apache.juneau.rest.RestContext.Builder} object:
	</p>
	<p class='bjava'>
	<ja>@HookEvent</ja>(<jsf>INIT</jsf>)
	<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) {
		<jv>builder</jv>.jsonSchemaGenerator().useBeanDefs();
	}
	</p>
	<p>
		In the Swagger UI, this causes bean definitions to show up in the Models section at the bottom of the page:
	</p>
	<h5 class='figure'>Models section</h5>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Models.1.png'> 
	<h5 class='figure'>Models section with Order bean expanded</h5>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Models.2.png'> 
	<p>
		In the generated Swagger JSON, embedded schema information for beans will be replaced with references such as the one shown below for the <c>Order</c> bean:
	</p>
	<p class='bjson'>
	{
		<jok>"swagger"</jok>: <jov>"2.0"</jov>,
		<jok>"paths"</jok>: {
			<jok>"/store/order"</jok>: {
				<jok>"get"</jok>: {
					<jok>"operationId"</jok>: <jov>"getOrders"</jov>,
					<jok>"summary"</jok>: <jov>"Petstore orders"</jov>,
					<jok>"responses"</jok>: {
						<jok>"200"</jok>: {
							<jok>"description"</jok>: <jov>"OK"</jov>,
							<jok>"schema"</jok>: {
								<jok>"description"</jok>: <jov>"java.util.Collection&lt;org.apache.juneau.examples.rest.petstore.Order&gt;"</jov>,
								<jok>"type"</jok>: <jov>"array"</jov>,
								<jok>"items"</jok>: {
									<jok>"$ref"</jok>: <jov>"#/definitions/Order"</jov>
								}
							},
							...
						...
					...
				...
			...
		},
		<jok>"definitions"</jok>: {
			<jok>"Order"</jok>: {
				<jok>"type"</jok>: <jov>"object"</jov>,
				<jok>"properties"</jok>: {
					<jok>"id"</jok>: {
						<jok>"type"</jok>: <jov>"integer"</jov>,
						<jok>"format"</jok>: <jov>"int64"</jov>
					},
					<jok>"petId": {
						<jok>"type"</jok>: <jov>"integer"</jov>,
						<jok>"format"</jok>: <jov>"int64"</jov>
					},
					<jok>"shipDate"</jok>: {
						<jok>"type"</jok>: <jov>"string"</jov>
					},
					<jok>"status"</jok>: {
						<jok>"type"</jok>: <jov>"string"</jov>,
						<jok>"enum"</jok>: [
							<jov>"PLACED"</jov>,
							<jov>"APPROVED"</jov>,
							<jov>"DELIVERED"</jov>
						]
					}
				},
				<jok>"description"</jok>: <jov>"org.apache.juneau.examples.rest.petstore.Order"</jov>,
				<jok>"example"</jok>: {
					<jok>"id"</jok>: <jov>123</jov>,
					<jok>"petId"</jok>: <jov>456</jov>,
					<jok>"shipDate"</jok>: <jov>"2012-12-21"</jov>,
					<jok>"status"</jok>: <jov>"APPROVED"</jov>
				}
			},
		...
	}
	</p>
	<p>
		Note that this does not affect how the information is rendered for that bean in the Swagger UI:
	</p>
	<img class='bordered w900' src='doc-files/jrs.Swagger.Models.3.png'> 
</div>
</div><!-- END: 8.15.7 - jrs.SwaggerModels -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.SwaggerStylesheet' id='jrs.SwaggerStylesheet'>8.15.8 - SwaggerUI.css</a></h4>
<div class='topic'><!-- START: 8.15.8 - jrs.SwaggerStylesheet -->
<div class='topic'>
	<p>
		The look-and-feel of the Swagger UI is controlled via a single CSS file:  <c>SwaggerUI.css</c>.
	</p>
	<p>
		In the microservice template, this file is located in the <c>files/htdocs/styles</c> directory.
		It's a simple straightforward file consisting of less than 350 lines.
		This file can be modified to change the look-and-feel of your Swagger UI.
	</p>
</div>
</div><!-- END: 8.15.8 - jrs.SwaggerStylesheet -->
</div><!-- END: 8.15 - jrs.Swagger -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.ExecutionStatistics' id='jrs.ExecutionStatistics'>8.16 - REST method execution statistics</a><span class='update'>created: 8.1.3, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.16 - jrs.ExecutionStatistics -->
<div class='topic'>
	<p>
		{@link org.apache.juneau.rest.annotation.Rest}-annotated classes get automated timing and error statistic information for all <ja>@RestOp</ja>
		and lifecycle-event annotated methods on the class.
	</p>
	<p>
		If you extend from {@link org.apache.juneau.rest.servlet.BasicRestServlet} or {@link org.apache.juneau.rest.servlet.BasicRestObject}, then
		the statics are made available through the REST interface via the following method:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/stats"</js>,
		summary=<js>"Timing statistics"</js>,
		description=<js>"Timing statistics for method invocations on this resource."</js>
	)
	<ja>@Override</ja> <jc>/* BasicRestOperations */</jc>
	<jk>public</jk> RestContextStats getStats(RestRequest <jv>req</jv>) {
		<jk>return</jk> <jv>req</jv>.getContext().getStats();
	}
	</p>
	<p>
		Rendered in a browser, it looks like this:
	</p>
	<img class='bordered w900' src='doc-files/jrs.ExecutionStatistics.1.png'>
	<p>
		The default REST configuration provides a link to the stats in the navlinks section of the page:
	</p>
	<img class='bordered w900' src='doc-files/jrs.ExecutionStatistics.2.png'>
	<p>
		The exception hash shown is the same hash that is shown in the log file and provides a quick way of locating
		the exception in the logs.
	</p>
	<p>
		Programmatic access to the statistics are provided via the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext#getStats() getStats()}
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 8.16 - jrs.ExecutionStatistics -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlDocAnnotation' id='jrs.HtmlDocAnnotation'>8.17 - @HtmlDocConfig</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.17 - jrs.HtmlDocAnnotation -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.html.annotation.HtmlDocConfig @HtmlDocConfig} annotation is used to customize the HTML 
		view of POJOs serialized by {@link org.apache.juneau.html.HtmlDocSerializer}.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlDocConfig}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#aside() aside}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#asideFloat() asideFloat}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#footer() footer}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#head() head}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#header() header}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#nav() nav}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#navlinks() navlinks}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#noResultsMessage() noResultsMessage}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#nowrap() nowrap}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#rank() rank}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#script() script}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#style() style}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#stylesheet() stylesheet}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#template() template}
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#widgets() widgets}			
			</ul>
		</li>
	</ul>
	<p>
		It's used in the following locations:
	</p>
	<ul>
		<li>{@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated classes. 
		<li>{@link org.apache.juneau.rest.annotation.RestOp @RestOp}-annotated methods.
	</ul>
	<p>
		For example, the following shows setting the title on a page:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>
	<ja>@HtmlDocConfig</ja>(
		title=<js>"My Resource Page"</js>
	)
	</p>
	<p>
		The purpose of this annotation is to populate the HTML document view which by default consists of the following
		structure:
	</p>
	<p class='bxml'>
	<xt>&lt;html&gt;
		&lt;head&gt;
			&lt;style <xa>type</xa>=<xs>'text/css'</xs>&gt;
				<xv>CSS styles and links to stylesheets</xv>
			&lt;/style&gt;
		&lt;/head&gt;
		&lt;body&gt;
			&lt;header&gt;
				<xv>Page header</xv>
			&lt;/header&gt;
			&lt;nav&gt;
				<xv>Navigation links</xv>
			&lt;/nav&gt;
			&lt;aside&gt;
				<xv>Side-bar text</xv>
			&lt;/aside&gt;
			&lt;article&gt;
				<xv>Contents of serialized object</xv>
			&lt;/article&gt;
			&lt;footer&gt;
				<xv>Footer message</xv>
			&lt;/footer&gt;
		&lt;/body&gt;
	&lt;/html&gt;</xt>
	</p>
	<p>
		The outline above is controlled by the {@link org.apache.juneau.html.HtmlDocTemplate} interface
		which can be overridden via the {@link org.apache.juneau.html.annotation.HtmlDocConfig#template() @HtmlDocConfig(template)} annotation.
	</p>
	<p>
		The <c>HelloWorldResource</c> class was an example of the <c>@HtmlDocConfig</c> annotation in use:
	</p>
	<p class='bjava'>
	<jd>/** 
	 * Sample REST resource that prints out a simple "Hello world!" message.
	 */</jd>
	<ja>@Rest</ja>(
		path=<js>"/helloWorld"</js>
	)
	<ja>@HtmlDocConfig</ja>(
		navlinks={
			<js>"up: request:/.."</js>,
			<js>"options: servlet:/?method=OPTIONS"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a resource that simply response with a 'Hello world!' message&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;The POJO serialized is a simple String.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		SVL variables can be used in any of these annotations:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/helloWorld"</js>,
		<jc>// Register a config file.</jc>
		config=<js>"MyConfig.cfg"</js>
	)
	<ja>@HtmlDocConfig</ja>(
		navlinks={
			<js>"up: request:/.."</js>,
			<js>"options: servlet:/?method=OPTIONS"</js>,
			<jc>// Add a nav link to view the source code for this class.</jc>
			<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/$R{servletClassSimple}.java"</js>
		},
		aside={
			<jc>// Localize our messages.</jc>
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;$L{localizedMessage1}&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;$L{localizedMessage2}&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {...}
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlUIvsDI' id='jrs.HtmlUIvsDI'>8.17.1 - User Interfaces (UI) vs. Developer Interfaces (DI)</a></h4>
<div class='topic'><!-- START: 8.17.1 - jrs.HtmlUIvsDI -->
<div class='topic'>
	<p>
		An important distinction needs to be made about the HTML representations produced by the REST
		API.  These should not be considered User Interfaces but rather Developer Interfaces.
	</p>
	<p>
		UIs should hide the end-user from the underlying architecture.
		The audience generally consists of non-technical people not interested in how the UI works.  
	</p>
	<p>
		DIs, on the other hand, should NOT hide the end-user from the underlying architecture.  
		Instead, it's a thin veneer over the REST interface with the following goals:
	</p>
	<ul class='spaced-list'>
		<li>Make it easy for the developer to explore and understand the REST API.
		<li>Make it easy for the developer to debug the REST API using simple tools (hopefully just a browser).
	</ul>		
	<p>
		As a result, the following guidelines are recommended: 
	</p>		
	<ul class='spaced-list'>
		<li>
			Use titles/descriptions/asides to describe why the REST interface exists.
			A developer knowing little about it should be able to access it with a browser and quickly 
			understand what it is and how to use it.
		<li>
			Don't hide the raw data!  
			The HTML view should simply be considered an easier-to-read representation of the data normally 
			rendered in JSON or some other format.
		<li>
			Limit your use of Javascript!  
			You can use it sparingly if you want to implement something simple like a pull-down menu to 
			simplify some debug task but remember that your audience cares more about interacting with your 
			service programmatically using REST.  
			Remember that the HTML is just icing on the cake.
		<li>
			Don't use it to implement a Web 2.0 interface!  
			If you want a Web 2.0 UI, implement it separately ON TOP OF this REST interface.
			The architecture is flexible enough that you could in theory pull in and use jQuery, React, 
			Angular, or any number of sophisticated Javascript UI frameworks.  Resist the urge to do so.
	</ul>		
</div>
</div><!-- END: 8.17.1 - jrs.HtmlUIvsDI -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlWidgets' id='jrs.HtmlWidgets'>8.17.2 - Widgets</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.17.2 - jrs.HtmlWidgets -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.widget.Widget} class allows you to add arbitrary HTML, CSS, and Javascript
		to HTML pages.
		<br>They are registered in the following location:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlDocConfig}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.html.annotation.HtmlDocConfig#widgets() widgets}
			</ul>
		</li>
	</ul>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@RestGet</ja>(...)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			MyWidget.<jk>class</jk>
		},
		navlinks={
			<js>"$W{MyWidget}"</js>
		},
		aside={
			<js>"Check out this widget:  $W{MyWidget}"</js>
		}
	)
	</p>
	<p>
		The <l>Widget</l> class is composed of the following methods:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.rest.widget.Widget}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.widget.Widget#getHtml(RestRequest,RestResponse) getHtml(RestRequest,RestResponse)}
			<li class='jm'>{@link org.apache.juneau.rest.widget.Widget#getStyle(RestRequest,RestResponse) getStyle(RestRequest,RestResponse)}
			<li class='jm'>{@link org.apache.juneau.rest.widget.Widget#getScript(RestRequest,RestResponse) getScript(RestRequest,RestResponse)}
		</ul>
	</ul>
	<p>
		The HTML content returned by the {@link org.apache.juneau.rest.widget.Widget#getHtml(RestRequest,RestResponse) getHtml(RestRequest,RestResponse)}
		method is added wherever the <js>"$W{...}"</js> variable is used.
	</p>
	<p>
		The CSS returned by {@link org.apache.juneau.rest.widget.Widget#getScript(RestRequest,RestResponse) getScript(RestRequest,RestResponse)}
		is added to the style section in the page header.
	</p>
	<p>	
		The Javascript returned by {@link org.apache.juneau.rest.widget.Widget#getScript(RestRequest,RestResponse) getScript(RestRequest,RestResponse)}
		is added to the script section in the page header.
	</p>
	<p>
		The following examples shows how to associate a widget with a REST method and then have it rendered in the links
		and aside section of the page.
		It shows an example of a widget that renders an image located in the <c>htdocs</c> static files
		directory in your classpath (see {@link org.apache.juneau.rest.annotation.Rest#staticFiles() @Rest(staticFiles)}):
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyWidget <jk>extends</jk> Widget {

		<ja>@Override</ja> <jc>/* Widget */</jc>
		<jk>public</jk> String getHtml(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			UriResolver <jv>resolver</jv> = <jv>req</jv>.getUriResolver(); <jc>// API used for resolving URIs.</jc>
			<jk>return</jk> <js>"&lt;img class='myimage' onclick='myalert(this)' src='"</js>+<jv>resolver</jv>.resolve(<js>"servlet:/htdocs/myimage.png"</js>)+<js>"'&gt;"</js>;
		}

		<ja>@Override</ja> <jc>/* Widget */</jc>
		<jk>public</jk> String getScript(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			<jk>return</jk> <js>""</js>
				+ <js>"\n function myalert(imageElement) {"</js>
				+ <js>"\n 	alert('cool!');"</js>
				+ <js>"\n }"</js>;
		}

		<ja>@Override</ja> <jc>/* Widget */</jc>
		<jk>public</jk> String getStyle(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			<jk>return</jk> <js>""</js>
				+ <js>"\n .myimage {"</js>
				+ <js>"\n 	border: 10px solid red;"</js>
				+ <js>"\n }"</js>;
		}
	}
	</p>
</div>
</div><!-- END: 8.17.2 - jrs.HtmlWidgets -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlPredefinedWidgets' id='jrs.HtmlPredefinedWidgets'>8.17.3 - Predefined Widgets</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.17.3 - jrs.HtmlPredefinedWidgets -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.widget} package contains predefined reusable widgets.
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.rest.widget}
			<ul>
				<li class='jac'>{@link org.apache.juneau.rest.widget.Widget}
					<ul>
						<li class='jac'>{@link org.apache.juneau.rest.widget.MenuItemWidget}
							<ul>
								<li class='jc'>{@link org.apache.juneau.rest.widget.ContentTypeMenuItem}
								<li class='jc'>{@link org.apache.juneau.rest.widget.QueryMenuItem}
								<li class='jc'>{@link org.apache.juneau.rest.widget.ThemeMenuItem}
							</ul>
						</li>
						<li class='jc'>{@link org.apache.juneau.rest.widget.PoweredByJuneau}
					</ul>
				</li>
				<li class='jc'>{@link org.apache.juneau.rest.widget.Tooltip}
			</ul>
		</li>
	</ul>
	
	<h5 class='topic'>MenuItemWidget</h5>
	<p>
		{@link org.apache.juneau.rest.widget.MenuItemWidget} is an abstract class for rendering menu items with drop-downs.
		It defines some simple CSS and Javascript for enabling drop-down menus in the nav section of the page (although 
		nothing keeps you from using it in an arbitrary location in the page).
	</p>
	<p>
		The script specifies a <c>menuClick(element)</c> function that toggles the visibility of the next sibling of the element.
	</p>
	<p>
		Subclasses implement the following two methods:
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.rest.widget.MenuItemWidget}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.widget.MenuItemWidget#getLabel(RestRequest,RestResponse) getLabel(RestRequest,RestResponse)}
				<li class='jm'>{@link org.apache.juneau.rest.widget.MenuItemWidget#getContent(RestRequest,RestResponse) getContent(RestRequest,RestResponse)}
			</ul>
		</li>
	</ul>
	<p>
		For example, to render a link that brings up a simple dialog in a div tag:
	</p>
	<p class='bjava'>
	<ja>@Override</ja>
	<jk>public</jk> String getLabel() {
		<jk>return</jk> <js>"my-menu-item"</js>;
	};

	<ja>@Override</ja>
	<jk>public</jk> Div getContent() {
		<jk>return</jk> Html5Builder.<jsm>div</jsm>(<js>"Surprise!"</js>).style(<js>"color:red"</js>);
	};
	</p>
	<p>
		The HTML content returned by the {@link org.apache.juneau.rest.widget.MenuItemWidget#getHtml(RestRequest,RestResponse) getHtml(RestRequest,RestResponse)} method is added where the <js>"$W{...}"</js> is referenced in the page.
	</p>
	
	<h5 class='topic'>ContentTypeMenuItem</h5>
	<p>
		{@link org.apache.juneau.rest.widget.ContentTypeMenuItem} is a predefined Widget that returns back a list of hyperlinks for rendering the contents of a page in a variety of content types.
	</p>
	<p>
		The variable it resolves is <js>"$W{ContentTypeMenuItem}"</js>.
	</p>
	<p>
		An example of this widget can be found in the <c>PetStoreResource</c> in the examples that provides a drop-down menu item for rendering all other supported content types in plain text:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(path=<js>"/"</js>)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>,
		},
		navlinks={
			<js>"up: ..."</js>,
			<js>"options: ..."</js>,
			<js>"$W{QueryMenuItem}"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"$W{ThemeMenuItem}"</js>,
			<js>"source: ..."</js>
		}
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() {
	</p>
	<p>
		It renders the following popup-box:
	</p>
	<img class='bordered w800' src='doc-files/jrs.HtmlDocAnnotation.PredefinedWidgets.1.png'>
	
	<h5 class='topic'>QueryMenuItem</h5>
	<p>
		{@link org.apache.juneau.rest.widget.QueryMenuItem} is a predefined Widget that returns a menu-item drop-down form for entering search/view/sort arguments.
	</p>
	<p>
		The variable it resolves is <js>"$W{QueryMenuItem}"</js>.
	</p>
	<p>
		This widget is designed to be used in conjunction with the {@link org.apache.juneau.rest.converter.Queryable} converter, although implementations
		can process the query parameters themselves if they wish to do so by using the {@link org.apache.juneau.rest.httppart.RequestQueryParams#getSearchArgs()}
		method to retrieve the arguments and process the data themselves.
	</p>
	<p>
		An example of this widget can be found in the <c>PetStoreResource</c> in the examples that provides
		search/view/sort capabilities against the collection of POJOs:
	<p class='bjava'>
	<ja>@RestGet</ja>(
		path=<js>"/"</js>,
		converters=Queryable.<jk>class</jk>
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			QueryMenuItem.<jk>class</jk>,
		},
		navlinks={
			<js>"up: ..."</js>,
			<js>"options: ..."</js>,
			<js>"$W{QueryMenuItem}"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"$W{ThemeMenuItem}"</js>,
			<js>"source: ..."</js>
		}
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() {
	</p>
	<p>
		It renders the following popup-box:
	</p>
	<img class='bordered w800' src='doc-files/jrs.HtmlDocAnnotation.PredefinedWidgets.2.png'>
	<p>
		Tooltips are provided by hovering over the field names.
	</p>
	<img class='bordered w800' src='doc-files/jrs.HtmlDocAnnotation.PredefinedWidgets.3.png'>
	
	<p>
		When submitted, the form submits a GET request against the current URI with special GET search API query parameters.
		(e.g. <js>"?s=column1=Foo*&amp;v=column1,column2&amp;o=column1,column2-&amp;p=100&amp;l=100"</js>).
		The {@link org.apache.juneau.rest.converter.Queryable} class knows how to perform these filters against collections of POJOs.
	</p>
	
	<h5 class='topic'>ThemeMenuItem</h5>
	<p>
		{@link org.apache.juneau.rest.widget.ThemeMenuItem} is a predefined Widget that returns back a list of hyperlinks for rendering the contents of a page in the various default styles.
	</p>
	<p>
		The variable it resolves is <js>"$W{ThemeMenuItem}"</js>.
	</p>
	<p>
		An example of this widget can be found in the <c>PetStoreResource</c> in the examples that provides
		a drop-down menu item for rendering all other supported content types in plain text:
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(path=<js>"/"</js>)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ThemeMenuItem.<jk>class</jk>,
		},
		navlinks={
			<js>"up: ..."</js>,
			<js>"options: ..."</js>,
			<js>"$W{QueryMenuItem}"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"$W{ThemeMenuItem}"</js>,
			<js>"source: ..."</js>
		}
	)
	<jk>public</jk> Collection&lt;Pet&gt; getPets() {
	</p>
	
	<h5 class='topic'>PoweredByJuneau</h5>
	<p>
		{@link org.apache.juneau.rest.widget.PoweredByJuneau} is a predefined Widget that places a powered-by-Juneau message on a page.
	</p>
	<p>
		The variable it resolves is <js>"$W{PoweredByJuneau}"</js>.
	</p>
	<p>
		It produces a simple Apache Juneau icon floating on the right.
		Typically it's used in the footer of the page, as shown below in the <c>AddressBookResource</c> from the examples:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(path=<js>"/addressBook"</js>)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			PoweredByJuneau.<jk>class</jk>
		},
		footer=<js>"$W{PoweredByJuneau}"</js>
	)
	</p>
	<p>
		It renders the following image:
	</p>
	<img class='bordered' src='doc-files/jrs.HtmlDocAnnotation.PredefinedWidgets.4.png'>
	 
	<h5 class='topic'>Tooltip</h5>
	<p>
		{@link org.apache.juneau.rest.widget.Tooltip} is a predefined template for adding tooltips to HTML5 bean constructs, typically in menu item widgets.
	</p>
	<p>
		The following examples shows how tooltips can be added to a menu item widget.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyFormMenuItem <jk>extends</jk> MenuItemWidget {
	
		<ja>@Override</ja>
		<jk>public</jk> String getLabel(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			<jk>return</jk> <js>"myform"</js>;
		}
	
		<ja>@Override</ja>
		<jk>public</jk> Object getContent(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			<jk>return</jk> div(
				<jsm>form</jsm>().id(<js>"form"</js>).action(<js>"servlet:/form"</js>).method(<jsf>POST</jsf>).children(
					<jsm>table</jsm>(
						<jsm>tr</jsm>(
							<jsm>th</jsm>(<js>"Field 1:"</js>),
							<jsm>td</jsm>(<jsm>input</jsm>().name(<js>"field1"</js>).type(<js>"text"</js>)),
							<jsm>td</jsm>(<jk>new</jk> Tooltip(<js>"(?)"</js>, <js>"This is field #1!"</js>, br(), <js>"(e.g. '"</js>, code(<js>"Foo"</js>), <js>"')"</js>))
						),
						<jsm>tr</jsm>(
							<jsm>th</jsm>(<js>"Field 2:"</js>),
							<jsm>td</jsm>(<jsm>input</jsm>().name(<js>"field2"</js>).type(<js>"text"</js>)),
							<jsm>td</jsm>(<jk>new</jk> Tooltip(<js>"(?)"</js>, <js>"This is field #2!"</js>, br(), <js>"(e.g. '"</js>, code(<js>"Bar"</js>), <js>"')"</js>))
						)
					)
				)
			);
		}
	}
	</p>
</div>
</div><!-- END: 8.17.3 - jrs.HtmlPredefinedWidgets -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlUiCustomization' id='jrs.HtmlUiCustomization'>8.17.4 - UI Customization</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.17.4 - jrs.HtmlUiCustomization -->
<div class='topic'>
	<p>
		The HTML views of POJOs can somewhat be considered a rudimentary User Interface.
		In reality, a better term for them would be a Developer Interface as they're meant to be used 
		primarily by developers and not end users.
		Despite that distinction, it is possible to 'brand' the HTML page to whatever you desire.
	</p>
	<p>
		The sample root page below includes some default branding for Juneau and Apache:
	</p>
	<p class='bcode'>
	http://localhost:10000/helloWorld
	</p>
	<img class='bordered w800' src='doc-files/jrs.UiCustomization.1.png'>
	<p>
		The Juneau REST framework does not provide specific branding support (i.e. there is no concept of a brand icon).
		Instead, it just uses the existing open-ended API for defining branding via annotations on your REST classes.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		<jc>// Optional external configuration file.</jc>
		config=<js>"$S{juneau.configFile}"</js>,
	)
	<ja>@HtmlDocConfig</ja>(
	
		<jc>// Default stylesheet to use for the page.
		// Can be overridden from external config file.
		// Default is DevOps look-and-feel (aka Depression look-and-feel).</jc>
		stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>,
	
		<jc>// Default page header contents.</jc>
		header={
			<js>"&lt;h1&gt;$RS{title}&lt;/h1&gt;"</js>,  <jc>// Use @Rest(title)</jc>
			<js>"&lt;h2&gt;$RS{operationSummary,description}&lt;/h2&gt;"</js>, <jc>// Use either @RestOp(summary) or @Rest(description)</jc>
			<js>"$C{REST/header}"</js>  <jc>// Extra header HTML defined in external config file.</jc>
		},
	
		<jc>// Default contents to add to the &lt;head&gt; section of the HTML page.
		// Use it to add a favicon link to the page.</jc>
		head={
			<js>"&lt;link rel='icon' href='$U{$C{REST/favicon}}'/&gt;"</js>
		},
	
		<jc>// Basic page navigation links.</jc>
		navlinks={
			<js>"up: request:/.."</js>
		},
		
		<jc>// No default page footer contents.
		// Can be overridden from external config file.</jc>
		footer=<js>"$C{REST/footer}"</js>
	)
	
	<jk>public interface</jk> BasicUniversalConfig {}
	</p>
	<p class='bjava'>			
	<ja>@Rest</ja>(...)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>,
			ThemeMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"options: ?method=OPTIONS"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"$W{ThemeMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/$R{servletClassSimple}.java"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This is an example of a 'router' page that serves as a jumping-off point to child resources.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Resources can be nested arbitrarily deep through router pages.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Note the &lt;span class='link'&gt;options&lt;/span&gt; link provided that lets you see the generated swagger doc for this page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;sources&lt;/span&gt; link on these pages to view the source code for the page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;All content on pages in the UI are serialized POJOs.  In this case, it's a serialized array of beans with 2 properties, 'name' and 'description'.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Other features (such as this aside) are added through annotations.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		},
		asideFloat=<js>"RIGHT"</js>
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {...}
	</p>
	
	<p>
		The default annotation values use {@link org.apache.juneau.config.vars.ConfigVar $C} variables to pull in values from an optional
		external configuration file such as the one shown below:
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# REST settings
	#=======================================================================================================================</cc>
	<cs>[REST]</cs>
	
	<ck>staticFiles</ck> = <cv>htdocs:files/htdocs</cv>
	
	<cc># Stylesheet to use for HTML views.</cc>
	<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
	
	<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
	<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
	<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
	<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
	
	<ck>favicon</ck> = <cv>$C{REST/headerIcon}</cv>
	<ck>header</ck> = 
		<cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	<ck>footer</ck> = 
		<cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/footerIcon}}' style='float:right;padding-right:20px;height:32px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	</p>
	<p>
		The take-away here is that the "User Interface" is open-ended, lets you define pretty much anything you want through arbitrary HTML, 
		and allows you either hardcode your interface inside annotations or pull them in via string variables from other places such as
		external config files.
	</p>
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jmj.UiCustomization">UI Customization</a>
	</ul>
</div>
</div><!-- END: 8.17.4 - jrs.HtmlUiCustomization -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlStylesheets' id='jrs.HtmlStylesheets'>8.17.5 - Stylesheets</a><span class='update'>updated: 8.1.0,<b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 8.17.5 - jrs.HtmlStylesheets -->
<div class='topic'>
	<p>
		The sample root page renders in the default "devops" look-and-feel:
	</p>
	<p class='bcode'>
	http://localhost:10000
	</p>
	<img class='bordered w800' src='doc-files/jrs.Stylesheets.0.png'>
	<p>
		The sample root page provides a dropdown widget to try out the other default look-and-feels:
	</p>
	<img class='bordered' src='doc-files/jrs.Stylesheets.1.png'/>
	<p>
		For example, the "light" look-and-feel:
	</p>
	<p class='bcode'>
	http://localhost:10000/?stylesheet=styles%2Flight.css
	</p>
	<img class='bordered w800' src='doc-files/jrs.Stylesheets.2.png'>
	<p>
		And the "dark" look-and-feel:
	</p>
	<p class='bcode'>
	http://localhost:10000/?stylesheet=styles%2Fdark.css
	</p>
	<img class='bordered w800' src='doc-files/jrs.Stylesheets.3.png'>
	<p>
		The stylesheet URL is controlled by the {@link org.apache.juneau.html.annotation.HtmlDocConfig#stylesheet() @HtmlDocConfig(stylesheet)} annotation.
		The {@link org.apache.juneau.rest.config.BasicUniversalConfig} interface defines the stylesheet served up as a static file:
	<p class='bjava'>
	<ja>@HtmlDocConfig</ja>(
		stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>
	)
	<jk>public interface</jk> BasicUniversalConfig {...}
	</p>		
	<p>
		The <js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js> variable says to use the URI defined
		in your servlet's config file, if there is one, and to default to serving up the file
		<c>htdocs/themes/devops.css</c> which is in the resource folder of the <c>juneau-rest-server</c> module.
	</p>
	<p>
		To provide your own stylesheet, simply override the stylesheet attribute and point to a different
		file:	
	</p>
	<p class='bjava'>
	<ja>@HtmlDocConfig</ja>(
		stylesheet=<js>"servlet:/htdocs/themes/my-style.css"</js>
	)
	<jk>public class</jk> MyResourceBaseClass <jk>extends</jk> BasicRestServlet {...}
	</p>
	<p>
		You can try out different stylesheets by passing in a <c>stylesheet</c> attribute in the request
		URL.
		The example above show this in use.
	</p>
	<p>
		In case you're curious about how the menu item works, it's defined via a widget:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(...)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			PoweredByApache.<jk>class</jk>,
			ContentTypeMenuItem.<jk>class</jk>,
			StyleMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"options: ?method=OPTIONS"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"$W{StyleMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/$R{servletClassSimple}.java"</js>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {...}
	</p>
	<p>
		The <c>StyleMenuItem</c> is a widget that extends from {@link org.apache.juneau.rest.widget.MenuItemWidget}, a
		specialized widget for creating pop-up menus.
		In the case of <l>StyleMenuItem</l>, it's simply returning a list of links wrapped in a div tag:
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;

	<jk>public class</jk> StyleMenuItem <jk>extends</jk> MenuItemWidget {
	
		<jk>private static final</jk> String[] <jsf>BUILT_IN_STYLES</jsf> = {<js>"devops"</js>, <js>"light"</js>, <js>"original"</js>, <js>"dark"</js>};
	
		<ja>@Override</ja> <jc>/* Widget */</jc>
		<jk>public</jk> String getLabel(RestRequest <jv>req</jv>) {
			<jk>return</jk> <js>"styles"</js>;
		}

		<ja>@Override</ja> <jc>/* MenuItemWidget */</jc>
		<jk>public</jk> Div getContent(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
			Div <jv>div</jv> = <jsm>div</jsm>();
			<jk>for</jk> (String <jv>style</jv> : <jsf>BUILT_IN_STYLES</jsf>) {
				java.net.URI <jk>uri</jk> = <jv>req</jv>.getUri(<jk>true</jk>, <jk>new</jk> AMap&lt;String,String&gt;().append(<js>"stylesheet"</js>, <js>"styles/"</js>+s+<js>".css"</js>));
				<jv>div</jv>.children(<jsm>a</jsm>(<jv>uri</jv>, <jv>style</jv>), <jsm>br</jsm>());
			}
			<jk>return</jk> <jv>div</jv>;
		}
	}
	</p>
</div>
</div><!-- END: 8.17.5 - jrs.HtmlStylesheets -->
</div><!-- END: 8.17 - jrs.HtmlDocAnnotation -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.LoggingAndDebugging' id='jrs.LoggingAndDebugging'>8.18 - Logging / Debugging</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.18 - jrs.LoggingAndDebugging -->
<div class='topic'>
	<p>
		The REST APIs provides supports enabling logging of HTTP requests and responses through
		the following annotations:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#debug() debug}
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#debugOn() debugOn}
			</ul>
		</li>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.RestOp#debug() debug}
			</ul>
		</li>
	</ul>
	<p>
		Debug mode enables the following:
	</p>	
	<ul class='spaced-list'>
		<li>
			HTTP request/response bodies are cached in memory for logging purposes.
		<li>
			HTTP requests/responses are logged to the registered {@link org.apache.juneau.rest.logger.CallLogger}.
	</ul>
	<p>
		The possible annotation values are:
	</p>
	<ul>
		<li><js>"true"</js> - Debug is enabled for all requests.
		<li><js>"false"</js> - Debug is disabled for all requests.
		<li><js>"conditional"</js> - Debug is enabled only for requests that have a <c class='snippet'>Debug: true</c> header.
	</ul>
	<h5 class='figure'>Example</h5>
	<p class='bjava'>
	<jc>// Enable debugging on all op calls on this resource</jc>
	<ja>@Rest</ja>(debug=<js>"true"</js>)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		These annotations support SVL variables, so it's possible to define them as a system property for example.
	</p>
	<p class='bjava'>
	<jc>// Enable via system property 'MyResource.debug'</jc>
	<ja>@Rest</ja>(debug=<js>"$S{MyResource.debug}"</js>)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		The {@link org.apache.juneau.rest.annotation.Rest#debugOn() @Rest(debugOn)} annotation can also be used
		to enable debugging.  It takes a comma-delimited list of key-value pairs, the keys
		being class or method names, and the values being one of <c>true|false|conditional</c>.
	</p>
	<p class='bjava'>
	<jc>// Turn on debug per-request on the class and always on the doX() method</jc>
	<ja>@Rest</ja>(debugOn=<js>"MyResource=conditional,MyResource.doX=true"</js>)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		The primary advantage of {@link org.apache.juneau.rest.annotation.Rest#debugOn() @Rest(debugOn)} is that
		you can control debugging externally such as through a system property or environment variable:
	</p>
	<p class='bjava'>
	<jc>// Turn on debug per-request on the class and always on the doX() method</jc>
	<ja>@Rest</ja>(debugOn=<js>"$E{DEBUG}"</js>)
	<jk>public class</jk> MyResource {...}
	</p>
	<p>
		Debugging can also be enabled programmatically with the use of the following APIs:
	</p>	
	<ul class='javatree'>
		<li class='jic'>{@link org.apache.juneau.rest.debug.DebugEnablement}
		<li class='jc'>{@link org.apache.juneau.rest.debug.BasicDebugEnablement}
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#debugEnablement() debugEnablement()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#debugEnablement(Class) debugEnablement(Class)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#debugEnablement(DebugEnablement) debugEnablement(DebugEnablement)}
			</ul>
		</li>
	</ul>
	<p>
		HTTP calls can be logged with the following levels of granularity:
	</p>	
	<ul class='javatree'>
		<li class='je'>{@link org.apache.juneau.rest.logger.CallLoggingDetail}
			<ul class='javatreec'>
				<li class='jf'>{@link org.apache.juneau.rest.logger.CallLoggingDetail#STATUS_LINE STATUS_LINE}
				<li class='jf'>{@link org.apache.juneau.rest.logger.CallLoggingDetail#HEADER HEADER}
				<li class='jf'>{@link org.apache.juneau.rest.logger.CallLoggingDetail#ENTITY ENTITY}
			</ul>
		</li>
	</ul>
	<p>
		The following examples show the output format for each detail type:
	</p>
	<h5 class='figure'>STATUS_LINE</h5>
	<p class='bcode'>
	WARNING: [500] HTTP POST /foo?foo=bar
	</p>
	<h5 class='figure'>HEADER</h5>
	<p class='bcode'>
	WARNING: 
	=== HTTP Call (incoming) ===================================================
	[500] HTTP POST /foo?foo=bar
		Request length: 3 bytes
		Response code: 500
		Response length: 3 bytes
		Exec time: 20ms
	---Request Headers---
		Foo: bar
	---Response Headers---
		Foo: bar
		Content-Type: text/plain
	=== END ===================================================================
	</p>
	<h5 class='figure'>ENTITY</h5>
	<p class='bcode'>
	WARNING: 
	=== HTTP Call (incoming) ===================================================
	[500] HTTP POST /foo?foo=bar
		Request length: 3 bytes
		Response code: 500
		Response length: 3 bytes
		Exec time: 20ms
	---Request Headers---
		Foo: bar
	---Response Headers---
		Foo: bar
		Content-Type: text/plain
	---Request Content UTF-8---
	Foo
	---Request Content Hex---
	46 6F 6F
	---Response Content UTF-8---
	Foo
	---Response Content Hex---
	46 6F 6F
	=== END ===================================================================
	</p>
	<p>
		The interface responsible for generating the log entries is {@link org.apache.juneau.rest.logger.CallLogger}
		and the default is {@link org.apache.juneau.rest.logger.BasicCallLogger} which produces the output above.  It
		can be changed through any of the following:
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.rest.annotation.Rest#callLogger() callLogger()}
			</ul>
		</li>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#callLogger() callLogger()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#callLogger(Class) callLogger(Class)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#callLogger(CallLogger) callLogger(CallLogger)}
			</ul>
		</li>
	</ul>
	<p>
		The call logger uses logging rules to map requests to logging detail levels.
		By default, these are the logging rules:
	</p>
	<p class='bjava'>
	RestLogger
		.<jsm>create</jsm>()
		.beanStore(<jv>beanStore</jv>)  <jc>// Allow injected beans in constructor</jc>
		.normalRules(  <jc>// Rules when debugging is not enabled</jc>
			RestLoggerRule.<jsm>create</jsm>()  <jc>// Log 500+ errors with status-line and header information</jc>
				.statusFilter(<jv>x</jv> -&gt; <jv>x</jv> &gt;= 500)
				.level(<jsf>SEVERE</jsf>)
				.requestDetail(<jsf>HEADER</jsf>)
				.responseDetail(<jsf>HEADER</jsf>)
				.build(),
			RestLoggerRule.<jsm>create</jsm>()  <jc>// Log 400-500 errors with just status-line information</jc>
				.statusFilter(<jv>x</jv> -&gt; <jv>x</jv> &gt;= 400)
				.level(<jsf>WARNING</jsf>)
				.requestDetail(<jsf>STATUS_LINE</jsf>)
				.responseDetail(<jsf>STATUS_LINE</jsf>)
				.build()
		)
		.debugRules(  <jc>// Rules when debugging is enabled</jc>
			RestLoggerRule.<jsm>create</jsm>()  <jc>// Log everything with full details</jc>
				.level(<jsf>SEVERE</jsf>)
				.requestDetail(<jsf>ENTITY</jsf>)
				.responseDetail(<jsf>ENTITY</jsf>)
				.build()
		);
	</p>
	<p>
		Thrown exceptions get logged with a stack trace hash and a counter like below:
	</p>
	<p class='bcode'>
	WARNING: [500,9b85cc96.13] HTTP POST /foo?foo=bar
	</p>
	<p>
		Stack trace hashes are controlled by the {@link org.apache.juneau.rest.stats.ThrownStore} bean which is configured
		via the following:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#thrownStore() thrownStore()}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#thrownStore(Class) thrownStore(Class)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#thrownStore(ThrownStore) thrownStore(ThrownStore)}
			</ul>
		</li>
	</ul>
	<ul class='notes'>
		<li class='note'>The {@link org.apache.juneau.rest.logger.BasicTestCallLogger} class is useful for testing and
			allows you to suppress logging when testing error conditions by passing in a <c>noTrace=true</c> query parameter
			or <c>No-Trace: true</c> header on requests.  
		<li class='note'>{@link org.apache.juneau.rest.debug.DebugEnablement}, {@link org.apache.juneau.rest.logger.CallLogger}, and 
			{@link org.apache.juneau.rest.stats.ThrownStore} can all be defined globally as Spring beans in a Spring Boot environment.
	</ul>
</div>
</div><!-- END: 8.18 - jrs.LoggingAndDebugging -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.HttpStatusCodes' id='jrs.HttpStatusCodes'>8.19 - HTTP Status Codes</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.19 - jrs.HttpStatusCodes -->
<div class='topic'>
	<p>
		By default, a 200 (OK) status is automatically set as the HTTP status when a Java method executes 
		successfully.
	</p>
	<p>
		Other status codes can be generated by throwing a {@link org.apache.juneau.http.response.BasicHttpException} with a 
		specific HTTP status code, or calling {@link javax.servlet.http.HttpServletResponse#setStatus(int)}.
	</p>
	<p>
		Non-OK (200) status codes are automatically triggered by the following conditions:
	</p>
	<table class='styled w800'>
		<tr>
			<th><l>Code</l></th>
			<th><l>Description</l></th>
			<th><l>When triggered</l></th>
		</tr>
		<tr>
			<td><l>401</l></td>
			<td>Unauthorized</td>
			<td>A {@link org.apache.juneau.rest.guard.RestGuard guard} prevented the method from being executed</td>
		</tr>
		<tr>
			<td><l>404</l></td>
			<td>Not Found</td>
			<td>No matching path patterns were found on any method</td>
		</tr>
		<tr>
			<td><l>405</l></td>
			<td>Method Not Implemented</td>
			<td>A path pattern matched but no Java methods were found for the HTTP method</td>
		</tr>
		<tr>
			<td><l>406</l></td>
			<td>Not Acceptable</td>
			<td>
				A path pattern matched but no Java methods were found with a matching serializer for the 
				<l>Accept</l> on the request
			</td>
		</tr>
		<tr>
			<td><l>412</l></td>
			<td>Precondition Failed</td>
			<td>
				A path pattern matched but no Java methods were found that were not rejected by 
				{@link org.apache.juneau.rest.matcher.RestMatcher matchers}
			</td>
		</tr>
		<tr>
			<td><l>415</l></td>
			<td>Unsupported Media Type</td>
			<td>
				A path pattern matched but no Java methods were found with a matching parser for the 
				<l>Content-Type</l> on the request
			</td>
		</tr>
		<tr>
			<td><l>500</l></td>
			<td>Internal Server Error</td>
			<td>The Java method threw an exception other than {@link org.apache.juneau.http.response.BasicHttpException}</td>
		</tr>
	</table>
</div>
</div><!-- END: 8.19 - jrs.HttpStatusCodes -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.BuiltInParameters' id='jrs.BuiltInParameters'>8.20 - Built-in Parameters</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.20 - jrs.BuiltInParameters -->
<div class='topic'>
	<p>
		The following URL parameters have special meaning and can be passed in through the URL of the request:
	</p>
	<table class='styled w800'>
		<tr>
			<th><l>GET Parameter</l></th>
			<th><l>Description</l></th>
		</tr>
		<tr>
			<td class='code'>&amp;plainText=true</td>
			<td>
				Response will always be <l>Content-Type: text/plain</l> and the returned text will be human-readable
				({@link org.apache.juneau.serializer.WriterSerializer.Builder#useWhitespace()} enabled).
				<br>Useful for debugging.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;debug=true</td>
			<td>
				Enable debug mode for request.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;noTrace=true</td>
			<td>
				If an error occurs, don't log the stack trace to the log file.
				<br>Useful for automated JUnit testcases testing error states to prevent the log file from filling 
				up with useless stack traces.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;method=X</td>
			<td>
				Overload the HTTP method as a GET parameter (e.g <l>"POST"</l>).
				<br>Must be enabled via {@link org.apache.juneau.rest.annotation.Rest#allowedMethodParams() @Rest(allowedMethodParams)} setting.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;Header-Name=headerValue</td>
			<td>
				Specify a header value as a GET parameter.
				<br>Must be enabled via {@link org.apache.juneau.rest.annotation.Rest#allowedHeaderParams() @Rest(allowedHeaderParams)} setting.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;body=X</td>
			<td>
				Pass in the HTTP body content on PUT and POST methods as a UON-encoded GET parameter.
				<br>Can be disabled via {@link org.apache.juneau.rest.annotation.Rest#disableContentParam() @Rest(disableContentParam)} setting.
			</td>
		</tr>
		<tr>
			<td class='code'>&amp;x-response-headers=X</td>
			<td>
				Pass-through headers to the response.
				<br>Must be a UON-encoded map of key-value pairs.
			</td>
		</tr>
	</table>
</div>
</div><!-- END: 8.20 - jrs.BuiltInParameters -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.UsingWithOsgi' id='jrs.UsingWithOsgi'>8.21 - Using with OSGi</a></h3>
<div class='topic'><!-- START: 8.21 - jrs.UsingWithOsgi -->
<div class='topic'>
	<p>
		Since REST servlets are basically just <l>HttpServlets</l>, incorporating them into an OSGi environment
		is pretty straightforward.
	</p>
	<p>
		The following code shows how to register your REST servlets in an OSGi <l>Activator</l>:
	</p>
	<p class='bjava'>
	<jk>package</jk> org.apache.juneau.examples.rest;
	
	<jk>import</jk> org.osgi.framework.*;
	<jk>import</jk> org.osgi.service.http.*;
	<jk>import</jk> org.osgi.util.tracker.*;
	
	<jk>import</jk> org.apache.juneau.rest.samples.*;
	
	<jd>/**
	 * Activator class used when running samples as a bundle in an OSGi environment.
	 */</jd>
	<jk>public class</jk> Activator <jk>implements</jk> BundleActivator, ServiceTrackerCustomizer {
	
		<jk>private</jk> ServiceTracker <jf>httpServiceTracker</jf>;
		<jk>private</jk> BundleContext <jf>context</jf>;
	
		<ja>@Override</ja> <jc>/* BundleActivator */</jc>
		<jk>public void</jk> start(BundleContext <jv>context</jv>) <jk>throws</jk> Exception {
			<jk>this</jk>.<jf>context</jf> = <jv>context</jv>;
			<jf>httpServiceTracker</jf> = <jk>new</jk> ServiceTracker(<jv>context</jv>, HttpService.<jk>class</jk>.getName(), <jk>this</jk>);
			<jf>httpServiceTracker</jf>.open();
		}
	
		<ja>@Override</ja> <jc>/* BundleActivator */</jc>
		<jk>public void</jk> stop(BundleContext <jv>context</jv>) <jk>throws</jk> Exception {
			<jf>httpServiceTracker</jf>.close();
		}
	
		<ja>@Override</ja> <jc>/* ServiceTrackerCustomizer */</jc>
		<jk>public</jk> Object addingService(ServiceReference <jv>reference</jv>) {
			Object <jv>service</jv> = <jf>context</jf>.getService(<jv>reference</jv>);
	
			<jk>if</jk> (service <jk>instanceof</jk> HttpService) {
				HttpService <jv>service</jv> = (HttpService)<jv>service</jv>;
				<jk>try</jk> {
					<jv>service</jv>.registerServlet(<js>"/sample"</js>, <jk>new</jk> MyRestServlet(), <jk>null</jk>, <jk>null</jk>);
				} <jk>catch</jk> (Exception <jv>e</jv>) {
					<jk>throw new</jk> RuntimeException(<jv>e</jv>);
				}
			}
	
			<jk>return</jk> <jv>service</jv>;
		}
	
		<ja>@Override</ja> <jc>/* ServiceTrackerCustomizer */</jc>
		<jk>public void</jk> modifiedService(ServiceReference <jv>reference</jv>, Object <jv>service</jv>) {
		}
	
		<ja>@Override</ja> <jc>/* ServiceTrackerCustomizer */</jc>
		<jk>public void</jk> removedService(ServiceReference <jv>reference</jv>, Object <jv>service</jv>) {
		}
	}
	</p>
</div>
</div><!-- END: 8.21 - jrs.UsingWithOsgi -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.RestContext' id='jrs.RestContext'>8.22 - RestContext</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.22 - jrs.RestContext -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.RestContext} object is the workhorse class for all of the configuration
		of a single REST resource class.  It's by-far the most important class in the REST API.
	</p>
	<p>
		Every class annotated with <l>@Rest</l> ends up with an instance of this object.  The object itself is read-only and unchangeable and is
		initialized with all of the various annotations pulled from the class and methods.  All functionality available through annotations
		have programmatic equivalents through the builder of this class.
	</p>
	<p>
		The {@link org.apache.juneau.rest.RestContext.Builder} class extends {@link org.apache.juneau.BeanContext.Builder}
		allowing you to programmatically set any properties defined on that builder class.
		It also implements {@link javax.servlet.ServletConfig}
	</p>
	<p>
		To access this object, simply pass it in as a constructor argument or in an INIT hook:
	</p>
	<p class='bjava'>
	<jc>// Option #1 - Pass in through constructor.</jc>
	<jk>public</jk> MyResource(RestContext.Builder <jv>builder</jv>) {
			<jv>builder</jv>
				.beanContext(<jv>x</jv> -&gt; <jv>x</jv>.swaps(TemporalCalendarSwap.Rfc1123DateTime.<jk>class</jk>))
				.debugEnablement(<jsf>CONDITIONAL</jsf>);
	}

	<jc>// Option #2 - Use an init hook.</jc>
	<ja>@RestInit</ja>
	<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			<jv>builder</jv>
				.beanContext(<jv>x</jv> -&gt; <jv>x</jv>.swaps(TemporalCalendarSwap.Rfc1123DateTime.<jk>class</jk>))
				.debugEnablement(<jsf>CONDITIONAL</jsf>);
	}
	</p>
	<p>
		This class is vast.  Combined with {@link org.apache.juneau.rest.RestOpContext} (which is the equivalent per-method context), these classes
		define the entire configuration and workflow of the REST API.
	</p>
	<p>
		There are multiple ways to programmatically alter how RestContext behaves.  The most straightforward are the following
		builder methods which are direct equivalents to values defined on the {@link org.apache.juneau.rest.annotation.Rest} annotation:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#allowedHeaderParams(String) allowedHeaderParams}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#allowedMethodHeaders(String) allowedMethodHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#allowedMethodParams(String) allowedMethodParams}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#clientVersionHeader(String) clientVersionHeader}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#child(String, Object) child}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#children(Object...) children}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#config(Config) config}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#consumes(MediaType...) consumes}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#debugDefault(Enablement) debugDefault}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultAccept(String) defaultAccept}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultCharset(Charset) defaultCharset}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultClasses(Class...) defaultClasses}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultContentType(String) defaultContentType}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestAttributes(NamedAttribute...) defaultRequestAttributes}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestHeaders(Header...) defaultRequestHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultResponseHeaders(Header...) defaultResponseHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultSetting(String, Object) defaultSetting}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#disableContentParam(boolean) disableContentParam}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#logger(Logger) logger}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#maxInput(String) maxInput}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#path(String) path}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#parserListener(Class) parserListener}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#produces(MediaType...) produces}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#renderResponseStackTraces(boolean) renderResponseStackTraces}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#restOpArgs(Class...) restOpArgs}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#serializerListener(Class) serializerListener}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#swaggerProvider(Class) swaggerProvider}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriAuthority(String) uriAuthority}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriContext(String) uriContext}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriRelativity(UriRelativity) uriRelativity}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriResolution(UriResolution) uriResolution}
		</ul>
	</ul>
	<p>
		For more complex configurations, access to sub-builders is provided via the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#callLogger() callLogger}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#config() config}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#consumes() consumes}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#debugEnablement() debugEnablement}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultClasses() defaultClasses}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestAttributes() defaultRequestAttributes}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultRequestHeaders() defaultRequestHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultResponseHeaders() defaultResponseHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#defaultSettings() defaultSettings}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#encoders() encoders}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#jsonSchemaGenerator() jsonSchemaGenerator}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#logger() logger}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#messages() messages}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#methodExecStore() methodExecStore}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#parsers() parsers}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#partParser() partParser}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#partSerializer() partSerializer}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#produces() produces}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#responseProcessors() responseProcessors}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#restOpArgs() restOpArgs}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#rootBeanStore() rootBeanStore}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#serializers() serializers}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#staticFiles() staticFiles}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#swaggerProvider() swaggerProvider}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#thrownStore() thrownStore}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#varResolver() varResolver}
		</ul>
	</ul>
	<ul>
		<li class='note'>
			The builders or built objects above can also be defined as injected beans defined in a Spring Configuration if 
			you wish to do all your app configuration Spring-style.  This is described in detail in the <a class="doclink" href="#juneau-rest-server-springboot">juneau-rest-server-springboot</a> 
			documentation.
	</ul>
	<p>
		The programmatic equivalent to the annotated lifecycle methods are below:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#postInitMethods() postInitMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#postInitChildFirstMethods() postInitChildFirstMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#startCallMethods() startCallMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#preCallMethods() preCallMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#postCallMethods() postCallMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#endCallMethods() endCallMethods}
			<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#destroyMethods() destroyMethods}
		</ul>
	</ul>
	<ul>
		<li class='note'>
			It is also possible to override methods on the {@link org.apache.juneau.rest.RestContext} class itself by providing your own specialized subclass via the 
			{@link org.apache.juneau.rest.RestContext.Builder#type(Class)} method.
	</ul>
</div>
</div><!-- END: 8.22 - jrs.RestContext -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.RestOpContext' id='jrs.RestOpContext'>8.23 - RestOpContext</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.23 - jrs.RestOpContext -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.RestOpContext} object is the workhorse class for an individual {@link org.apache.juneau.rest.annotation.RestOp}-annotated method.
	</p>
	<p>
		Every class annotated with <l>@RestOp</l> ends up with an instance of this object.  Similar to {@link org.apache.juneau.rest.RestContext}, the object is read-only and unchangeable and is
		initialized with all of the various annotations pulled from the method.  All functionality available through annotations
		have programmatic equivalents through the builder of this class.
	</p>
	<p>
		To access the builder for these objects, simply implement the following init method that will be called for each {@link org.apache.juneau.rest.annotation.RestOp}-annotated method.
	</p>
	<p class='bjava'>
	<jc>// Use an init hook with RestOpContext.Builder as a parameter.</jc>
	<ja>@RestInit</ja>
	<jk>public void</jk> init(RestOpContext.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			<jv>builder</jv>
				.beanContext(<jv>x</jv> -&gt; <jv>x</jv>.swaps(TemporalCalendarSwap.Rfc1123DateTime.<jk>class</jk>))
				.debugEnablement(<jsf>CONDITIONAL</jsf>);
	}
	</p>
	<p>
		There are multiple ways to programmatically alter how RestOpContext behaves.  The most straightforward are the following
		builder methods which are direct equivalents to values defined on the {@link org.apache.juneau.rest.annotation.RestOp} annotation:
	</p>



	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestOpContext.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#clientVersion(String) clientVersion}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#consumes(MediaType...) consumes}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#debug(Enablement) debug}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultCharset(Charset) defaultCharset}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#dotAll() dotAll}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#httpMethod(String) httpMethod}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#maxInput(String) maxInput}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#path(String...) path}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#produces(MediaType...) produces}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#roleGuard(String) roleGuard}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#rolesDeclared(String...) rolesDeclared}
		</ul>
	</ul>
	<p>
		For more complex configurations, access to sub-builders is provided via the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestOpContext.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#converters() converters}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultClasses() defaultClasses}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestAttributes() defaultRequestAttributes}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestFormData() defaultRequestFormData}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestHeaders() defaultRequestHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultRequestQueryData() defaultRequestQueryData}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#defaultResponseHeaders() defaultResponseHeaders}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#encoders() encoders}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#guards() guards}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#jsonSchemaGenerator() jsonSchemaGenerator}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#matchers() matchers}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#parsers() parsers}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#partParser() partParser}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#partSerializer() partSerializer}
			<li class='jm'>{@link org.apache.juneau.rest.RestOpContext.Builder#serializers() serializers}
		</ul>
	</ul>
	<ul>
		<li class='note'>
			It is also possible to override methods on the {@link org.apache.juneau.rest.RestOpContext} class itself by providing your own specialized subclass via the 
			{@link org.apache.juneau.rest.RestOpContext.Builder#type(Class)} method.
	</ul>

</div>
</div><!-- END: 8.23 - jrs.RestOpContext -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.ResponseProcessors' id='jrs.ResponseProcessors'>8.24 - Response Processors</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.24 - jrs.ResponseProcessors -->
<div class='topic'>
	<p>
		The REST Server API uses the concept of registered response processors for converting objects returned by REST
		methods or set through {@link org.apache.juneau.rest.RestResponse#setContent(Object)} into appropriate HTTP responses.
	</p>
	<p>
		By default, REST resource classes are registered with the following response processors:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.processor.HttpEntityProcessor} 
		<li class='jc'>{@link org.apache.juneau.rest.processor.HttpResourceProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.HttpResponseProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.InputStreamProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.PlainTextPojoProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.ReaderProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.ResponseBeanProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.SerializedPojoProcessor}
		<li class='jc'>{@link org.apache.juneau.rest.processor.ThrowableProcessor}	
	</ul>	
	<p>
		Custom response processors can be associated with REST resources via the following:
	</p>
	<ul>
		<li class='ja'>{@link org.apache.juneau.rest.annotation.Rest#responseProcessors}
		<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#responseProcessors()}
	</ul>
	
	<p>
		Response processors can be used to process POJOs that cannot normally be handled through Juneau serializers, or
		because it's simply easier to define response processors for special cases.
	</p>
	<p>
		The following example shows how to create a response processor to handle special <c>Foo</c> objects outside the
		normal Juneau architecture.
	</p>
	<p class='bjava'>
		<ja>@Rest</ja>(
			path=<js>"/example"</js>,
			responseProcessors=FooProcessor.<jk>class</jk>
		)
		<jk>public class</jk> Example <jk>extends</jk> BasicRestServlet {

			<ja>@RestGet</ja>(<js>"/"</js>)
			<jk>public</jk> Foo test1() {
				<jk>return new</jk> Foo(<js>"123"</js>);
			}

			<jk>public static class</jk> FooProcessor <jk>implements</jk> ResponseProcessor {
				<ja>@Override</ja>
				<jk>public int</jk> process(RestOpSession <jv>opSession</jv>) {

					RestResponse <jv>res</jv> = <jv>opSession</jv>.getRestResponse();
					Foo <jv>foo</jv> = <jv>res</jv>.getOutput(Foo.<jk>class</jk>);

					<jk>if</jk> (<jv>foo</jv> == <jk>null</jk>)
						<jk>return</jk> <jsf>NEXT</jsf>;  <jc>// Let the next processor handle it.</jc>

					<jc>// Set some headers and body content.</jc>
					<jv>res</jv>.setHeader(<js>"Foo-ID"</js>, <jv>foo</jv>.getId());
					<jv>res</jv>.getWriter().write(<js>"foo.id="</js> + <jv>foo</jv>.getId());

					<jk>return</jk> <jsf>FINISHED</jsf>;  <jc>// We handled it.</jc>
				}
			}
		}
	</p>
</div>
</div><!-- END: 8.24 - jrs.ResponseProcessors -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.RestRpc' id='jrs.RestRpc'>8.25 - REST/RPC</a><span class='update'>updated: 8.0.0,<b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.25 - jrs.RestRpc -->
<div class='topic'>
	<p>
		The REST/RPC (RPC over REST) API allows the creation of client-side remote proxy interfaces for calling methods on server-side POJOs using entirely REST.
	</p>
	<ul>
		<li class='note'>
			This is not to be confused with REST Proxies which are entirely client-side driven Java interfaces
			against arbitrary backend REST interfaces.
	</ul>
	
	<h5 class='topic'>Remote Interfaces</h5>
	<p>
		The following example shows a remote interface:
	</p>
	<p class='bjava'>
	<ja>@RemoteInterface</ja> <jc>// Annotation is optional</jc>
	<jk>public interface</jk> IAddressBook {

		<jk>void</jk> init() <jk>throws</jk> Exception;
	
		List&lt;Person&gt; getPeople();
	
		List&lt;Address&gt; getAddresses();
	
		<jk>int</jk> createPerson(CreatePerson cp) <jk>throws</jk> Exception;
	
		Person findPerson(<jk>int</jk> id);
	
		Address findAddress(<jk>int</jk> id);
	
		Person findPersonWithAddress(<jk>int</jk> id);
	
		Person removePerson(<jk>int</jk> id);
	}
	</p>			
	<p>
		The requirements for a remote interface method are:
	</p>
	<ul class='spaced-list'>
		<li>
			Must be public.
		<li>
			Can be called anything.
		<li>
			Can have any number of <a class="doclink" href="#jm.PojoCategories">serializable and parsable</a> parameters.
		<li>
			Can return a <a class="doclink" href="#jm.PojoCategories">serializable and parsable</a> value.
		<li>
			Can throw any <c>Throwables</c>.
	</ul>
	<p>
		Throwables with public no-arg or single-arg-string constructors are automatically recreated on the client side
		when thrown on the server side.
	</p>
	
	<h5 class='topic'>Client side</h5>
	<p>
		Remote Interface proxies are instantiated on the client side using one of the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#getRrpcInterface(Class) getRrpcInterface(Class)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#getRrpcInterface(Class,Object) getRrpcInterface(Class,Object)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#getRrpcInterface(Class,Object,Serializer,Parser) getRrpcInterface(Class,Object,Serializer,Parser)}
			</ul>
		</li>
	</ul>
	<p>
		Since we build upon the existing <c>RestClient</c> API, we inherit all of it's features.
		For example, convenience methods for setting POJO filters and properties to customize the behavior of the 
		serializers and parsers, and the ability to provide your own customized Apache <c>HttpClient</c> for 
		handling various scenarios involving authentication and Internet proxies.
	</p>
	<p>
		Here's an example of the above interface being used:
	</p>
	<p class='bjava'>
	<jc>// Create a RestClient using JSON for serialization, and point to the server-side remote interface servlet.</jc>
	RestClient client = RestClient.<jsm>create</jsm>()
		.json()
		.rootUrl(<js>"http://localhost:10000/remote"</js>)
		.build();
	
	<jc>// Create a proxy interface.</jc>
	IAddressBook ab = client.getRrpcInterface(IAddressBook.<jk>class</jk>);
	
	<jc>// Invoke a method on the server side and get the returned result.</jc>
	Person p = ab.createPerson(
		<jk>new</jk> Person(
			<js>"John Smith"</js>, 
			<js>"Aug 1, 1999"</js>,
			<jk>new</jk> Address(<js>"My street"</js>, <js>"My city"</js>, <js>"My state"</js>, 12345, <jk>true</jk>)
		)
	);
	</p>
	<p>
		Under the covers, this method call gets converted to a REST POST.
	</p>
	<p class='bcode'>
	HTTP POST http://localhost:10000/remote/org.apache.juneau.examples.addressbook.IAddressBook/createPerson(org.apache.juneau.examples.addressbook.Person)
	Accept: application/json
	Content-Type: application/json
	
	[
		{
			"name":"John Smith",
			"birthDate":"Aug 1, 1999",
			"addresses":[
				{
					"street":"My street",
					"city":"My city",
					"state":"My state",
					"zip":12345,
					"isCurrent":true
				}
			]
		}
	]
	</p>
	<p>
		Note that the body of the request is an array.  
		This array contains the serialized arguments of the method.
		The object returned by the method is then serialized as the body of the response.
	</p>
	
	<h5 class='topic'>Server side</h5>
	<p>
		There are two ways to expose remote interfaces on the server side:
	</p>
	<ol class='spaced-list'>
		<li>
			Extending from {@link org.apache.juneau.rest.remote.RrpcServlet}.
		<li>
			Using a <c><ja>@RestOp</ja>(method=<jsf>RRPC</jsf>)</c> annotation on a Java method.
	</ol>
	<p>
		In either case, the proxy communications layer is pure REST.
		Therefore, in cases where the interface classes are not available on the client side, the same method calls can 
		be made through pure REST calls.  
		This can also aid significantly in debugging, since calls to the remote interface service can be made directly from
		a browser with no coding involved.
	</p>
	
	<h5 class='topic'>RrpcServlet</h5>
	<p>
		The {@link org.apache.juneau.rest.remote.RrpcServlet} class is a simple specialized servlet with an abstract 
		<c>getServiceMap()</c> method to define the server-side POJOs:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/remote"</js>
	)
	<jk>public class</jk> SampleRrpcServlet <jk>extends</jk> RrpcServlet {
	
		<jc>// Our server-side POJO.</jc>
		<jk>private</jk> AddressBook <jf>addressBook</jf> = <jk>new</jk> AddressBook();
	
		<ja>@Override</ja> <jc>/* RrpcServlet */</jc>
		<jk>protected</jk> Map&lt;Class&lt;?&gt;,Object&gt; getServiceMap() <jk>throws</jk> Exception {
			Map&lt;Class&lt;?&gt;,Object&gt; <jv>map</jv> = <jk>new</jk> LinkedHashMap&lt;Class&lt;?&gt;,Object&gt;();
	
			<jc>// In this simplified example, we expose the same POJO service under two different interfaces.
			// One is IAddressBook which only exposes methods defined on that interface, and
			// the other is AddressBook itself which exposes all methods defined on the class itself (dangerous!).</jc>
			<jv>map</jv>.put(IAddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			<jv>map</jv>.put(AddressBook.<jk>class</jk>, <jf>addressBook</jf>);
			<jk>return</jk> <jv>map</jv>;
		}
	}
	</p>
	
	<h5 class='topic'>@RestOp(method=RRPC)</h5>
	<p>
		The <c><ja>@RestOp</ja>(method=<jsf>RRPC</jsf>)</c> approach is easier if you only have a single 
		interface you want to expose.  
		You simply define a Java method whose return type is an interface, and return the implementation of that 
		interface:
	</p>
	<p class='bjava'>
	<jc>// Our exposed interface.</jc>
	<ja>@RestOp</ja>(method=<jsf>RRPC</jsf>, path=<js>"/addressbookproxy/*"</js>)
	<jk>public</jk> IAddressBook getProxy() {
		<jk>return</jk> <jf>addressBook</jf>;
	}
	</p>
	
	<h5 class='topic'>RrpcServlet in a browser</h5>
	<p>
		If you point your browser to the servlet above, you get a list of available interfaces:
	</p>
	<p class='bcode'>
	http://localhost:10000/remote
	</p>
	<img class='bordered w800' src='doc-files/jrs.restRPC.1.png'>
	<p>
		Clicking the hyperlinks on each shows you the list of methods that can be invoked on that service.
		Note that the <c>IAddressBook</c> link shows that you can only invoke methods defined on that
		interface, whereas the <c>AddressBook</c> link shows ALL public methods defined on that class.
	</p>
	<h5 class='figure'>IAddressBook</h5>
	<p class='bcode'>
	http://localhost:10000/remote/org.apache.juneau.examples.addressbook.IAddressBook
	</p>
	<img class='bordered w800' src='doc-files/jrs.restRPC.2.png'>
	<p>
		Since <c>AddressBook</c> extends from <c>LinkedList</c>, you may notice familiar collections
		framework methods listed.
	</p>
	<h5 class='figure'>AddressBook</h5>
	<p class='bcode'>
	http://localhost:10000/remote/org.apache.juneau.examples.addressbook.AddressBook
	</p>
	<img class='bordered w800' src='doc-files/jrs.restRPC.3.png'>
	<p>
		Let's see how we can interact with this interface through nothing more than REST calls to get a better idea on 
		how this works.
		We'll use the same method call as in the introduction.
		First, we need to create the serialized form of the arguments:
	</p>
	<p class='bjava'>
	Object[] <jv>args</jv> = <jk>new</jk> Object[] {
		<jk>new</jk> CreatePerson(<js>"Test Person"</js>,
			AddressBook.<jsm>toCalendar</jsm>(<js>"Aug 1, 1999"</js>),
			<jk>new</jk> CreateAddress(<js>"Test street"</js>, <js>"Test city"</js>, <js>"Test state"</js>, 12345, <jk>true</jk>))
	};
	String <jv>asJson</jv> = Json5Serializer.<jsf>DEFAULT_READABLE</jsf>.toString(<jv>args</jv>);
	System.<jsf>err</jsf>.println(<jv>asJson</jv>);
	</p>
	<p>
		That produces the following JSON output:
	</p>
	<p class='bjson'>
	[
		{
			name: <js>'Test Person'</js>, 
			birthDate: <js>'Aug 1, 1999'</js>, 
			addresses: [
				{
					street: <js>'Test street'</js>, 
					city: <js>'Test city'</js>, 
					state: <js>'Test state'</js>, 
					zip: 12345, 
					isCurrent: <jk>true</jk>
				}
			]
		}
	]	
	</p>
	<p>
		Note that in this example we're using JSON.  
		However, various other content types can also be used such as XML, URL-Encoding, UON, or HTML.  
		In practice however, JSON will preferred since it is often the most efficient.
	</p>
	<p>
		Next, we can use a tool such as Poster to make the REST call.
		Methods are invoked by POSTing the serialized object array to the URI of the interface method.
		In this case, we want to POST our JSON to the following URL:
	</p>
	<p class='bcode'>
	http://localhost:10000/remote/org.apache.juneau.examples.addressbook.IAddressBook/createPerson(org.apache.juneau.examples.addressbook.CreatePerson)
	</p>
	<p>
		Make sure that we specify the <c>Content-Type</c> of the body as <c>text/json</c>.
		We also want the results to be returned as JSON, so we set the <c>Accept</c> header to 
		<c>text/json</c> as well.
	</p>
	<img class='bordered w400' src='doc-files/jrs.restRPC.4.png'>
	<p>
		When we execute the POST, we should see the following successful response whose body contains the returned 
		<c>Person</c> bean serialized to JSON:
	</p>
	<img class='bordered w400' src='doc-files/jrs.restRPC.5.png'>
	<p>
		From there, we could use the following code snippet to reconstruct the response object from JSON:
	</p>
	<p class='bjava'>
	String response = <js>"<i>output from above</i>"</js>;
	Person p = JsonParser.<jsf>DEFAULT</jsf>.parse(response, Person.<jk>class</jk>);
	</p>
	<p>
		If we alter our servlet to allow overloaded GET requests, we can invoke methods using nothing more than a 
		browser...
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/remote"</js>,
		
		<jc>// Allow us to use method=POST from a browser.</jc>
		allowedMethodParams=<js>"*"</js>
	)
	<jk>public class</jk> SampleRrpcServlet <jk>extends</jk> RrpcServlet {
	</p>
	<p>
		For example, to invoke the <c>getPeople()</c> method on our bean:
	</p>
	<p class='bcode'>
	http://localhost:10000/remote/org.apache.juneau.examples.addressbook.IAddressBook/getPeople?method=POST
	</p>			
	<img class='bordered w800' src='doc-files/jrs.restRPC.6.png'>
	<p>
		Here we call the <c>findPerson(<jk>int</jk>)</c> method to retrieve a person and get the 
		returned POJO (in this case as HTML since that's what's in the <c>Accept</c> header when calling from a 
		browser):
	</p>
	<p class='bcode'>
	http://localhost:10000/remote/org.apache.juneau.examples.addressbook.IAddressBook/findPerson(int)?method=POST&amp;body=@(3)
	</p>			
	<img class='bordered w800' src='doc-files/jrs.restRPC.7.png'>
	<p>
		When specifying the POST body as a <c>&amp;body</c> parameter, the method arguments should be in UON 
		notation.
		See {@link org.apache.juneau.uon.UonSerializer} for more information about this encoding.
		Usually you can also pass in JSON if you specify <c>&amp;Content-Type=text/json</c> in the URL parameters
		but passing in unencoded JSON in a URL may not work in all browsers.  
		Therefore, UON is preferred.
	</p>
	<p>
		The hyperlinks on the method names above lead you to a simple form-entry page where you can test
		passing parameters in UON notation as URL-encoded form posts.
	</p>
	<h5 class='figure'>Sample form entry page</h5>
	<img class='bordered w800' src='doc-files/jrs.restRPC.8.png'>
	<h5 class='figure'>Sample form entry page results</h5>
	<img class='bordered w800' src='doc-files/jrs.restRPC.9.png'>
</div>
</div><!-- END: 8.25 - jrs.RestRpc -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.SerializingUris' id='jrs.SerializingUris'>8.26 - Serializing URIs</a><span class='update'>updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.26 - jrs.SerializingUris -->
<div class='topic'>
	<p>
		As mention earlier <a class="doclink" href="#jm.MarshallingUris">here</a>, Juneau serializers have sophisticated support for transforming relative URIs to absolute form.
	</p>
	<p>
		The following example shows a REST method that returns a list of URIs of various forms: 
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		uriAuthority=<js>"http://foo.com:123"</js>,
		uriContext=<js>"/myContext"</js>
	)
	<jk>public class</jk> MyResource {
	
		<ja>@RestGet</ja>
		<jk>public</jk> URI[] getURIs() {
			<jk>return new</jk> URI[] {
				URI.<jsm>create</jsm>(<js>"http://www.apache.org/f1a"</js>),
				URI.<jsm>create</jsm>(<js>"/f1b"</js>),
				URI.<jsm>create</jsm>(<js>"/f1c/x/y"</js>),
				URI.<jsm>create</jsm>(<js>"f1d"</js>),
				URI.<jsm>create</jsm>(<js>"f1e/x/y"</js>),
				URI.<jsm>create</jsm>(<js>""</js>),
				URI.<jsm>create</jsm>(<js>"context:/f2a/x"</js>),
				URI.<jsm>create</jsm>(<js>"context:/f2b"</js>),
				URI.<jsm>create</jsm>(<js>"context:/"</js>),
				URI.<jsm>create</jsm>(<js>"context:/.."</js>),
				URI.<jsm>create</jsm>(<js>"servlet:/f3a/x"</js>),
				URI.<jsm>create</jsm>(<js>"servlet:/f3b"</js>),
				URI.<jsm>create</jsm>(<js>"servlet:/"</js>),
				URI.<jsm>create</jsm>(<js>"servlet:/.."</js>),
				URI.<jsm>create</jsm>(<js>"request:/f4a/x"</js>),
				URI.<jsm>create</jsm>(<js>"request:/f4b"</js>),
				URI.<jsm>create</jsm>(<js>"request:/"</js>),
				URI.<jsm>create</jsm>(<js>"request:/.."</js>)
			};
		}
	}	
	</p>
	<p>
		When requested as JSON, it produces the following result:
	</p>
	<p class='bjson'>
	{
		<jok>f1a</jok>:<jov>'http://www.apache.org/f1a'</jov>,
		<jok>f1b</jok>:<jov>'http://foo.com:123/f1b'</jov>,
		<jok>f1c</jok>:<jov>'http://foo.com:123/f1c/x/y'</jov>,
		<jok>f1d</jok>:<jov>'http://foo.com:123/myContext/myServlet/f1d'</jov>,
		<jok>f1e</jok>:<jov>'http://foo.com:123/myContext/myServlet/f1e/x/y'</jov>,
		<jok>f1f</jok>:<jov>'http://foo.com:123/myContext/myServlet'</jov>,
		<jok>f2a</jok>:<jov>'http://foo.com:123/myContext/f2a/x'</jov>,
		<jok>f2b</jok>:<jov>'http://foo.com:123/myContext/f2b'</jov>,
		<jok>f2c</jok>:<jov>'http://foo.com:123/myContext'</jov>,
		<jok>f2d</jok>:<jov>'http://foo.com:123'</jov>,
		<jok>f3a</jok>:<jov>'http://foo.com:123/myContext/myServlet/f3a/x'</jov>,
		<jok>f3b</jok>:<jov>'http://foo.com:123/myContext/myServlet/f3b'</jov>,
		<jok>f3c</jok>:<jov>'http://foo.com:123/myContext/myServlet'</jov>,
		<jok>f3d</jok>:<jov>'http://foo.com:123/myContext'</jov>,
		<jok>f4a</jok>:<jov>'http://foo.com:123/myContext/myServlet/myPath/f4a/x'</jov>,
		<jok>f4b</jok>:<jov>'http://foo.com:123/myContext/myServlet/myPath/f4b'</jov>,
		<jok>f4c</jok>:<jov>'http://foo.com:123/myContext/myServlet/myPath'</jov>,
		<jok>f4d</jok>:<jov>'http://foo.com:123/myContext/myServlet'</jov>
	}
	</p>
	<p>
		URI resolution is controlled by the following settings:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriAuthority(String) uriAuthority(String)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriContext(String) uriContext(String)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriRelativity(UriRelativity) uriRelativity(UriRelativity)}
				<li class='jm'>{@link org.apache.juneau.rest.RestContext.Builder#uriResolution(UriResolution) uriResolution(UriResolution)}
			</ul>
		</li>	
	</ul>
	
	<p>
		URIs are resolved by both regular and part serializers.
	</p>
</div>
</div><!-- END: 8.26 - jrs.SerializingUris -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.UtilityBeans' id='jrs.UtilityBeans'>8.27 - Utility Beans</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.27 - jrs.UtilityBeans -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.beans} package contains a set of reusable utility beans meant to help with putting together
		explorable REST interfaces.
	</p>
	<p>
		The {@link org.apache.juneau.examples.rest.UtilityBeansResource} class shows how these beans are used.
		The resource class is hosted in the example REST applications rendered below:
	</p>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.png'>
	
	<h5 class='topic'>ResourceDescriptions</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.UtilityBeansResource#getChildDescriptions() getChildDescriptions()} method shows an example
		of rendering a list of descriptive links for child endpoints.
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/"</js>)
	<jk>public</jk> ResourceDescriptions getChildDescriptions() {
		<jk>return</jk> ResourceDescriptions
			.<jsm>create</jsm>()
			.append(<js>"BeanDescription"</js>, <js>"Example of BeanDescription bean"</js>)
			.append(<js>"Hyperlink"</js>, <js>"Example of Hyperlink bean"</js>)
			.append(<js>"SeeOtherRoot"</js>, <js>"Example of SeeOtherRoot bean"</js>);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.json.png'>
	
	<h5 class='topic'>BeanDescription</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.UtilityBeansResource#aBeanDescription() aBeanDescription()} method shows an example
		of rendering simple schema information about an arbitrary bean class.
	</p>
		
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/BeanDescription"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized org.apache.juneau.rest.utilitybeans.ResourceDescriptions bean.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public</jk> BeanDescription aBeanDescription() {
		<jk>return</jk> BeanDescription.<jsm>of</jsm>(Address.<jk>class</jk>);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.BeanDescription.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.BeanDescription.json.png'>
	
	<h5 class='topic'>Hyperlink</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.UtilityBeansResource#aHyperlink() aHyperlink()} method shows an example
		of rendering a simple hyperlink.
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/Hyperlink"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized org.apache.juneau.rest.utilitybeans.Hyperlink bean.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public</jk> Hyperlink aHyperlink() {
		<jk>return</jk> Hyperlink.<jsm>create</jsm>(<js>"/utilitybeans"</js>, <js>"Back to /utilitybeans"</js>);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.Hyperlink.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.Hyperlink.json.png'>
	
	<h5 class='topic'>SeeOtherRoot</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.UtilityBeansResource#aSeeOtherRoot() aSeeOtherRoot()} method shows an example
		of sending a <c>303 See Other</c> with a <c>Location</c> header pointing to the servlet root.
	</p>
	<p class='bjava'>
	<ja>@RestGet</ja>(<js>"/SeeOtherRoot"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized org.apache.juneau.rest.utilitybeans.SeeOtherRoot bean.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public</jk> SeeOtherRoot aSeeOtherRoot() {
		<jk>return</jk> SeeOtherRoot.<jsf>INSTANCE</jsf>;
	}
	</p>
	
	<p>
		Clicking on the link will just redirect to this same page. 
	</p>
	<img class='bordered w800' src='doc-files/jrs.UtilityBeans.png'>
	
	<p>
		Typically this is useful for endpoints where you want to redirect back to the servlet root, such as a DELETE.
	</p>
	
</div>
</div><!-- END: 8.27 - jrs.UtilityBeans -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.HtmlBeans' id='jrs.HtmlBeans'>8.28 - Using with HTML Beans</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 8.28 - jrs.HtmlBeans -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.examples.rest.HtmlBeansResource} class shows how {@link org.apache.juneau.dto.html5 HTML5 beans} can be
		used to generate arbitrary HTML on REST endpoints.
	</p>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.png'>
	
	<h5 class='topic'>table</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.HtmlBeansResource#aTable() aTable()} method shows an example
		of rendering an HTML table.
	</p>
		
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestGet</ja>(<js>"/table"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized table.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public</jk> Table aTable() {
		<jk>return</jk> <jsm>table</jsm>(
			<jsm>tr</jsm>(
				<jsm>th</jsm>(<js>"c1"</js>),
				<jsm>th</jsm>(<js>"c2"</js>)
			),
			<jsm>tr</jsm>(
				<jsm>td</jsm>(<js>"v1"</js>),
				<jsm>td</jsm>(<js>"v2"</js>)
			)
		);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.table.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.table.json.png'>
	
	<h5 class='topic'>div</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.HtmlBeansResource#aDiv() aDiv()} method shows an example
		of rendering a div tag with mixed content.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestGet</ja>(<js>"/div"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized div tag.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public</jk> HtmlElement aDiv() {
		<jk>return</jk> <jsm>div</jsm>()
			.children(
				<jsm>p</jsm>(<js>"Juneau supports "</js>, <jsm>b</jsm>(<jsm>i</jsm>(<js>"mixed"</js>)), <js>" content!"</js>)
			)
			.onmouseover(<js>"alert(\"boo!\");"</js>);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.div.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.div.json.png'>
	
	<h5 class='topic'>form</h5>
	<p>
		The {@link org.apache.juneau.examples.rest.HtmlBeansResource#aForm() aForm()} method shows an example
		of rendering an HTML form.
	</p>
	<p class='bjava'>
	<jk>import static</jk> org.apache.juneau.dto.html5.HtmlBuilder.*;
	
	<ja>@RestGet</ja>(<js>"/form"</js>)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;Example of serialized HTML form.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public Form</jk> aForm() {
		<jk>return</jk> <jsm>form</jsm>().action(<js>"/submit"</js>).method(<js>"POST"</js>)
			.children(
				<js>"Position (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"pos"</js>).value(1), <jsm>br</jsm>(),
				<js>"Limit (1-10000): "</js>, <jsm>input</jsm>(<js>"number"</js>).name(<js>"limit"</js>).value(100), <jsm>br</jsm>(),
				<jsm>button</jsm>(<js>"submit"</js>, <js>"Submit"</js>),
				<jsm>button</jsm>(<js>"reset"</js>, <js>"Reset"</js>)
			);
	}
	</p>
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.form.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrs.HtmlBeans.form.json.png'>
	
</div>
</div><!-- END: 8.28 - jrs.HtmlBeans -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrs.OtherNotes' id='jrs.OtherNotes'>8.29 - Other Notes</a></h3>
<div class='topic'><!-- START: 8.29 - jrs.OtherNotes -->
<div class='topic'>
	<ul class='notes'>
		<li class='note'>
			Subclasses can use either {@link javax.servlet.http.HttpServlet#init(ServletConfig)} 
			or {@link javax.servlet.http.HttpServlet#init()} for initialization just like any other servlet.
		<li class='note'>
			The <l>X-Response-Headers</l> header can be used to pass through header values into the response.
			The value should be a URL-encoded map of key-value pairs.
			For example, to add a <l>"Refresh: 1"</l> header to the response to auto-refresh a page, the following 
			parameter can be specified:  <l>"/sample?X-Response-Headers={Refresh=1}"</l>
	</ul>
</div>
</div><!-- END: 8.29 - jrs.OtherNotes -->
</div><!-- END: 8 - juneau-rest-server -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-rest-server-springboot' id='juneau-rest-server-springboot'>9 - juneau-rest-server-springboot</a><span class='update'>created: 8.0.0, updated: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 9 - juneau-rest-server-springboot -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-rest-server-springboot<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-rest-server-springboot-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.rest.server.springboot_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The <c>juneau-rest-server-springboot</c> library provides classes to make it easy to integrate
		Juneau REST resources with Spring and Spring Boot.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrss.Overview' id='jrss.Overview'>9.1 - Overview</a><span class='update'>created: 8.0.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 9.1 - jrss.Overview -->
<div class='topic'>
	<p>
		The Juneau REST servlet APIs are designed to work seemlessly with the Spring Boot framework.
		The only restriction is that your top-level REST resource must extend from one of the following classes:
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.rest.springboot}
		<ul class='javatree'>
			<li class='jc'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} - Basic servlet
			<li class='jc'>{@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup} - Basic servlet group
		</ul>
	</ul>
	<p>
		These classes are the equivalent to the {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestServletGroup}
		except they hook into the injection framework of Spring Boot to provide resolution of beans (e.g. child resources, various
		configuration classes).
	</p>
	<p>
		The <c>org.apache.juneau.examples.rest.springboot</c> package and <c>org.apache.juneau.examples.rest.springboot.App</c> 
		application are a basic Spring Boot application that shows off simple Juneau examples including injection beans.
	</p>	
	<p class='bjava'>
	<ja>@SpringBootApplication</ja>
	<ja>@Controller</ja>
	<jk>public class</jk> App {
	
		<jc>//Entry point method.</jc>
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			<jk>new</jk> SpringApplicationBuilder(App.<jk>class</jk>).run(<jv>args</jv>);
		}
	
		<jc>// Our root REST bean.
		// Note that this must extend from {@link org.apache.juneau.rest.springboot.SpringRestServlet} to allow use of injection.
		// All REST objects are attached to this bean using the {@link org.apache.juneau.rest.annotation.Rest#children()} annotation.</jc>
		<ja>@Bean</ja>
		<jk>public</jk> RootResources getRootResources() {
			<jk>return new</jk> RootResources();
		}
	
		<jc>// Registers our REST bean at the URI root.</jc>
		<ja>@Bean</ja>
		<jk>public</jk> ServletRegistrationBean&lt;Servlet&gt; getRootServlet(RootResources <jv>rootResources</jv>) {
			<jk>return new</jk> ServletRegistrationBean&lt;&gt;(<jv>rootResources</jv>, <js>"/*"</js>);
		}
	
		<jc>// Injected child resource.</jc>
		<ja>@Bean</ja>
		<jk>public</jk> HelloWorldResource getHelloWorldResource() {
			<jk>return new</jk> HelloWorldResource();
		}
	
		<jc>// Injected child bean used in injected child resource.</jc>
		<ja>@Bean</ja>
		<jk>public</jk> HelloWorldMessageProvider getHelloWorldMessageProvider() {
			<jk>return new</jk> HelloWorldMessageProvider(<js>"Hello Spring injection user!"</js>);
		}
	}
	</p>	
	<p>
		Our root resource servlet serves as a router page.  It is defined as follows:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		title=<js>"Root resources"</js>,
		description=<js>"Example of a router resource page."</js>,
		children={
			HelloWorldResource.<jk>class</jk>,
			DtoExamples.<jk>class</jk>,
			UtilityBeansResource.<jk>class</jk>,
			HtmlBeansResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			ShutdownResource.<jk>class</jk>
		}
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"api: servlet:/api"</js>,
			<js>"stats: servlet:/stats"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/$R{servletClassSimple}.java"</js>
		},
		aside={
			<js>"&lt;div class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This is an example of a 'router' page that serves as a jumping-off point to child resources.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Resources can be nested arbitrarily deep through router pages.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Note the &lt;span class='link'&gt;API&lt;/span&gt; link provided that lets you see the generated swagger doc for this page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;STATS&lt;/span&gt; link that provides basic usage statistics.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;SOURCE&lt;/span&gt; link on these pages to view the source code for the page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;All content on pages in the UI are serialized POJOs.  In this case, it's a serialized array of beans with 2 properties, 'name' and 'description'.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Other features (such as this aside) are added through annotations.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		},
		asideFloat=<js>"RIGHT"</js>
	)
	<ja>@SerializerConfig</ja>(
		quoteChar=<js>"'"</js>
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicSpringRestServletGroup {
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L;
	}
	</p>	
	
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrss.Overview.RootResources.png'>
	
	<h5 class='figure'>JSON representation</h5>
	<img class='bordered w800' src='doc-files/jrss.Overview.RootResources.json.png'>
	
	<p>
		The <c>org.apache.juneau.examples.rest.springboot.HelloWorldResource</c> class shows an example of a child resource
		defined as an injected bean.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		title=<js>"Hello World"</js>,
		description=<js>"An example of the simplest-possible resource"</js>,
		path=<js>"/helloWorld"</js>
	)
	<ja>@HtmlDocConfig</ja>(
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a resource that simply response with a 'Hello world!' message&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;The POJO serialized is a simple String.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestObject {
	
		<ja>@Autowired</ja>
		<jk>private</jk> HelloWorldMessageProvider <jf>messageProvider</jf>;
	
		<ja>@RestGet</ja>(path=<js>"/*"</js>, summary=<js>"Responds with injected message"</js>)
		<jk>public</jk> String sayHello() {
			<jk>return</jk> <jf>messageProvider</jf>.get();
		}
	}
	</p>
	
	<p>
		Note that the message rendered is coming from our injected message provider:
	</p>
	<h5 class='figure'>HTML representation</h5>
	<img class='bordered w800' src='doc-files/jrss.Overview.HelloWorldResource.png'>
	
</div>
</div><!-- END: 9.1 - jrss.Overview -->
</div><!-- END: 9 - juneau-rest-server-springboot -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-rest-client' id='juneau-rest-client'>10 - juneau-rest-client</a><span class='update'>updated: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 10 - juneau-rest-client -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-rest-client<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-rest-client-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.rest.client_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		Built upon the feature-rich Apache HttpClient library, the Juneau RestClient API adds support for fluent-style
		REST calls and the ability to perform marshalling of POJOs to and from HTTP parts.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON support and download a bean.</jc>
	MyBean <jv>bean</jv> = RestClient.<jsm>create</jsm>()
		.json5()
		.build()
		.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(200)
		.assertHeader(<js>"Content-Type"</js>).matchesSimple(<js>"application/json*"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
	
	<p>
		Breaking apart the fluent call, we can see the classes being used:
	</p>
	
	<p class='bjava'>
	RestClient.Builder <jv>builder</jv> = RestClient.<jsm>create</jsm>().json5();
	RestClient <jv>client</jv> = <jv>builder</jv>.build();
	RestRequest <jv>req</jv> = <jv>client</jv>.get(<jsf>URI</jsf>);
	RestResponse <jv>res</jv> = <jv>req</jv>.run();
	RestResponseStatusLineAssertion <jv>statusLineAssertion</jv> = <jv>res</jv>.assertStatus();
	FluentIntegerAssertion&lt;RestResponse&gt; <jv>codeAssertion</jv> = <jv>statusLineAssertion</jv>.asCode();
	<jv>res</jv> = <jv>codeAssertion</jv>.is(200);
	FluentStringAssertion&lt;RestResponse&gt; <jv>headerAssertion</jv> = <jv>res</jv>.assertHeader(<js>"Content-Type"</js>);
	<jv>res</jv> = <jv>headerAssertion</jv>.matchesSimple(<js>"application/json*"</js>);
	ResponseContent <jv>content</jv> = <jv>res</jv>.getContent();
	MyBean <jv>bean</jv> = <jv>content</jv>.as(MyBean.<jk>class</jk>);
	</p>
	
	<p>
		It additionally provides support for creating remote proxy interfaces using REST as the transport medium.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Define a Remote proxy for interacting with a REST interface.</jc>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {
	
		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		Pet addPet(
			<ja>@Content</ja> CreatePet <jv>pet</jv>,
			<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>,
			<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
		);
	}

	PetStore <jv>store</jv> = RestClient
		.<jsm>create</jsm>()
		.json5()
		.build()
		.getRemote(PetStore.<jk>class</jk>, <js>"http://localhost:10000"</js>);
	CreatePet <jv>createPet</jv> = <jk>new</jk> CreatePet(<js>"Fluffy"</js>, 9.99);
	Pet <jv>pet</jv> = <jv>store</jv>.addPet(<jv>createPet</jv>, UUID.<jsm>randomUUID</jsm>(), <jk>true</jk>);
	</p>
	
	<p>
		The classes are closely tied to Apache HttpClient, yet provide lots of additional functionality:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient} <jk>implements</jk> {@link org.apache.http.client.HttpClient}, creates {@link org.apache.juneau.rest.client.RestRequest} objects.
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest} <jk>implements</jk> {@link org.apache.http.client.methods.HttpUriRequest}, creates {@link org.apache.juneau.rest.client.RestResponse} objects.
		<li class='jc'>{@link org.apache.juneau.rest.client.RestResponse} <jk>implements</jk> {@link org.apache.http.HttpResponse}, creates {@link org.apache.juneau.rest.client.ResponseContent} and {@link org.apache.juneau.rest.client.ResponseHeader} objects.
		<li class='jc'>{@link org.apache.juneau.rest.client.ResponseContent} <jk>implements</jk> {@link org.apache.http.HttpEntity}
	</ul>
	
	<p>
		Instances of this class are built using the {@link org.apache.juneau.rest.client.RestClient.Builder} class which can be constructed using
		the {@link org.apache.juneau.rest.client.RestClient#create() RestClient.create()} method as shown above.
	</p>
	<p>
		Clients are typically created with a root URI so that relative URIs can be used when making requests.
		This is done using the {@link org.apache.juneau.rest.client.RestClient.Builder#rootUrl(Object)} method.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client where all URIs are relative to localhost.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json().rootUrl(<js>"http://localhost:10000"</js>).build();

	<jc>// Use relative paths.</jc>
	String <jv>content</jv> = <jv>client</jv>.get(<js>"/subpath"</js>).run().getContent().asString();
	</p>
	
	<p>
		The {@link org.apache.juneau.rest.client.RestClient} class creates {@link org.apache.juneau.rest.client.RestRequest} objects using the following methods:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient}
			<ul>
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#get(Object) get(uri)} / {@link org.apache.juneau.rest.client.RestClient#get() get()}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#put(Object,Object) put(uri,body)} / {@link org.apache.juneau.rest.client.RestClient#put(Object) put(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#post(Object) post(uri,body)} / {@link org.apache.juneau.rest.client.RestClient#post(Object) post(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#patch(Object,Object) patch(uri,body)} / {@link org.apache.juneau.rest.client.RestClient#patch(Object) patch(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#delete(Object) delete(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#head(Object) head(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#options(Object) options(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#formPost(Object,Object) formPost(uri,body)} / {@link org.apache.juneau.rest.client.RestClient#formPost(Object) formPost(uri)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#formPostPairs(Object,String...) formPostPairs(uri,parameters...)}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestClient#request(String,Object,Object) request(method,uri,body)}
			</ul>
		</li>
	</ul>
	 
	<p>
		The {@link org.apache.juneau.rest.client.RestRequest} class creates {@link org.apache.juneau.rest.client.RestResponse} objects using the following methods:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest}
			<ul>
				<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#run() run()}
				<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#complete() complete()}
			</ul>
		</li>
	</ul>
	
	<p>
		The distinction between the two methods is that {@link org.apache.juneau.rest.client.RestRequest#complete() complete()} automatically consumes the response body and
		{@link org.apache.juneau.rest.client.RestRequest#run() run()} does not.  Note that you must consume response bodies in order for HTTP connections to be freed up
		for reuse!  The {@link java.io.InputStream InputStreams} returned by the {@link org.apache.juneau.rest.client.ResponseContent} object are auto-closing once
		they are exhausted, so it is often not necessary to explicitly close them.
	</p>
	
	<p>
		The following examples show the distinction between the two calls:
	</p>
	
	<p class='bjava'>
	<jc>// Consuming the response, so use run().</jc>
	String <jv>content</jv> = <jv>client</jv>.get(<jsf>URI</jsf>).run().getContent().asString();

	<jc>// Only interested in response status code, so use complete().</jc>
	<jk>int</jk> <jv>status</jv> = <jv>client</jv>.get(<jsf>URI</jsf>).complete().getStatusCode();
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.PojoMarshalling' id='jrc.PojoMarshalling'>10.1 - POJO Marshalling</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.1 - jrc.PojoMarshalling -->
<div class='topic'>
	<p>
		By default, JSON support is provided for HTTP request and response bodies.
		Other languages can be specified using any of the following builder methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#json() json()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#json5() json5()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#xml() xml()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#html() html()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#plainText() plainText()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#msgPack() msgPack()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#uon() uon()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#urlEnc() urlEnc()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#openApi() openApi()}
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON 5 support.</jc>
	<jc>// Typically easier to use when performing unit tests.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json5().build();
	</p>
	
	<p>
		Clients can also support multiple languages:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a REST client with support for multiple languages.</jc>
	RestClient <jv>client1</jv> = RestClient.<jsm>create</jsm>().json().xml().openApi().build();

	<jc>// Create a REST client with support for all supported languages.</jc>
	RestClient <jv>client2</jv> = RestClient.<jsm>create</jsm>().universal().build();
	</p>
	
	<p>
		When using clients with multiple language support, the request language is selected by setting the <c>Content-Type</c> 
		request header.
	</p>
	<p class='bjava'>
	<jc>// Create a REST client with support for multiple languages.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().universal().build();

	<jv>client</jv>.post(<jsf>URI</jsf>, myBean)
		.contentType(<js>"application/json"</js>)
		.complete()
		.assertStatus().asCode().is(200);
	</p>
	
	<p>
		Languages can also be specified per-request.
	</p>
	<p class='bjava'>
	<jc>// Create a REST client with no default languages supported.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().build();

	<jc>// Use JSON for this request.</jc>
	<jv>client</jv>.post(<jsf>URI</jsf>, myBean)
		.json()
		.complete()
		.assertStatus().asCode().is(200);
	</p>
	
	<p>
		The {@link org.apache.juneau.rest.client.RestClient.Builder} class provides convenience methods for setting common serializer and parser
		settings.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a basic REST client with JSON support.</jc>
	<jc>// Use single-quotes and whitespace.</jc>
	RestClient <jv>client1</jv> = RestClient.<jsm>create</jsm>().json().sq().ws().build();
	</p>
	
	<p>
		Other methods are also provided for specifying the serializers and parsers used for lower-level marshalling support:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#serializer(Serializer) serializer(Serializer)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#parser(Parser) parser(Parser)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#marshaller(Marshaller) marshaller(Marshaller)}
		</ul>
	</ul>
	
	<p>
		HTTP parts (headers, query parameters, form data...) are serialized and parsed using the {@link org.apache.juneau.httppart.HttpPartSerializer}
		and {@link org.apache.juneau.httppart.HttpPartParser} APIs.  By default, clients are configured to use {@link org.apache.juneau.oapi.OpenApiSerializer} and
		{@link org.apache.juneau.oapi.OpenApiParser}.  These can be overridden using the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#partSerializer(Class) partSerializer(Class&lt;? extends HttpPartSerializer>)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#partParser(Class) partParser(Class&lt;? extends HttpPartParser>)}
		</ul>
	</ul>
</div>
</div><!-- END: 10.1 - jrc.PojoMarshalling -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.RequestParts' id='jrc.RequestParts'>10.2 - Request Parts</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.2 - jrc.RequestParts -->
<div class='topic'>
	<p>
		Per-client or per-request HTTP parts (headers, query/form data, path parameters) can be manipulated via the following methods
		that return back builders for those parts:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#headers() headers()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#formData() formData()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#queryData() queryData()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#pathData() pathData()}
		</ul>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#getHeaders() getHeaders()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#getFormData() getFormData()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#getQueryData() getQueryData()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#getPathData() getPathData()}
		</ul>
	</ul>
	<p>
		Convenience methods are also provided for quickly adding parts:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#header(String,String) header(String,String)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#header(String,Supplier) header(String,Supplier&lt;String&gt;)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#headers(Header...) headers(Header...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#headersDefault(Header...) headersDefault(Header...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#formData(NameValuePair...) formData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#formData(String,String) formData(String,String)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#formData(String,Supplier) formData(String,Supplier&lt;String&gt;)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#formDataDefault(NameValuePair...) formDataDefault(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#queryData(NameValuePair...) queryData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#queryData(String,String) queryData(String,String)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#queryData(String,Supplier) queryData(String,Supplier&lt;String&gt;)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#queryDataDefault(NameValuePair...) queryDataDefault(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#pathData(NameValuePair...) pathData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#pathData(String,String) pathData(String,String)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#pathData(String,Supplier) pathData(String,Supplier&lt;String&gt;)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#pathDataDefault(NameValuePair...) pathDataDefault(NameValuePair...)}
		</ul>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest}
		<ul class='javatreec'>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#header(Header) header(Header)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#header(String,Object) header(String,Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#headerPairs(String...) headerPairs(String...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#headers(Header...) headers(Header...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#headersBean(Object) headersBean(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#formData(NameValuePair...) formData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#formData(String,Object) formData(String,Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#formDataBean(Object) formDataBean(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#formDataCustom(Object) formDataCustom(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#formDataPairs(String...) formDataPairs(String...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#queryData(NameValuePair...) queryData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#queryData(String,Object) queryData(String,Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#queryDataBean(Object) queryDataBean(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#queryDataPairs(String...) queryDataPairs(String...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#pathData(NameValuePair...) pathData(NameValuePair...)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#pathData(String,Object) pathData(String,Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#pathDataBean(Object) pathDataBean(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#pathDataPairs(String...) pathDataPairs(String...)}
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client that adds a "Foo: bar" header to every request.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().header(<js>"Foo"</js>,<js>"bar"</js>).build();

	<jc>// Or do it on every request.</jc>
	String <jv>response</jv> = <jv>client</jv>.get(<jsf>URI</jsf>).header(<js>"Foo"</js>,<js>"bar"</js>).run().getContent().asString();
	</p>
	
	<p>
		The supplier methods are particularly useful for header values whose values may change over time (such as <c>Authorization</c> headers
		which may need to change every few minutes).
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client that adds a dynamic Authorization header to every request.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().header(<js>"Authorization"</js>, ()-&gt;getMyAuthToken()).build();
	</p>
	
	<ul class='seealso'>
		<li class='jp'>{@link org.apache.juneau.http.header} - Predefined {@link org.apache.http.Header} beans.
	</ul>
</div>
</div><!-- END: 10.2 - jrc.RequestParts -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.RequestContent' id='jrc.RequestContent'>10.3 - Request Content</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.3 - jrc.RequestContent -->
<div class='topic'>
	<p>
		The request body can either be passed in with the client creator method (e.g. {@link org.apache.juneau.rest.client.RestClient#post(Object,Object) post(uri,body)}),
		or can be specified via the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#content(Object) content(Object)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#content(Object,HttpPartSchema) content(Object,HttpPartSchema)}
		</ul>
	</ul>
	
	<p>
		The request body can be any of the following types:
	</p>
	<ul class='javatree'>
		<li class='jc'>
			{@link java.lang.Object} - POJO to be converted to text using the {@link org.apache.juneau.serializer.Serializer} defined on the client or request.
		<li class='jc'>
			{@link java.io.Reader} - Raw contents of {@code Reader} will be serialized to remote resource.
		<li class='jc'>
			{@link java.io.InputStream} - Raw contents of {@code InputStream} will be serialized to remote resource.
		<li class='jc'>
			{@link org.apache.http.HttpEntity} - Bypass Juneau serialization and pass HttpEntity directly to HttpClient.
		<li class='jc'>
			{@link org.apache.juneau.http.part.PartList} - Converted to a URL-encoded FORM post.
		<li class='jc'>
			{@link java.util.function.Supplier} - A supplier of anything on this list.
	</ul>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Create a client with JSON 5 support.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json5().build();
	
	<jc>// Post a JSON-serialized bean.</jc>
	<jv>client</jv>
		.post(<jsf>URI</jsf>)
		.content(<jv>bean</jv>)
		.complete()
		.assertStatus().asCode().is(200);
	
	<jc>// Post contents from a reader.</jc>
	<jv>client</jv>
		.post(<jsf>URI</jsf>)
		.content(<jk>new</jk> FileReader(<js>"/tmp/foo.json"</js>))
		.complete()
		.assertStatus().asCode().is(200);
	
	<jc>// Post contents from an Apache HttpEntity object.</jc>
	<jv>client</jv>
		.post(<jsf>URI</jsf>)
		.content(<jk>new</jk> StringEntity(<jv>jsonString</jv>, ContentType.<jsf>APPLICATION_JSON</jsf>))
		.complete()
		.assertStatus().asCode().is(200);
	</p>
	
	<ul class='notes'>
		<li class='note'>If the serializer on the client or request is explicitly set to <jk>null</jk>, POJOs will be converted to strings
			using the registered part serializer as content type <js>"text/plain</js>.  If the part serializer is also <jk>null</jk>,
			POJOs will be converted to strings using {@link org.apache.juneau.ClassMeta#toString(Object)} which typically just calls {@link java.lang.Object#toString()}.
	</ul>
</div>
</div><!-- END: 10.3 - jrc.RequestContent -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.ResponseStatus' id='jrc.ResponseStatus'>10.4 - Response Status</a><span class='update'>created: 8.1.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.4 - jrc.ResponseStatus -->
<div class='topic'>
	<p>
		After execution using {@link org.apache.juneau.rest.client.RestRequest#run()} or {@link org.apache.juneau.rest.client.RestRequest#complete()}, the following methods can be used
		to get the response status:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestResponse}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getStatusLine() getStatusLine()} <jk>returns</jk> {@link org.apache.http.StatusLine}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getStatusCode() getStatusCode()} <jk>returns</jk> <jk>int</jk></c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getReasonPhrase() getReasonPhrase()} <jk>returns</jk> String</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#assertStatus() assertStatus()} <jk>returns</jk> {@link org.apache.juneau.rest.client.assertion.FluentResponseStatusLineAssertion}</c>
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Only interested in status code.</jc>
	<jk>int</jk> <jv>statusCode</jv> = <jv>client</jv>.get(<jsf>URI</jsf>).complete().getStatusCode();
	</p>
	
	<p>
		Equivalent methods with mutable parameters are provided to allow access to status values without breaking fluent call chains.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Interested in multiple values.</jc>
	Value&lt;Integer&gt; <jv>statusCode</jv> = Value.<jsm>empty</jsm>();
	Value&lt;String&gt; <jv>reasonPhrase</jv> = Value.<jsm>empty</jsm>();
	
	<jv>client</jv>.get(<jsf>URI</jsf>).complete().getStatusCode(<jv>statusCode</jv>).getReasonPhrase(<jv>reasonPhrase</jv>);
	System.<jsf>err</jsf>.println(<js>"statusCode="</js>+<jv>statusCode</jv>.get()+<js>", reasonPhrase="</js>+<jv>reasonPhrase</jv>.get());
	</p>
	
	<ul class='notes'>
		<li class='note'>If you are only interested in the response status and not the response body, be sure to use {@link org.apache.juneau.rest.client.RestRequest#complete()} instead
			of {@link org.apache.juneau.rest.client.RestRequest#run()} to make sure the response body gets automatically cleaned up.  Otherwise you must
			consume the response yourself.
	</ul>
	
	<p>
		The assertion method is provided for quickly asserting status codes in fluent calls.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Status assertion using a static value.</jc>
	String <jv>content1</jv> = <jv>client</jv>.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().isBetween(200,399)
		.getContent().asString();

	<jc>// Status assertion using a predicate.</jc>
	String <jv>content2</jv> = <jv>client</jv>.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(<jv>x</jv> -&gt; <jv>x</jv>&lt;400)
		.getContent().asString();
	</p>
</div>
</div><!-- END: 10.4 - jrc.ResponseStatus -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.ResponseHeaders' id='jrc.ResponseHeaders'>10.5 - Response Headers</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.5 - jrc.ResponseHeaders -->
<div class='topic'>
	<p>
		Response headers are accessed through the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestResponse}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getHeader(String) getHeader(String)} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getHeaders(String) getHeaders(String)} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseHeader}[]</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getFirstHeader(String) getFirstHeader(String)} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getLastHeader(String) getLastHeader(String)} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getAllHeaders() getAllHeaders()} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseHeader}[]</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getStringHeader(String) getStringHeader(String)} <jk>returns</jk> String</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#containsHeader(String) containsHeader(String)} <jk>returns</jk> <jk>boolean</jk></c>
		</ul>
	</ul>
	
	<p>
		Unlike {@link org.apache.juneau.rest.client.RestResponse#getFirstHeader(String)} and {@link org.apache.juneau.rest.client.RestResponse#getLastHeader(String)}, the {@link org.apache.juneau.rest.client.RestResponse#getHeader(String)}
		method returns an empty {@link org.apache.juneau.rest.client.ResponseHeader} object instead of returning <jk>null</jk>.
		This allows it to be used more easily in fluent calls.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	RestResponse <jv>res</jv> = <jv>client</jv>.get(<jsf>URI</jsf>).complete();
	ResponseHeader <jv>header</jv> = <jv>res</jv>.getHeader(<js>"Location"</js>);

	<jc>// See if response contains Location header.</jc>
	<jk>boolean</jk> <jv>hasLocationHeader</jv> = <jv>header</jv>.isPresent();

	<jc>// Get actual value if it exists.</jc>
	<jk>String</jk> <jv>locationHeader1</jv> = <jv>header</jv>.orElse(<js>"http://localhost"</js>);

	<jc>// Converted to object.</jc>
	<jk>URI</jk> <jv>locationHeader2</jv> = <jv>header</jv>.as(URI.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	
	<p>
		The {@link org.apache.juneau.rest.client.ResponseHeader} class extends from the HttpClient {@link org.apache.http.Header} class and provides several convenience
		methods:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.ResponseHeader}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#isPresent() isPresent()} <jk>returns</jk> <jk>boolean</jk></c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asString() asString()} <jk>returns</jk> String</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#as(Type,Type...) as(Type,Type...)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#as(Class) as(Class&lt;T&gt;)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asMatcher(Pattern) asMatcher(Pattern)} <jk>returns</jk> {@link java.util.regex.Matcher}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asMatcher(String) asMatcher(String)} <jk>returns</jk> {@link java.util.regex.Matcher}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asHeader(Class) asHeader(Class&lt;T <jk>extends</jk> BasicHeader&gt; c)} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asStringHeader() asStringHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicIntegerHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asIntegerHeader() asIntegerHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicStringHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asLongHeader() asLongHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicLongHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asDateHeader() asDateHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicDateHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asCsvHeader() asCsvHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicCsvHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asEntityTagsHeader() asEntityTagsHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicEntityTagsHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asStringRangesHeader() asStringRangesHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicStringRangesHeader}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#asUriHeader() asUriHeader()} <jk>returns</jk> {@link org.apache.juneau.http.header.BasicUriHeader}</c>
		</ul>
	</ul>
	
	<p>
		The {@link org.apache.juneau.rest.client.ResponseHeader#schema(HttpPartSchema)} method allows you to perform parsing of OpenAPI formats for
		header parts.
	</p>
		
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Parse the header "Foo: bar|baz".</jc>
	List&lt;String&gt; <jv>fooHeader</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.complete()
		.getHeader(<js>"Foo"</js>).schema(<jsf>T_ARRAY_PIPES</jsf>).as(List.<jk>class</jk>, String.<jk>class</jk>);
	</p>
	
	<p>
		Assertion methods are also provided for fluent-style calls:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.ResponseHeader}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#assertString() assertString()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentStringAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#assertInteger() assertInteger()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentIntegerAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#assertLong() assertLong()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentLongAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseHeader#assertZonedDateTime() assertZonedDateTime()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentZonedDateTimeAssertion}</c>
		</ul>
	</ul>
	
	<p>
		Note how in the following example, the fluent assertion returns control to the {@link org.apache.juneau.rest.client.RestResponse} object after
		the assertion has been completed:
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Assert the response content type is any sort of JSON.</jc>
	String <jv>content</jv> = <jv>client</jv>.get(<jsf>URI</jsf>)
		.run()
		.getHeader(<js>"Content-Type"</js>).assertString().matchesSimple(<js>"application/json*"</js>)
		.getContent().asString();
	</p>
</div>
</div><!-- END: 10.5 - jrc.ResponseHeaders -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.ResponseContent' id='jrc.ResponseContent'>10.6 - Response Content</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.6 - jrc.ResponseContent -->
<div class='topic'>
	<p>
		The response body is accessed through the following method:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestResponse}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestResponse#getContent() getContent()} <jk>returns</jk> {@link org.apache.juneau.rest.client.ResponseContent}</c>
		</ul>
	</ul>
	
	<p>
		The {@link org.apache.juneau.rest.client.ResponseContent} class extends from the HttpClient {@link org.apache.http.HttpEntity} class and provides several convenience
		methods:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.ResponseContent}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asInputStream() asInputStream()} <jk>returns</jk> InputStream</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asReader() asReader()} <jk>returns</jk> Reader</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asReader(Charset) asReader(Charset)} <jk>returns</jk> Reader</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#pipeTo(OutputStream) pipeTo(OutputStream)} <jk>returns</jk> {@link org.apache.juneau.rest.client.RestResponse}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#pipeTo(Writer) pipeTo(Writer)} <jk>returns</jk> {@link org.apache.juneau.rest.client.RestResponse}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#as(Type,Type...) as(Type,Type...)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#as(Class) as(Class&lt;T&gt;)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asFuture(Class) asFuture(Class&lt;T&gt;)} <jk>returns</jk> Future&lt;T&gt;</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asFuture(Type,Type...) asFuture(Type,Type...)} <jk>returns</jk> Future&lt;T&gt;</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asString() asString()} <jk>returns</jk> String</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asStringFuture() asStringFuture()} <jk>returns</jk> Future&lt;String&gt;</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asAbbreviatedString(int) asAbbreviatedString(int)} <jk>returns</jk> String</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asMatcher(Pattern) asMatcher(Pattern)} <jk>returns</jk> {@link java.util.regex.Matcher}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#asMatcher(String) asMatcher(String)} <jk>returns</jk> {@link java.util.regex.Matcher}</c>
		</ul>
	</ul>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Parse into a bean.</jc>
	MyBean <jv>bean</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(MyBean.<jk>class</jk>);

	<jc>// Parse into a linked-list of strings.</jc>
	List&lt;String&gt; <jv>list1</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(LinkedList.<jk>class</jk>, String.<jk>class</jk>);

	<jc>// Parse into a linked-list of beans.</jc>
	List&lt;MyBean&gt; <jv>list2</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(LinkedList.<jk>class</jk>, MyBean.<jk>class</jk>);

	<jc>// Parse into a linked-list of linked-lists of strings.</jc>
	List&lt;List&lt;String&gt;&gt; <jv>list3</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(LinkedList.<jk>class</jk>, LinkedList.<jk>class</jk>, String.<jk>class</jk>);

	<jc>// Parse into a map of string keys/values.</jc>
	Map&lt;String,String&gt; <jv>map1</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(TreeMap.<jk>class</jk>, String.<jk>class</jk>, String.<jk>class</jk>);

	<jc>// Parse into a map containing string keys and values of lists containing beans.</jc>
	Map&lt;String,List&lt;MyBean&gt;&gt; <jv>map2</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().as(TreeMap.<jk>class</jk>, String.<jk>class</jk>, List.<jk>class</jk>, MyBean.<jk>class</jk>);
	</p>
	
	<p>
		The response body can only be consumed once unless it has been cached into memory.  In many cases, the body is
		automatically cached when using the assertions methods or methods such as {@link org.apache.juneau.rest.client.ResponseContent#asString()}.
		However, methods that involve reading directly from the input stream cannot be called twice.
		In these cases, the {@link org.apache.juneau.rest.client.RestResponse#cacheContent()} and {@link org.apache.juneau.rest.client.ResponseContent#cache()} methods are provided
		to cache the response body in memory so that you can perform several operations against it.
	</p>
	
	<p class='bjava'>
	<jc>// Cache the response body so we can access it twice.</jc>
	InputStream <jv>inputStream</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.cacheContent()
		.getContent().pipeTo(<jv>someOtherStream</jv>)
		.getContent().asInputStream();
	</p>
	
	<p>
		Assertion methods are also provided for fluent-style calls:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.ResponseContent}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#assertString() assertString()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentStringAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#assertBytes() assertBytes()} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentByteArrayAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#assertObject(Class) assertObject(Class)} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentObjectAssertion}</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.ResponseContent#assertObject(Type,Type...) assertObject(Type,Type...)} <jk>returns</jk> {@link org.apache.juneau.assertions.FluentObjectAssertion}</c>
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Assert that the body contains the string "Success".</jc>
	String <jv>content</jv> = <jv>client</jv>
		.get(<jsf>URI</jsf>)
		.run()
		.getContent().assertString().contains(<js>"Success"</js>)
		.getContent().asString();
	</p>
	
	<p>
		Object assertions allow you to parse the response body into a POJO and then perform various tests on that resulting
		POJO.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Parse bean into POJO and then validate that it was parsed correctly.</jc>
	MyBean <jv>bean</jv> = <jv>client</jv>.get(<jsf>URI</jsf>)
		.run()
		.getContent().assertObject(MyBean.<jk>class</jk>).asJson().is(<js>"{foo:'bar'}"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
</div>
</div><!-- END: 10.6 - jrc.ResponseContent -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.CustomCallHandlers' id='jrc.CustomCallHandlers'>10.7 - Custom Call Handlers</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.7 - jrc.CustomCallHandlers -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.client.RestCallHandler} interface provides the ability to provide custom handling of requests.
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#callHandler(Class) callHandler(Class&lt;? extends RestCallHandler&gt;)}
		</ul>
		<li class='jic'>{@link org.apache.juneau.rest.client.RestCallHandler}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestCallHandler#run(HttpHost,HttpRequest,HttpContext) run(HttpHost,HttpRequest,HttpContext)} <jk>returns</jk> HttpResponse</c>
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Our custom call handler.</jc>
	<jk>public class</jk> MyRestCallHandler <jk>implements</jk> RestCallHandler {

		<jk>private final</jk> RestClient <jf>client</jf>;

		<jk>public</jk> MyRestCallHandler(RestClient <jv>client</jv>) {
			<jk>this</jk>.<jf>client</jf> = <jv>client</jv>;
		}

		<ja>@Override</ja>
		<jk>public</jk> HttpResponse run(HttpHost <jv>target</jv>, HttpRequest <jv>request</jv>, HttpContext <jv>context</jv>) <jk>throws</jk> IOException {
			<jc>// Insert any special handling here.</jc>
			<jc>// The following is the default behavior:</jc>
			<jk>if</jk> (<jv>target</jv> == <jk>null</jk>)
				<jk>return</jk> <jf>client</jf>.execute((HttpUriRequest)<jv>request</jv>, <jv>context</jv>);
			<jk>return</jk> <jf>client</jf>.execute(<jv>target</jv>, <jv>request</jv>, <jv>context</jv>);
		}
	}
	
	<jc>// Create a client that uses our custom handler.</jc>
	RestClient <jv>client</jv> = RestClient()
		.create()
		.json()
		.callHandler(MyCallHandler.<jk>class</jk>)
		.build();
	</p>
	 
	<p>
		Note that there are other ways of accomplishing this such as extending the {@link org.apache.juneau.rest.client.RestClient} class and overriding
		the {@link org.apache.juneau.rest.client.RestClient#run(HttpHost,HttpRequest,HttpContext)} method
		or by defining your own {@link org.apache.http.protocol.HttpRequestExecutor}.  Using this interface is often simpler though.
	</p>
</div>
</div><!-- END: 10.7 - jrc.CustomCallHandlers -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.Interceptors' id='jrc.Interceptors'>10.8 - Interceptors</a><span class='update'>created: 8.2.0</span></h3>
<div class='topic'><!-- START: 10.8 - jrc.Interceptors -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.client.RestCallInterceptor} API provides a quick way of intercepting and manipulating requests and responses beyond
		the existing {@link org.apache.http.HttpRequestInterceptor} and {@link org.apache.http.HttpResponseInterceptor} APIs.
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#interceptors(Object...) interceptors(Object...)}
		</ul>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestRequest}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestRequest#interceptors(RestCallInterceptor...) interceptors(RestCallInterceptor...)}
		</ul>
		<li class='jic'>{@link org.apache.juneau.rest.client.RestCallInterceptor}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestCallInterceptor#onInit(RestRequest) onInit(RestRequest)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestCallInterceptor#onConnect(RestRequest,RestResponse) onConnect(RestRequest,RestResponse)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestCallInterceptor#onClose(RestRequest,RestResponse) onClose(RestRequest,RestResponse)}
		</ul>
	</ul>
	
	<h5 class='section'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client with a customized interceptor.</jc>
	RestClient <jv>client</jv> = RestClient
		.<jsm>create</jsm>()
		.interceptors(
			<jk>new</jk> RestCallInterceptor() {

				<ja>@Override</ja>
				<jk>public void</jk> onInit(RestRequest <jv>req</jv>) <jk>throws</jk> Exception {
					<jc>// Intercept immediately after RestRequest object is created and all headers/query/form-data has been
					// set on the request from the client.</jc>
				}

				<ja>@Override</ja>
				<jk>public void</jk> onConnect(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) <jk>throws</jk> Exception {
					<jc>// Intercept immediately after an HTTP response has been received.</jc>
				}

				<ja>@Override</ja>
				<jk>public void</jk> onClose(RestRequest <jv>req</jv>, RestResponse <jv>res</jv>) <jk>throws</jk> Exception {
					<jc>// Intercept when the response body is consumed.</jc>
				}
			}
		)
		.build();
	</p>
</div>
</div><!-- END: 10.8 - jrc.Interceptors -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.Proxies' id='jrc.Proxies'>10.9 - REST Proxies</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.9 - jrc.Proxies -->
<div class='topic'>
	<p>
		One of the more powerful features of the REST client class is the ability to produce Java interface proxies against
		arbitrary 3rd party REST resources.
	</p>
	
	<p>
		The methods to retrieve remote interfaces are:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient}
		<ul>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestClient#getRemote(Class) getRemote(Class&lt;T&gt;)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestClient#getRemote(Class,Object) getRemote(Class&lt;T&gt;,Object)} <jk>returns</jk> T</c>
			<li class='jm'><c>{@link org.apache.juneau.rest.client.RestClient#getRemote(Class,Object,Serializer,Parser) getRemote(Class&lt;T&gt;,Object,Serializer,Parser)} <jk>returns</jk> T</c>
		</ul>
	</ul>
	
	<p>
		Annotations are used on the interface and interface methods to specify how to convert input and output to HTTP headers, query parameters, form 
		post parameters, or request/response bodies.
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.http.remote}
		<ul>
			<li class='ja'>{@link org.apache.juneau.http.remote.Remote} - Applied to interface class.
			<li class='ja'>{@link org.apache.juneau.http.remote.RemoteOp} - Applied to interface methods.
		</ul>
		<li class='jp'>{@link org.apache.juneau.http.annotation}
		<ul class='javatreec'>
			<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
			<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
			<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
			<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
			<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
			<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
			<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {
		
		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		Pet addPet(
			<ja>@Content</ja> CreatePet <jv>createPet</jv>, 
			<ja>@Header</ja>(<js>"E-Tag"</js>) UUID <jv>etag</jv>, 
			<ja>@Query</ja>(<js>"debug"</js>) <jk>boolean</jk> <jv>debug</jv>
		);
	}
	</p>
	
	<p class='bjava'>	
	<jc>// Use a RestClient with default JSON 5 support.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json5().build();
	
	<jc>// Instantiate our proxy interface.</jc>
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>, <js>"http://localhost:10000"</js>);
	
	<jc>// Use it to create a pet.</jc>
	CreatePet <jv>createPet</jv> = <jk>new</jk> CreatePet(<js>"Fluffy"</js>, 9.99);
	Pet <jv>pet</jv> = <jv>store</jv>.addPet(<jv>createPet</jv>, UUID.<jsm>randomUUID</jsm>(), <jk>true</jk>);
	</p>
	
	<p>
		The call above translates to the following REST call:
	</p>
	
	<p class='bcode'>
	POST http://localhost:10000/petstore/pets?debug=true HTTP/1.1
	Accept: application/json
	Content-Type: application/json
	E-Tag: 475588d4-0b27-4f56-9296-cc683251d314
	
	{
		name: 'Fluffy',
		price: 9.99 
	}
	</p>
	
	<p>
		The <ja>@RemoteOp</ja> annotations can be eliminated if you use specific naming conventions on your 
		method names to identify the HTTP method and path. 
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {
		
		<jc>// @RemoteOp optional since method and path is inferred from method name.</jc> 
		String postPets(<ja>@Content</ja> CreatePet pet);
	}
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Remote' id='jrc.Remote'>10.9.1 - @Remote</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.1 - jrc.Remote -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.remote.Remote @Remote} annotation is used on your interface class
		to identify it as a REST proxy interface.
	</p>
	
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.remote.Remote}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.http.remote.Remote#path path}
				<li class='jma'>{@link org.apache.juneau.http.remote.Remote#headers headers}
				<li class='jma'>{@link org.apache.juneau.http.remote.Remote#version version}
				<li class='jma'>{@link org.apache.juneau.http.remote.Remote#versionHeader versionHeader}
			</ul>
		</li>
	</ul>
	
	<p>
		The <ja>@Remote</ja> annotation is optional but often included for code readability.
	</p>
	
	<h5 class='topic'>@Remote(path)</h5>
	<p>
		The {@link org.apache.juneau.http.remote.Remote#path @Remote(path)} annotation is used to define the
		HTTP path of the REST service.
	</p>
	
	<p>
		The path can be an absolute path to your REST service.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(path=<js>"http://localhost:10000/petstore"</js>)
	<jk>public interface</jk> PetStore {...}
	</p>
	<p class='bjava'>	
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>);
	</p>
	
	<p>
		<a class="doclink" href="#jm.DefaultVarResolver">VarResolver.DEFAULT</a> can also be used in the path.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<jc>// URL is specified via a system property.</jc>
	<ja>@Remote</ja>(path=<js>"$S{PetStoreUrl}"</js>)
	<jk>public interface</jk> PetStore {...}
	</p>
	
	<p>
		When a relative path is specified, it's relative to the root-url defined on the <c>RestClient</c> used to instantiate the interface.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {...}
	</p>
	<p class='bjava'>
	RestClient <jv>client</jv> = RestClient
		.<jsm>create</jsm>()
		.json()
		.rootUrl(<js>"http://localhost:10000"</js>)
		.build();
			
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>);
	</p>
	
	<p>
		When no path is specified, the root-url defined on the <c>RestClient</c> is used.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>
	<jk>public interface</jk> PetStore {...}
	</p>
	<p class='bjava'>
	RestClient <jv>client</jv> = RestClient
		.<jsm>create</jsm>()
		.json()
		.rootUrl(<js>"http://localhost:10000/petstore"</js>)
		.build();
			
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>);
	</p>
	
	
	<h5 class='topic'>@Remote(headers/headerList)</h5>
	<p>
		The {@link org.apache.juneau.http.remote.Remote#headers @Remote(headers)} and {@link org.apache.juneau.http.remote.Remote#headerList @Remote(headerList)} 
		annotations are used to add headers on all requests.  
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(
		path=<js>"/petstore"</js>,
		headers={
			<js>"Foo: bar"</js>,
			<js>"Baz: $S{bazProperty}"</js>
		},
		headerList=MyHeaderList.<jk>class</jk>
	)
	<jk>public interface</jk> PetStore {...}
	</p>
	<p class='bjava'>
	<jc>// Our dynamic supplier.</jc>
	<jk>public class</jk> MyHeaderList <jk>extends</jk> HeaderList {
		...
	}
	</p>
	
	
	<h5 class='topic'>@Remote(version/versionHeader)</h5>
	<p>
		The {@link org.apache.juneau.http.remote.Remote#version @Remote(version)} and {@link org.apache.juneau.http.remote.Remote#versionHeader @Remote(versionHeader)} 
		annotations are used to specify the client-side version of this interface that can be used on the server side
		to perform version-specific handling.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>(
		path=<js>"/petstore"</js>,
		version=<js>"1.2.3"</js>  <jc>// Adds "Client-Version: 1.2.3" header to all requests.</jc>
	)
	<jk>public interface</jk> PetStore {...}
	</p>
	
	<p>
		This can be used in conjunction with the server-side client-versioning support.
	</p>
	<p class='bjava'>
	<jc>// Call this method if Client-Version is at least 2.0.
	// Note that this also matches 2.0.1.</jc>
	<ja>@RestGet</ja>(clientVersion=<js>"2.0"</js>)
	<jk>public</jk> Object foo()  {...}

	<jc>// Call this method if Client-Version is at least 1.1 but less than 2.0.</jc>
	<ja>@RestGet</ja>(clientVersion=<js>"[1.1,2.0)"</js>)
	<jk>public</jk> Object foo()  {...}

	<jc>// Call this method if Client-Version is less than 1.1.</jc>
	<ja>@RestGet</ja>(clientVersion=<js>"[0,1.1)"</js>)
	<jk>public</jk> Object foo()  {...}
	</p>
	
	<ul class='seealso'>
		<li class='doclink'><a class="doclink" href="#jrs.ClientVersioning">Client Versioning</a>
	</ul>
</div>
</div><!-- END: 10.9.1 - jrc.Remote -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.RemoteMethod' id='jrc.RemoteMethod'>10.9.2 - @RemoteOp</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.2 - jrc.RemoteMethod -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.remote.RemoteOp @RemoteOp} annotation is applied to methods
		of <ja>@Remote</ja>-annotated interfaces to identify REST endpoints.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteOp}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.http.remote.RemoteOp#method method}
				<li class='jma'>{@link org.apache.juneau.http.remote.RemoteOp#path path}
				<li class='jma'>{@link org.apache.juneau.http.remote.RemoteOp#returns returns}
			</ul>
		</li>
	</ul>

	<p>
		Specialized sub-annotations are provided for common HTTP methods:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteGet}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemotePost}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemotePut}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemotePatch}
		<li class='ja'>{@link org.apache.juneau.http.remote.RemoteDelete}
	</ul>

	<h5 class='topic'>@RemoteOp(method/path)</h5>
	<p>
		The HTTP method and path are mapped to a Java method using the <c>method</c> and <c>path</c> annotations.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>
	<jk>public interface</jk> PetStore {
		
		<jc>// GET /pets/{petId}</jc>
		<ja>@RemoteGet</ja>(<js>"/pets/{petId}"</js>)
		Pet getPet(<ja>@Path</ja>(<js>"petId"</js>) <jk>int</jk> <jv>id</jv>);
	}
	</p>
	<p>
		The Java method name can be anything.  
	</p>
	
	<h5 class='topic'>Inferred method/path</h5>
	<p>
		In such cases, <c>method</c> and <c>path</c> annotations are optional if you follow certain naming
		conventions on your method that identify the method and path.
	</p>
	<p>
		For example, the <c>getPet</c> method below defaults to <c>GET /pet</c>:
	</p>
	<p class='bjava'>	
	<ja>@Remote</ja>
	<jk>public interface</jk> PetStore {
		
		<jc>// GET /pet</jc>
		<ja>@RemoteOp</ja>
		Pet getPet(...);
	}
	</p>
	<p>
		In such cases, the <ja>@RemoteOp</ja> annotation is optional.
	</p>
	<p>
		Method names matching the following pattern are assumed to be implying the HTTP method name:
	</p>
	<p class='bcode'>
	(get|put|post|delete|options|head|connect|trace|patch).*
	</p>
	<p class='bcode'>
	do(?i)(get|put|post|delete|options|head|connect|trace|patch)
	</p>
	
	<h5 class='figure'>Examples:</h5>
	<table class='styled w500'>
		<tr>
			<th>Java method name</th>
			<th>Inferred HTTP method</th>
			<th>Inferred HTTP path</th>
		</tr>
		<tr>
			<td class='code'>getPet()</td>
			<td class='code'>GET</td>
			<td class='code'>/pet</td>
		</tr>
		<tr>
			<td class='code'>get()</td>
			<td class='code'>GET</td>
			<td class='code'>/</td>
		</tr>
		<tr>
			<td class='code'>postPet()</td>
			<td class='code'>POST</td>
			<td class='code'>/pet</td>
		</tr>
		<tr>
			<td class='code'>fooPet()</td>
			<td class='code'>[default]</td>
			<td class='code'>/fooPet</td>
		</tr>
		<tr>
			<td class='code'>doGet()</td>
			<td class='code'>GET</td>
			<td class='code'>/</td>
		</tr>
		<tr>
			<td class='code'>doGET()</td>
			<td class='code'>GET</td>
			<td class='code'>/</td>
		</tr>
		<tr>
			<td class='code'>doFoo()</td>
			<td class='code'>[default]</td>
			<td class='code'>/doFoo</td>
		</tr>
	</table>
	
	<h5 class='topic'>@RemoteOp(returns)</h5>
	<p>
		The return type of the Java methods of can be any of the following:
	</p>
	<ul class='spaced-list'>
		<li>
			<jk>void</jk>/{@link java.lang.Void}
			- Don't parse any response.  
			<br>Note that the method will still throw a runtime exception if an error HTTP status is returned.
		<li>
			Any <a class="doclink" href="#jm.PojoCategories">parseable</a> POJO 
			- The body of the response will be converted to the POJO using the parser defined on the 
			<c>RestClient</c> based on the <c>Content-Type</c> of the response.
		<li>
			Any {@link org.apache.juneau.http.annotation.Response @Response}-annotated type. (described later)
		<li>
			<c>HttpResponse</c> 
			- Returns the raw <c>HttpResponse</c> returned by the inner <c>HttpClient</c>.
		<li>
			{@link java.io.Reader} 
			- Returns access to the raw reader of the response.
		<li>
			{@link java.io.InputStream} 
			- Returns access to the raw input stream of the response.
		<li>
			A {@link java.util.concurrent.Future} or {@link java.util.concurrent.CompletableFuture} of anything on this list. 
	</ul>
	
	<p>
		If you're only interested in the HTTP status code of the response, you can use the {@link org.apache.juneau.http.remote.RemoteOp#returns() returns}
		annotation with a value of {@link org.apache.juneau.http.remote.RemoteReturn#STATUS STATUS}:
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>
	<jk>public interface</jk> PetStore {
		
		<jc>// POST /pets</jc>
		<jc>// Returns HTTP status code.</jc>
		<ja>@RemotePost</ja>(returns=<jsf>STATUS</jsf>)
		<jk>int</jk> pets(...);
	}
	</p>
	<p>
		If your <c>RestClient</c> does not have a parser associated with it, then the value is converted directly from a String using
		the rules defined in <a class="doclink" href="#jm.PojoCategories">POJO Categories</a>. 
	</p>
</div>
</div><!-- END: 10.9.2 - jrc.RemoteMethod -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Content' id='jrc.Content'>10.9.3 - @Content</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.3 - jrc.Content -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Content @Content} annotation can be applied to arguments of <ja>@RemoteOp</ja>-annotated methods
		to denote that they are the HTTP body of the request.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
			<ul class='javatreec'>
				<li class='jma'>{@link org.apache.juneau.http.annotation.Content#schema() schema}
			</ul>
		</li>
	</ul>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// Used on parameter</jc>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {

		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		String addPet(<ja>@Content</ja> Pet <jv>pet</jv>);
	}
	</p>
	<p class='bjava'>
	<jc>// Used on class</jc>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {

		<ja>@RemotePost</ja>(<js>"/pets"</js>)
		String addPet(Pet <jv>pet</jv>);
	}

	<ja>@Content</ja>
	<jk>public class</jk> Pet {...}
	</p>
	
	<p>
		The argument can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			Any serializable POJO - Converted to output using the {@link org.apache.juneau.serializer.Serializer} registered with the <c>RestClient</c>.
			<br><c>Content-Type</c> is set to that of the <c>Serializer</c>.
		<li>
			{@link java.io.Reader} - Raw contents of {@code Reader} will be serialized to remote resource.
			<br><c>Content-Type</c> is set to <js>"text/plain"</js>.
		<li>
			{@link java.io.InputStream} - Raw contents of {@code InputStream} will be serialized to remote resource.
			<br><c>Content-Type</c> is set to <js>"application/octet-stream"</js>.
		<li>
			{@link org.apache.juneau.http.part.PartList} - Converted to a URL-encoded FORM post.
			<br><c>Content-Type</c> is set to <js>"aplication/x-www-form-urlencoded"</js>.
		<li>
			<c>HttpEntity</c> - Bypass Juneau serialization and pass HttpEntity directly to HttpClient.
	</ul>
	 
	<p>
		OpenAPI schema based serialization can be used by using the {@link org.apache.juneau.oapi.OpenApiSerializer} class.
	</p>
	
	<p class='bjava'>
	<ja>@RemotePost</ja>(<js>"/comma-delimited-pipe-delimited-ints"</js>)
	String addCommaDelimitedPipeDelimitedInts(
		<ja>@Content</ja>(
			serializer=OpenApiSerializer.<jk>class</jk>,
			schema=<ja>@Schema</ja>(
				type=<js>"array"</js>,
				collectionFormat=<js>"pipes"</js>,
				items=<ja>@Items</ja>(
					type=<js>"array"</js>
					items=<ja>@SubItems</ja>(
						type=<js>"int32"</js>,
					 	<jc>// Auto-validates on client side!</jc>
						minimum=<js>"0"</js>,
						maximum=<js>"64"</js>
					)
				)
			)
		)
		<jk>int</jk>[][] <jv>input</jv>
	);
	</p>
	<p class='bjava'>
	<jc>// Same as above but using free-form schema.</jc>
	<jc>// Format is simplified-JSON (outer {} brackets are optional).</jc>
	<ja>@RemotePost</ja>(<js>"/comma-delimited-pipe-delimited-ints"</js>)
	String addCommaDelimitedPipeDelimitedInts(
		<ja>@Content</ja>(
			serializer=OpenApiSerializer.<jk>class</jk>,
			schema=<ja>@Schema</ja>(
				<js>"type:'array',collectionFormat:'pipes',items:[type:'array',items:[type:'int32',minimum:0,maximum:64]]"</js>
			)
		)
		<jk>int</jk>[][] <jv>input</jv>
	);
	</p>
	<p>
		See <a class="doclink" href="#jm.OpenApiSerializers">OpenAPI Serializers</a> for information about supported data types in OpenAPI serialization.
	</p>
	
	<p>
		If your <c>RestClient</c> class does not have a serializer associated with it, the body will automatically be serialized to a 
		string using the rules defined in <a class="doclink" href="#jm.PojoCategories">POJO Categories</a>.
	</p>
</div>
</div><!-- END: 10.9.3 - jrc.Content -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.FormData' id='jrc.FormData'>10.9.4 - @FormData</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.4 - jrc.FormData -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.FormData @FormData} annotation can be applied to arguments of <ja>@RemoteOp</ja>-annotated methods
		to denote that they are form-data parameters on the request.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.FormData#name() name} - Form data entry name.
			<li class='jf'>{@link org.apache.juneau.http.annotation.FormData#serializer() serializer} - Override the part serializer.
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/myproxy"</js>)
	<jk>public interface</jk> MyProxy {

		<jc>// Explicit names specified for form data parameters.</jc>
		<ja>@RemotePost</ja>
		String postParameters(
			<ja>@FormData</ja>(<js>"foo"</js>)</ja> String <jv>foo</jv>,
			<ja>@FormData</ja>(<js>"bar"</js>)</ja> MyPojo <jv>pojo</jv>
		);

		<jc>// Multiple values pulled from a PartList object.</jc>
		<jc>// Name "*" is inferred.</jc>
		<ja>@RemotePost</ja>
		String postPartList(<ja>@FormData</ja> PartList <jv>partList</jv>);

		<jc>// Multiple values pulled from a Map.</jc>
		<ja>@RemotePost</ja>
		String postMap(<ja>@FormData</ja> Map&lt;String,Object&gt; <jv>map</jv>);

		<jc>// Multiple values pulled from a bean.</jc>
		<ja>@RemotePost</ja>
		String postBean(<ja>@FormData</ja> MyBean <jv>bean</jv>);

		<jc>// An entire form-data HTTP body as a String.</jc>
		<ja>@RemotePost</ja>
		String postString(<ja>@FormData</ja> String <jv>string</jv>);

		<jc>// An entire form-data HTTP body as a Reader.</jc>
		<ja>@RemotePost</ja>
		String postReader(<ja>@FormData</ja> Reader <jv>reader</jv>);
	}
	</p>
	
	<p>
		Single-part arguments (i.e. those with name != <js>"*"</js>) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			Any serializable POJO - Converted to a string using the {@link org.apache.juneau.httppart.HttpPartSerializer} registered with the
			<c>RestClient</c> ({@link org.apache.juneau.oapi.OpenApiSerializer} by default) or associated via the {@link org.apache.juneau.http.annotation.FormData#serializer() @FormData(serializer)} annotation.
	</ul>
	<p>
		Multi-part arguments (i.e. those with name == <js>"*"</js> or empty) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link java.io.Reader} - Raw contents of {@code Reader} will be serialized to remote resource.
		<li>
			{@link java.io.InputStream} - Raw contents of {@code InputStream} will be serialized to remote resource.
		<li>
			{@link org.apache.juneau.http.part.PartList} - Converted to a URL-encoded FORM post.
		<li>
			<c>Map</c> - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			Bean - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			<c>CharSequence</c> - Used directly as am <js>"application/x-www-form-urlencoded"</js> entity.
	</ul>
	<p>
		See the link below for information about supported data types in OpenAPI serialization.
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.OpenApiSerializers">OpenAPI Serializers</a>
	</ul>
</div>
</div><!-- END: 10.9.4 - jrc.FormData -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Query' id='jrc.Query'>10.9.5 - @Query</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.5 - jrc.Query -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Query @Query} annotation can be applied to arguments of <ja>@RemoteOp</ja>-annotated methods
		to denote that they are query parameters on the request.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.Query#name() name} - Query parameter name.
			<li class='jf'>{@link org.apache.juneau.http.annotation.Query#serializer() serializer}  - Override the part serializer.
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/myproxy"</js>)
	<jk>public interface</jk> MyProxy {

		<jc>// Explicit names specified for query parameters.</jc>
		<ja>@RemoteGet</ja>
		String parameters(
			<ja>@Query</ja>(<js>"foo"</js>)</ja> String <jv>foo</jv>,
			<ja>@Query</ja>(<js>"bar"</js>)</ja> MyPojo <jv>pojo</jv>);

		<jc>// Multiple values pulled from a PartList object.</jc>
		<jc>// Same as @Query("*").</jc>
		<ja>@RemoteGet</ja>
		String partList(<ja>@Query</ja> PartList <jv>partList</jv>);

		<jc>// Multiple values pulled from a Map.</jc>
		<jc>// Same as @Query("*").</jc>
		<ja>@RemoteGet</ja>
		String map(<ja>@Query</ja> Map&lt;String,Object&gt; <jv>map</jv>);

		<jc>// Multiple values pulled from a bean.</jc>
		<jc>// Same as @Query("*").</jc>
		<ja>@RemoteGet</ja>
		String bean(<ja>@Query</ja> MyBean <jv>myBean</jv>);

		<jc>// An entire query string as a String.</jc>
		<jc>// Same as @Query("*").</jc>
		<ja>@RemoteGet</ja>
		String string(<ja>@Query</ja> String <jv>string</jv>);

		<jc>// An entire query string as a Reader.</jc>
		<jc>// Same as @Query("*").</jc>
		<ja>@RemoteGet</ja>
		String reader(<ja>@Query</ja> Reader <jv>reader</jv>);
	}
	</p>
	
	<p>
		Single-part arguments (i.e. those with name != <js>"*"</js>) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			Any serializable POJO - Converted to a string using the {@link org.apache.juneau.httppart.HttpPartSerializer} registered with the
			<c>RestClient</c> ({@link org.apache.juneau.oapi.OpenApiSerializer} by default) or associated via the {@link org.apache.juneau.http.annotation.Query#serializer() @Query(serializer)} annotation.
	</ul>
	
	<p>
		Multi-part arguments (i.e. those with name == <js>"*"</js> or empty) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link java.io.Reader} - Raw contents of {@code Reader} will be serialized directly a query string.
		<li>
			{@link org.apache.juneau.http.part.PartList} - Serialized as individual query parameters.
		<li>
			<c>Map</c> - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			Bean - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			<c>CharSequence</c> - Serialized directly a query string.
	</ul>
	
	<p>
		See the link below for information about supported data types in OpenAPI serialization.
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.OpenApiSerializers">OpenAPI Serializers</a>
	</ul>
</div>
</div><!-- END: 10.9.5 - jrc.Query -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Header' id='jrc.Header'>10.9.6 - @Header</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.6 - jrc.Header -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Header @Header} annotation can be applied to arguments of <ja>@RemoteOp</ja>-annotated methods
		to denote that they are header parameters on the request.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.Header#name() name} - Header name.
			<li class='jf'>{@link org.apache.juneau.http.annotation.Header#serializer() serializer} - Override the part serializer.
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/myproxy"</js>)
	<jk>public interface</jk> MyProxy {

		<jc>// Explicit names specified for HTTP headers.</jc>
		<jc>// pojo will be converted to UON notation (unless plain-text parts enabled).</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod1"</js>)
		String myProxyMethod1(<ja>@Header</ja>(<js>"Foo"</js>)</ja> String <jv>foo</jv>,
			<ja>@Header</ja>(<js>"Bar"</js>)</ja> MyPojo <jv>pojo</jv>);

		<jc>// Multiple values pulled from a HeaderList object.</jc>
		<jc>// Same as @Header("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod2"</js>)
		String myProxyMethod2(<ja>@Header</ja> HeaderList <jv>headerList</jv>);

		<jc>// Multiple values pulled from a Map.</jc>
		<jc>// Same as @Header("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod3"</js>)
		String myProxyMethod3(<ja>@Header</ja> Map&lt;String,Object&gt; <jv>map</jv>);

		<jc>// Multiple values pulled from a bean.</jc>
		<jc>// Same as @Header("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod4"</js>)
		String myProxyMethod4(<ja>@Header</ja> MyBean <jv>myBean</jv>);
	}
	</p>
	
	<p>
		Single-part arguments (i.e. those with name != <js>"*"</js>) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			Any serializable POJO - Converted to a string using the {@link org.apache.juneau.httppart.HttpPartSerializer} registered with the
			<c>RestClient</c> ({@link org.apache.juneau.oapi.OpenApiSerializer} by default) or associated via the {@link org.apache.juneau.http.annotation.Header#serializer() @Header(serializer)} annotation.
	</ul>
	
	<p>
		Multi-part arguments (i.e. those with name == <js>"*"</js> or empty) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.http.header.HeaderList} - Serialized as individual headers.
		<li>
			<c>Map</c> - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			Bean - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
	</ul>
	
	<p>
		See the link below for information about supported data types in OpenAPI serialization.
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.OpenApiSerializers">OpenAPI Serializers</a>
	</ul>
</div>
</div><!-- END: 10.9.6 - jrc.Header -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Path' id='jrc.Path'>10.9.7 - @Path</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.7 - jrc.Path -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Path @Path} annotation can be applied to arguments of <ja>@RemoteOp</ja>-annotated methods
		to denote that they are path parameters on the request.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.Path#name() name} - Path variable name.
			<li class='jf'>{@link org.apache.juneau.http.annotation.Path#serializer() serializer} - Override the part serializer.
		</ul>
	</ul>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/myproxy"</js>)
	<jk>public interface</jk> MyProxy {

		<jc>// Explicit names specified for path parameters.</jc>
		<jc>// pojo will be converted to UON notation (unless plain-text parts enabled).</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod1/{foo}/{bar}"</js>)
		String myProxyMethod1(<ja>@Path</ja>(<js>"foo"</js>)</ja> String <jv>foo</jv>, <ja>@Path</ja>(<js>"bar"</js>)</ja> MyPojo <jv>pojo</jv>);

		<jc>// Multiple values pulled from a PartList object.</jc>
		<jc>// Same as @Path("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod2/{foo}/{bar}/{baz}"</js>)
		String myProxyMethod2(<ja>@Path</ja> PartList <jv>partList</jv>);

		<jc>// Multiple values pulled from a Map.</jc>
		<jc>// Same as @Path("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod3/{foo}/{bar}/{baz}"</js>)
		String myProxyMethod3(<ja>@Path</ja> Map&lt;String,Object&gt; <jv>map</jv>);

		<jc>// Multiple values pulled from a bean.</jc>
		<jc>// Same as @Path("*").</jc>
		<ja>@RemoteGet</ja>(<js>"/mymethod4/{foo}/{bar}/{baz}"</js>)
		String myProxyMethod4(<ja>@Path</ja> MyBean <jv>myBean</jv>);
	}
	</p>
	
	<p>
		Single-part arguments (i.e. those with name != <js>"*"</js>) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			Any serializable POJO - Converted to a string using the {@link org.apache.juneau.httppart.HttpPartSerializer} registered with the
			<c>RestClient</c> ({@link org.apache.juneau.oapi.OpenApiSerializer} by default) or associated via the {@link org.apache.juneau.http.annotation.Path#serializer() @Path(serializer)} annotation.
	</ul>
	
	<p>
		Multi-part arguments (i.e. those with name == <js>"*"</js> or empty) can be any of the following types:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.http.part.PartList} - Serialized as individual path parameters.
		<li>
			<c>Map</c> - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
		<li>
			Bean - Converted to key-value pairs.
				<br>Values serialized using the registered {@link org.apache.juneau.httppart.HttpPartSerializer} ({@link org.apache.juneau.oapi.OpenApiSerializer} by default).
	</ul>
	
	<p>
		See the link below for information about supported data types in OpenAPI serialization.
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#jm.OpenApiSerializers">OpenAPI Serializers</a>
	</ul>
</div>
</div><!-- END: 10.9.7 - jrc.Path -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Request' id='jrc.Request'>10.9.8 - @Request</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.8 - jrc.Request -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Request @Request} annotation can be applied to a type of a <ja>@RemoteOp</ja>-annotated method 
		to identify it as a bean for setting HTTP parts through a bean-like interface.
	</p>
	
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.Request#serializer() serializer} - Override the part serializer.
		</ul>
	</ul>
	
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {

		<ja>@RemotePost</ja>
		String postPet(CreatePetRequest <jv>bean</jv>);
	}
	</p>
	<p class='bjava'>
	<ja>@Request</ja> 
	<jk>public class</jk> CreatePetRequest {
	
		<jk>private</jk> CreatePet <jf>pet</jf>;
	
		<jk>public</jk> CreatePetRequest(String <jv>name</jv>, <jk>float</jk> <jv>price</jv>) {
			<jk>this</jk>.<jf>pet</jf> = <jk>new</jk> CreatePet(<jv>name</jv>, <jv>price</jv>);
		}
		
		<ja>@Content</ja>
		<jk>public</jk> CreatePet getContent() {
			<jk>return</jk> <jk>this</jk>.<jf>pet</jf>;
		}
	
		<ja>@Query</ja>
		<jk>public</jk> Map&lt;String,Object&gt; getQueryParams() {
			<jk>return</jk> AMap.<jsm>of</jsm>(<js>"debug"</js>, <jk>true</jk>);
		}
	
		<ja>@Header</ja>(<js>"E-Tag"</js>)
		<jk>public static</jk> UUID <jsm>getUUID</jsm>() {
			<jk>return</jk> UUID.<jsm>generatedUUID</jsm>();
		}
	}
	</p>
	<p class='bjava'>
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>, <js>"http://localhost:10000"</js>);
	
	CreatePetRequest <jv>requestBean</jv> = <jk>new</jk> CreatePetRequest(<js>"Fluffy"</js>, 9.99);
	String <jv>response</jv> = <jv>store</jv>.postPet(requestBean);
	</p>
	<p>
		The <ja>@Request</ja> annotation can be applied to either the class or argument.
	</p>
	<p>
		The annotated methods must be no-arg and public.  
		They can be named anything.
	</p>
	<p>
		Any of the following annotations can be used on the methods:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
	</ul>
	<p>
		The behavior and functionality of all of the annotations are the same as if they were used on method arguments directly.
		This means full support for OpenAPI serialization and validation.
	</p>
	<p>
		Annotations on methods are inherited from parent classes and interfaces. 
		For example, the request bean above could have defined annotations in an interface to keep them clear from the implementation:
	</p>
	<p class='bjava'>
	<ja>@Request</ja> 
	<jk>public interface</jk> CreatePetRequest {
	
		<ja>@Content</ja>
		CreatePet getContent();
	
		<ja>@Query</ja>
		Map&lt;String,Object&gt; getQueryParams();
	
		<ja>@Header</ja>(<js>"E-Tag"</js>)
		UUID getUUID();
	}
	</p>
	<p class='bjava'>
	<jk>public class</jk> CreatePetRequestImpl <jk>implements</jk> CreatePetRequest {
	
		<jk>public</jk> CreatePetRequestImpl(String <jv>name</jv>, <jk>float</jk> <jv>price</jv>) {...}

		<ja>@Override</ja>
		<jk>public</jk> CreatePet getContent() {
			<jk>return</jk> <jk>this</jk>.<jf>pet</jf>;
		}
	
		<ja>@Override</ja>
		<jk>public</jk> Map&lt;String,Object&gt; getQueryParams() {
			<jk>return</jk> JsonMap.<jsm>of</jsm>(<js>"debug"</js>, <jk>true</jk>);
		}
	
		<ja>@Override</ja>
		<jk>public</jk> UUID getUUID() {
			<jk>return</jk> UUID.<jsm>generateUUID</jsm>();
		}
	}
	</p>
</div>
</div><!-- END: 10.9.8 - jrc.Request -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.Response' id='jrc.Response'>10.9.9 - @Response</a><span class='update'>updated: <b>9.0.0</b></span></h4>
<div class='topic'><!-- START: 10.9.9 - jrc.Response -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.http.annotation.Response @Response} annotation can be applied to types returned by <ja>@RemoteOp</ja>-annotated methods.
	</p>
	<ul class='javatree'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Response}
		<ul>
			<li class='jf'>{@link org.apache.juneau.http.annotation.Response#parser() parser} - Override the part parser.
		</ul>
	</ul>
	<p>
		The <ja>@Response</ja> annotation can be used to define interfaces for retrieving response parts using a bean-like proxy.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>	
	<ja>@Remote</ja>
	<jk>public interface</jk> PetStore {
		
		<ja>@RemotePost</ja>
		CreatePetResponse postPet(...);
	}
	</p>
	<p class='bjava'>
	<ja>@Response</ja> 
	<jk>public interface</jk> CreatePetResponse {
	
		<ja>@Content</ja>
		Pet getContent();
	
		<ja>@Header</ja>(<js>"E-Tag"</js>)
		UUID getUUID();
		
		<ja>@StatusCode</ja>
		<jk>int</jk> getStatus();
	}
	</p>
	<p class='bjava'>
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>, <js>"http://localhost:10000"</js>);
	
	CreatePetResponse <jv>response</jv> = <jv>store</jv>.postPet(...);
	Pet <jv>pet</jv> = <jv>response</jv>.getContent();
	UUID <jv>uuid</jv> = <jv>response</jv>.getUUID();
	<jk>int</jk> <jv>status</jv> = <jv>response</jv>.getStatus();
	</p>
	<p>
		The annotated methods must be no-arg.  
		They can be named anything.
	</p>
	<p>
		Any of the following annotations can be used on the methods:
	</p>
	<ul class='javatreec'>
		<li class='ja'>{@link org.apache.juneau.http.annotation.Content}
		<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
		<li class='ja'>{@link org.apache.juneau.http.annotation.StatusCode}
	</ul>
	<p>
		The behavior and functionality of all of the annotations are the same as if they were used on method arguments directly. This means full support for OpenAPI serialization and validation.
	</p>
</div>
</div><!-- END: 10.9.9 - jrc.Response -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.DualPurposeInterfaces' id='jrc.DualPurposeInterfaces'>10.9.10 - Dual-purpose (end-to-end) interfaces</a><span class='update'>created: 8.0.0</span></h4>
<div class='topic'><!-- START: 10.9.10 - jrc.DualPurposeInterfaces -->
<div class='topic'>
	<p>
		A common coding practice is to use the same Java interface to define both your server and client side REST interfaces.
		The advantage to this approach is that changes that you make to your REST interface can be reflected in both places
		at the same time, reducing the chances for compatibility mistakes.
	</p>
	<p>
		What makes this possible is that method-level annotations such as <ja>@RestOp</ja> and parameter-level annotations
		such as <ja>@Query</ja> are inherited from parent classes.  
		This normally isn't possible but the framework will spider up the parent hierarchy of classes to find method and parameter level
		annotations defined on overridden methods.
	</p>
	<p>
		The general approach is to define your {@link org.apache.juneau.http.remote.Remote @Remote}-annotated interface first.
		The following example is pulled from the PetStore app:
	</p>
	<p class='bjava'>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {
	
		<ja>@RemoteGet</ja>(<js>"/pet"</js>)
		<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable;
	
		<ja>@RemotDelete</ja>(<js>"/pet/{petId}"</js>)
		<jk>public</jk> Ok deletePet(
			<ja>@Header</ja>(
				name=<js>"api_key"</js>,
				description=<js>"Security API key"</js>,
				required=<jk>true</jk>,
				example=<js>"foobar"</js>
			)
			String <jv>apiKey</jv>,
			<ja>@Path</ja>(
				name=<js>"petId"</js>,
				description=<js>"Pet id to delete"</js>,
				example=<js>"123"</js>
			)
			<jk>long</jk> <jv>petId</jv>
		) <jk>throws</jk> IdNotFound, NotAcceptable;
		
		...
	</p>
	<p>
		Next you define the implementation of your interface as a normal Juneau REST resource:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		...
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestServlet <jk>implements</jk> PetStore {
	
		...
	
		<ja>@Override</ja> <jc>/* PetStore */</jc>
		<ja>@RestOp</ja>(
			method=<jsm>GET</jsm>,
			path=<js>"/pet"</js>,
			summary=<js>"All pets in the store"</js>,
			...
		)
		<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable {
			<jk>return</jk> <jsf>store</jsf>.getPets();
		}
	
		<ja>@Override</ja> <jc>/* PetStore */</jc>
		<ja>@RestOp</ja>(
			method=<jsf>DELETE</jsf>,
			path=<js>"/pet/{petId}"</js>,
			summary=<js>"Deletes a pet"</js>,
			...
		)
		<jk>public</jk> Ok deletePet(String <jv>apiKey</jv>, <jk>long</jk> <jv>petId</jv>) <jk>throws</jk> IdNotFound, NotAcceptable {
			<jsf>store</jsf>.removePet(<jv>petId</jv>);
			<jk>return</jk> <jsf>OK</jsf>;
		}
	</p>
	<p>
		Then use the interface as a remote resource like so:
	</p>
	<p class='bjava'>
	RestClient client = RestClient.<jsm>create</jsm>().json().rootUrl(<js>"http://localhost:10000"</js>).build();
	PetStore <jv>store</jv> = <jv>client</jv>.getRemote(PetStore.<jk>class</jk>);

	<jk>for</jk> (Pet <jv>pet</jv> : <jv>store</jv>.getPets()) {
		<jv>store</jv>.deletePet(<js>"my-special-key"</js>, <jv>pet</jv>.getId());
		System.<jsf>err</jsf>.println(<js>"Deleted pet:  id="</js> + <jv>pet</jv>.getId());
	}
	</p>	
	<p>
		In the example above, we chose to add the <ja>@RestOp</ja> annotation to the implementation class.  
		However, they could have been added to the interface instead.  It's personal preference where you want to place
		the annotations.
	</p>
	<p>
		Note how we didn't need to use the <ja>@Header</ja> and <ja>@Path</ja> annotations in our implementation since
		the annotations were inherited from the interface.
	</p>
</div>
</div><!-- END: 10.9.10 - jrc.DualPurposeInterfaces -->
</div><!-- END: 10.9 - jrc.Proxies -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.LoggingAndDebugging' id='jrc.LoggingAndDebugging'>10.10 - Logging and Debugging</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.10 - jrc.LoggingAndDebugging -->
<div class='topic'>
	<p>
		The following methods provide logging of requests and responses:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#logger(Logger) logger(Logger)}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#logToConsole() logToConsole()}
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#logRequests(DetailLevel,Level,BiPredicate) logRequests(DetailLevel,Level,BiPredicate)}
		</ul>
	</ul>
	
	<p>
		The following example shows the results of logging all requests that end with <c>/bean</c>.
	</p>
	
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// A simple bean we're going to round-trip.</jc>
	MyBean <jv>bean</jv> = <jk>new</jk> MyBean();
	
	<jv>bean</jv> = RestClient
		.<jsm>create</jsm>()
		.json5()
		.logRequests(DetailLevel.<jsf>FULL</jsf>, Level.<jsf>SEVERE</jsf>, (<jv>req</jv>,<jv>res</jv>)-&gt;<jv>req</jv>.getUri().endsWith(<js>"/bean"</js>))
		.logToConsole()
		.build()
		.post(<js>"http://localhost/bean"</js>, <jv>bean</jv>)
		.run()
		.getContent().as(MyBean.<jk>class</jk>);
	</p>
	
	<p>
		This produces the following console output:
	</p>
	
	<p class='bconsole'>
	=== HTTP Call (outgoing) ======================================================
	=== REQUEST ===
	POST http://localhost/bean
	---request headers---
		Accept: application/json5
	---request entity---
	Content-Type: application/json5
	---request content---
	{f:1}
	=== RESPONSE ===
	HTTP/1.1 200
	---response headers---
		Content-Type: application/json
	---response content---
	{f:1}
	=== END =======================================================================",
	</p>
	
	<p class='notes w900'>
		It should be noted that if you enable request logging detail level {@link org.apache.juneau.DetailLevel#FULL}, response bodies will be cached by default which may introduce
		a performance penalty.
	</p>
	
	<p>
		Additionally, the following method is also provided for enabling debug mode:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#debug() debug()}
		</ul>
	</ul>
	
	<p>
		Enabling debug mode has the following effects:
	</p>
	
	<ul>
		<li>{@link org.apache.juneau.rest.client.RestClient.Builder#logToConsole()} is called.
	</ul>
</div>
</div><!-- END: 10.10 - jrc.LoggingAndDebugging -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.CustomizingHttpClient' id='jrc.CustomizingHttpClient'>10.11 - Customizing HttpClient</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 10.11 - jrc.CustomizingHttpClient -->
<div class='topic'>
	<p>
		Several methods are provided for customizing the underlying HTTP client and client builder classes:
	</p>
	
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
		<ul>
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#httpClientBuilder(HttpClientBuilder) httpClientBuilder(HttpClientBuilder)} - Set the client builder yourself.
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#createHttpClientBuilder() createHttpClientBuilder()} - Override to create the client builder.
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#createHttpClient() createHttpClient()} - Override to create the client.
			<li class='jm'>{@link org.apache.juneau.rest.client.RestClient.Builder#createConnectionManager() createConnectionManager()} - Override to create the connection management.
		</ul>
	</ul>
	
	<p>
		Additionally, all methods on the <c>HttpClientBuilder</c> class have been extended with fluent setters.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client with customized HttpClient settings.</jc>
	MyBean <jv>bean</jv> = RestClient
		.<jsm>create</jsm>()
		.disableRedirectHandling()
		.connectionManager(<jv>myConnectionManager</jv>)
		.addInterceptorFirst(<jv>myHttpRequestInterceptor</jv>)
		.build();
	</p>
	
	<p>
		Refer to the {@code org.apache.http.client.impl.HttpClientBuilder} docs for more information.
	</p>
</div>
</div><!-- END: 10.11 - jrc.CustomizingHttpClient -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.ExtendingRestClient' id='jrc.ExtendingRestClient'>10.12 - Extending RestClient</a><span class='update'>created: 8.2.0</span></h3>
<div class='topic'><!-- START: 10.12 - jrc.ExtendingRestClient -->
<div class='topic'>
	<p>
		The <c>RestClient</c> API has been designed to allow for the ability to be easily extended.
		The following example that overrides the primary run method shows how this can be done.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>public class</jk> MyRestClient <jk>extends</jk> RestClient {

		<jc>// Must provide this constructor!</jc>
		<jk>public</jk> MyRestClient(ContextProperties <jv>ps</jv>) {
			<jk>super</jk>(<jv>ps</jv>);
		}

		<ja>@Override</ja>
		<jk>public</jk> HttpResponse run(HttpHost <jv>target</jv>, HttpRequest <jv>request</jv>, HttpContext <jv>context</jv>) <jk>throws</jk> IOException {
			<jc>// Perform special handling of requests.</jc>
		}
	}

	<jc>// Instantiate your client.</jc>
	MyRestClient <jv>client</jv> = RestClient.<jsm>create</jsm>().json().build(MyRestClient.<jk>class</jk>);
	</p>
	
	<p>
		The {@link org.apache.juneau.rest.client.RestRequest} and {@link org.apache.juneau.rest.client.RestResponse} objects can also be extended and integrated by overriding the
		{@link org.apache.juneau.rest.client.RestClient#createRequest(URI, String, boolean)} and {@link org.apache.juneau.rest.client.RestClient#createResponse(RestRequest, HttpResponse, Parser)} methods.
	</p>
</div>
</div><!-- END: 10.12 - jrc.ExtendingRestClient -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrc.Authentication' id='jrc.Authentication'>10.13 - Authentication</a><span class='update'>updated: 8.2.0</span></h3>
<div class='topic'><!-- START: 10.13 - jrc.Authentication -->
<div class='topic'>
	<p>
		The Juneau REST client itself does not implement any support for authentication.  
		Instead, it delegates it to the underlying Apache HTTP Client interface.
	</p>
	<p>
		The following sections show how some common authentication mechanisms can be set up using HTTP Client APIs.
	</p>
</div>

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.AuthenticationBASIC' id='jrc.AuthenticationBASIC'>10.13.1 - BASIC Authentication</a></h4>
<div class='topic'><!-- START: 10.13.1 - jrc.AuthenticationBASIC -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.client.RestClient.Builder#basicAuth(String,int,String,String)} method 
		can be used to quickly enable BASIC authentication support.
	</p>
	
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Create a client that performs BASIC authentication using the specified user/pw.</jc>
	RestClient <jv>client</jv> = RestClient.<jsm>create</jsm>() 
		.basicAuth(<jsf>HOST</jsf>, <jsf>PORT</jsf>, <jsf>USER</jsf>, <jsf>PW</jsf>)
		.build();
	</p>
	<p>
		This is functionally equivalent to the following:
	</p>
	<p class='bjava'>
	RestClient.Builder <jv>builder</jv> = RestClient.<jsm>create</jsm>();
	AuthScope <jv>scope</jv> = <jk>new</jk> AuthScope(<jsf>HOST</jsf>, <jsf>PORT</jsf>);
	Credentials <jv>up</jv> = <jk>new</jk> UsernamePasswordCredentials(<jsf>USER</jsf>, <jsf>PW</jsf>);
	CredentialsProvider <jv>provider</jv> = <jk>new</jk> BasicCredentialsProvider();
	<jv>provider</jv>.setCredentials(<jv>scope</jv>, <jv>up</jv>);
	<jv>builder</jv>.setDefaultCredentialsProvider(<jv>provider</jv>);
	</p>
</div>
</div><!-- END: 10.13.1 - jrc.AuthenticationBASIC -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.AuthenticationForm' id='jrc.AuthenticationForm'>10.13.2 - FORM-based Authentication</a></h4>
<div class='topic'><!-- START: 10.13.2 - jrc.AuthenticationForm -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.client.RestClient.Builder} class does not itself provide FORM-based 
		authentication since there is no standard way of providing such support. 
		Typically, to perform FORM-based or other types of authentication, you'll want to create your own
		subclass of {@link org.apache.juneau.rest.client.RestClient.Builder} and override the 
		{@link org.apache.juneau.rest.client.RestClient.Builder#createHttpClient()} method to provide an 
		authenticated client.
	</p>
	<p>
		The following example shows an implementation of a client that performs FORM-based authentication against
		the IBM Jazz platform.
	</p>
	<p class='bjava'>
	<jd>/**
	 * Constructor.
	 */</jd>
	<jk>public</jk> JazzRestClient.Builder(URI <jv>jazzUri</jv>, String <jv>user</jv>, String <jv>pw</jv>) <jk>throws</jk> IOException {
		...
	}

	<jd>/**
	 * Override the createHttpClient() method to return an authenticated client.
	 */</jd>
	<ja>@Override</ja> <jc>/* RestClient.Builder */</jc>
	<jk>protected</jk> CloseableHttpClient createHttpClient() <jk>throws</jk> Exception {
		CloseableHttpClient <jv>client</jv> = <jk>super</jk>.createHttpClient();
		formBasedAuthenticate(<jv>client</jv>);
		visitAuthenticatedURL(<jv>client</jv>);
		<jk>return</jk> <jv>client</jv>;
	}

	<jc>/*
	 * Performs form-based authentication against the Jazz server.
	 */</jc>
	<jk>private void</jk> formBasedAuthenticate(HttpClient <jv>client</jv>) <jk>throws</jk> IOException {

		URI <jv>uri2</jv> = <jf>jazzUri</jf>.resolve(<js>"j_security_check"</js>);
		HttpPost <jv>request</jv> = <jk>new</jk> HttpPost(uri2);
		<jv>request</jv>.setConfig(RequestConfig.<jsm>custom</jsm>().setRedirectsEnabled(<jk>false</jk>).build());
		
		<jc>// Charset must explicitly be set to UTF-8 to handle user/pw with non-ascii characters.</jc>
		<jv>request</jv>.addHeader(<js>"Content-Type"</js>, <js>"application/x-www-form-urlencoded; charset=utf-8"</js>);

		List&lt;NameValuePair&gt; <jv>params</jv> = AList.<jsm>of</jsm>(
			BasicNameValuePair.<jsm>of</jsm>(<js>"j_username""</js>, <jf>user</jf>),
			BasicNameValuePair.<jsm>of</jsm>(<js>"j_password"</js>, <jf>pw</jf>)
		);
		<jv>request</jv>.setEntity(<jk>new</jk> UrlEncodedFormEntity(<jv>params</jv>));

		HttpResponse <jv>response</jv> = <jv>client</jv>.execute(<jv>request</jv>);
		<jk>try</jk> {
			<jk>int</jk> <jv>rc</jv> = <jv>response</jv>.getStatusLine().getStatusCode();

			Header <jv>authMsg</jv> = <jv>response</jv>.getFirstHeader(<js>"X-com-ibm-team-repository-web-auth-msg"</js>);
			<jk>if</jk> (<jv>authMsg</jv> != <jk>null</jk>)
				<jk>throw new</jk> IOException(<jv>authMsg</jv>.getValue());

			<jc>// The form auth request should always respond with a 200 ok or 302 redirect code</jc>
			<jk>if</jk> (<jv>rc</jv> == <jsf>SC_MOVED_TEMPORARILY</jsf>) {
				<jk>if</jk> (<jv>response</jv>.getFirstHeader(<js>"Location"</js>).getValue().isPattern(<js>"^.*/auth/authfailed.*$"</js>))
					<jk>throw new</jk> IOException(<js>"Invalid credentials."</js>);
			} <jk>else if</jk> (<jv>rc</jv> != <jsf>SC_OK</jsf>) {
				<jk>throw new</jk> IOException(<js>"Unexpected HTTP status: "</js> + <jv>rc</jv>);
			}
		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(<jv>response</jv>.getEntity());
		}
	}

	<jc>/*
	 * This is needed for Tomcat because it responds with SC_BAD_REQUEST when the j_security_check URL is visited before an
	 * authenticated URL has been visited. This same URL must also be visited after authenticating with j_security_check
	 * otherwise tomcat will not consider the session authenticated
	 */</jc>
	<jk>private int</jk> visitAuthenticatedURL(HttpClient <jv>httpClient</jv>) <jk>throws</jk> IOException {
		HttpGet <jv>authenticatedURL</jv> = <jk>new</jk> HttpGet(<jf>jazzUri</jf>.resolve(<js>"authenticated/identity"</js>));
		HttpResponse <jv>response</jv> = <jv>httpClient</jv>.execute(<jv>authenticatedURL</jv>);
		<jk>try</jk> {
			<jk>return</jk> <jv>response</jv>.getStatusLine().getStatusCode();
		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(<jv>response</jv>.getEntity());
		}
	}
	</p>
</div>
</div><!-- END: 10.13.2 - jrc.AuthenticationForm -->

<!-- ==================================================================================================== -->

<h5 class='topic' onclick='toggle(this)'><a href='#jrc.AuthenticationOIDC' id='jrc.AuthenticationOIDC'>10.13.3 - OIDC Authentication</a></h4>
<div class='topic'><!-- START: 10.13.3 - jrc.AuthenticationOIDC -->
<div class='topic'>
	<p>
		The following example shows an implementation of a client that performs OIDC authentication against
		the IBM Jazz platform.
	</p>
	<p class='bjava'>
	<jd>/**
	 * Constructor.
	 */</jd>
	<jk>public</jk> JazzRestClient.Builder(URI <jv>jazzUri</jv>, String <jv>user</jv>, String <jv>pw</jv>) <jk>throws</jk> IOException {
		...
	}

	<jd>/**
	 * Override the createHttpClient() method to return an authenticated client.
	 */</jd>
	<ja>@Override</ja> <jc>/* RestClient.Builder */</jc>
	<jk>protected</jk> CloseableHttpClient createHttpClient() <jk>throws</jk> Exception {
		CloseableHttpClient <jv>client</jv> = <jk>super</jk>.createHttpClient();
		oidcAuthenticate(<jv>client</jv>);
		<jk>return</jk> <jv>client</jv>;
	}

	<jk>private void</jk> oidcAuthenticate(HttpClient <jv>client</jv>) <jk>throws</jk> IOException {

		HttpGet <jv>request</jv> = <jk>new</jk> HttpGet(<jf>jazzUri</jf>);
		<jv>request</jv>.setConfig(RequestConfig.<jsm>custom</jsm>().setRedirectsEnabled(<jk>false</jk>).build());
		
		<jc>// Charset must explicitly be set to UTF-8 to handle user/pw with non-ascii characters.</jc>
		<jv>request</jv>.addHeader(<js>"Content-Type"</js>, <js>"application/x-www-form-urlencoded; charset=utf-8"</js>);

		HttpResponse <jv>response</jv> = <jv>client</jv>.execute(<jv>request</jv>);
		<jk>try</jk> {
			<jk>int</jk> <jv>code</jv> = <jv>response</jv>.getStatusLine().getStatusCode();

			<jc>// Already authenticated</jc>
			<jk>if</jk> (<jv>code</jv> == <jsf>SC_OK</jsf>)
				<jk>return</jk>;

			<jk>if</jk> (<jv>code</jv> != <jsf>SC_UNAUTHORIZED</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication: "</js> 
					+ <jv>response</jv>.getStatusLine());

			<jc>// x-jsa-authorization-redirect</jc>
			String <jv>redirectUri</jv> = getHeader(<jv>response</jv>, <js>"X-JSA-AUTHORIZATION-REDIRECT"</js>);

			<jk>if</jk> (<jv>redirectUri</jv> == <jk>null</jk>)
				<jk>throw new</jk> RestCallException(<js>"Expected a redirect URI during OIDC authentication: "</js> 
					+ <jv>response</jv>.getStatusLine());

			<jc>// Handle Bearer Challenge</jc>
			HttpGet <jv>method</jv> = <jk>new</jk> HttpGet(<jv>redirectUri</jv> + <js>"&amp;prompt=none"</js>);
			addDefaultOidcHeaders(<jv>method</jv>);

			<jv>response</jv> = <jv>client</jv>.execute(<jv>method</jv>);

			<jv>code</jv> = <jv>response</jv>.getStatusLine().getStatusCode();

			<jk>if</jk> (<jv>code</jv> != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 2: "</js> 
					+ <jv>response</jv>.getStatusLine());

			String <jv>loginRequired</jv> = getHeader(<jv>response</jv>, <js>"X-JSA-LOGIN-REQUIRED"</js>);

			<jk>if</jk> (! <js>"true"</js>.equals(<jv>loginRequired</jv>))
				<jk>throw new</jk> RestCallException(<js>"X-JSA-LOGIN-REQUIRED header not found on response during OIDC authentication phase 2: "</js> 
					+ <jv>response</jv>.getStatusLine());

			<jv>method</jv> = <jk>new</jk> HttpGet(<jv>redirectUri</jv> + <js>"&amp;prompt=none"</js>);

			addDefaultOidcHeaders(<jv>method</jv>);
			<jv>response</jv> = <jv>client</jv>.execute(<jv>method</jv>);

			<jv>code</jv> = <jv>response</jv>.getStatusLine().getStatusCode();

			<jk>if</jk> (<jv>code</jv> != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 3: "</js> 
					+ <jv>response</jv>.getStatusLine());

			<jc>// Handle JAS Challenge</jc>
			<jv>method</jv> = <jk>new</jk> HttpGet(<jv>redirectUri</jv>);
			addDefaultOidcHeaders(<jv>method</jv>);

			<jv>response</jv> = <jv>client</jv>.execute(<jv>method</jv>);

			<jv>code</jv> = <jv>response</jv>.getStatusLine().getStatusCode();

			<jk>if</jk> (<jv>code</jv> != <jsf>SC_OK</jsf>)
				<jk>throw new</jk> RestCallException(<js>"Unexpected response during OIDC authentication phase 4: "</js> 
					+ <jv>response</jv>.getStatusLine());

			<jf>cookie</jf> = getHeader(<jv>response</jv>, <js>"Set-Cookie"</js>);

			Header[] <jv>defaultHeaders</jv> = <jk>new</jk> Header[] {
				BasicStringHeader.<jsm>of</jsm>(<js>"User-Agent"</js>, <js>"Jazz Native Client"</js>),
				BasicStringHeader.<jsm>of</jsm>(<js>"X-com-ibm-team-configuration-versions"</js>, 
					<js>"com.ibm.team.rtc=6.0.0,com.ibm.team.jazz.foundation=6.0"</js>),
				BasicStringHeader.<jsm>of</jsm>(<js>"Accept"</js>, <js>"text/json"</js>),
				BasicStringHeader.<jsm>of</jsm>(<js>"Authorization"</js>, <js>"Basic "</js> 
					+ StringUtils.<jsm>base64EncodeToString</jsm>(<jf>user</jf> + <js>":"</js> + <jf>pw</jf>)),
				BasicStringHeader.<jsm>of</jsm>(<js>"Cookie"</js>, <jf>cookie</jf>)
			};

			setDefaultHeaders(AList.<jsm>of</jsm>(<jv>defaultHeaders</jv>));

		} <jk>finally</jk> {
			EntityUtils.<jsm>consume</jsm>(<jv>response</jv>.getEntity());
		}
	}

	<jk>private void</jk> addDefaultOidcHeaders(HttpRequestBase <jv>method</jv>) {
		<jv>method</jv>.addHeader(<js>"User-Agent"</js>, <js>"Jazz Native Client"</js>);
		<jv>method</jv>.addHeader(<js>"X-com-ibm-team-configuration-versions"</js>, 
			<js>"com.ibm.team.rtc=6.0.0,com.ibm.team.jazz.foundation=6.0"</js>);
		<jv>method</jv>.addHeader(<js>"Accept"</js>, <js>"text/json"</js>);

		<jk>if</jk> (<jf>cookie</jf> != <jk>null</jk>) {
			<jv>method</jv>.addHeader(<js>"Authorization"</js>, <js>"Basic "</js> 
				+ StringUtils.<jsm>base64EncodeToString</jsm>(<jf>user</jf> + <js>":"</js> + <jf>pw</jf>));
			<jv>method</jv>.addHeader(<js>"Cookie"</js>, <jf>cookie</jf>);
		}
	}
	</p>	
</div>
</div><!-- END: 10.13.3 - jrc.AuthenticationOIDC -->
</div><!-- END: 10.13 - jrc.Authentication -->
</div><!-- END: 10 - juneau-rest-client -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-rest-mock' id='juneau-rest-mock'>11 - juneau-rest-mock</a><span class='update'>created: 8.1.0, updated: 8.2.0</span></h2>
<div class='topic'><!-- START: 11 - juneau-rest-mock -->
<div class='topic'>
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-rest-mock<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-rest-mock-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.rest.mock_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		The <c>juneau-rest-mock</c> module contains convenience APIs for performing serverless unit
		testing of your REST APIs.
		Each of the APIs provide the ability to fully test your server and client REST interfaces without the
		need for a running servlet container.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jrm.MockRestClient' id='jrm.MockRestClient'>11.1 - MockRestClient</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 11.1 - jrm.MockRestClient -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestClient} class is used for performing serverless unit testing of {@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated
		and {@link org.apache.juneau.http.remote.Remote @Remote}-annotated classes.
	</p>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestClient} itself extends from {@link org.apache.juneau.rest.client.RestClient} providing it with the rich
		feature set of that API.
		The following shows a simple example of invoking a PUT method on a simple REST interface and asserting
		the correct status code and response body: 
	</p>
	<p class='bjava'>
	<jk>public class</jk> MockTest {

		<jc>// A simple bean with one field.</jc>
		<jk>public static class</jk> MyBean {
			<jk>public int</jk> <jf>foo</jf> = 1;
		}

		<jc>// Our REST resource to test.</jc>
		<jc>// Simply echos the response.</jc>
		<ja>@Rest</ja>
		<jk>public static class</jk> EchoRest <jk>implements</jk> BasicRestServlet {

			<ja>@RestPut</ja>
			<jk>public</jk> MyBean echo(<ja>@Content</ja> MyBean <jv>bean</jv>) {
				<jk>return</jk> <jv>bean</jv>;
			}
		}

		<jc>// Our JUnit test.</jc>
		<ja>@Test</ja>
		<jk>public void</jk> testEcho() <jk>throws</jk> Exception {

			MyBean <jv>myBean</jv> = <jk>new</jk> MyBean();

			<jc>// Do a round-trip on the bean through the REST interface</jc>
			<jv>myBean</jv> = MockRestClient
				.<jsm>create</jsm>(EchoRest.<jk>class</jk>)
				.json5()
				.build()
				.put(<js>"/echo"</js>, <jv>myBean</jv>)
				.run()
				.assertStatus().is(200)
				.assertContent().is(<js>"{foo:1}"</js>)
				.getContent().as(MyBean.<jk>class</jk>);

			<jsm>assertEquals</jsm>(1, <jv>myBean</jv>.<jf>foo</jf>);
		}
	}
	</p>
	<p>
		Breaking apart the fluent method call above will help you understand how this works.
	</p>
	<p class='bjava'>
	<ja>@Test</ja>
	<jk>public void</jk> testEcho() <jk>throws</jk> Exception {

		<jc>// Instantiate our mock client.</jc>
		MockRestClient <jv>client</jv> = MockRestClient
			.<jsm>create</jsm>(EchoRest.<jk>class</jk>)
			.json5()
			.build();

		<jc>// Create a request.</jc>
		RestRequest <jv>req</jv> = <jv>client</jv>.put(<js>"/echo"</js>, <jv>myBean</jv>);

		<jc>// Execute it (by calling RestCallHandler.service(...) and then returning the response object).</jc>
		RestResponse <jv>res</jv> = <jv>req</jv>.run();

		<jc>// Run assertion tests on the results.</jc>
		<jv>res</jv>.assertStatus().is(200);
		<jv>res</jv>.assertContent().is(<js>"'foo'"</js>);

		<jv>myBean</jv> = <jv>res</jv>.getContent().as(MyBean.<jk>class</jk>);
	}
	</p>
	<p>
		The concept of the design is simple.  The {@link org.apache.juneau.rest.mock.MockRestClient} class is used to create instances of {@link org.apache.juneau.rest.mock.MockServletRequest}
		and {@link org.apache.juneau.rest.mock.MockServletResponse} which are passed directly to the call handler on the resource class {@link org.apache.juneau.rest.RestOpInvoker#invoke(RestOpSession)}.
		In effect, you're fully testing your REST API as if it were running in a live servlet container, yet not
		actually having to run in a servlet container.	
		All aspects of the client and server side code are tested, yet no servlet container is required.  The actual
		over-the-wire transmission is the only aspect being bypassed.
	</p>
	<p>
		The <c>create(Object)</c> method can take in either <c>Class</c> objects or pre-instantiated beans.
		The latter is particularly useful for testing REST APIs written as Spring beans.
	</p>
	
	<p class='bjava'>
	<ja>@RunWith</ja>(SpringRunner.<jk>class</jk>)
	<ja>@ContextConfiguration</ja>(classes = {MyApp.<jk>class</jk>})
	<ja>@SpringBootTest</ja>
	<jk>public class</jk> MockTest {

		<ja>@Autowired</ja>
		EchoRest <jf>echoRest</jf>;

		MockRestClient <jf>client</jf>;

		<ja>@Before</ja>
		<jk>public void</jk> setup() {
			<jc>// Instantiate our mock client.</jc>
			<jf>client</jf> = MockRestClient
				.<jsm>create</jsm>(<jf>echoRest</jf>)
				.json5()
				.build();
		}

		<jc>// Our JUnit test.</jc>
		<ja>@Test</ja>
		<jk>public void</jk> testEcho() <jk>throws</jk> Exception {

			MyBean <jv>myBean</jv> = <jk>new</jk> MyBean();

			<jc>// Do a round-trip on the bean through the REST interface</jc>
			<jv>myBean</jv> = <jf>client</jf>
				.put(<js>"/echo"</js>, <jv>myBean</jv>)
				.run()
				.assertStatus().is(200)
				.assertContent().is(<js>"{foo:1}"</js>)
				.getContent().as(MyBean.<jk>class</jk>);

			<jsm>assertEquals</jsm>(1, <jv>myBean</jv>.<jf>foo</jf>);
		}
	}
	</p>
	
	<hr>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestRequest} object has convenience methods provided to allow you to set properties
		directly on the underlying {@link javax.servlet.http.HttpServletRequest} object.  The following example shows how
		this can be used to directly set roles on the request object to perform security testing.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(roleGuard=<js>"ADMIN"</js>)
	<jk>public</jk> class A {
		<ja>@RestGet</ja>
		<jk>public</jk> String get() {
			<jk>return</jk> <js>"OK"</js>;
		}
	}

	<ja>@Test</ja>
	<jk>public void</jk> mytest() <jk>throws</jk> Exception {
		MockRestClient <jv>client</jv> = MockRestClient.<jsm>build</jsm>(A.<jk>class</jk>);

		<jc>// Admin user should get 200 but anyone else should get 403-Unauthorized.</jc>
		<jv>client</jv>.get().roles(<js>"ADMIN"</js>).run().assertStatus().is(200);
		<jv>client</jv>.get().roles(<js>"USER"</js>).run().assertStatus().is(403);
	}
	</p>
	<hr>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestClient} class has a debug mode that will cause your HTTP requests and responses to
		be sent to the console:
	</p>
	<p class='bjava'>
	MockRestClient <jv>client</jv> = MockRestClient
		.<jsm>create</jsm>(MyRest.<jk>class</jk>)
		.debug()
		.json5()
		.build();
	</p>
	<hr>
	<p>
		The {@link org.apache.juneau.rest.mock.MockRestClient} class can also be used for testing of {@link org.apache.juneau.http.remote.Remote}-annotated
		interfaces against {@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated resources.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// Our remote resource to test.</jc>
	<ja>@Remote</ja>
	<jk>public interface</jk> MyRemoteInterface {
	
		<ja>@RemoteGet</ja>(<js>"/echoQuery"</js>)
		<jk>public int</jk> echoQuery(<ja>@Query</ja>(name=<js>"id"</js>) <jk>int</jk> <jv>id</jv>);
	}

	<jc>// Our mocked-up REST interface to test against.</jc>
	<ja>@Rest</ja>
	<jk>public class</jk> MyRest {
	
		<ja>@RestGet</ja>
		<jk>public int</jk> echoQuery(<ja>@Query</ja>(<js>"id"</js>) String <jv>id</jv>) {
			<jk>return</jk> <jv>id</jv>;
		}
	}

	<ja>@Test</ja>
	<jk>public void</jk> testProxy() {
		MyRemoteInterface <jv>mri</jv> = MockRestClient
			.create(MyRest.<jk>class</jk>)
			.json()
			.build()
			.getRemote(MyRemoteInterface.<jk>class</jk>);
		
		<jsm>assertEquals</jsm>(123, <jv>mri</jv>.echoQuery(123));
	}
	</p>
</div>
</div><!-- END: 11.1 - jrm.MockRestClient -->
</div><!-- END: 11 - juneau-rest-mock -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-microservice-core' id='juneau-microservice-core'>12 - juneau-microservice-core</a><span class='update'>created: 8.1.0</span></h2>
<div class='topic'><!-- START: 12 - juneau-microservice-core -->
<div class='topic'>
	
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-microservice-core<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-microservice-core-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.microservice.core_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		Juneau Microservice is an API for creating stand-alone executable jars with automatic support for
		Juneau configurations and console commands.
	</p>
	
	<p>
		Features include:
	</p>
	<ul class='spaced-list'>
		<li>
			A builder-based API for defining and starting microservices.
		<li>
			An extensible API that allows you to hook into various lifecycle events.
		<li>
			Simple-to-use APIs for accessing manifest file entries, command-line arguments, and external configuration 
			file properties.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.Overview' id='jmc.Overview'>12.1 - Microservice Overview</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.1 - jmc.Overview -->
<div class='topic'>
	<p>
		The Microservice API consists of a base class for defining executable microservices.
	</p>
	<p>
		Features include:
	</p>
	<ul class='spaced-list'>
		<li>
			A builder-based API for defining and starting microservices.
		<li>
			An extensible API that allows you to hook into various lifecycle events.
		<li>
			Simple-to-use APIs for accessing manifest file entries, command-line arguments, and external configuration 
			file properties.
	</ul>
	<p>
		The Microservice API consists of the following packages and classes:
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.microservice}
			<ul>
				<li class='jc'>{@link org.apache.juneau.microservice.Microservice} - The base microservice class.
				<li class='jc'>{@link org.apache.juneau.microservice.Microservice.Builder} - Builder for the microservice class.
				<li class='jic'>{@link org.apache.juneau.microservice.MicroserviceListener} - Interface for hooking into lifecyle events of the microservice.
					<ul>
						<li class='jc'>{@link org.apache.juneau.microservice.BasicMicroserviceListener} - Adapter for MicroserviceListener class.
					</ul>
			</ul>
		</li>
		<li class='jp'>{@link org.apache.juneau.microservice.console}
			<ul>
				<li class='jac'>{@link org.apache.juneau.microservice.console.ConsoleCommand} - Abstract class for defining console commands.
			</ul>
		</li>
	</ul>
	<p>
		By itself the Microservice API doesn't provided much functionality but it does provide the basis for the <a class="doclink" href="#juneau-microservice-jetty">Jetty Microservice</a> described later.
	</p> 
	<p>
		The most-basic creation of a microservice from an entry-point method is shown below:
	</p>	
	<p class='bjava'>
	<jk>public class</jk> App {
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			Microservice
				.<jsm>create</jsm>()   <jc>// Create builder.</jc>
				.args(<jv>args</jv>) <jc>// Pass in args.</jc>
				.build()    <jc>// Create microservice.</jc>
				.start()    <jc>// Start microservice.</jc>
			;
		}
	}
	</p>
</div>
</div><!-- END: 12.1 - jmc.Overview -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.LifecycleMethods' id='jmc.LifecycleMethods'>12.2 - Lifecycle Methods</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.2 - jmc.LifecycleMethods -->
<div class='topic'>
	<p>
		The lifecycle methods of the {@link org.apache.juneau.microservice.Microservice} class consists of the following:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#start() start()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#startConsole() startConsole()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#join() join()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#stop() stop()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#stopConsole() stopConsole()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#exit() exit()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#kill() kill()} 
			</ul>
		</li>
	</ul>
	<p>
		A typical implementation of an app with lifecycle methods might look like the following:
	</p>
	<p class='bjava'>
	<jk>public class</jk> App {
	
		<jk>private static final</jk> Microservice <jsf>MICROSERVICE</jsf>;
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			<jsf>MICROSERVICE</jsf> = Microservice
				.<jsm>create</jsm>()          <jc>// Create builder.</jc>
				.args(<jv>args</jv>)        <jc>// Pass in args.</jc>
				.build()           <jc>// Create microservice.</jc>
				.start()           <jc>// Start microservice.</jc>
				.startConsole()    <jc>// Start console.</jc>
				.join()            <jc>// Join thread.</jc>
			;
		}
		
		<jk>public static void</jk> restart() {
			<jsf>MICROSERVICE</jsf>.stop().start();
		}
		
		<jk>public static void</jk> exit() {
			<jsf>MICROSERVICE</jsf>.exit();
		}
	}
	</p>
	<p>
		If your application consists of a single microservice, you can use the {@link org.apache.juneau.microservice.Microservice#getInstance()} method
		from anywhere in your code:
	</p>
	<p class='bjava'>
	<jk>public class</jk> App {
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			Microservice
				.<jsm>create</jsm>()          <jc>// Create builder.</jc>
				.args(<jv>args</jv>)        <jc>// Pass in args.</jc>
				.build()           <jc>// Create microservice.</jc>
				.start()           <jc>// Start microservice.</jc>
				.startConsole()    <jc>// Start console.</jc>
				.join()            <jc>// Join thread.</jc>
			;
		}
		
		<jk>public static void</jk> restart() {
			Microservice.<jsm>getInstance</jsm>().stop().start();
		}
		
		<jk>public static void</jk> exit() {
			Microservice.<jsm>getInstance</jsm>().exit();
		}
	}
	</p>
	<p>
		The {@link org.apache.juneau.microservice.Microservice#startConsole()} and {@link org.apache.juneau.microservice.Microservice#stopConsole()} control
		the lifecycle of the console commands.  
		Typically you'll want to control these separately from the app so that you can easily restart your application
		from the console without affecting the console itself.
	</p>
	<p>
		The lifecycle methods on the {@link org.apache.juneau.microservice.Microservice} class are purposely left non-final so that 
		subclasses can override them to provide customized behavior.  
	</p>
</div>
</div><!-- END: 12.2 - jmc.LifecycleMethods -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.Args' id='jmc.Args'>12.3 - Args</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.3 - jmc.Args -->
<div class='topic'>
	<p>
		Command-line arguments can be associated with a microservice using the {@link org.apache.juneau.microservice.Microservice.Builder#args(String...)} method.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jk>public static void</jk> main(String[] <jv>args</jv>) {
		Microservice
			.<jsm>create</jsm>()          <jc>// Create builder.</jc>
			.args(<jv>args</jv>)        <jc>// Pass in args.</jc>
			.build()           <jc>// Create microservice.</jc>
			.start()           <jc>// Start microservice.</jc>
			.join()            <jc>// Join thread.</jc>
		;
	}
	</p>
	<p>
		When specified, the arguments can be retrieved using the {@link org.apache.juneau.microservice.Microservice#getArgs()} method which provides
		an API for easily accessing command-line arguments using common notation:
	</p>
	<p class='bjava'>
	Args <jv>args</jv> = Microservice.<jsm>getInstance</jsm>().getArgs();
	
	<jc>// One main argument</jc>
	<jc>// a1</jc>
	String <jv>a1</jv> = <jv>args</jv>.getArg(0); <jc>// "a1"</jc>
	String <jv>a2</jv> = <jv>args</jv>.getArg(1); <jc>// null</jc>

	<jc>// Two main arguments</jc>
	<jc>// a1 a2</jc>
	String <jv>a1</jv> = <jv>args</jv>.getArg(0); <jc>// "a1"</jc>
	String <jv>a2</jv> = <jv>args</jv>.getArg(1); <jc>// "a2"</jc>

	<jc>// One main argument and one optional argument with no value</jc>
	<jc>// a1 -a2</jc>
	String <jv>args</jv>a1 = <jv>args</jv>.getArg(0);
	<jk>boolean</jk> <jv>hasA2</jv> = <jv>args</jv>.hasArg(<js>"a2"</js>); <jc>// true</jc>
	<jk>boolean</jk> <jv>hasA3</jv> = <jv>args</jv>.hasArg(<js>"a3"</js>); <jc>// false</jc>

	<jc>// One main argument and one optional argument with one value</jc>
	<jc>// a1 -a2 v2</jc>
	String <jv>a1</jv> = <jv>args</jv>.getArg(0);
	String <jv>a2</jv> = <jv>args</jv>.getArg(<js>"a2"</js>); <jc>// "v2"</jc>
	String <jv>a3</jv> = <jv>args</jv>.getArg(<js>"a3"</js>); <jc>// null</jc>

	<jc>// One main argument and one optional argument with two values</jc>
	<jc>// a1 -a2 v2a v2b</jc>
	String <jv>a1</jv> = <jv>args</jv>.getArg(0);
	List&lt;String&gt; <jv>a2</jv> = <jv>args</jv>.getArgs(<js>"a2"</js>); <jc>// Contains ["v2a","v2b"]</jc>
	List&lt;String&gt; <jv>a3</jv> = <jv>args</jv>.getArgs(<js>"a3"</js>); <jc>// Empty list</jc>

	<jc>// Same as previous, except specify optional argument name multiple times</jc>
	<jc>// a1 -a2 v2a -a2 v2b</jc>
	String <jv>a1</jv> = <jv>args</jv>.getArg(0);
	List&lt;String&gt; <jv>a2</jv> = <jv>args</jv>.getArgs(<js>"a2"</js>); <jc>// Contains ["v2a","v2b"]</jc>
	</p>
	<p>
		Specifying the command-line arguments also makes them available through {@link org.apache.juneau.svl.vars.ArgsVar $A} SVL variables.
		These can be used in the configuration file and throughout various Juneau annotations.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	<jc>// $A used in variable resolver.</jc>
	VarResolver <jv>varResolver</jv> = Microservice.<jsm>getInstance</jsm>().getVarResolver();
	System.<jsf>out</jsf>.println(<jv>varResolver</jv>.resolve(<js>"Arg #1 is set to $A{1}"</js>));
	</p>
	<p class='bjava'>
	<jc>// $A used in annotation.</jc>
	<ja>@Rest</ja>(
		title=<js>"$A{title}"</js>,
		...
	)
	</p>
</div>
</div><!-- END: 12.3 - jmc.Args -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.Manifest' id='jmc.Manifest'>12.4 - Manifest</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.4 - jmc.Manifest -->
<div class='topic'>
	<p>
		The {@link org.apache.juneau.microservice.Microservice.Builder#manifest(Object)} method can be used to specify the contents or location of of the main 
		manifest file of the executable jar.
	</p>
	<p>
		If you do not specify the location/contents of the manifest file, the microservice will attempt to resolve it through the following methods:
	</p>
	<ol class='spaced-list'>
		<li>
			Looking on the file system for a file at <js>"META-INF/MANIFEST.MF"</js>.
			This is primarily to allow for running microservices from within eclipse workspaces where the manifest file
			is located in the project root.
		<li>
			Using the class loader for this class to find the file at the URL <js>"META-INF/MANIFEST.MF"</js>.
	</ol>
	<p>
		If you do manually specify the manifest file, you can pass in any of the following types:
	</p>		
	<ul>
		<li>{@link org.apache.juneau.utils.ManifestFile} - A pre-parsed manifest file.
		<li>{@link java.util.jar.Manifest} - A pre-parsed manifest file.
		<li>{@link java.io.Reader} - Containing the raw contents of the manifest. 
		<li>{@link java.io.InputStream} - Containing the raw contents of the manifest.
		<li>{@link java.io.File} - File containing the raw contents of the manifest.
		<li>{@link java.lang.String} - Path to file containing the raw contents of the manifest.
		<li>{@link java.lang.Class} - Finds and loads the manifest file of the jar file that the specified class is contained within.
	</ul>
	<p>
		The manifest file can be retrieved using the the {@link org.apache.juneau.microservice.Microservice#getManifest()} method which 
		provides an API for accessing manifest file entries.
		This method returns an instance of {@link org.apache.juneau.utils.ManifestFile} which extends from {@link org.apache.juneau.collections.JsonMap} allowing
		you to retrieve entries as any data types supported by that class.
	</p>
	<h5 class='figure'>Example:</h5>
	<p class='bjava'>
	ManifestFile <jv>manifestFile</jv> = Microservice.<jsm>getInstance</jsm>().getManifest();
	
	String <jv>mainClass</jv> = <jv>manifestFile</jv>.getString(<js>"Main-Class"</js>);
	<jk>int</jk> <jv>myInt</jv> = <jv>manifestFile</jv>.getInt(<js>"My-Int"</js>, 123);
	<jk>boolean</jk> <jv>myBoolean</jv> = <jv>manifestFile</jv>.getBoolean(<js>"My-Boolean"</js>);
	</p>
	<p>
		The manifest is also used for the {@link org.apache.juneau.svl.vars.ManifestFileVar $MF} SVL variable.
	</p>
	<h5 class='figure'>Examples:</h5>
	<p class='bjava'>
	<jc>// $MF used in variable resolver.</jc>
	VarResolver <jv>var</jv> = Microservice.<jsm>getInstance</jsm>().getVarResolver();
	System.<jsf>out</jsf>.println(<jv>vr</jv>.resolve(<js>"The main class is $MF{Main-Class}"</js>));
	</p>
	<p class='bjava'>
	<jc>// $MF used in annotation.</jc>
	<ja>@Rest</ja>(
		title=<js>"$MF{Application-Title}"</js>,
		...
	)
	</p>
</div>
</div><!-- END: 12.4 - jmc.Manifest -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.Config' id='jmc.Config'>12.5 - Config</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.5 - jmc.Config -->
<div class='topic'>
	<p>
		The following methods can be used to define the configuration for your microservice using the powerful Config API:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#config(Config) config(Config)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#configName(String) configName(String)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#configStore(ConfigStore) configStore(ConfigStore)} 
			</ul>
		</li>
	</ul>
	<p>
		If you do not specify any of this information, we attempt to resolve it through the following methods:
	</p>
	<ol class='spaced-list'>
		<li>
			Resolve file first in working directory, then in classpath, using the following names:
			<ol>
				<li>
					The <js>"configFile"</js> argument in the command line arguments passed in through the constructor.
				<li>
					The value of the <c>Main-Config</c> entry in the manifest file.
				<li>
					A config file in the same location and with the same name as the executable jar file.
					(e.g. <js>"java -jar myjar.jar"</js> will look for <js>"myjar.cfg"</js>).
			</ol>
		<li>
			Resolve any <js>"*.cfg"</js> file that can be found in the working directory.
		<li>
			Resolve any of the following files in the classpath:
			<ol>
				<li><c>juneau.cfg</c>
				<li><c>default.cfg</c>
				<li><c>application.cfg</c>
				<li><c>app.cfg</c>
				<li><c>settings.cfg</c>
			</ol>
	</ol>
	<p>
		If no configuration file is found, and empty in-memory configuration is used.
	</p>
	<p>
		The {@link org.apache.juneau.microservice.Microservice.Builder#configName(String) configName(String)} method allows you to explicitly specify the name
		of the external configuration file location for your microservice.
	</p>
	<p class='bjava'>
	Microservice
		.<jsm>create</jsm>()     
		.config(<js>"my-files/MyMicroservice.cfg"</js>) 
		.build()
		.start()
	;
	</p>
	<p>
		By default, we try to find the file on the file system and then the classpath.
		If located on the file system, then the configuration is writeable and the microservice can automatically 
		listen for and react to changes in the configuration file on the file system.
		If located on the classpath, then the configuration can still react to modifications made to it through
		the Config API but the changes cannot be persisted since the location prevents the file from being modified.
	</p>
	
	<p>
		The {@link org.apache.juneau.microservice.Microservice.Builder#configStore(ConfigStore) configStore(ConfigStore)} method can be used to explicitly
		specify a configuration store.
		This can include your own custom configuration store, such as one that's implemented in a relational database.
	</p>
	<p class='bjava'>
	Microservice
		.<jsm>create</jsm>()     
		.configStore(<jk>new</jk> MyConfigSqlStore()) 
		.configName(<js>"MyConfig"</js>) 
		.build()
		.start()
	;
	</p>
	<p>
		The {@link org.apache.juneau.microservice.Microservice.Builder#config(Config) config(Config)} method can be used to explicitly specify a {@link org.apache.juneau.config.Config} 
		file as the microservice configuration.  When this method is used, the above two methods are bypassed entirely.
	</p>
	<p class='bjava'>
	Config <jv>config</jv> = <jsm>getMyOwnConfig</jsm>();

	Microservice
		.<jsm>create</jsm>()     
		.config(<jv>config</jv>) 
		.build()
		.start()
	;
	</p>
	<p>
		Once the configuration is resolved, it is made as the system default configuration available through the {@link org.apache.juneau.config.Config#getSystemDefault()}.
		This in turn allows it to be used by REST resources that reference the system default configuration via the <js>"SYSTEM_DEFAULT"</js> such as those
		implementing the <del>BasicRestConfig</del> interface.
	<p>
	<h5 class='figure'>BasicRestConfig.java</h5>
	<p class='bjava'>
	<ja>@Rest</ja>(
		config=<js>"$S{juneau.configFile,SYSTEM_DEFAULT}"</js>
		...
	)
	</p>
	<p>
		The {@link org.apache.juneau.microservice.Microservice#getConfig()} method can be used to get access to the configuration.
	</p>
	<p class='bjava'>
	Config <jv>config</jv> = Microservice.<jsm>getInstance</jsm>().getConfig();
	
	File <jv>logDir</jv> = <jv>config</jv>.get(<js>"Logging/logDir"</js>).as(File.<jk>class</jk>).orElse(<jk>null</jk>);
	<jk>boolean</jk> <jv>append</jv> = <jv>config</jv>.get(<js>"Logging/append"</js>).asBoolean().orElse(<jk>null</jk>);
	String <jv>format</jv> = <jv>config</jv>.get(<js>"Logging/format"</js>, <js>"[{date} {level}] {msg}%n"</js>).orElse(<jk>null</jk>);
	<jk>long</jk> <jv>limit</jv> = <jv>config</jv>.get(<js>"Logging/limit"</js>).asLong().orElse(<jk>null</jk>);
	Map&lt;String,Level&gt; <jv>levels</jv> = <jv>config</jv>.get(<js>"Logging/levels"</js>).as(Map.<jk>class</jk>, String.<jk>class</jk>, Level.<jk>class</jk>).orElse(<jk>null</jk>);
	</p>
	<p>
		Changes to the configuration file can trigger notifications that can be used to restart your microservice or make various other
		on-the-fly changes.  
		This can be accomplished by either overriding the {@link org.apache.juneau.microservice.Microservice#onConfigChange(ConfigEvents)} or implementing
		a listener and using the {@link org.apache.juneau.microservice.MicroserviceListener#onConfigChange(Microservice,ConfigEvents)} methods.
		These will be described in detail later.
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#juneau-config">juneau-config</a>
	</ul>
</div>
</div><!-- END: 12.5 - jmc.Config -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.SystemProperties' id='jmc.SystemProperties'>12.6 - System properties</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.6 - jmc.SystemProperties -->
<div class='topic'>
	<p>
		As a convenience, the <c>SystemProperties</c> section of your configuration file can be used to define system
		properties to set during initialization of your microservice:
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# System properties
	#-----------------------------------------------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#=======================================================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Configure Jetty for StdErrLog Logging
	# org.eclipse.jetty.util.log.class = org.eclipse.jetty.util.log.StrErrLog</cc>
	
	<cc># Configure Jetty to log using java-util logging</cc>
	<ck>org.eclipse.jetty.util.log.class</ck> = <cv>org.apache.juneau.microservice.jetty.JettyLogger</cv>
	
	<cc># Jetty logging level
	# Possible values:  ALL, DEBUG, INFO, WARN, OFF</cc>
	<ck>org.eclipse.jetty.LEVEL</ck> = <cv>WARN</cv>
	
	<ck>derby.stream.error.file</ck> = <cv>$C{Logging/logDir}/derby-errors.log</cv>
	</p>
</div>
</div><!-- END: 12.6 - jmc.SystemProperties -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.VarResolver' id='jmc.VarResolver'>12.7 - VarResolver</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.7 - jmc.VarResolver -->
<div class='topic'>
	<p>
		The Microservice API incorporates the <a class="doclink" href="#jm.SimpleVariableLanguage">Simple Variable Language</a> API.
	</p>
	<p>
		The variable resolver can be augmented through the following methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#vars(Class...) vars(Class...)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#varBean(Class,Object) varBean(Class,Object)} 
			</ul>
		</li>
	</ul>
	<p>
		A typical usage pattern is shown below:
	</p>
	<p class='bjava'>
	<jc>// $A used in variable resolver.</jc>
	VarResolver <jv>varResolver</jv> = Microservice.<jsm>getInstance</jsm>().getVarResolver();
	System.<jsf>out</jsf>.println(<jv>varResolver</jv>.resolve(<js>"Main class is set to $MF{Main-Class, unknown}"</js>));
	</p>
	<p>
		The variable resolver becomes much more powerful when used in REST resource annotations which will be
		described latter in <a class="doclink" href="#juneau-microservice-jetty">juneau-microservice-jetty</a>
	</p>
	<p>
		By default, support for the following variables are provided:
	</p>
	<ul>
		<li><c>$S{key[,default]}</c> - {@link org.apache.juneau.svl.vars.SystemPropertiesVar}
		<li><c>$E{key[,default]}</c> - {@link org.apache.juneau.svl.vars.EnvVariablesVar}
		<li><c>$A{key[,default]}</c> - {@link org.apache.juneau.svl.vars.ArgsVar}
		<li><c>$C{key[,default]}</c> - {@link org.apache.juneau.config.vars.ConfigVar}
		<li><c>$MF{key[,default]}</c> - {@link org.apache.juneau.svl.vars.ManifestFileVar}
		<li><c>$IF{arg,then[,else]}</c> - {@link org.apache.juneau.svl.vars.IfVar}
		<li><c>$SW{arg,pattern1:then1[,pattern2:then2...]}</c> - {@link org.apache.juneau.svl.vars.SwitchVar}
		<li><c>$CO{arg[,arg2...]}</c> - {@link org.apache.juneau.svl.vars.CoalesceVar}
		<li><c>$PM{arg,pattern}</c> - {@link org.apache.juneau.svl.vars.PatternMatchVar}
		<li><c>$UC{arg}</c> - {@link org.apache.juneau.svl.vars.UpperCaseVar}
		<li><c>$LC{arg}</c> - {@link org.apache.juneau.svl.vars.LowerCaseVar}
		<li><c>$NE{arg}</c> - {@link org.apache.juneau.svl.vars.NotEmptyVar}
	</ul>
</div>
</div><!-- END: 12.7 - jmc.VarResolver -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.ConsoleCommands' id='jmc.ConsoleCommands'>12.8 - Console Commands</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.8 - jmc.ConsoleCommands -->
<div class='topic'>
	<p>
		The Microservice API provides support for simple console commands.
	</p>
	<p class='bjava'>
	<jk>public static void</jk> main(String[] <jv>args</jv>) {
		Microservice
			.<jsm>create</jsm>() 
			.args(<jv>args</jv>)
			.build()
			.start()
			.startConsole()    <jc>// Start console.</jc>
			.join()
		;
	}
	</p>
	<p>
		When started, the console renders the following output:
	</p>
	<p class='bconsole'>
	Running class 'Microservice' using config file 'my-microservice.cfg'.
	
	List of available commands:
		exit -- Shut down service
		restart -- Restarts service
		help -- Commands help
	
	&gt; 			
	</p>
	<p>
		The builder methods for controlling the console are as follows:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice.Builder}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#consoleEnabled(boolean) consoleEnabled(boolean)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#consoleCommands(ConsoleCommand...) consoleCommands(ConsoleCommand...)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#consoleCommands(Class...) consoleCommands(Class...)} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#console(Scanner,PrintWriter) console(Scanner,PrintWriter)} 
			</ul>
		</li>
	</ul>
	<p>
		By default, the supported commands are pulled from the configuration file:
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# Console settings
	#=======================================================================================================================</cc>
	<cs>[Console]</cs>
	
	<ck>enabled = <cv>true</cv>
	
	<cc># List of available console commands.
	# These are classes that implements ConsoleCommand that allow you to submit commands to the microservice via
	# the console.
	# When listed here, the implementations must provide a no-arg constructor.
	# They can also be provided dynamically by overriding the Microservice.createConsoleCommands() method.</cc>
	<ck>commands</ck> = 
		<cv>org.apache.juneau.microservice.console.ExitCommand,
		org.apache.juneau.microservice.console.RestartCommand,
		org.apache.juneau.microservice.console.HelpCommand</cv>
	</p>
	<p>
		New commands can be added by adding them to the configuration file, or programmatically using the {@link org.apache.juneau.microservice.Microservice.Builder#consoleCommands(ConsoleCommand...) consoleCommands(ConsoleCommand...)} 
		builder method.
	</p>
	<p>
		The API for defining console commands is shown below: 
	</p>
	<ul class='javatree'>
		<li class='jac'>{@link org.apache.juneau.microservice.console.ConsoleCommand}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#execute(Scanner,PrintWriter,Args) execute(Scanner,PrintWriter,Args)} 
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#getDescription() getDescription()} 
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#getExamples() getExamples()} 
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#getInfo() getInfo()} 
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#getName() getName()} 
				<li class='jm'>{@link org.apache.juneau.microservice.console.ConsoleCommand#getSynopsis() getSynopsis()} 
			</ul>
		</li>
	</ul>
	<p>
		By default, the console input and output are taken from {@link java.lang.System#in} and {@link java.lang.System#out}.
		These can be overridden using the {@link org.apache.juneau.microservice.Microservice.Builder#console(Scanner,PrintWriter) console(Scanner,PrintWriter)} method.
	</p>
</div>
</div><!-- END: 12.8 - jmc.ConsoleCommands -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmc.Listeners' id='jmc.Listeners'>12.9 - Listeners</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 12.9 - jmc.Listeners -->
<div class='topic'>
	<p>
		As mentioned previously, the lifecycle methods for the {@link org.apache.juneau.microservice.Microservice} class are explicitly
		defined as non-final so that they can be overridden by subclasses.
	</p>
	<p>
		In addition to this support, an interface for defining event listeners for your microservice:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice.Builder}
			<ul>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice.Builder#listener(MicroserviceListener) listener(MicroserviceListener)} 
			</ul>
		</li>
		<li class='jic'>{@link org.apache.juneau.microservice.MicroserviceListener}
			<ul>
				<li class='jm'>{@link org.apache.juneau.microservice.MicroserviceListener#onStart(Microservice) onStart(Microservice)} 
				<li class='jm'>{@link org.apache.juneau.microservice.MicroserviceListener#onStop(Microservice) onStop(Microservice)} 
				<li class='jm'>{@link org.apache.juneau.microservice.MicroserviceListener#onConfigChange(Microservice,ConfigEvents) onConfigChange(Microservice,ConfigEvents)} 
			</ul>
		</li>
		<li class='jac'>{@link org.apache.juneau.microservice.BasicMicroserviceListener}
	</ul>
	<p>
		This listener API can be used for listening for and reacting to configuration changes on the file system.
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyMicroserviceListener <jk>extends</jk> BasicMicroserviceListener {
	
		<ja>@Override</ja> <jc>/* MicroserviceListener */</jc>
		<jk>public void</jk> onConfigChange(Microservice <jv>microservice</jv>, ConfigEvents <jv>events</jv>) {
			
			<jc>// Restart the microservice if anything was modified in one of our sections</jc>
			<jk>if</jk> (<jv>events</jv>.isSectionChanged(<js>"MySection"</js>))
				<jv>microservice</jv>.stop().start();
		}
	}
	</p>
	<p>
		Note that the {@link org.apache.juneau.microservice.Microservice#onConfigChange(ConfigEvents)} method can also be overridden
		to react to configuration changes as well:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyMicroservice <jk>extends</jk> Microservice {
	
		<ja>@Override</ja> <jc>/* MicroserviceListener */</jc>
		<jk>public void</jk> onConfigChange(ConfigEvents <jv>events</jv>) {
			
			<jc>// Restart the microservice if anything was modified in one of our sections</jc>
			<jk>if</jk> (<jv>events</jv>.isSectionChanged(<js>"MySection"</js>))
				<jk>this</jk>.stop().start();
		}
	}
	</p>
</div>
</div><!-- END: 12.9 - jmc.Listeners -->
</div><!-- END: 12 - juneau-microservice-core -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-microservice-jetty' id='juneau-microservice-jetty'>13 - juneau-microservice-jetty</a><span class='update'>created: 8.1.0</span></h2>
<div class='topic'><!-- START: 13 - juneau-microservice-jetty -->
<div class='topic'>
	
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bxml w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-microservice-jetty<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt><juneauVersion>9.0.0</juneauVersion><xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	
	<h5 class='figure'>Java Library</h5>
	<p class='bcode w500'>
	juneau-microservice-jetty-<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<h5 class='figure'>OSGi Module</h5>
	<p class='bcode w500'>
	org.apache.juneau.microservice.jetty_<juneauVersion>9.0.0</juneauVersion>.jar 
	</p>	
	
	<p>
		Juneau Microservice Jetty is an API for creating stand-alone executable jars that can be used to 
		start lightweight configurable REST interfaces with all the power of the Juneau REST server and client APIs.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.Overview' id='jmj.Overview'>13.1 - Overview</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.1 - jmj.Overview -->
<div class='topic'>
	<p>
		The Jetty Microservice API consists of a combination of the Juneau Core, Server, and Client APIs and an embedded
		Eclipse Jetty Servlet Container.  
	</p>
	<p>
		The API builds upon the <a class="doclink" href="#juneau-microservice-core">Core Microservices</a> classes to produce easy-to-create and
		easy-to-use microservices in a standard Java 1.8+ environment.
	</p>
	<p>
		The <c>juneau-microservice-jetty</c> library consists of the following classes:
	</p>
	<ul class='javatree'>
		<li class='jp'>{@link org.apache.juneau.microservice.jetty}
			<ul>
				<li class='jc'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice} - The Jetty microservice class.
				<li class='jc'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder} - Builder for the microservice class.
				<li class='jic'>{@link org.apache.juneau.microservice.jetty.JettyMicroserviceListener} - Interface for hooking into lifecyle events of the microservice.
					<ul>
						<li class='jc'>{@link org.apache.juneau.microservice.jetty.BasicJettyMicroserviceListener} - Adapter for JettyMicroserviceListener class.
					</ul>
				</li>
				<li class='jic'>{@link org.apache.juneau.microservice.jetty.JettyServerFactory} - Interface for defining custom Jetty servers.
					<ul>
						<li class='jc'>{@link org.apache.juneau.microservice.jetty.BasicJettyServerFactory} - Adapter for JettyServerFactory class.
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	
	<p>
		The most-basic creation of a Jetty microservice from an entry-point method is shown below:
	</p>	
	<p class='bjava'>
	<jk>public class</jk> App {
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			JettyMicroservice
				.<jsm>create</jsm>()                     <jc>// Create builder.</jc>
				.args(<jv>args</jv>)                   <jc>// Pass in args.</jc>
				.servlets(RootResource.<jk>class</jk>) <jc>// A Juneau RestServlet class.</jc>
				.build()                      <jc>// Create microservice.</jc>
				.start()                      <jc>// Start microservice.</jc>
			;
		}
	}
	</p>
</div>
</div><!-- END: 13.1 - jmj.Overview -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.LifecycleMethods' id='jmj.LifecycleMethods'>13.2 - Lifecycle Methods</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.2 - jmj.LifecycleMethods -->
<div class='topic'>
	<p>
		To review, the {@link org.apache.juneau.microservice.Microservice} class contains the following lifecycle methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.Microservice}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#start() start()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#startConsole() startConsole()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#join() join()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#stop() stop()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#stopConsole() stopConsole()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#exit() exit()} 
				<li class='jm'>{@link org.apache.juneau.microservice.Microservice#kill() kill()} 
			</ul>
		</li>
	</ul>
	<p>
		The {@link org.apache.juneau.microservice.jetty.JettyMicroservice} class which extends from {@link org.apache.juneau.microservice.Microservice} 
		provides the following additional lifecycle methods:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice}
			<ul class='javatreec'>
				<li class='jm'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice#createServer() createServer()} 
				<li class='jm'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice#startServer() startServer()} 
				<li class='jm'>{@link org.apache.juneau.microservice.jetty.JettyMicroservice#destroyServer() destroyServer()} 
			</ul>
		</li>
	</ul>
	<p>
		The additional lifecycle methods are typically not called directly but are exposed to allow subclasses to
		provide customized behavior for these events.  
		For this reason, these methods are left as non-final so that they can be overridden.
	</p>
	<p>
		A typical implementation of an app with lifecycle methods might look like the following:
	</p>
	<p class='bjava'>
	<jk>public class</jk> App {
	
		<jk>private static final</jk> JettyMicroservice <jsf>MICROSERVICE</jsf>;
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			<jsf>MICROSERVICE</jsf> = JettyMicroservice
				.<jsm>create</jsm>()                     <jc>// Create builder.</jc>
				.args(<jv>args</jv>)                   <jc>// Pass in args.</jc>
				.servlets(RootResource.<jk>class</jk>) <jc>// A Juneau RestServlet class.</jc>
				.build()                      <jc>// Create microservice.</jc>
				.start()                      <jc>// Start microservice.</jc>
				.startConsole()               <jc>// Start console.</jc>
				.join()                       <jc>// Join thread.</jc>
			;
		}
		
		<jk>public static void</jk> restart() {
			<jsf>MICROSERVICE</jsf>.stop().start();
		}
		
		<jk>public static void</jk> exit() {
			<jsf>MICROSERVICE</jsf>.exit();
		}
	}
	</p>
	<p>
		Similar to {@link org.apache.juneau.microservice.Microservice#getInstance()}, the {@link org.apache.juneau.microservice.jetty.JettyMicroservice#getInstance()}
		also allows easy access to the microservice:
	</p>
	<p class='bjava'>
	<jk>public class</jk> App {
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			JettyMicroservice
				.<jsm>create</jsm>()                     <jc>// Create builder.</jc>
				.args(<jv>args</jv>)                   <jc>// Pass in args.</jc>
				.servlets(RootResource.<jk>class</jk>) <jc>// A Juneau RestServlet class.</jc>
				.build()                      <jc>// Create microservice.</jc>
				.start()                      <jc>// Start microservice.</jc>
				.startConsole()               <jc>// Start console.</jc>
				.join()                       <jc>// Join thread.</jc>
			;
		}
		
		<jk>public static void</jk> restart() {
			JettyMicroservice.<jsm>getInstance</jsm>().stop().start();
		}
		
		<jk>public static void</jk> exit() {
			JettyMicroservice.<jsm>getInstance</jsm>().exit();
		}
	}
	</p>
</div>
</div><!-- END: 13.2 - jmj.LifecycleMethods -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.ResourceClasses' id='jmj.ResourceClasses'>13.3 - Resource Classes</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.3 - jmj.ResourceClasses -->
<div class='topic'>
	<p>
		This section describes how to define a top-level REST resource page and deploy it in our microservice.
		The example is a router page that serves as a jumping off page to child resources.
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/*"</js>,
		title=<js>"My Microservice"</js>,
		description=<js>"Top-level resources page"</js>,
		htmldoc=<ja>@HtmlDoc</ja>(
			navlinks={
				<js>"options: servlet:/?method=OPTIONS"</js>
			}
		),
		children={
			HelloWorldResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {
		<jc>// No code! </jc>
	}
	</p>
	<p>
		When deployed, it looks like this in a browser:
	</p>
	<p class='bcode'>
	http://localhost:10000
	</p>			
	<img class='bordered w800' src='doc-files/jmj.Running.1.png'>
	<ul class='spaced-list'>
		<li>
			The </l>title</l> and <l>description</l> annotations define the titles on the page.
			<br>These can be globalized using <l>$L{...}</l> variables, or by defining specially-named properties in the 
			properties file for the resource.
		<li>
			In this case, the <l>path</l> annotation defines the context root of your application since it was 
			not specified in the manifest or config file.
			<br>Therefore, this resource is mapped to <l>http://localhost:10000</l>.
		<li>
			The <l>children</l> annotation make up the list of child resources.
			<br>These child resources can be anything that extends from <l>Servlet</l>, although usually
			they will be subclasses of {@link org.apache.juneau.rest.servlet.BasicRestServlet} or other resource groups.
	</ul>
	<p>
		If you click the <l>helloWorld</l> link in your application, you'll get a simple hello world message:
	</p>
	<p class='bcode'>
	http://localhost:10000/helloWorld
	</p>			
	<img class='bordered w800' src='doc-files/jmj.ResourceClasses.1.png'>
	<p>
		...which is generated by this class...
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/helloWorld"</js>,
		title=<js>"Hello World example"</js>,
		description=<js>"Simplest possible REST resource"</js>
	)
	<jk>public class</jk> HelloWorldResource <jk>extends</jk> BasicRestServlet {
	
		<ja>@RestGet</ja>(<js>"/*"</js>)
		<jk>public</jk> String sayHello() {
			<jk>return</jk> <js>"Hello world!"</js>;
		}
	}		
	</p>
	<p>
		The most-common case for deploying the top-level resource is to use the {@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder#servlet(Class)} method:
	</p>	
	<p class='bjava'>
	<jk>public class</jk> App {
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			JettyMicroservice
				.<jsm>create</jsm>() 
				.args(<jv>args</jv>)
				.servlet(RootResources.<jk>class</jk>) <jc>// Our root resource.</jc>
				.build() 
				.start()
			;
		}
	}
	</p>
	<p>
		However, there are multiple ways of deploying top-level resources:
	</p>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder#servlet(Class)} - Using the builder.  Several methods provided.
		<li>
			{@link org.apache.juneau.microservice.jetty.JettyMicroservice#addServlet(Servlet,String)} - After the Jetty container has been started.
		<li>
			As a configuration variable <js>"Jetty/servlets"</js>.
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Jetty settings
	#=======================================================================================================================</cc>
	<cs>[Jetty]</cs>

	<cc># Subclasses of RestServlet</cc>	
	<ck>servlets</ck> = <cv>org.apache.juneau.examples.rest.RootResources</cv>	
			</p>
		<li>
			As a configuration variable <js>"Jetty/servletMap"</js>.
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Jetty settings
	#=======================================================================================================================</cc>
	<cs>[Jetty]</cs>

	<cc># Any servlets and their path specs</cc>	
	<ck>servletMap</ck> = 
		<cv>{
			'/*': 'org.apache.juneau.examples.rest.RootResources'
		}</cv>
	</cv>	
			</p>
		<li>
			Directly in the <c>jetty.xml</c> file.
			<p class='bxml'>
	<xt>&lt;Configure</xt> <xa>id</xa>=<xs>"ExampleServer"</xs> <xa>class</xa>=<xs>"org.eclipse.jetty.server.Server"</xs><xt>&gt;</xt>
		...
		<xt>&lt;New</xt> <xa>id</xa>=<xs>"context"</xs> <xa>class</xa>=<xs>"org.eclipse.jetty.servlet.ServletContextHandler"</xs><xt>&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"contextPath"</xs><xt>&gt;/&lt;/Set&gt;</xt>
			<xt>&lt;Call</xt> <xa>name</xa>=<xs>"addServlet"</xs><xt>&gt;</xt>
				<xt>&lt;Arg&gt;</xt>org.apache.juneau.rest.test.Root<xt>&lt;/Arg&gt;</xt>
				<xt>&lt;Arg&gt;</xt>/*<xt>&lt;/Arg&gt;</xt>
			<xt>&lt;/Call&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"sessionHandler"</xs><xt>&gt;</xt>
				<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.session.SessionHandler"</xs> <xt>/&gt;</xt>
			<xt>&lt;/Set&gt;</xt>
		<xt>&lt;/New&gt;</xt>
		...
			</p>
	</ul>
</div>
</div><!-- END: 13.3 - jmj.ResourceClasses -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.PredefinedResourceClasses' id='jmj.PredefinedResourceClasses'>13.4 - Predefined Resource Classes</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.4 - jmj.PredefinedResourceClasses -->
<div class='topic'>
	<p>
		The following predefined resource classes are also provided for easy inclusion into your microservice:
	</p>
	<ul class='javatree'>
		<li class='jc'>{@link org.apache.juneau.microservice.resources.ConfigResource}
			- View and modify the external INI config file.
		<li class='jc'>{@link org.apache.juneau.microservice.resources.DirectoryResource}
			- View and modify file system directories.
		<li class='jc'>{@link org.apache.juneau.microservice.resources.SampleRootResource}
			- A sample root resource class to get started from.
		<li class='jc'>{@link org.apache.juneau.microservice.resources.ShutdownResource}
			- Shutdown and/or restart the JVM.
	</ul>
</div>
</div><!-- END: 13.4 - jmj.PredefinedResourceClasses -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.Config' id='jmj.Config'>13.5 - Config</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.5 - jmj.Config -->
<div class='topic'>
	<p>
		In <a class="doclink" href="#jmc.Config">Config</a>, we described how to associate a configuration file with your
		microservice.
		In this section we describe how that configuration can be used to customize the behavior or your REST resource
		classes.
	</p>	
	<p>
		The most common usage for the configuration file is to reference values using the {@link org.apache.juneau.config.vars.ConfigVar $C} variable in annotations.
		For example, the {@link org.apache.juneau.rest.config.DefaultConfig} interface that defines the annotations that control the look-and-feel of
		classes that extend from {@link org.apache.juneau.rest.servlet.BasicRestServlet} use several <c>$C</c> variables to externalize values:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		...
		<jc>// These are static files that are served up by the servlet under the specified sub-paths.
		// For example, "/servletPath/htdocs/javadoc.css" resolves to the file "[servlet-package]/htdocs/javadoc.css"
		// By default, we define static files through the external configuration file.</jc>
		staticFiles=<js>"$C{REST/staticFiles}"</js>
	)
	<jc>// HTML-page specific settings</jc>
	<ja>@HtmlDocConfig</ja>(
	
		<jc>// Default page header contents.</jc>
		header={
			<js>"&lt;h1&gt;$RS{title}&lt;/h1&gt;"</js>,  <jc>// Use @Rest(title)</jc>
			<js>"&lt;h2&gt;$RS{operationSummary,description}&lt;/h2&gt;"</js>, <jc>// Use either @RestOp(summary) or @Rest(description)</jc>
			<js>"$C{REST/header}"</js>  <jc>// Extra header HTML defined in external config file.</jc>
		},
	
		<jc>// Default stylesheet to use for the page.
		// Can be overridden from external config file.
		// Default is DevOps look-and-feel (aka Depression look-and-feel).</jc>
		stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>,
	
		<jc>// Default contents to add to the &lt;head&gt; section of the HTML page.
		// Use it to add a favicon link to the page.</jc>
		head={
			<js>"&lt;link rel='icon' href='$U{$C{REST/favicon}}'/&gt;"</js>
		},
	
		<jc>// No default page footer contents.
		// Can be overridden from external config file.</jc>
		footer=<js>"$C{REST/footer}"</js>,
		...
	)
	<jk>public interface</jk> BasicRestConfig {}
	</p>
	<p>
		These values in turn are pulled from the external configuration file shown below.
		Note that the configuration file can also contain <c>$C</c> variables.
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# REST settings
	#=======================================================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># Mappings to folders containing static files.</cc>
	<cc># Can be in the working directory or in the classpath.</cc>
	<ck>staticFiles</ck> = <cv>htdocs:files/htdocs</cv>
	
	<cc># Stylesheet to use for HTML views.</cc>
	<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
	
	<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
	<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
	<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
	<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
	
	<ck>favicon</ck> = <cv>$C{REST/headerIcon}</cv>
	<ck>header</ck> = 
		<cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	<ck>footer</ck> = 
		<cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/footerIcon}}' style='float:right;padding-right:20px;height:32px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	</p>
	
	<p>
		Configuration files can also be accessed programmatically.
		There are 3 primary ways of getting access to the config file:
	</p>
	<ul class='javatree'>
		<li class='jm'>{@link org.apache.juneau.microservice.Microservice#getConfig()} 
			<p>Any <a class="doclink" href="#jrs.SvlVariables">initialization-time variables</a> can be used.</p>
		</li>
		<li class='jm'>{@link org.apache.juneau.rest.RestContext#getConfig()} 
			<p>Any <a class="doclink" href="#jrs.SvlVariables">initialization-time variables</a> can be used.</p>
			<h5 class='figure'>Example usage:</h5>
			<p class='bini'>
	<cc>#----------------------------------</cc>
	<cc># Configuration for MyHelloResource </cc>
	<cc>#----------------------------------</cc>
	<cs>[MyHelloResource]</cs>
	<ck>greeting</ck> = <cv>Hello world!</cv> 
			</p>
			<p class='bjava'>
	<cc>#---------------------------------</cc>
	<cc># Contents of MyHelloResource.java </cc>
	<cc>#---------------------------------</cc>
	<ja>@Rest</ja>(...)
	<jk>public class</jk> MyHelloResource <jk>extends</jk> BasicRestServlet {
		<jk>private</jk> String <jf>greeting</jf>; 
		
		<jc>// Or access config file in servlet init method.</jc>
		<ja>@Override</ja> <jc>/* Servlet */</jc>
		<jk>public void</jk> init() {
			Config <jv>config</jv> = getContext().getConfig();
			<jk>this</jk>.<jf>greeting</jf> = <jv>config</jv>.getString(<js>"MyHelloResource/greeting"</js>); 
		}
	}		
			</p>
			<p>
				Additional user-defined variables at the servlet level can be defined by adding a  
				{@link org.apache.juneau.rest.annotation.RestInit} hook method
				and using the <del> org.apache.juneau.rest.RestContext.Builder.vars(Class...)</del> method.
			</p>
		</li>
		<li class='jm'>
			{@link org.apache.juneau.rest.RestRequest#getConfig()} 
			- An instance method to access it from inside a REST method.
			<p>Any <a class="doclink" href="#jrs.SvlVariables">initialization-time or request-time variables</a> can be used.</p>
			
			<h5 class='figure'>Example usage:</h5>
			<p class='bini'>
	<cc>#----------------------------------</cc>
	<cc># Configuration for MyHelloResource</cc>
	<cc>#----------------------------------</cc>
	<cs>[MyHelloResource]</cs>
	<ck>greeting</ck> = <cv>Hello $RP{person}!</cv> <cc>// $RP is RequestPathVar</cc>
	<ck>localizedGreeting</ck> = <cv>$L{HelloMessage,$RP{person}}</cv> <cc>// $L is LocalizationVar with args</cc>
			</p>
			<p class='bjava'>
	<cc>#---------------------------------</cc>
	<cc># Contents of MyHelloResource.java </cc>
	<cc>#---------------------------------</cc>
	<ja>@Rest</ja>(
		path=<js>"/hello"</js>,
		messages=<js>"nls/Messages"</js>,
		...
	)
	<jk>public class</jk> MyHelloResource <jk>extends</jk> BasicRestServlet {

		<jd>/** Standard hello message. */</jd>
		<ja>@RestGet</ja>(<js>"/{person}"</js>)
		<jk>public</jk> String sayHello(RestRequest <jv>req</jv>) {
			<jk>return</jk> <jv>req</jv>.getConfig().getString(<js>"MyHelloResource/greeting"</js>);
		}

		<jd>/** Hello message in users language. */</jd>
		<ja>@RestGet</ja>(<js>"/localized/{person}"</js>)
		<jk>public</jk> String sayLocalizedHello(RestRequest <jv>req</jv>) {
			<jk>return</jk> <jv>req</jv>.getConfig().getString(<js>"MyHelloResource/localizedGreeting"</js>);
		}
	}		
			</p>
			<p class='bini'>
	<cc>#---------------------------------------</cc>
	<cc># Contents of nls/Messages_en.properties </cc>
	<cc>#---------------------------------------</cc>
	<ck>MyHelloResource.HelloMessage</ck> = <cv>Hello {0}!</cv> 
			</p>
			<p>
				Additional user-defined variables can be defined at this level by overriding the 
				<del> org.apache.juneau.rest.RestContext.Builder.vars(Class...)</del> method.
			</p>
		</li>
	</ul>
	<p>
		That <l>sayLocalizedHello()</l> example might need some explanation since there's a lot going on there.
		Here's what happens when an HTTP call is made to <l>GET /hello/localized/Bob</l>:
	</p>
	<ol class='spaced-list'>
		<li>
			The HTTP call matches the <l>/hello</l> path on the <l>MyHelloResource</l> class.
		<li>
			The HTTP call matches the <l>/localized/{person}</l> path on the <l>sayLocalizedHello()</l> method.
		<li>
			The request attribute <l>person</l> gets assigned the value <l>"Bob"</l>.
		<li>
			The call to <l>req.getConfig().getString("MyHelloResource/localizedGreeting")</l> 
			finds the value <l>"$L{HelloMessage,$RP{person}}"</l>.
		<li>
			The arguments in the <l>$L{}</l> variable get resolved, resulting in <l>"$L{HelloMessage,Bob}"</l>.
		<li>
			The <l>$L{}</l> variable gets resolved to the message <l>"Hello {0}!"</l> in the localized properties 
			file of the servlet based on the <l>Accept-Language</l> header on the request.
		<li>
			The arguments get replaced in the message resulting in <l>"Hello Bob!"</l>. 
		<li>
			The resulting message <l>"Hello Bob!"</l> is returned as a POJO to be serialized to whatever content 
			type was specified on the <l>Accept</l> header on the request.
	</ol>
	<p>
		This particular example is needlessly complex but it gives an idea of how variables can be used 
		recursively to produce sophisticated results
	</p>
	
	<ul class='seealso'>
		<li class='link'><a class="doclink" href="#juneau-config">juneau-config</a>
	</ul>
</div>
</div><!-- END: 13.5 - jmj.Config -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.JettyXml' id='jmj.JettyXml'>13.6 - Jetty.xml file</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.6 - jmj.JettyXml -->
<div class='topic'>
	<p>
		The Jetty microservice comes with a bare-bones <c>jetty.xml</c> file which can be modified to suite any needs. 
	</p>	
	<p>
		The <c>jetty.xml</c> can be located in either the <js>"."</js> or <js>"files"</js> working directory or classpath.
		It can also be specified in any of the following ways:
	</p>
	<ul class='spaced-list'>
		<li>
			Using the {@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder#jettyXml(Object,boolean)} method to specify the location or contents
			of the file.
		<li>
			Specifying the location using a <c>Jetty-Config</c> value in the <c>MANIFEST.MF</c> file.
			<p class='bini'>
	<mk>Jetty-Config:</mk> <mv>files/jetty.xml</mv>
			</p>
		<li>
			Specifying the location using the <js>"Jetty/jettyXml"</js> configuration value.
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Jetty settings
	#=======================================================================================================================</cc>
	<cs>[Jetty]</cs>
	
	<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>
	<ck>config</ck> = <cv>files/jetty.xml</cv>
			</p>
	</ul>
	<p>
		SVL variables in the <c>jetty.xml</c> file are automatically resolved by the microservice.
		This allows you to reference values in your configuration file from the <c>jetty.xml</c> file.
	</p>
	<p>
		The HTTP port used is controlled via the following:
	</p>
	<ul class='spaced-list'>
		<li>
			The {@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder#ports(int...)} method.
			<p class='bjava'>
	JettyMicroservice
		.<jsm>create</jsm>() 
		.args(<jv>args</jv>)  
		.servlets(RootResource.<jk>class</jk>)
		.port(1000,2000,0,0,0)  <jc>// Try port 1000, then 2000, then 3 random ports.</jc>
		.build()  
		.start()
			</p>
		<li>
			The <js>"Jetty/ports"</js> configuration property.
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Jetty settings
	#=======================================================================================================================</cc>
	<cs>[Jetty]</cs>
	
	<cc># Port to use for the jetty server.
	# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.
	<ck>port</ck> = <cv>1000,2000,0,0,0</cv>
			</p>
	</ul>
	<p>
		The first available port is then made available through the system property <js>"availablePort"</js> so that it
		can be referenced in our <c>jetty.xml</c> file.
	</p>
	<p class='bxml'>
	<xt>&lt;Set</xt> <xa>name</xa>=<xs>"connectors"</xs><xt>&gt;</xt>
		<xt>&lt;Array</xt> <xa>type</xa>=<xs>"org.eclipse.jetty.server.Connector"</xs><xt>&gt;</xt>
			<xt>&lt;Item&gt;</xt>
				<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.ServerConnector"</xs><xt>&gt;</xt>
					<xt>&lt;Arg&gt;</xt>
						<xt>&lt;Ref</xt> <xa>refid</xa>=<xs>"ExampleServer"</xs> <xt>/&gt;</xt>
					<xt>&lt;/Arg&gt;</xt>
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"port"</xs><xt>&gt;</xt>$S{availablePort,8080}<xt>&lt;/Set&gt;</xt>
				<xt>&lt;/New&gt;</xt>
			<xt>&lt;/Item&gt;</xt>
		<xt>&lt;/Array&gt;</xt>
	<xt>&lt;/Set&gt;</xt>
	</p>
	<p>
		The {@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder#jettyServerFactory(JettyServerFactory)} method is also provided
		to use your own customized Jetty server.
	</p>
</div>
</div><!-- END: 13.6 - jmj.JettyXml -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.UiCustomization' id='jmj.UiCustomization'>13.7 - UI Customization</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.7 - jmj.UiCustomization -->
<div class='topic'>
	<p>
		The Microservice project contains a <c>files/htdocs</c> folder with predefined stylesheets and
		images.
	</p>
	<img style='width:200px' src='doc-files/jmj.UiCustomization.1.png'>
	<p>
		These files can be used to tailor the look-and-feel of your microservice.
	</p>
	<p class='bcode'>
	http://localhost:10000/helloWorld
	</p>
	<img class='bordered w800' src='doc-files/jrs.UiCustomization.1.png'>
	<p>
		The REST configuration section of your microservice configuration file can be used to tailor the header and footer on the pages:
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# REST settings
	#=======================================================================================================================</cc>
	<cs>[REST]</cs>
	
	<ck>staticFiles</ck> = <cv>htdocs:files/htdocs</cv>
	
	<cc># Stylesheet to use for HTML views.</cc>
	<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
	
	<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
	<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
	<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
	<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
	
	<ck>favicon</ck> = <cv>$C{REST/headerIcon}</cv>
	<ck>header</ck> = 
		<cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	<ck>footer</ck> = 
		<cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;</cv>
			<cv>&lt;img src='$U{$C{REST/footerIcon}}' style='float:right;padding-right:20px;height:32px'/&gt;</cv>
		<cv>&lt;/a&gt;</cv>
	</p>
	<p>
		The {@link org.apache.juneau.rest.config.DefaultConfig} interface (which defines the default settings for {@link org.apache.juneau.rest.servlet.BasicRestServlet} 
		pulls in this information using {@link org.apache.juneau.config.vars.ConfigVar $C} and {@link org.apache.juneau.rest.vars.UrlVar $U} variables:
	</p>
	<p class='bjava'>
	<ja>@Rest</ja>(
		...
		<jc>// Optional external configuration file.</jc>
		config=<js>"$S{juneau.configFile}"</js>,
	
		<jc>// These are static files that are served up by the servlet under the specified sub-paths.
		// For example, "/servletPath/htdocs/javadoc.css" resolves to the file "[servlet-package]/htdocs/javadoc.css"
		// By default, we define static files through the external configuration file.</jc>
		staticFiles=<js>"$C{REST/staticFiles}"</js>
	)
	<jc>// HTML-page specific settings</jc>
	<ja>@HtmlDocConfig</ja>(
		<jc>// Default page header contents.</jc>
		header={
			<js>"&lt;h1&gt;$RS{title}&lt;/h1&gt;"</js>,  <jc>// Use @Rest(title)</jc>
			<js>"&lt;h2&gt;$RS{operationSummary,description}&lt;/h2&gt;"</js>, <jc>// Use either @RestOp(summary) or @Rest(description)</jc>
			<js>"$C{REST/header}"</js>  <jc>// Extra header HTML defined in external config file.</jc>
		},
	
		<jc>// Default stylesheet to use for the page.
		// Can be overridden from external config file.
		// Default is DevOps look-and-feel (aka Depression look-and-feel).</jc>
		stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>,
	
		<jc>// Default contents to add to the &lt;head&gt; section of the HTML page.
		// Use it to add a favicon link to the page.</jc>
		head={
			<js>"&lt;link rel='icon' href='$U{$C{REST/favicon}}'/&gt;"</js>
		},
	
		<jc>// No default page footer contents.
		// Can be overridden from external config file.</jc>
		footer=<js>"$C{REST/footer}"</js>
	)
	<jk>public interface</jk> BasicRestConfig {}
	</p>
	<p>
		Note that the <c>files/htdocs</c> directory is mapped to <js>"servlet:/htdocs"</js> using the <c>staticFiles</c>
		setting.  This allows those files to be served up through the servlet through the URL <js>"/[servlet-path]/htdocs"</js>
	</p>
	<p>
		The theme files are externally accessible and can be modified to produce any look-and-feel you desire.
		The microservice still works without the files directory.  An embedded <c>devops.css</c> is included in the jar as a default spreadsheet.
	</p>
	<p>
		If you're testing out changes in the theme stylesheets, you may want to set the following system property that prevents caching of those files so 
		that you don't need to restart the microservice each time a change is made:
	</p>
	<p class='bini'>
	<cc>#=======================================================================================================================
	# System properties
	#-----------------------------------------------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#=======================================================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Disable classpath resource caching.
	# Useful if you're attached using a debugger and you're modifying classpath resources while running.</cc>
	<ck>RestContext.disableClasspathResourceCaching.b</ck> = <cv>true</cv>
	</p>
</div>
</div><!-- END: 13.7 - jmj.UiCustomization -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jmj.Extending' id='jmj.Extending'>13.8 - Extending JettyMicroservice</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 13.8 - jmj.Extending -->
<div class='topic'>
	<p>
		This example shows how the {@link org.apache.juneau.microservice.jetty.JettyMicroservice} class
		can be extended to implement lifecycle listener methods or override existing methods.
		We'll create a new class <l>com.foo.MyJettyMicroservice</l>.
	</p>
	<p class='bjava'>
	<jd>/**
	 * Sample subclass of a JettyMicroservice that provides customized behavior.
	 */</jd>
	<jk>public class</jk> MyJettyMicroservice <jk>extends</jk> JettyMicroservice {
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) <jk>throws</jk> Exception {
			JettyMicroservice.Builder builder = JettyMicroservice.<jsm>create</jsm>();
			<jk>new</jk> MyJettyMicroservice(builder).start().join();
		}
	
		<jk>public</jk> MyJettyMicroservice(JettyMicroservice.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			<jk>super</jk>(<jv>builder</jv>);
		}
		
		<jc>// Customized code here.</jc>
	</p>
	<p>
		Optionally, you can extend the {@link org.apache.juneau.microservice.jetty.JettyMicroservice.Builder} class as well:
	</p>
	<p class='bjava'>
	<jk>public class</jk> MyJettyMicroservice.Builder <jk>extends</jk> JettyMicroservice.Builder {
	
		<jk>int</jk> <jf>extraField</jf>;

		<jd>/**
		 * Constructor (required).
		 */</jd>
		<jk>protected</jk> MyJettyMicroservice.Builder() {}
	
		<jd>/**
		 * Copy constructor (required).
		 *
		 * <ja>@param</ja> copyFrom The builder to copy settings from.
		 */</jd>
		<jk>protected</jk> MyJettyMicroservice.Builder(MyJettyMicroservice.Builder <jv>copyFrom</jv>) {
			<jk>super</jk>(<jv>copyFrom</jv>);
		}
	
		<jc>// Additional setters</jc>
	
		<jk>public</jk> MyJettyMicroservice.Builder extraField(<jk>int</jk> <jv>extraField</jv>) {
			<jk>this</jk>.<jf>extraField</jf> = <jv>extraField</jv>;
			<jk>return this</jk>;
		}
	
		<jc>// Overridden methods</jc>
	
		<ja>@Override</ja> <jc>/* JettyMicroservice.Builder */</jc>
		<jk>public</jk> MyJettyMicroservice.Builder copy() {
			<jk>return new</jk> MyJettyMicroservice.Builder(<jk>this</jk>);
		}
	
		<ja>@Override</ja> <jc>/* JettyMicroservice.Builder */</jc>
		<jk>public</jk> MyJettyMicroservice.Builder ports(<jk>int</jk>...<jv>ports</jv>) {
			<jk>super</jk>.ports(<jv>ports</jv>);
			<jk>return this</jk>;
		}
	
		<ja>@Override</ja> <jc>/* JettyMicroservice.Builder */</jc>
		<jk>public</jk> MyJettyMicroservice.Builder servlet(Class&lt;? <jk>extends</jk> RestServlet&gt; <jv>cls</jv>) <jk>throws</jk> InstantiationException, IllegalAccessException {
			<jk>super</jk>.servlet(<jv>cls</jv>);
			<jk>return this</jk>;
		}
	
		...
	}
	</p>
</div>
</div><!-- END: 13.8 - jmj.Extending -->
</div><!-- END: 13 - juneau-microservice-jetty -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#my-jetty-microservice' id='my-jetty-microservice'>14 - my-jetty-microservice</a><span class='update'>created: 8.1.0</span></h2>
<div class='topic'><!-- START: 14 - my-jetty-microservice -->
<div class='topic'>
	<h5 class='figure'>Starter Project Zip</h5>
	<p class='bcode w500'>
	my-jetty-microservice-<juneauVersion>9.0.0</juneauVersion>.zip 
	</p>	
	
	<p>
		The <l>my-jetty-microservice.zip</l> file is a predefined starter Eclipse project for developing
		REST microservices using the <a class="doclink" href="#juneau-microservice-jetty">juneau-microservice-jetty</a> package.
	</p>
	<p>
		It includes a combination of the Juneau Core, Server, and Client APIs and all libraries needed to execute in a Java 1.8+ environment.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#mjm.Installing' id='mjm.Installing'>14.1 - Installing in Eclipse</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 14.1 - mjm.Installing -->
<div class='topic'>
	<p>
		Follow these instructions to create a new template project in Eclipse.
	</p>		
	<ol class='spaced-list'>
		<li>
			Download the <c>my-jetty-microservice-<juneauVersion>9.0.0</juneauVersion>.zip</c> file from the downloads page
			(located in the binaries) and import it into your workspace as an existing project:
			<br><br>
			<img class='bordered' src='doc-files/mjm.Installing.1.png' style='width:524px'>
		<li>
			Select the archive file and import the project:
			<br><br>
			<img class='bordered' src='doc-files/mjm.Installing.2.png' style='width:549px'>
		<li>
			In your workspace, you should now see the following project:
			<br><br>
			<img class='bordered' src='doc-files/mjm.Installing.3.png' style='width:400px'>
	</ol>
	<p>
		The important elements in this project are:
	</p>
	<ul class='spaced-list'>
		<li>
			<l>App.java</l> - The entry point. 
			<br>This class creates and starts our microservice:
			<br><br>
			<p class='bjava'>
	<jk>public class</jk> App {
		
		<jk>public static void</jk> main(String[] <jv>args</jv>) <jk>throws</jk> Exception {
			JettyMicroservice
				.<jsm>create</jsm>()
				.args(<jv>args</jv>)
				.servlet(RootResources.<jk>class</jk>)
				.build()
				.start()
				.startConsole()
				.join();
		}
	}
			</p>
		<li>
			<l>RootResources.java</l> - The top-level REST resource. 
			<br>This class routes HTTP requests to child resources:
			<br><br>
			<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/"</js>,
		title=<js>"My Microservice"</js>,
		description=<js>"Top-level resources page"</js>,
		children={
			HelloWorldResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>
		}
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>,
			StyleMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"options: servlet:/?method=OPTIONS"</js>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {
		<jc>// No code</jc>
	}
			</p>
		<li>
			<l>mjm.cfg</l> - The external configuration file. 
			<br>Contains various useful settings.
			<br>Can be used for your own resource configurations.
			<br><br>
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Basic configuration file for REST microservices
	# Subprojects can use this as a starting point.
	#=======================================================================================================================</cc>
	
	<cc>#=======================================================================================================================
	# Jetty settings
	#=======================================================================================================================</cc>
	<cs>[Jetty]</cs>
	
	<cc># Path of the jetty.xml file used to configure the Jetty server.</cc>
	<ck>config</ck> = <cv>jetty.xml</cv>
	
	<cc># Resolve Juneau variables in the jetty.xml file.</cc>
	<ck>resolveVars</ck> = <cv>true</cv>
	
	<cc># Port to use for the jetty server.
	# You can specify multiple ports.  The first available will be used.  '0' indicates to try a random port.
	# The resulting available port gets set as the system property "availablePort" which can be referenced in the 
	# jetty.xml file as "$S{availablePort}" (assuming resolveVars is enabled).</cc>
	<ck>port</ck> = <cv>10000,0,0,0</cv>
	
	<cc># Optionally specify your servlets here:
	#servlets = org.apache.juneau.microservice.sample.RootResources</cc>

	<cc>#=======================================================================================================================
	# REST settings
	#=======================================================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># Comma-delimited list of key-value pairs that represent locations of static files that can be served up by your @Rest-annotated
	# classes.  These are static files that are served up by the servlet under the specified sub-paths.
	# For example, given the following setting...
	# 	staticFiles = htdocs:my-docs,styles/my-styles
	# ...the URI "/servletPath/htdocs/javadoc.css" resolves to the path "/my-docs/javadoc.css".
	# This path can be relative to the working directory, classpath root, or package of your resource class.
	# Used by the BasicRestConfig interface that defines the following value:
	# 	staticFiles="$C{REST/staticFiles}"</cc>
	<ck>staticFiles</ck> = htdocs:htdocs
	
	<cc># Stylesheet to use for HTML views.
	# Used by the BasicRestConfig interface that defines the following value:
	# 	stylesheet="$C{REST/theme,servlet:/htdocs/themes/devops.css}"</cc>
	<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
	
	<cc># Various look-and-feel settings used in the BasicRestConfig interface.</cc>
	<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
	<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
	<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
	<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
	<ck>favicon</ck> = <cv>$C{REST/headerIcon}</cv>
	<ck>header</ck> = 
		<cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;
			&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;
		&lt;/a&gt;</cv>
	<ck>footer</ck> = 
		<cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;
			&lt;img src='$U{$C{REST/footerIcon}}' style='float:right;padding-right:20px;height:32px'/&gt;
		&lt;/a&gt;</cv>
	
	<cc>#=======================================================================================================================
	# Console settings
	#=======================================================================================================================</cc>
	<cs>[Console]</cs>
	
	<ck>enabled</ck> = <cv>true</cv>
	
	<cc># List of available console commands.
	# These are classes that implements ConsoleCommand that allow you to submit commands to the microservice via
	# the console.
	# When listed here, the implementations must provide a no-arg constructor.
	# They can also be provided dynamically by overriding the Microservice.createConsoleCommands() method.</cc>
	<ck>commands</ck> = 
		<cv>org.apache.juneau.microservice.console.ExitCommand,
		org.apache.juneau.microservice.console.RestartCommand,
		org.apache.juneau.microservice.console.HelpCommand,
		org.apache.juneau.microservice.console.ConfigCommand</cv>
		
	<cc>#=======================================================================================================================
	# Logger settings
	#-----------------------------------------------------------------------------------------------------------------------
	# See FileHandler Java class for details.
	#=======================================================================================================================</cc>
	<cs>[Logging]</cs>

	...
	
	<cc>#=======================================================================================================================
	# System properties
	#-----------------------------------------------------------------------------------------------------------------------
	# These are arbitrary system properties that are set during startup.
	#=======================================================================================================================</cc>
	<cs>[SystemProperties]</cs>
	
	<cc># Configure Jetty for StdErrLog Logging
	# org.eclipse.jetty.util.log.class = org.eclipse.jetty.util.log.StrErrLog</cc>
	
	<cc># Configure Jetty to log using java-util logging</cc>
	<ck>org.eclipse.jetty.util.log.class</ck> = <cv>org.apache.juneau.microservice.jetty.JettyLogger</cv>
	
	<cc># Jetty logging level
	# Possible values:  ALL, DEBUG, INFO, WARN, OFF</cc>
	<ck>org.eclipse.jetty.LEVEL</ck> = <cv>WARN
	
	<ck>derby.stream.error.file</ck> = <cv>$C{Logging/logDir}/derby-errors.log</cv>					
			</p>
		<li>
			<l>jetty.xml</l> - The Jetty configuration file. 
			<br>A bare-bones config file that can be extended to use any Jetty features.
			<br><br>
			<p class='bxml'>
	<xt>&lt;Configure</xt> <xa>id</xa>=<xs>"ExampleServer"</xs> <xa>class</xa>=<xs>"org.eclipse.jetty.server.Server"</xs>&gt;</xt>
	
		<xt>&lt;Set</xt> <xa>name</xa>=<xs>"connectors"</xs><xt>&gt;</xt>
			<xt>&lt;Array</xt> <xa>type</xa>=<xs>"org.eclipse.jetty.server.Connector"</xs><xt>&gt;</xt>
				<xt>&lt;Item&gt;</xt>
					<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.ServerConnector"</xs><xt>&gt;</xt>
						<xt>&lt;Arg&gt;</xt>
							<xt>&lt;Ref</xt> <xa>refid</xa>=<xs>"ExampleServer"</xs><xt>/&gt;</xt>
						<xt>&lt;/Arg&gt;</xt>
						<xt>&lt;Set</xt> <xa>name</xa>=<xs>"port"</xs><xt>&gt;</xt>$S{availablePort,8080}<xt>&lt;/Set&gt;</xt>
					<xt>&lt;/New&gt;</xt>
				<xt>&lt;/Item&gt;</xt>
			<xt>&lt;/Array&gt;</xt>
		<xt>&lt;/Set&gt;</xt>
	
		<xt>&lt;New</xt> <xa>id</xa>=<xs>"context"</xs> <xa>class</xa>=<xs>"org.eclipse.jetty.servlet.ServletContextHandler"</xs><xt>&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"contextPath"</xs><xt>&gt;/&lt;/Set&gt;</xt>
			<xc>&lt;!-- Optionally specify your servlets here --&gt;
			&lt;!--Call name="addServlet"&gt;
				&lt;Arg&gt;org.apache.juneau.microservice.sample.RootResources&lt;/Arg&gt;
				&lt;Arg&gt;/*&lt;/Arg&gt;
			&lt;/Call--&gt;</xc>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"sessionHandler"</xs><xt>&gt;</xt>
				<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.session.SessionHandler"</xs><xt>/&gt;</xt>
			<xt>&lt;/Set&gt;</xt>
		<xt>&lt;/New&gt;</xt>
	
		<xt>&lt;Set</xt> <xa>name</xa>=<xs>"handler"</xs><xt>&gt;</xt>
			<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.handler.HandlerCollection"</xs><xt>&gt;</xt>
				<xt>&lt;Set</xt> <xa>name</xa>=<xs>"handlers"</xs><xt>&gt;</xt>
					<xt>&lt;Array</xt> <xa>type</xa>=<xs>"org.eclipse.jetty.server.Handler"</xs><xt>&gt;</xt>
						<xt>&lt;Item&gt;</xt>
							<xt>&lt;Ref</xt> <xa>refid</xa>=<xs>"context"</xs><xt>/&gt;</xt>
						<xt>&lt;/Item&gt;</xt>
						<xt>&lt;Item&gt;</xt>
							<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.handler.DefaultHandler"</xs><xt>/&gt;</xt>
						<xt>&lt;/Item&gt;</xt>
					<xt>&lt;/Array&gt;</xt>
				<xt>&lt;/Set&gt;</xt>
			<xt>&lt;/New&gt;</xt>
		<xt>&lt;/Set&gt;</xt>
	
		<xt>&lt;New</xt> <xa>id</xa>=<xs>"RequestLogImpl"</xs> <xa>class</xa>=<xs>"org.eclipse.jetty.server.CustomRequestLog"</xs><xt>&gt;</xt>
			<xc>&lt;!-- Param 0: org.eclipse.jetty.server.RequestLogWriter --&gt;</xc>
			<xt>&lt;Arg&gt;</xt>
				<xt>&lt;New</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.RequestLogWriter"</xs><xt>&gt;</xt>
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"append"</xs><xt>&gt;</xt>false<xt>&lt;/Set&gt;</xt>;
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"filename"</xs><xt>&gt;&lt;Property</xt> <xa>name</xa>=<xs>"jetty.logs"</xs> <xa>default</xa>=<xs>"$C{Logging/logDir,logs}"</xs> <xt>/&gt;</xt>/jetty-requests.log<xt>&lt;/Set&gt;</xt>;
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"filenameDateFormat"</xs><xt>&gt;</xt>yyyy_MM_dd<xt>&lt;/Set&gt;</xt>
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"retainDays"</xs><xt>&gt;</xt>90<xt>&lt;/Set&gt;</xt>
					<xt>&lt;Set</xt> <xa>name</xa>=<xs>"timeZone"</xs><xt>&gt;</xt>GMT<xt>&lt;/Set&gt;</xt>
				<xt>&lt;/New&gt;</xt>
			<xt>&lt;/Arg&gt;</xt>
			<xc>&lt;!-- Param 1: String --&gt;</xc>
			<xt>&lt;Arg&gt;</xt>
				<xt>&lt;Get</xt> <xa>class</xa>=<xs>"org.eclipse.jetty.server.CustomRequestLog"</xs> <xa>name</xa>=<xs>"EXTENDED_NCSA_FORMAT"</xs> <xt>/&gt;</xt>
			<xt>&lt;/Arg&gt;</xt>
		<xt>&lt;/New&gt;</xt>
	
		<xt>&lt;Get</xt> <xa>name</xa>=<xs>"ThreadPool"</xs><xt>&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"minThreads"</xs> <xa>type</xa>=<xs>"int"</xs><xt>&gt;</xt>10<xt>&lt;/Set&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"maxThreads"</xs> <xa>type</xa>=<xs>"int"</xs><xt>&gt;</xt>100<xt>&lt;/Set&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"idleTimeout"</xs> <xa>type</xa>=<xs>"int"</xs><xt>&gt;</xt>60000<xt>&lt;/Set&gt;</xt>
			<xt>&lt;Set</xt> <xa>name</xa>=<xs>"detailedDump"</xs><xt>&gt;</xt>true<xt>&lt;/Set&gt;</xt>
		<xt>&lt;/Get&gt;</xt>
	<xt>&lt;/Configure&gt;</xt>
			</p>
	</ul>
	<p>
		At this point, you're ready to start the microservice from your workspace.
	</p>
</div>
</div><!-- END: 14.1 - mjm.Installing -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#mjm.Running' id='mjm.Running'>14.2 - Running in Eclipse</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 14.2 - mjm.Running -->
<div class='topic'>
	<p>
		The <l>mjm.launch</l> file is already provided to allow you to quickly start
		your new microservice.
	</p>
	<p>
		Go to <b>Run -&gt; Run Configurations -&gt; Java Application -&gt; my-jetty-microservice</b> and click <b>Run</b>.
		In your console view, you should see the following output:
	</p>
	<p class='bconsole'>
	Running class 'JettyMicroservice' using config file 'mjm.cfg'.
	Server started on port 10000
	
	List of available commands:
		exit -- Shut down service
		restart -- Restarts service
		help -- Commands help
	
	&gt; 			
	</p>
	<p>
		Now open your browser and point to <l>http://localhost:10000</l>.  
		You should see the following:
	</p>
	<p class='bcode w400'>
	http://localhost:10000
	</p>			
	<img class='bordered w400' src='doc-files/mjm.Running.1.png'>
	<p>
		You can enter the command <c>exit</c> to shut it down.
	</p>
</div>
</div><!-- END: 14.2 - mjm.Running -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#mjm.Building' id='mjm.Building'>14.3 - Building and Running from Command-Line</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 14.3 - mjm.Building -->
<div class='topic'>
	<p>
		The <l>pom.xml</l> file is a basic Maven build script for creating your microservice
		as an executable uber-jar.
	</p>
	<p>
		The easiest way to build your microservice is to run the following from the project root.
	</p>
	<p class='bconsole'>
	mvn clean install
	</p>
	<p>
		Your <c>target</c> directory should now contain the following files:
	</p>
	<ul>
		<li><c>my-jetty-microservice-1.0.jar</c>
		<li><c>mjm.cfg</c>
	</ul>
	<p>
		To start from a command line, run the following command from inside your <c>target</c> directory:
	</p>
	<p class='bconsole'>
	java -jar my-jetty-microservice-1.0.jar
	</p>
	<p>
		You should see the following console output:
	</p>
	<p class='bconsole'>
	Running class 'JettyMicroservice' using config file 'mjm.cfg'.
	Server started on port 10000
	
	List of available commands:
		exit -- Shut down service
		restart -- Restarts service
		help -- Commands help
	
	&gt; 			
	</p>
	<p>
		If you get this error message: <code class='snippet'>java.net.BindException: Address already in use</code>, 
		then this microservice is already running elsewhere and so it cannot bind to port 10000.
	</p>
</div>
</div><!-- END: 14.3 - mjm.Building -->
</div><!-- END: 14 - my-jetty-microservice -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#my-springboot-microservice' id='my-springboot-microservice'>15 - my-springboot-microservice</a><span class='update'>created: 8.0.0</span></h2>
<div class='topic'><!-- START: 15 - my-springboot-microservice -->
<div class='topic'>
	<h5 class='figure'>Starter Project Zip</h5>
	<p class='bcode w500'>
	my-springboot-microservice-<juneauVersion>9.0.0</juneauVersion>.zip 
	</p>	
	
	<p>
		The <l>my-springboot-microservice.zip</l> file is a predefined starter Eclipse project for developing
		REST microservices using the <a class="doclink" href="#juneau-rest-server-springboot">juneau-rest-server-springboot</a> package with Spring Boot.
	</p>
	<p>
		It includes a combination of the Juneau Core, Server, and Client APIs and all libraries needed to execute in a Java 1.8+ environment.
	</p>
	<p>
		One significant difference is that we are not using the Juneau {@link org.apache.juneau.microservice.Microservice} API for our
		application but instead using the existing Spring Boot API.
	</p>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#msm.Installing' id='msm.Installing'>15.1 - Installing in Eclipse</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 15.1 - msm.Installing -->
<div class='topic'>
	<p>
		Follow these instructions to create a new template project in Eclipse.
	</p>		
	<ol class='spaced-list'>
		<li>
			Download the <c>my-springboot-microservice-<juneauVersion>9.0.0</juneauVersion>.zip</c> file from the downloads page
			(located in the binaries) and import it into your workspace as an existing project:
			<br><br>
			<img class='bordered' src='doc-files/msm.Installing.1.png' style='width:524px'>
		<li>
			Select the archive file and import the project:
			<br><br>
			<img class='bordered' src='doc-files/msm.Installing.2.png' style='width:549px'>
		<li>
			In your workspace, you should now see the following project:
			<br><br>
			<img class='bordered' src='doc-files/msm.Installing.3.png' style='width:400px'>
	</ol>
	<p>
		The important elements in this project are:
	</p>
	<ul class='spaced-list'>
		<li>
			<l>App.java</l> - The entry point. 
			<br>This class creates and starts our microservice.
			<br>Note that we're using the existing Spring Boot application logic for the microservice and we're retrieving
			our root resource as a spring bean.
			<br>Only the top-level resource needs to be annotated with <del>JuneauRestRoot @JuneauRestRoot</del>
			<br><br>
			<p class='bjava'>
	<ja>@SpringBootApplication</ja>
	<ja>@Controller</ja>
	<jk>public class</jk> App {
	
		<jk>public static void</jk> main(String[] args) {
			<jk>new</jk> SpringApplicationBuilder(App.<jk>class</jk>)
				.initializers(<jk>new</jk> JuneauRestInitializer(App.<jk>class</jk>))
				.run(args);
		}
	
		<ja>@Bean @JuneauRestRoot</ja>
		<jk>public</jk> RootResources getRootResources() {
			<jk>return new</jk> RootResources();
		}
	}
			</p>
		<li>
			<l>RootResources.java</l> - The top-level REST resource. 
			<br>This class routes HTTP requests to child resources.
			<br>This is identical to the Jetty example.
			<br><br>
			<p class='bjava'>
	<ja>@Rest</ja>(
		path=<js>"/"</js>,
		title=<js>"My Microservice"</js>,
		description=<js>"Top-level resources page"</js>,
		htmldoc=<ja>@HtmlDoc</ja>(
			widgets={
				ContentTypeMenuItem.<jk>class</jk>,
				StyleMenuItem.<jk>class</jk>
			},
			navlinks={
				<js>"options: servlet:/?method=OPTIONS"</js>
			}
		),
		children={
			HelloWorldResource.<jk>class</jk>,
			ConfigResource.<jk>class</jk>,
			LogsResource.<jk>class</jk>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicRestServletGroup {
		<jc>// No code</jc>
	}
			</p>
		<li>
			<l>juneau.cfg</l> - The configuration file. 
			<br>Contains various useful settings.
			<br>Can be used for your own resource configurations.
			<br>Note that the Jetty configuration is not present.
			<br>Also it's located in the classpath so that our microservice can be built as a single executable jar. 
			<br><br>
			<p class='bini'>
	<cc>#=======================================================================================================================
	# Basic configuration file for REST microservices
	# Subprojects can use this as a starting point.
	#=======================================================================================================================</cc>
	
	<cc>#=======================================================================================================================
	# REST settings
	#=======================================================================================================================</cc>
	<cs>[REST]</cs>
	
	<cc># Comma-delimited list of key-value pairs that represent locations of static files that can be served up by your @Rest-annotated
	# classes.  These are static files that are served up by the servlet under the specified sub-paths.
	# For example, given the following setting...
	# 	staticFiles = htdocs:my-docs,styles/my-styles
	# ...the URI "/servletPath/htdocs/javadoc.css" resolves to the path "/my-docs/javadoc.css".
	# This path can be relative to the working directory, classpath root, or package of your resource class.
	# Used by the BasicRestConfig interface that defines the following value:
	# 	staticFiles="$C{REST/staticFiles}"</cc>
	<ck>staticFiles</ck> = htdocs:htdocs
	
	<cc># Stylesheet to use for HTML views.
	# Used by the BasicRestConfig interface that defines the following value:
	# 	stylesheet="$C{REST/theme,servlet:/htdocs/themes/devops.css}"</cc>
	<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
	
	<cc># Various look-and-feel settings used in the BasicRestConfig interface.</cc>
	<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
	<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
	<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
	<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
	<ck>favicon</ck> = <cv>$C{REST/headerIcon}</cv>
	<ck>header</ck> = 
		<cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;
			&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;
		&lt;/a&gt;</cv>
	<ck>footer</ck> = 
		<cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;
			&lt;img src='$U{$C{REST/footerIcon}}' style='float:right;padding-right:20px;height:32px'/&gt;
		&lt;/a&gt;</cv>
			</p>
	</ul>
	<p>
		At this point, you're ready to start the microservice from your workspace.
	</p>
</div>
</div><!-- END: 15.1 - msm.Installing -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#msm.Running' id='msm.Running'>15.2 - Running in Eclipse</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 15.2 - msm.Running -->
<div class='topic'>
	<p>
		The <l>msm.launch</l> file is already provided to allow you to quickly start
		your new microservice.
	</p>
	<p>
		Go to <b>Run -&gt; Run Configurations -&gt; Java Application -&gt; my-springboot-microservice</b> and click <b>Run</b>.
		In your console view, you should see the following output:
	</p>
	<p class='bconsole'>
	  .   ____          _            __ _ _
	 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
	( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
	 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
	  '  |____| .__|_| |_|_| |_\__, | / / / /
	 =========|_|==============|___/=/_/_/_/
	 :: Spring Boot ::        (v2.0.1.RELEASE)
	...
	INFO: Tomcat started on port(s): 8080 (http) with context path ''
	Dec 21, 2012 12:30:00 AM org.springframework.boot.StartupInfoLogger logStarted
	INFO: Started App in 1.999 seconds (JVM running for 2.999)
	</p>
	<p>
		Now open your browser and point to <l>http://localhost:5000</l>.  
		You should see the following:
	</p>
	<p class='bcode w400'>
	http://localhost:5000
	</p>			
	<img class='bordered w400' src='doc-files/msm.Running.1.png'>
</div>
</div><!-- END: 15.2 - msm.Running -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#msm.Building' id='msm.Building'>15.3 - Building and Running from Command-Line</a><span class='update'>created: 8.0.0</span></h3>
<div class='topic'><!-- START: 15.3 - msm.Building -->
<div class='topic'>
	<p>
		The <l>pom.xml</l> file is a basic Maven build script for creating your microservice
		as an executable uber-jar.
	</p>
	<p>
		The easiest way to build your microservice is to run the following from the project root.
	</p>
	<p class='bconsole'>
	mvn clean install
	</p>
	<p>
		Your <c>target</c> directory should now contain the following files:
	</p>
	<ul>
		<li><c>my-springboot-microservice-1.0.jar</c>
	</ul>
	<p>
		To start from a command line, run the following command from inside your <c>target</c> directory:
	</p>
	<p class='bconsole'>
	java -jar my-springboot-microservice-1.0.jar
	</p>
	<p>
		You should see the following console output:
	</p>
	<p class='bconsole'>
	  .   ____          _            __ _ _
	 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
	( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
	 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
	  '  |____| .__|_| |_|_| |_\__, | / / / /
	 =========|_|==============|___/=/_/_/_/
	 :: Spring Boot ::        (v2.0.1.RELEASE)
	...
	INFO: Tomcat started on port(s): 8080 (http) with context path ''
	Dec 21, 2012 12:30:00 AM org.springframework.boot.StartupInfoLogger logStarted
	INFO: Started App in 1.999 seconds (JVM running for 2.999)
	</p>
</div>
</div><!-- END: 15.3 - msm.Building -->
</div><!-- END: 15 - my-springboot-microservice -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#juneau-petstore' id='juneau-petstore'>16 - juneau-petstore</a><span class='update'>created: 8.2.0, updated: <b>9.0.0</b></span></h2>
<div class='topic'><!-- START: 16 - juneau-petstore -->
<div class='topic'>
	<p>
		The <c>PetStore</c> application is an functional application meant to demonstrate using Juneau with Spring Boot
		to create an end-to-end client/server REST API. 
	</p>
	<p>
		What makes Juneau unique is the ability to create Java interfaces that behave just like RPC but using REST
		as the underlying protocol.  And the technology it not tied to any platform so it can be used in any environment
		by simply pulling in Maven dependencies.  The server-side need only provide the ability to host a servlet.
	</p>
	<p>
		Visit the <a class='doclink' href='https://github.com/apache/juneau-petstore'>GitHub project</a> hosting the application.
	</p>
	<p>
		The project is broken down into the following subprojects:
	</p>
	<ul class='spaced-list'>
		<li><c>juneau-petstore-api</c> - Contains the Java interface and DTOs for the petstore application.
		<li><c>juneau-petstore-server</c> - Contains the server-side Java implementation of the petstore Java interface as a REST resource.
		<li><c>juneau-petstore-client</c> - Contains the client-side Java proxy of the petstore Java interface.
	</ul>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jp.RunningTheApp' id='jp.RunningTheApp'>16.1 - Running the Pet Store App</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 16.1 - jp.RunningTheApp -->
<div class='topic'>
	<p>
		The Pet Store app is a Spring Boot application that can be started up by running the <c>App</c> class.
		This starts the application on port 5000.  It can also be started in a docker container using the following
		instructions:
	</p>
	<ul class='spaced-list'>
		<li>
			Install <a class='doclink' href='https://docs.docker.com/install/'>docker</a> on your machine.
		</li>
		<li>
			<p>
				Clone the Petstore project on your machine.
			</p>
			<p class='bcode w800'>
	git clone https://github.com/apache/juneau-petstore.git
			</p>
		</li>
		<li>
			<p>
				Open terminal inside the project directory and run the below command to start the app.
			</p>
			<p class='bcode w800'>
	docker build . -t petstore &amp;&amp; docker run -p 5000:5000 petstore
			</p>
		</li>
	</ul>
</div>
</div><!-- END: 16.1 - jp.RunningTheApp -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jp.juneau-petstore-api' id='jp.juneau-petstore-api'>16.2 - juneau-petstore-api</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 16.2 - jp.juneau-petstore-api -->
<div class='topic'>
	<p>
		The <c>juneau-petstore-api</c> module contains the Java interface of our application and the DTOs that go along
		with it.  These classes are meant to be shared between the server and client side code.
	</p>
	
	<p>
		The <c>PetStore</c> class is our primary class for defining our application.  It's a standard Java interface with 
		annotations used to describe how the methods map to REST calls.
	</p>
	<h5 class='figure'>PetStore.java</h5>
	<p class='bcode w800'>
	<ja>@Remote</ja>(path=<js>"/petstore"</js>)
	<jk>public interface</jk> PetStore {
	
		<jc>//------------------------------------------------------------------------------------------------------------------
		// Pets
		//------------------------------------------------------------------------------------------------------------------</jc>
	
		<jd>/**
		 * Returns all pets in the database.
		 *
		 * @return All pets in the database.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 */</jd>
		<ja>@RemoteGet</ja>(<js>"/pet"</js>)
		<jk>public</jk> Collection<Pet> getPets() <jk>throws</jk> NotAcceptable;
	
		<jd>/**
		 * Returns a pet from the database.
		 *
		 * @param petId The ID of the pet to retrieve.
		 * @return The pet.
		 * @throws IdNotFound Pet was not found.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 */</jd>
		<ja>@RemoteGet</ja>(<js>"/pet/{petId}"</js>)
		<jk>public</jk> Pet getPet(
			<ja>@Path</ja>(
				name=<js>"petId"</js>,
				schema=<ja>@Schema</ja>(description=<js>"ID of pet to return"</js>)
			)
			<jk>long</jk> <jv>petId</jv>
		) <jk>throws</jk> IdNotFound, NotAcceptable;
	
		<jd>/**
		 * Adds a pet to the database.
		 *
		 * @param pet The pet data to add to the database.
		 * @return Ok if successful.
		 * @throws IdConflict ID already in use.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 * @throws UnsupportedMediaType Unsupported <c>Content-Type</c> header specified.
		 */</jd>
		<ja>@RemotePost</ja>(<js>"/pet"</js>)
		<jk>public long</jk> createPet(
			<ja>@Content</ja>(
				schema=<ja>@Schema</ja>(description=<js>"Pet object to add to the store"</js>)
			)
			CreatePet <jv>pet</jv>
		) <jk>throws</jk> IdConflict, NotAcceptable, UnsupportedMediaType;
	
		<jd>/**
		 * Updates a pet in the database.
		 *
		 * @param pet The pet data to add to the database.
		 * @return Ok if successful.
		 * @throws IdNotFound ID not found.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 * @throws UnsupportedMediaType Unsupported <c>Content-Type</c> header specified.
		 */</jd>
		<ja>@RemotePut</ja>(<js>"/pet/{petId}"</js>)
		<jk>public</jk> Ok updatePet(
			<ja>@Content</ja>(
				schema=<ja>@Schema</ja>(description=<js>"Pet object that needs to be added to the store"</js>)
			)
			UpdatePet <jv>pet</jv>
		) <jk>throws</jk> IdNotFound, NotAcceptable, UnsupportedMediaType;
	
		<jd>/**
		 * Find all pets with the matching statuses.
		 *
		 * @param status The statuses to match against.
		 * @return The pets that match the specified statuses.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 */</jd>
		<ja>@RemoteGet</ja>(<js>"/pet/findByStatus"</js>)
		<jk>public</jk> Collection&lt;Pet&gt; findPetsByStatus(
			<ja>@Query</ja>(
				name=<js>"status"</js>,
				schema=<ja>@Schema</ja>(
					description=<js>"Status values that need to be considered for filter."</js>,
					required=<jk>true</jk>,
					type=<js>"array"</js>,
					collectionFormat=<js>"csv"</js>,
					items=<ja>@Items</ja>(
						type=<js>"string"</js>,
						_enum=<js>"AVAILABLE,PENDING,SOLD"</js>,
						_default=<js>"AVAILABLE"</js>
					)
				)
			)
			PetStatus[] <jv>status</jv>
		) <jk>throws</jk> NotAcceptable;
	
		<jd>/**
		 * Deletes the specified pet.
		 *
		 * @param apiKey Security key.
		 * @param petId ID of pet to delete.
		 * @return Ok if successful.
		 * @throws IdNotFound Pet not found.
		 * @throws NotAcceptable Unsupported <c>Accept</c> header specified.
		 */</jd>
		<ja>@RemoteDelete</ja>(<js>"/pet/{petId}"</js>)
		<jk>public</jk> Ok deletePet(
			<ja>@Header</ja>(
				name=<js>"api_key"</js>,
				schema=<ja>@Schema</ja>(
					description=<js>"Security API key"</js>,
					required=<jk>true</jk>
				)
			)
			String <jv>apiKey</jv>,
			<ja>@Path</ja>(
				name=<js>"petId"</js>,
				schema=<ja>@Schema(description=<js>"Pet id to delete"</js>)
			)
			<jk>long</jk> <jv>petId</jv>
		) <jk>throws</jk> IdNotFound, NotAcceptable;
	
		<jd>/**
		 * Deletes all pets in the database.
		 *
		 * @return Ok if successful.
		 */</jd>
		<ja>@RemoteDelete</ja>(<js>"/pet"</js>)
		<jk>public</jk> Ok deleteAllPets();
	
		<jc>//------------------------------------------------------------------------------------------------------------------
		// Orders
		//------------------------------------------------------------------------------------------------------------------</jc>
	
		...
	}
	</p>

	<p>
		<ja>@Remote</ja> and <ja>@RemoteX</ja> are client-side annotations used to map the method calls to REST
		and will be describe in the client code section.
	</p>
	<p>
		<ja>@Path</ja> and <ja>@Body</ja> are used by both the client and server side code to map to REST artifacts on both
		sides.
	</p>
	<p>
		Both sets of annotations are provided by pulling in the Juneau dependency below:
	
	<h5 class='figure'>Maven Dependency</h5>
	<p class='bcode w500'>
	<xt>&lt;dependency&gt;</xt>
		<xt>&lt;groupId&gt;</xt>org.apache.juneau<xt>&lt;/groupId&gt;</xt>
		<xt>&lt;artifactId&gt;</xt>juneau-marshall<xt>&lt;/artifactId&gt;</xt>
		<xt>&lt;version&gt;</xt>9.x.x<xt>&lt;/version&gt;</xt>
	<xt>&lt;/dependency&gt;</xt>
	</p>	
	<p>
		The <c>Pet</c> class is a DTO that gets serialized over the REST connection.  It is also annotated with JPA annotations
		so that they can easily be stored in a JPA datastore on the server side.
	</p>
	<h5 class='figure'>Pet.java</h5>
	<p class='bcode w800'>
	<ja>@Bean</ja>(typeName=<js>"Pet"</js>, properties=<js>"id,species,name,tags,price,status"</js>)
	<ja>@Entity</ja>(name=<js>"PetstorePet"</js>)
	<jk>public class</jk> Pet {
	
		<ja>@Column @Id @GeneratedValue</ja>
		<ja>@Schema</ja>(description=<js>"Unique identifier for this pet."</js>)
		<ja>@Html</ja>(link=<js>"servlet:/pet/{id}"</js>)
		<jk>private long</jk> <jf>id</jf>;
	
		<ja>@Column</ja>(length=50)
		<ja>@Schema</ja>(description=<js>"Pet name."</js>, minLength=3, maxLength=50)
		<jk>private</jk> String <jf>name</jf>;
	
		<ja>@Column</ja>
		<ja>@Schema</ja>(description=<js>"Price of pet."</js>, maximum=<js>"999.99"</js>)
		<ja>@Html</ja>(render=PriceRender.<jk>class</jk>)
		<jk>private float</jk> <jf>price</jf>;
	
		...
	}
	</p>
	<p>
		The annotations here are a combination of Juneau annotations for controlling marshalling (<ja>@Bean</ja>, <ja>@Html</ja>) 
		and documentation/validation (<ja>@Schema</ja>), and JPA annoations for database persistence (<ja>@Entity</ja>, <ja>@Column</ja>).
	</p>
	<div class='info'>
		Most applications may choose to have separate classes for DTOs and JPA beans since you typically are not going to want
		to expose server-side details to client-side code.  In these examples however they were combined into the same classes for brevity.
	</div>
</div>
</div><!-- END: 16.2 - jp.juneau-petstore-api -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jp.juneau-petstore-client' id='jp.juneau-petstore-client'>16.3 - juneau-petstore-client</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 16.3 - jp.juneau-petstore-client -->
<div class='topic'>
	<p>
		The <c>juneau-petstore-client</c> module contains a single <c>Main</c> class used to instantiate the proxy against
		our remote REST interface using the Java interface described above.
	</p>
	
	<h5 class='figure'>Main.java</h5>
	<p class='bcode w800'>
	<jk>public class</jk> Main {
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
	
			<jc>// Create a RestClient with JSON serialization support.</jc>
			RestClient <jv>restClient</jv> = RestClient.<jsm>create</jsm>().json5().build();
	
			<jc>// Instantiate our proxy.</jc>
			PetStore <jv>petStore</jv> = <jv>restClient</jv>.getRemote(PetStore.<jk>class</jk>, <js>"http://localhost:5000"</js>);
	
			<jc>// Print out the pets in the store.</jc>
			Collection&lt;Pet&gt; <jv>pets</jv> = <jv>petStore</jv>.getPets();
	
			<jc>// Pretty-print them to STDOUT.</jc>
			Json5.<jsf>DEFAULT_READABLE</jsf>.println(<jv>pets</jv>);
		}
	}
	</p>
	<p>
		Notice how little code is necessary to construct a remote proxy.
	</p>
</div>
</div><!-- END: 16.3 - jp.juneau-petstore-client -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#jp.juneau-petstore-server' id='jp.juneau-petstore-server'>16.4 - juneau-petstore-server</a><span class='update'>created: <b>9.0.0</b></span></h3>
<div class='topic'><!-- START: 16.4 - jp.juneau-petstore-server -->
<div class='topic'>
	<p>
		The <c>juneau-petstore-server</c> module contains all of the guts of the application.  It's a standard Spring Boot
		application with Juneau integration support.  For brevity, the app and configuration classes are combined into
		the following:
	</p>
	
	<h5 class='figure'>App.java</h5>
	<p class='bcode w800'>
	<ja>@SpringBootApplication</ja>
	<ja>@EnableJpaRepositories</ja>(basePackages=<js>"org.apache.juneau.petstore"</js>)
	<ja>@EnableCaching</ja>
	<ja>@Controller</ja>
	<jk>public class</jk> App {
	
		<jc>//-----------------------------------------------------------------------------------------------------------------
		// App
		//-----------------------------------------------------------------------------------------------------------------</jc>
	
		<jk>public static void</jk> main(String[] <jv>args</jv>) {
			<jk>try</jk> {
				<jk>new</jk> SpringApplicationBuilder(App.<jk>class</jk>).run(<jv>args</jv>);
			} <jk>catch</jk> (Exception <jv>e</jv>) {
				<jv>e</jv>.printStackTrace();
			}
		}
	
		<jc>//-----------------------------------------------------------------------------------------------------------------
		// Beans
		//-----------------------------------------------------------------------------------------------------------------</jc>
	
		<ja>@Bean</ja>
		<jk>public</jk> PetStoreService petStoreService() {
			<jk>return new</jk> PetStoreService();
		}
	
		<ja>@Bean</ja>
		<jk>public</jk> RootResources rootResources() {
			<jk>return new</jk> RootResources();
		}
	
		<ja>@Bean</ja>
		<jk>public</jk> PetStoreResource petStoreResource() {
			<jk>return new</jk> PetStoreResource();
		}
	
		<ja>@Bean</ja>
		<jk>public</jk> ServletRegistrationBean<Servlet> getRootServlet(RootResources <jv>rootResources</jv>) {
			<jk>return new</jk> ServletRegistrationBean&lt;&gt;(<jv>rootResources</jv>, <js>"/*"</js>);
		}
	}
	</p>
	<p>
		Notice how cleanly Juneau servlets fit into Spring Boot.  No special initializers are required
		to integrate Juneau with Spring Boot.
	</p>
	
	<p>
		The <c>RootResources</c> class is the top-level entry point into the REST API.  It allows us to group
		child resources.  In our case though we only have one child resource...<c>PetStoreResource</c>:
	</p>

	<h5 class='figure'>RootResources.java</h5>
	<p class='bcode w800'>
	<ja>@Rest</ja>(
		path=<js>"/*"</js>,
		title=<js>"Root resources"</js>,
		description=<js>"Example of a router resource page."</js>,
		children={
			PetStoreResource.<jk>class</jk>
		}
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>
		},
		navlinks={
			<js>"options: ?method=OPTIONS"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/petstore/rest/$R{servletClassSimple}.java"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This is an example of a 'router' page that serves as a jumping-off point to child resources.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Resources can be nested arbitrarily deep through router pages.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Note the &lt;span class='link'&gt;options&lt;/span&gt; link provided that lets you see the generated swagger doc for this page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Also note the &lt;span class='link'&gt;sources&lt;/span&gt; link on these pages to view the source code for the page.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;All content on pages in the UI are serialized POJOs.  In this case, it's a serialized array of beans with 2 properties, 'name' and 'description'.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;Other features (such as this aside) are added through annotations.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		}
	)
	<jk>public class</jk> RootResources <jk>extends</jk> BasicSpringRestServletGroup {
		<jk>private static final long</jk> <jsf>serialVersionUID</jsf> = 1L;
	}
	</p>
	<p>
		By extending from <c>BasicSpringRestServletGroup</c>, the root servlet hooks into the injection framework of Spring
		to resolve spring beans such as the child resource <c>PetStoreResource</c>.
	</p>
	<p>
		This page renders as follows:
	</p>
	
	<p class='bcode w800'>
	http://localhost:5000
	</p>			
	<img class='bordered w800' src='doc-files/RootResources.png'>
	
	<p>
		The <c>PetStoreResource</c> class is the REST implementation of our <c>PetStore</c> interface.  
	</p>
	
	<h5 class='figure'>PetStoreResource.java</h5>
	<p class='bcode w800'>
	<ja>@Rest</ja>(
		path=<js>"/petstore"</js>,
		title=<js>"Petstore application"</js>,
		description={
			<js>"This is a sample server Petstore server based on the Petstore sample at Swagger.io."</js>,
			<js>"You can find out more about Swagger at http://swagger.io."</js>,
		},
		swagger=<ja>@Swagger</ja>(
			version=<js>"1.0.0"</js>,
			title=<js>"Swagger Petstore"</js>,
			termsOfService=<js>"You are on your own."</js>,
			contact=<ja>@Contact</ja>(
				name=<js>"Juneau Development Team"</js>,
				email=<js>"dev@juneau.apache.org"</js>,
				url=<js>"http://juneau.apache.org"</js>
			),
			license=<ja>@License</ja>(
				name=<js>"Apache 2.0"</js>,
				url=<js>"http://www.apache.org/licenses/LICENSE-2.0.html"</js>
			),
			externalDocs=<ja>@ExternalDocs</ja>(
				description=<js>"Find out more about Juneau"</js>,
				url=<js>"http://juneau.apache.org"</js>
			),
			tags={
				<ja>@Tag</ja>(
					name=<js>"pet"</js>,
					description=<js>"Everything about your Pets"</js>,
					externalDocs=<ja>@ExternalDocs</ja>(
						description=<js>"Find out more"</js>,
						url=<js>"http://juneau.apache.org"</js>
					)
				),
				<ja>@Tag</ja>(
					name=<js>"store"</js>,
					description=<js>"Access to Petstore orders"</js>
				),
				<ja>@Tag</ja>(
					name=<js>"user"</js>,
					description=<js>"Operations about user"</js>,
					externalDocs=<ja>@ExternalDocs</ja>(
						description=<js>"Find out more about our store"</js>,
						url=<js>"http://juneau.apache.org"</js>
					)
				)
			}
		),
		staticFiles={<js>"htdocs:/htdocs"</js>} 
	)
	<ja>@HtmlDocConfig</ja>(
		widgets={
			ContentTypeMenuItem.<jk>class</jk>,
		},
		navlinks={
			<js>"up: request:/.."</js>,
			<js>"options: servlet:/?method=OPTIONS"</js>,
			<js>"$W{ContentTypeMenuItem}"</js>,
			<js>"source: $C{Source/gitHub}/org/apache/juneau/petstore/rest/$R{servletClassSimple}.java"</js>
		},
		head={
			<js>"&lt;link rel='icon' href='$U{servlet:/htdocs/cat.png}'/&gt;"</js>  <jc>// Add a cat icon to the page.</jc>
		},
		header={
			<js>"&lt;h1&gt;$R{resourceTitle}&lt;/h1&gt;"</js>,
			<js>"&lt;h2&gt;$R{methodSummary}&lt;/h2&gt;"</js>,
			<js>"$C{PetStore/headerImage}"</js>
		},
		aside={
			<js>"&lt;div style='max-width:400px' class='text'&gt;"</js>,
			<js>"	&lt;p&gt;This page shows a standard nested REST resource.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;It shows how different properties can be rendered on the same bean in different views.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;It also shows examples of HtmlRender classes and @BeanProperty(format) annotations.&lt;/p&gt;"</js>,
			<js>"	&lt;p&gt;It also shows how the Queryable converter and query widget can be used to create searchable interfaces.&lt;/p&gt;"</js>,
			<js>"&lt;/div&gt;"</js>
		},
		stylesheet=<js>"servlet:/htdocs/themes/dark.css"</js>  <jc>// Use dark theme by default.</jc>
	)
	<jk>public class</jk> PetStoreResource <jk>extends</jk> BasicRestObject <jk>implements</jk> PetStore {
	
		<ja>@Autowired</ja>
		<jk>private</jk> PetStoreService <jf>store</jf>;
	
		<jd>/**
		 * Navigation page
		 *
		 * @return Navigation page contents.
		 */</jd>
		<ja>@RestGet</ja>(
			path=<js>"/"</js>,
			summary=<js>"Navigation page"</js>
		)
		<ja>@HtmlDocConfig</ja>(
			style={
				<js>"INHERIT"</js>,  <jc>// Flag for inheriting resource-level CSS.</jc>
				<js>"body { "</js>,
					<js>"background-image: url('petstore/htdocs/background.jpg'); "</js>,
					<js>"background-color: black; "</js>,
					<js>"background-size: cover; "</js>,
					<js>"background-attachment: fixed; "</js>,
				<js>"}"</js>
			}
		)
		<jk>public</jk> ResourceDescriptions getTopPage() {
			<jk>return new</jk> ResourceDescriptions()
				.append(<js>"pet"</js>, <js>"All pets in the store"</js>)
				.append(<js>"store"</js>, <js>"Orders and inventory"</js>)
				.append(<js>"user"</js>, <js>"Petstore users"</js>)
			;
		}
		
		...
	</p>		
	<p>
		Clicking the <c>petstore</c> link on the root page takes you to our PetStore resource:
	</p>
	<p class='bcode w800'>
	http://localhost:5000/petstore
	</p>			
	<img class='bordered w800' src='doc-files/PetStore.png'>

	<p>
		The methods defined in our <c>PetStore</c> interface are implemented like so:
	</p>		
	<h5 class='figure'>PetStoreResource.java</h5>
	<p class='bcode w800'>
	<ja>@Override</ja> <jc>/* PetStore */</jc>
	<ja>@RestGet</ja>(
		path=<js>"/pet"</js>,
		summary=<js>"All pets in the store"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>,
			parameters={
				Queryable.<jsf>SWAGGER_PARAMS</jsf>  <jc>// Documents searching.</jc>
			}
		),
		converters={Queryable.<jk>class</jk>}  <jc>// Searching support.</jc>
	)
	<ja>@Bean</ja>(on=<js>"Pet"</js>, excludeProperties=<js>"tags,photo"</js>)  <jc>// In this view, don't serialize tags/photos properties.</jc>
	<jk>public</jk> Collection&lt;Pet&gt; getPets() <jk>throws</jk> NotAcceptable {
		<jk>return</jk> <jf>store</jf>.getPets();
	}
	
	<ja>@Override</ja> <jc>/* PetStore */</jc>
	<ja>@RestGet</ja>(
		path=<js>"/pet/{petId}"</js>,
		summary=<js>"Find pet by ID"</js>,
		description=<js>"Returns a single pet"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>
		)
	)
	<jk>public</jk> Pet getPet(<jk>long</jk> <jv>petId</jv>) <jk>throws</jk> IdNotFound, NotAcceptable {
		<jk>return</jk> <jf>store</jf>.getPet(<jv>petId</jv>);
	}
	
	<ja>@Override</ja> <jc>/* PetStore */</jc>
	<ja>@RestPost</ja>(
		path=<js>"/pet"</js>,
		summary=<js>"Add a new pet to the store"</js>,
		swagger=<ja>@OpSwagger</ja>(
			tags=<js>"pet"</js>
		),
		roleGuard=<js>"ROLE_ADMIN || (ROLE_USER &amp;&amp; ROLE_WRITABLE)"</js>  <jc>// Restrict access to this method.</jc>
	)
	<jk>public long</jk> createPet(CreatePet <jv>pet</jv>) <jk>throws</jk> IdConflict, NotAcceptable, UnsupportedMediaType {
		<jk>return</jk> <jf>store</jf>.create(<jv>pet</jv>).getId();
	}
	
	...
	</p>		
	<p>
		After running the <c>Main</c> method in the client code to populate the database, the page renders as follows:
	</p>
	<p class='bcode w800'>
	http://localhost:5000/petstore/pet
	</p>			
	<img class='bordered w800' src='doc-files/PetStore_pets.png'>

	<p>
		The <l>OPTIONS</l> menu items takes you to the auto-generated Swagger UI for the application:
	</p>
	<p class='bcode w900'>
	http://localhost:10000/petstore/pet?method=OPTIONS
	</p>			
	<img class='bordered w900' src='doc-files/9a.png'>
	<p>
		Since we've defined tags on our annotations, the pet-related operations are all grouped under the <l>pet</l> tag:
	</p>
	<img class='bordered w900' src='doc-files/9b.png'>
	<p>
		Information for all HTTP parts is automatically generated:
	</p>
	<img class='bordered w900' src='doc-files/9h.png'>
	<p>
		The schema models for POJO models is available in the <l>Responses</l> section of an operation:
	</p>
	<img class='bordered w900' src='doc-files/9c.png'>
	<p>
		Auto-generated examples are available for all supported languages:
	</p>
	<img class='bordered w900' src='doc-files/9d.png'>
	<p>
		For example, <l>application/json5</l>:
	</p>
	<img class='bordered w900' src='doc-files/9e.png'>
	<p>
		Examples can be derived in a number of ways.  In our case, we've defined a static method on our <l>Pet</l>
		class annotated with <ja>@Example</ja>:
	</p>
	<h5 class='figure'>Pet.java</h5>
	<p class='bcode w800'>
	<ja>@Example</ja>
	<jk>public static</jk> Pet example() {
		<jk>return new</jk> Pet()
			.id(123)
			.species(Species.<jsf>DOG</jsf>)
			.name(<js>"Doggie"</js>)
			.tags(<js>"friendly"</js>,<js>"smart"</js>)
			.status(PetStatus.<jsf>AVAILABLE</jsf>);
	}
	</p>
	<p>
		Similar functionality exists for request bodies as well:
	</p>
	<img class='bordered w900' src='doc-files/9f.png'>
	<p>
		At the bottom of the page is a listing of the POJO models in the app:
	</p>
	<img class='bordered w900' src='doc-files/9g.png'>
	
</div>
</div><!-- END: 16.4 - jp.juneau-petstore-server -->
</div><!-- END: 16 - juneau-petstore -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#Security' id='Security'>17 - Security Best-Practices</a></h2>
<div class='topic'><!-- START: 17 - Security -->
<div class='topic'>
	<p>
		Security is always an ongoing concern in any library.  
		If you discover any security vulnerabilities in this code, please refer to the instructions found here:
	</p>
	<ul class='spaced-list'>
		<li class='extlink'><a class="doclink" href="http://www.apache.org/security">SECURITY</a>
	</ul>
</div>

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#s.Marshall' id='s.Marshall'>17.1 - juneau-marshall</a><span class='update'>created: 8.2.0</span></h3>
<div class='topic'><!-- START: 17.1 - s.Marshall -->
<h5 class='topic'>Demarshalling vulnerabilities</h5>
<div class='topic'>
	<p>
		One common security vulnerability is the ability to create arbitrary Java object instances through crafted
		user input.  For example, support for constructing POJOs based on an input attribute defining a 
		fully-qualified class name like <js>"{class:'com.foo.MyBean',...}"</js>
	</p>
	<p>
		Fortunately, Juneau does not support an open-ended <js>"class</js> attribute.  
		As a rule, it should not be possible to create arbitrary POJOs by any of the parsers.
		The demarshalled object types are inferred via reflection of the class objects passed in through the parser 
		method (e.g. <c>JsonParser.<jsf>DEFAULT</jsf>.parse(input, MyBean.<jk>class</jk>)</c>).
		As long as the <c>Class</c> object passed into this method is not constructed from user-generated input,
		it should be free from demarshalling vulnerabilities.   
	</p> 
	<p>
		The following example shows a potential vector that circumvents the restriction above:
	</p>
	<p class='bjava'>
	<jc>// Don't do this!</jc>
	Class <jv>c</jv> = Class.<jsf>forName</jsf>(<jv>someUserInputString</jv>);
	JsonParser.<jsf>DEFAULT</jsf>.parse(<jv>input</jv>, <jv>c</jv>);  <jc>// Oops!  Security hole!</jc>
	</p>
	<p>
		Juneau does support something similar to a <js>"class"</js> attribute that allows you to define the
		POJO type at runtime.
		This is the <js>"type"</js> attribute.
		The difference is that it's not possible to specify fully-qualified class names in <js>"type"</js> attributes,
		and instead can only specify type keys defined through bean dictionaries. 
		Instead of serializing the fully-qualified class names in the output, we instead serialize type
		names that represent those POJO types.
		i.e. instead of <js>"class='com.foo.MyBean'"</js>, we instead serialize <js>"type='MyBeanIdentifier'"</js>.
		Since bean types are defined at compile time, it's impossible to instantiate arbitrary POJOs.
	</p>
	<p>
		POJO types of generalized input are also inferred through swaps.
		Again, since the POJO types are hardcoded at compile time, these should not be subject to demarshalling
		vulnerabilities.  However, it is possible to circumvent this through your swap implementation as shown
		below: 	
	</p>
	<p class='bjava'>
	<jc>// Don't do this!</jc>
	<jk>public class</jk> MyInsecureSwap <jk>extends</jk> ObjectSwap&lt;JsonMap,Object&gt; {
		<jk>public</jk> Object swap(BeanSession <jv>session</jv>, JsonMap <jv>input</jv>) <jk>throws</jk> Exception {
			<jc>// Security hole!</jc>
			<jk>return</jk> Class.<jsf>forName</jsf>(<jv>input</jv>.getString(<js>"class"</js>)).newInstance();
		}
	}
	</p>
	<p>
		All other parsers (JSON, URL-Encoding, MessagePack, etc...) work the same way in determining POJO types, so
		should be safe from demarshalling vulnerabilities.  
	</p>
</div>

<h5 class='topic'>Dependent libraries</h5>
<div class='topic'>
	<p>
		When accessing security vulnerabilities of any library, dependent libraries must also be taken into account:
	</p>
	<ul>
		<li>The JSON, HTML, MsgPack, URL-Encoding, and UON parsers are written from scratch and do not rely on
			any other parsing technologies.
		<li>The XML and HTML parsers uses the built-in Java StAX parser.
			This *should* be free from vulnerabilities.    
		<li>The RDF parsers rely on Apache Jena 2.7.1.  
			As of <c>7.0.1</c>, no known security vulnerabilities exist that affect Juneau at this time.
	</ul>
</div>
</div><!-- END: 17.1 - s.Marshall -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#s.Svl' id='s.Svl'>17.2 - juneau-svl</a><span class='update'>created: 8.2.0</span></h3>
<div class='topic'><!-- START: 17.2 - s.Svl -->
<div class='topic'>
	<p>
		Care must be used when defining new {@link org.apache.juneau.svl.Var Vars} using the SVL API since mistakes 
		could potentially expose system properties, environment variables, or even file system files.
	</p>
	<p>
		For recap, the SVL support allows you to embed variables of the form <js>"$X{key}"</js> inside strings that
		get resolved to other strings.  The resolved strings themselves can also contain variables that also
		get recursively resolved.  
	</p>
	<p>
		An example of a potential security hole is shown below that could potentially expose any file on a file
		system through a REST request:
	</p>
	<p class='bjava'>
	<jk>public</jk> String doUnsafeGet(RestRequest <jv>req</jv>) {
		<jc>// Security hole!</jc>
		<jk>return</jk> <jv>req</jv>.getVarResolver().resolve(<js>"$RQ{foo}"</js>);
	}
	</p>
	<p>
		This code is simply echoing the value of the <c>foo</c> query parameter.
		Now say for example that a bad actor passes in the query string <js>"foo=$F{/some/file/on/file/system}"</js>.
		The <c>$F</c> variable allows you to resolve the contents of files using SVL, and is provided
		by default using the built-in variable resolver returned by the <c>RestRequest</c> object.
		You've potentially just exposed the contents of that file through your REST interface.
	</p>
	<p>
		In reality, the above security hole does not exist because of the following restrictions:
	</p>
	<ul class='spaced-list'>
		<li>
			<c>Vars</c> have two methods {@link org.apache.juneau.svl.Var#allowNested()} and 
			{@link org.apache.juneau.svl.Var#allowRecurse()} that can be overridden to prevent recursive processing
			of string variables.  These are both <jk>false</jk> for the <c>$R</c> variable, so the <c>$F</c>
			variable in the result will never get processed and instead be treated as plain text. 
		<li>
			The <c>$F</c> variable only allows you to retrieve files within the JVM starting directory. 
	</ul>
	<p>
		Even though the built-in Juneau variables are safe, special care is needed when defining your own custom
		variables.  If your variable resolves user input in any way, it's HIGHLY recommended that you override the
		{@link org.apache.juneau.svl.Var#allowNested()} and {@link org.apache.juneau.svl.Var#allowRecurse()} 
		methods to prevent recursive handling of variables.
	</p>
</div>
</div><!-- END: 17.2 - s.Svl -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#s.Rest' id='s.Rest'>17.3 - juneau-rest-server</a><span class='update'>created: 8.2.0</span></h3>
<div class='topic'><!-- START: 17.3 - s.Rest -->
<div class='topic'>
	<p>
		Denial of service attacks can be alleviated through the {@link org.apache.juneau.rest.annotation.Rest#maxInput() maxInput()}
		setting.  Arbitrarily-large input will trigger an exception before causing out-of-memory errors.
		The default value for this setting is 100MB.  
	</p>
	<p>
		Since the parsers do not use intermediate DOMs and instead parse directly into Java objects,  
		deeply nested data structures will almost always trigger stack overflow errors long before memory consumption
		becomes an issue.  However, this is NOT true of the RDF parsers that use an intermediate DOM.  If parsing 
		RDF, you may want to consider lowering the max-input value above.
	</p>
</div>
</div><!-- END: 17.3 - s.Rest -->
</div><!-- END: 17 - Security -->

<!-- ==================================================================================================== -->

<h2 class='topic' onclick='toggle(this)'><a href='#v9.0-migration-guide' id='v9.0-migration-guide'>18 - v9.0 Migration Guide</a></h2>
<div class='topic'><!-- START: 18 - v9.0-migration-guide -->
<div class='topic'>
	<p>
		The following guide can be used to help migrate your code to v9.0.  Note that you can also refer to the <a href='#9.0.0'>Release Notes</a> for
		changes as well.
	</p>
	<table class='styled w900'>
		<tr>
			<th>
				Old
			</th>
			<th>
				New
			</th>
		</tr>
		<tr>
			<td>
				<ja>@RestMethod</ja> annotation.
			</td>
			<td>
				Has been replaced with {@link org.apache.juneau.rest.annotation.RestOp}, {@link org.apache.juneau.rest.annotation.RestGet}, {@link org.apache.juneau.rest.annotation.RestPut}, {@link org.apache.juneau.rest.annotation.RestPost}, {@link org.apache.juneau.rest.annotation.RestDelete}, {@link org.apache.juneau.rest.annotation.RestOptions}
			</td>
		</tr>
		<tr>
			<td>
				<ja>@RemoteMethod</ja> annotation.
			</td>
			<td>
				Has been replaced with {@link org.apache.juneau.http.remote.RemoteOp}, {@link org.apache.juneau.http.remote.RemoteGet}, {@link org.apache.juneau.http.remote.RemotePut}, {@link org.apache.juneau.http.remote.RemotePost}, {@link org.apache.juneau.http.remote.RemoteDelete}.
			</td>
		</tr>
		<tr>
			<td>
				<c>BasicRestServletJena</c>, <c>BasicRestServletJenaGroup</c> classes.
			</td>
			<td>
				These have been removed in 9.0 due to the removal of the Jena packages (due to security issues).  Replace
				with {@link org.apache.juneau.rest.servlet.BasicRestServlet} and {@link org.apache.juneau.rest.servlet.BasicRestServletGroup}.
			</td>
		</tr>
		<tr>
			<td>
				<ja>@Body</ja> annotation.
			</td>
			<td>
				Has been renamed to <ja>@Content</ja> (to better match HTTP naming conventions such as Content-Type/Content-Encoding headers).
			</td>
		</tr>
		<tr>
			<td>
				<c><ja>@Query</ja>(_default)</c>, <c><ja>@FormData</ja>(_default)</c>.
			</td>
			<td>
				Has been renamed to {@link org.apache.juneau.http.annotation.Query#def} / {@link org.apache.juneau.http.annotation.FormData#def}.  Note however that <ja>@RestOp</ja>-annotated parameters
				now also support use of Optional parameters which simplifies the coding of default values.
			</td>
		</tr>
		<tr>
			<td>
				<c><ja>@Rest</ja>(reqHeaders)</c>.
			</td>
			<td>
				Has been renamed to {@link org.apache.juneau.rest.annotation.Rest#defaultRequestHeaders} and added {@link org.apache.juneau.rest.annotation.Rest#defaultResponseHeaders}.
			</td>
		</tr>
		<tr>
			<td>
				<ja>@Rest(staticFiles)</ja>.
			</td>
			<td>
				Changed from a string array to a <c>Class&lt;? <jk>extends</jk> StaticFiles&gt;</c>.  If you're extending from 
				{@link org.apache.juneau.rest.servlet.BasicRestServlet}/{@link org.apache.juneau.rest.servlet.BasicRestObject}, the {@link org.apache.juneau.rest.servlet.BasicRestOperations#getHtdoc(String,Locale)}
				is already implemented for you to provide static files under the sub-URI <js>/htdocs/*</js>.  The default implementation for finding
				static files is {@link org.apache.juneau.rest.staticfile.BasicStaticFiles} which provides basic out-of-the-box functionality, so you can usually
				just remove the previous <c><ja>@Rest</ja>(staticFiles)</c> value.
			</td>
		</tr>
	</table>
	
</div>
</div><!-- END: 18 - v9.0-migration-guide -->


<h2 class='topic' onclick='toggle(this)'><a href='#ReleaseNotes' id='ReleaseNotes'>Release Notes</a></h2>
<div class='topic'>
	
	<h5 class='toc'>Release Notes</h5>
	<ul class='toc'>
<li><p><a class='doclink' href='#5.0.0.0'>5.0.0.0 (Jun 11, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.1'>5.0.0.1 (Jun 14, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.2'>5.0.0.2 (Sept 28, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.3'>5.0.0.3 (Oct 3, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.4'>5.0.0.4 (Oct 7, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.5'>5.0.0.5 (Oct 29, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.6'>5.0.0.6 (Oct 30, 2012)</a></p>
<li><p><a class='doclink' href='#5.0.0.7'>5.0.0.7 (Jan 20, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.8'>5.0.0.8 (Jan 30, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.9'>5.0.0.9 (Feb 26, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.10'>5.0.0.10 (Mar 7, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.11'>5.0.0.11 (Mar 8, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.12'>5.0.0.12 (Mar 10, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.13'>5.0.0.13 (Mar 14, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.14'>5.0.0.14 (Mar 23, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.15'>5.0.0.15 (Mar 24, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.16'>5.0.0.16 (Mar 25, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.17'>5.0.0.17 (Mar 25, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.18'>5.0.0.18 (Mar 27, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.19'>5.0.0.19 (Apr 1, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.20'>5.0.0.20 (Apr 7, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.21'>5.0.0.21 (Apr 9, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.22'>5.0.0.22 (Apr 12, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.23'>5.0.0.23 (Apr 14, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.24'>5.0.0.24 (May 9, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.25'>5.0.0.25 (May 11, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.26'>5.0.0.26 (Jun 5, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.27'>5.0.0.27 (July 7, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.28'>5.0.0.28 (July 9, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.29'>5.0.0.29 (Aug 2, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.30'>5.0.0.30 (Aug 8, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.31'>5.0.0.31 (Aug 9, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.32'>5.0.0.32 (Oct 5, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.33'>5.0.0.33 (Oct 20, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.34'>5.0.0.34 (Nov 10, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.35'>5.0.0.35 (Nov 26, 2013)</a></p>
<li><p><a class='doclink' href='#5.0.0.36'>5.0.0.36 (Dec 18, 2013)</a></p>
<li><p><a class='doclink' href='#5.1.0.0'>5.1.0.0 (Jan 18, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.1'>5.1.0.1 (Jan 25, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.2'>5.1.0.2 (Apr 27, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.3'>5.1.0.3 (Jun 28, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.4'>5.1.0.4 (Aug 25, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.5'>5.1.0.5 (Sept 1, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.6'>5.1.0.6 (Sept 21, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.7'>5.1.0.7 (Oct 5, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.8'>5.1.0.8 (Oct 25, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.9'>5.1.0.9 (Dec 1, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.10'>5.1.0.10 (Dec 23, 2014)</a></p>
<li><p><a class='doclink' href='#5.1.0.11'>5.1.0.11 (Feb 14, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.12'>5.1.0.12 (Mar 28, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.13'>5.1.0.13 (Apr 24, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.14'>5.1.0.14 (May 10, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.15'>5.1.0.15 (May 24, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.16'>5.1.0.16 (June 28, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.17'>5.1.0.17 (Aug 3, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.18'>5.1.0.18 (Aug 5, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.19'>5.1.0.19 (Aug 15, 2015)</a></p>
<li><p><a class='doclink' href='#5.1.0.20'>5.1.0.20 (Sept 5, 2015)</a></p>
<li><p><a class='doclink' href='#5.2.0.0'>5.2.0.0 (Dec 30, 2015)</a></p>
<li><p><a class='doclink' href='#5.2.0.1'>5.2.0.1 (Mar 23, 2016)</a></p>
<li><p><a class='doclink' href='#6.0.0'>6.0.0 (Oct 3, 2016)</a></p>
<li><p><a class='doclink' href='#6.0.1'>6.0.1 (Jan 3, 2017)</a></p>
<li><p><a class='doclink' href='#6.1.0'>6.1.0 (Feb 25, 2017)</a></p>
<li><p><a class='doclink' href='#6.2.0'>6.2.0 (Apr 28, 2017)</a></p>
<li><p><a class='doclink' href='#6.3.0'>6.3.0 (Jun 30, 2017)</a></p>
<li><p><a class='doclink' href='#6.3.1'>6.3.1 (Aug 1, 2017)</a></p>
<li><p><a class='doclink' href='#6.4.0'>6.4.0 (Oct 5, 2017)</a></p>
<li><p><a class='doclink' href='#7.0.0'>7.0.0 (Oct 25, 2017)</a></p>
<li><p><a class='doclink' href='#7.0.1'>7.0.1 (Dec 24, 2017)</a></p>
<li><p><a class='doclink' href='#7.1.0'>7.1.0 (Mar 08, 2018)</a></p>
<li><p><a class='doclink' href='#7.2.0'>7.2.0 (Sept 25, 2018)</a></p>
<li><p><a class='doclink' href='#7.2.1'>7.2.1 (Oct 23, 2018)</a></p>
<li><p><a class='doclink' href='#7.2.2'>7.2.2 (Nov 7, 2018)</a></p>
<li><p><a class='doclink' href='#8.0.0'>8.0.0 (Jan 01, 2019)</a></p>
<li><p><a class='doclink' href='#8.1.0'>8.1.0 (Aug 21, 2019)</a></p>
<li><p><a class='doclink' href='#8.1.1'>8.1.1 (Sept 20, 2019)</a></p>
<li><p><a class='doclink' href='#8.1.2'>8.1.2 (Dec 01, 2019)</a></p>
<li><p><a class='doclink' href='#8.1.3'>8.1.3 (Jan 20, 2020)</a></p>
<li><p><a class='doclink' href='#8.2.0'>8.2.0 (Oct 14, 2020)</a></p>
<li><p><a class='doclink' href='#9.0.0'>9.0.0 (TBD)</a></p>
</ul>

	
<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.0' id='5.0.0.0'>5.0.0.0 (Jun 11, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.0 -->
<div class='topic'>
	<p>
		Version 5.0 marks a major release milestone for the Juno/JJSON library.  
		It is now available for download from iRAM under the name "Juno (previously JJSON)".  
		The Juno Starters Guide has been updated to reflect new functionality in this release.  
	</p>
	<ul class='spaced-list'>
		<li>
			New name.<br>
			Unfortunately, "JJSON" was already trademarked by another similar library.  
			Therefore, it's been renamed "Juno" (after the Roman goddess and wife of Jupiter) which does not appear to have any similar trademark issues (crosses fingers).  
			The name is also a play on the word "Uno", indicating that this is a single simple unifying interface of several kinds of technology.
		</li>
		<li>
			Simplified APIs for working with beans.<br>
			Significant improvements have been made to the parsers to make it easier to convert serialized POJOs back into their original forms.
		</li>
		<li>
			Serializer/Parser classes now directly subclass from {@link org.apache.juneau.BeanContext}.<br>
			In previous releases, if you wanted to change the way beans were handled by the serializers and parsers, you had to construct a separate bean map factory and pass it to the serializer or parser.  
			Now, you can call the bean map factory methods directly on the serializer or parser class.
		</li>
		<li>
			Simplified Filter API for handling non-standard POJOs.<br>
			The API for handling non-standard POJOs has been simplified by introducing the concept of a <del>Transform</del> class, which is associated with the <c>BeanContext</c> class (and thus the Serializer and Parser classes too) through the <c>BeanContext.addTransforms(Class[])</c> method.<br>
			Two new subclasses of <del>Transform</del>:
			<ul>
				<li><del>BeanFilter</del> - Filter POJO beans.</li>
				<li><del>PojoSwap</del> - Filter POJOs that aren't beans.</li>
			</ul>
			This new API replaces the previous separate <c>Cast</c> and <c>BeanFilter</c> APIs which were considerably more complicated and puts them under a common API. 
		</li>
		<li>
			Elimination of <c>_class</c> attributes in parsable output.<br>
			One of the complaints about the previous version of JJSON was that if you wanted to have the resulting JSON or XML be parsable back into beans, you had to enable the <js>"addClassAttrs"</js> property on the bean map factory class so that <js>"_class"</js> attributes could be added to the output.<br>
			This requirement is virtually eliminated in v5.  In many cases, the parsers are able to determine through reflection what the correct target type is based on the top-level class passed in on the parse method. 
		</li>
		<li>
			Performance improvements.<br>
			Several significant performance improvements have been made in this release.
			<ul>
				<li>
					New Reader-based JSON parser.<br>
					Previously, the JSON parser required that the entire JSON text be loaded into memory as a String before being parsed.  
					The new JSON parser is Reader-based which significantly reduces memory consumption.
				</li>
				<li>     
					New StAX-based XML parser.<br>
					The old XML parser was based on DOM.  The new XML parser uses a StAX parser which significantly reduces memory consumption.
				</li>
				<li>
					Caching of reflection data in the <c>BeanMap</c> API.<br>
					The number of reflection calls have been significantly reduced in the <c>BeanMap</c> API code.  
					Reflection is used to determine the class types of property values on beans.  
					This information is now cached and persisted so that the reflection API calls to determine class types are only performed the first time a bean type is encountered.
	   				</li>
	   				<li>
					Automatic support for GZIP compression/decompression in <c>RestServlets</c>.<br>
					This is completely transparent to the developer.  
					The output writer is negotiated by the framework to automatically handle compression and charset requests without the developer needing to know anything about it.
				</li>
			</ul>
		</li>
		<li>
			Cognos/XML support.
		</li>
		<li>
			JSON-schema support.
		</li>
		<li>
			New <del>PojoIntrospector</del> class.
		</li>
		<li>
			Significant REST servlet API improvements.
			<ul>
				<li>
					Defining child resources is considerably simpler now.  
					In addition to the standard doX() methods for handling the requests for the current resource, you can also define getX() methods for returning child resources which automatically become available under the child URL specified by the getter name.
				</li>
				<li>
					Initialization of the child resources occurs automatically when the parent resource initialization occurs.
				</li>
				<li>
					Other improvments have been made in the area of automatic negotiation of input and output type streams.  
					For example, automatic support is provided for GZIP (<c>Accept-Encoding: gzip</c>) and charsets (e.g <c>Accept-Charset: SJIS</c>) on both incoming and outgoing data.  
					It's all transparent from a developers perspective.  
					The developer simply working with POJOs, and all details about content types, encoding, charsets, and so forth are handled by the framework.
				</li>
				<li>
					Support for generating complex <c>OPTIONS</c> pages for resources.
				</li>
			</ul>
		</li>
		<li>
			Automatic support for SOAP XML output on <js>"text/soap+xml"</js> requests against <c>RestServlet</c>.
		</li>
		<li>
			Support for XML namespaces. 
		</li>
		<li>
			Support for setting the XML root element name by either passing in a parameter on the serializer, or by specifying it via a <ja>@Bean</ja> annotation.
		</li>
			<li>
			Support for loading beans directly from Readers and Strings. 
		</li>
		<li>
			Parsing support for POJOs of type <c>Enum</c>.
		</li>
			<li>
			Significant improved support for various flavors of parameterized types, such as subclasses of parameterized types (e.g. <c>MyBeanList <jk>extends</jk> LinkedList&lt;MyBean&gt;</c>).
			</li>
			<li>
			Improved ordering of bean properties (should now be ordered as they are defined in the class).
		</li>
		<li>
			Various default filters provided:
			<ul>
				<li>byte[]&lt;--&gt;Base64 encoded strings</li>
				<li>Date/Calendar&lt;--&gt;ISO8601/RFC822/Long</li>
			</ul>
		</li>
		<li>
			New {@link org.apache.juneau.html.HtmlParser} and {@link org.apache.juneau.urlencoding.UrlEncodingParser} classes.
		</li>
		<li>
			HtmlSerializer now produces XHTML.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.1' id='5.0.0.1'>5.0.0.1 (Jun 14, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.1 -->
<div class='topic'>
	<p>
		Juno 5.0.0.1 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			New support for generating XML-Schema documents from POJO models.
		</li>
		<li>
			New support for serializing to RDF/XML.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.2' id='5.0.0.2'>5.0.0.2 (Sept 28, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.2 -->
<div class='topic'>
	<p>
		Juno 5.0.0.2 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			Improvements to Javadocs.  Most of the information in the Juno Starters Guide wiki has been moved into the overview and package-level javadocs.<br>
			Since the information is now written in HTML, you can now copy and paste the code examples directly from the Javadocs.<br>
			The code examples are also syntax-highlighted using CSS.
		</li>
		<li> 
			Support for defining default XML namespaces on packages and classes for the XML and RDF serializers.
		</li>
		<li>
			Restructured the packages along content type support (e.g. all JSON support moved to <c>org.apache.juneau.json</c>).
		</li>
		<li>
			Automatic support for parsing maps with <c>Enum</c> keys, and parsing <c>Enum</c> strings.<br>
			This was previously possible using filters but now it's built-in for all the parsers.
		</li>
		<li> 
			Replaced the <c>ObjectList.toXArray()</c> methods with a new <c>elements(Class&lt;T&gt; type)</c> method that's more efficient and avoids creating an unnecessary array.
		</li>
		<li> 
			Support for parsing into beans with read-only properties.<br>
			New <del>@BeanConstructor</del> annotation allows you to specify bean property values to be passed in through a constructor.
		</li>
		<li> 
			Separated the rest library into separate independent client and server libraries.<br>
			Use one, use both, it's up to you.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.2 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.3' id='5.0.0.3'>5.0.0.3 (Oct 3, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.3 -->
<div class='topic'>
	<p>
		Juno 5.0.0.3 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			Support for parsing into read-only beans (i.e. beans with only getters, property values set through constructor args).<br>
			To support this, the <del>@BeanConstructor</del> annotation has been added.
		</li>
		<li>
			Merged separate settings classes back into their base classes (simplifies the API).
		</li>
		<li>
			<del>SerializerGroup SerializerGroups</del> and <del>ParserGroup ParserGroups</del> now share {@link org.apache.juneau.BeanContext BeanContexts} to reduce memory consumption of class type metadata.	
		</li>	
	</ul>
</div>
</div><!-- END: 5.0.0.3 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.4' id='5.0.0.4'>5.0.0.4 (Oct 7, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.4 -->
<div class='topic'>
	<p>
		Juno 5.0.0.4 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			New <del>RestMethod @RestMethod</del> annotation on <del>RestServlet</del> methods.<br>
			Allows the usage of URL pattern matching and automatic conversion of URL variables to arguments passed to method handlers.<br>
			See <del>RestServlet</del> for more information.
		</li>
		<li>
			Enhancements to <del>BeanContext.convertToType(Object,Class)</del>to be able to convert <c>Strings</c> to classes with 
			<c>fromString(String)</c>/<c>valueOf(String)</c> static methods or <c>T(String)</c> constructors.
		</li>	
	</ul>
</div>
</div><!-- END: 5.0.0.4 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.5' id='5.0.0.5'>5.0.0.5 (Oct 29, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.5 -->
<div class='topic'>
	<p>
		Juno 5.0.0.5 is a major update.
	</p>
	<ul class='spaced-list'>
		<li>New <c><ja>@RestChild</ja></c> annotation for identifying child resources.</li>
		<li>
			New <c>traversable</c> and <c>filterable</c> attributes added to <del>RestMethod @RestMethod</del> annotation.<br>
			Eliminates the need for <del>PojoResource</del> and <del>FilteredRestResource</del> classes.
		</li>
		<li>Simplified client API.  Easier to use when making multiple connections to the same server.</li>
		<li>Support for pluggable authentication in the client API.</li>
		<li>Support for authenticating against Jazz Team Servers.</li>
		<li>Support for rendering package-level Javadocs in REST resources.</li>
		<li>Support for parsing of header values into specific object types.</li>
		<li>Changed default XML representation to not include JSON-type attributes.  Produces cleaner XML.</li>
		<li>
			New <c>resourceUri</c> attributed added to <ja>@Bean</ja> annotation to associate beans with resource URIs.
			<ul>
				<li>Used for automatically creating hyperlinks in {@link org.apache.juneau.html.HtmlSerializer}.</li>
				<li>Used for automatically creating <xa>uri</xa> attributes in {@link org.apache.juneau.xml.XmlSerializer}.</li>
				<li>Used for automatically creating <xa>rdf:about</xa> attributes in <c>RdfXmlSerializer</c>.</li>
			</ul>
		</li>	
	</ul>
</div>
</div><!-- END: 5.0.0.5 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.6' id='5.0.0.6'>5.0.0.6 (Oct 30, 2012)</a></h3>
<div class='topic'><!-- START: 5.0.0.6 -->
<div class='topic'>
	<p>
		Juno 5.0.0.6 is a minor update that fixes a small bug in 5.0.0.5.
	</p>
</div>
</div><!-- END: 5.0.0.6 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.7' id='5.0.0.7'>5.0.0.7 (Jan 20, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.7 -->
<div class='topic'>
	<p>
		Juno 5.0.0.7 is a major update.
	</p>
	<h5 class='topic w800'>Core API updates</h5>
	<ul class='spaced-list'>
		<li>Combined previous 3 libraries into a single library.</li>
		<li>
			New {@link org.apache.juneau.parser.ParserListener} class.<br>
			Adds ability to find and process unknown bean properties during parsing.
		</li>
		<li>
			Enhancements to {@link org.apache.juneau.xml.XmlParser}:
			<ul>
				<li>Coalescing support</li>
				<li>Validations support</li>
				<li>Support for replacing entity references</li>
				<li>Resolver support</li>
				<li>Event allocator support</li>
				<li>Trim-whitespace support</li>
			</ul>
		</li>
		<li>	
			Enhanced XML support:
			<ul>
				<li>
					New {@link org.apache.juneau.xml.annotation.Xml#format() @Xml.format} annotation.<br>
					Controls how POJOs get serialized to XML.<br>
					Also allows you to collapse collections and arrays.
				</li>
				<li>
					New <c>@Xml.namespaces</c> annotation.<br>
					Namespaces can be defined at package, class, method, or field levels.
				</li>
				<li>
					New <c>@Xml.nsUri</c> annotation.<br>
					Shortcut for specifying namespace URIs.
				</li>
				<li>
					New <c>@Xml.valAttr</c> annotation.<br>
				Serializes a bean property value as an attribute.
				</li>
				<li>Ability to override XS and XSI namespaces on XML and RDF/XML serializers.</li>
				<li>Ability to override RDF namespace on RDF/XML serializer.</li>
				<li>New more-efficient namespace resolution.</li>	
			</ul>
		</li>
		<li>
			New configurable property classes for everything are now structured better and easier to locate and identify through the following new classes:
			<ul>
				<li>{@link org.apache.juneau.BeanContext}</li>
				<li><del>SerializerContext</del></li>
				<li><del>ParserContext</del></li>
			</ul>		
		</li>
		<li>
			Enhancements to {@link org.apache.juneau.BeanContext}:
			<ul>
				<li>
					Ability to mark bean properties as hidden using <del>@BeanProperty(hidden)</del> so that they don't get serialized.
				</li>
				<li>
					Simplified <c>ClassType</c> {@link org.apache.juneau.ClassMeta} API.<br>
					Combined 4 classes into a single class.
				</li>
				<li>
					New <del>@Bean.filter</del>and <del>@BeanProperty.filter</del>annotations.<br>
					Used for defining filters on bean classes and bean properties instead of just globally through <c>BeanContext.addTransforms(Class[])</c>.
				</li>
				<li>
					New {@link org.apache.juneau.PropertyNamer} API / {@link org.apache.juneau.annotation.Bean#propertyNamer() @Bean.propertyNamer} annotation.<br>
					Used for customizing bean property names.
				</li>
				<li>
					New <del>@BeanProperty.beanUri</del>and <del>@BeanProperty.id</del>annotations.<br>
					Used for associating beans with URLs and IDs.<br>
					Used by XML serializer to add a url attribute on a bean element.<br>
					Used by RDF/XML serializer to construct <c>rdf:resource</c> attributes.
				</li>
				<li>
					New <del>BeanProperty.properties()</del>annotation.
					Used for limiting properties on child elements.
				</li>	
			</ul>
		</li>
		<li>
			Automatic support for {@link java.net.URL} and {@link java.net.URI} objects.
			<ul>
				<li>Converted to hrefs in HTML.</li>
				<li>Converted to url attributes in XML.</li>
				<li>Converted to resource:about attributes in RDF/XML.</li>
			</ul>				
		</li>
		<li>
			Improvements to Javadocs.
		</li>
		<li>
			Improved <del>PojoQuery</del> support.
		</li>
	</ul>
	<h5 class='topic w800'>REST client updates</h5>
	<ul class='spaced-list'>
		<li>GZIP compression support.</li>
		<li>Bug fixes.</li>
	</ul>
	<h5 class='topic w800'>REST server updates</h5>
	<ul class='spaced-list'>
			<li>
			Support for overriding bean context and serializer properties in a REST method call through new <del>RestResponse.setProperty(String,Object)</del>method.<br>
			For example, allows you to control whitespace options on a per-request basis.
		</li>
		<li>
			Several new annotations on REST servlets:
			<ul>
				<li><del>@RestResource.filters</del>- Associate post-formatting filters on a resource level.</li>
				<li><del>@RestResource.guards</del>- Associate resource-level guards.</li>
				<li><del>@RestResource.messages</del>- Associate a resource bundle with a REST servlet.  Comes with several convenience methods for looking up messages for the client locale.</li>
				<li><del>@RestResource.properties</del>- Override default bean context, serializer, and parser properties though an annotation.</li>
			</ul> 
		</li>
		<li>
			Several new annotations on REST methods:
			<ul>
				<li><c>@RestMethod(filters)</c> - Associate post-formatting filters on a method level.</li>
				<li><del>RestMethod.guards() @RestMethod(guards)</del> - Associate method-level guards.</li>
			</ul>
		</li>
		<li>				
			New annotations on REST method parameters with automatic conversion:
			<ul>
				<li><del>@Attr</del> - A parameter or URL variable value as a parsed POJO.</li>
				<li><del>@Param</del> - A query parameter value as a parsed POJO.</li>
				<li><del>@PathRemainder</del>- The remainder after a URL pattern match as a String.</li>
				<li><del>@Header</del> - An HTTP header value as a parsed POJO.</li>
				<li><del>@Content</del>- The HTTP content as a parsed POJO.</li>
				<li>{@link org.apache.juneau.rest.annotation.Method @Method} - The HTTP method name as a String.</li>
			</ul>
		</li>
		<li>
			HTTP response content POJOs can now simply be returned from methods instead of calling <del>RestResponse.setOutput(Object)</del>.		
		</li>	
	</ul>
</div>
</div><!-- END: 5.0.0.7 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.8' id='5.0.0.8'>5.0.0.8 (Jan 30, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.8 -->
<div class='topic'>
	<p>
		Juno 5.0.0.8 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			New {@link org.apache.juneau.config INI file} support. 
			<ul>
				<li>Makes reading, updating, and manipulating INI configuration files a snap. </li>
				<li>Supports automatic conversion of data types in line with the functionality of the rest of the product.</li>
				<li>Comments and layout of INI files are persisted during saves. </li>
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.8 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.9' id='5.0.0.9'>5.0.0.9 (Feb 26, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.9 -->
<div class='topic'>
	<p>
		Juno 5.0.0.9 is a moderate update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.config INI config file support}:
			<ul>
				<li>A convenient API for reading, writing, and manipulating INI files.</li>
				<li>Ability to convert INI files to batch and shell environment variables.</li>
				<li>Command-line interface for updating INI files.</li>
				<li>Support for encoded INI file values.</li>
			</ul>
		</li>
		<li>Support for fluent-style bean setters (setters that return the bean itself).</li>
		<li>Ability to use {@link org.apache.juneau.annotation.Bean @Bean} annotation to override bean identification settings.</li>
		<li>New <del>ObjectMap.cast(Class)</del>method to convert <c>ObjectMaps</c> directly to beans.</li>
	</ul>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>Build-in default <c>OPTIONS</c> pages.</li>
		<li>New <del>@RestResource.defaultRequestHeaders</del>and <del>@RestResource.defaultResponseHeaders</del>annotations.</li>
		<li>New <del>RestMethod.serializers() @RestMethod(serializers)</del>and <del>RestMethod.parsers() @RestMethod(parsers)</del>annotations.</li>
		<li>New <del>RestMethod.properties() @RestMethod(properties)</del> annotation.</li>
		<li>New <del>@RestMethod(defaultRequestHeaders)</del>annotation.</li>
		<li>New <del>RestMethod.matchers() @RestMethod(matchers)</del> annotation and <del>RestMatcher</del> class.</li>
		<li><c>Readers</c> and <c>InputStreams</c> can be specified on <del>@Content</del> annotated parameters.</li>
		<li>New <del>@HasParam</del>annotation.</li>
		<li>Full RFC2616 support for matching <c>Accept</c> headers to serializers.</li>		
	</ul>
	<h5 class='topic w800'>Other notes</h5>
	<ul class='spaced-list'>
		<li>Smaller library size (460kB).</li>
	</ul>
</div>
</div><!-- END: 5.0.0.9 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.10' id='5.0.0.10'>5.0.0.10 (Mar 7, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.10 -->
<div class='topic'>
	<p>
		Juno 5.0.0.10 is a minor update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>New <del>ObjectMap.findKeyIgnoreCase(String)</del>method.
		<li>HtmlSerializer will now create 2-dimensional tables for collections of mixed beans/maps if all object have the same set of property names/keys.</li>
	</ul>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>New <c>RestServletProperties</c> class that defines all the class-level properties that can be set on the servlet.</li>
		<li>Properties can be set through <del>@RestResource.properties</del>annotation, or new <del>RestServlet.setProperty(String,Object)</del>method.</li>
		<li>New <js>"?noTrace"</js> URL parameter to prevent stack traces from being logged (for JUnit testing of error conditions).</li>
		<li>New <c>RestServletProperties.REST_useStackTraceHashes</c> property to prevent the same stack trace from being logged multiple times.</li>
		<li>New <c>RestServletProperties.REST_renderResponseStackTraces</c> property for preventing stack traces in responses for security reasons.</li>
		<li>New overridable <c>RestServlet.onError(HttpServletRequest,HttpServletResponse,RestException,boolean)</c> and <del>RestServlet.onSuccess(RestRequest,RestResponse,long)</del>methods for plugging in your own logging and peformance monitoring.</li>
		<li>Eliminated <c>RestServlet.getInitParams()</c> method, since it's now redundant with <del>RestServlet.getProperties()</del>.</li>
		<li>Header parameters passed as URL parameters are now case-insensitive.</li>			
	</ul>
</div>
</div><!-- END: 5.0.0.10 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.11' id='5.0.0.11'>5.0.0.11 (Mar 8, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.11 -->
<div class='topic'>
	<p>
		Juno 5.0.0.11 is a moderate update.
	</p>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>	
			New <c>UrlEncodingRestSerializer</c> and <c>UrlEncodingRestParser</c> classes.<br>
			Allows parsing form posts directly to POJOs.
		</li>
		<li>
			Support for <c>Accept</c> and <c>Content-Type</c> <js>"application/x-www-form-urlencoded"</js> added by default on <del>BasicRestServlet</del>.
		</li>
		<li>
			New <del>RestServlet.renderError(HttpServletRequest,HttpServletResponse,RestException)</del>method to allow customized handling of response errors.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.11 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.12' id='5.0.0.12'>5.0.0.12 (Mar 10, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.12 -->
<div class='topic'>
	<p>
		Juno 5.0.0.12 is a minor update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
			Relaxed method naming conventions when using <del>@BeanProperty</del> annotation.<br>
			Methods with zero parameters are interpreted as getters, and methods with one parameter are interpreted as setters.<br>
			Eliminated the <c>BeanProperty.method</c> annotation, since it's now unnecessary.
				</li>
	</ul>		
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>		
			Significantly improved response error messages.<br> 
			Older messages were rather cryptic.   Error conditions should be much easier to debug now.
		</li>
		<li>
			New <c>PlainTextRestSerializer</c> class for serializing <js>"plain/text"</js> requests.<br>
			Useful for debugging purposes.
		</li>
		<li>
			<c>Readers</c> and <c>InputStreams</c> can now be passed in as <del>@Content</del> parameters if you need direct access to the HTTP body content without involving the parsers.<br> 
			Equivalent to previously calling {@link org.apache.juneau.rest.RestRequest#getInputStream()} and {@link org.apache.juneau.rest.RestRequest#getReader()}.
		</li>
		<li>
			Improved support for the <c>?debug</c> parameter.<br>
			Dumps better information to the log file, such as all header parameters.
		</li>
	</ul>		
</div>
</div><!-- END: 5.0.0.12 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.13' id='5.0.0.13'>5.0.0.13 (Mar 14, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.13 -->
<div class='topic'>
	<p>
		Juno 5.0.0.13 is a minor update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>		
			New support for relative URIs.
			<ul>
				<li>URIs of the form <js>"foo/bar"</js> are interpreted as relative to the context root of the web application.</li>
				<li>URIs of the form <js>"/foo/bar"</js> are interpreted as relative to the HTTP authority (e.g. <js>"http://myhost:9080"</js>).</li>
			</ul>
		</li>
		<li>
			New <c>SerializerContext.SERIALIZER_uriContext</c> and <c>SerializerContext.SERIALIZER_uriAuthority</c> serializer properties for specifying values for relative URIs.
		</li>
		<li>
			New <del>URI @URI</del> annotation that allows you to specify classes and bean properties as URLs that aren't <c>java.net.URI</c> or <c>java.net.URL</c>.
		</li>
		<li>
			New <del>HtmlSerializer.HTML_uriAnchorText</del>HTML serializer property for tailoring how anchor text is rendered.
		</li>
		<li>
			Renamed <c>BeanProperty#uri</c> annotation to <c>BeanProperty#beanUri</c> to make it clear that this property represents the URI of the bean itself instead of an arbitrary property containing a URI.
		</li>
		<li>
			Removed <c>BeanProperty#id</c> annotation.
		</li>
	</ul>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>
			Improvements to <del>RestServlet</del> to automatically handle relative URIs in POJOs.
			<ul>
				<li><c>SerializerContext.SERIALIZER_uriContext</c> property set by default to web app context root.</li>
				<li><c>SerializerContext.SERIALIZER_uriAuthority</c> property set by default to the request scheme+hostname+port.</li>
			</ul>
		</li>
		<li>
			Fixed bug involving <c>Accept-Charset</c> header in Chrome that prevented HTML output from rendering correctly in that browser.<br>
			<c>Accept-Charset</c> handling should now be fully W3C compliant.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.13 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.14' id='5.0.0.14'>5.0.0.14 (Mar 23, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.14 -->
<div class='topic'>
	<p>
		Juno 5.0.0.14 is a major update.
	</p>
	<p>
		The biggest change is that the <c>RestSerializer</c>, <c>RestParser</c>, <c>RestSerializerGroup</c>, and <c>RestParserGroup</c> classes have been eliminated entirely.<br>  
		Instead, the existing {@link org.apache.juneau.serializer.Serializer}, {@link org.apache.juneau.parser.Parser}, <del>SerializerGroup</del>, and <del>ParserGroup</del> classes of the core API have been augmented to replace them.
	</p>
	<p>
		Adoptions will be required if you have previously used these classes.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
			New <c>org.apache.juneau.serializer</c> package.
			<ul>
				<li>Entirely reworked class hierarchy to make it easier to define new serializers.</li>
				<li>New {@link org.apache.juneau.serializer.WriterSerializer} base class for defining character-based serializers.</li>
				<li>New {@link org.apache.juneau.serializer.OutputStreamSerializer} base class for defining byte-based serializers.</li>
				<li>Updated <del>SerializerGroup</del> class with full support for RFC2616 <c>Accept-Content</c> headers.</li>
				<li>Improved cloning support on serializers and serializer groups.</li>
			</ul>
	       	</li>
	       	<li>
	       		New <c>org.apache.juneau.parser</c> package.
	       		<ul>
	       			<li>Entirely reworked class hierarchy to make it easier to define new parsers.</li>
				<li>New {@link org.apache.juneau.parser.ReaderParser} base class for defining character-based parsers.</li>
				<li>New {@link org.apache.juneau.parser.InputStreamParser} base class for defining byte-based parsers.</li>
				<li>Improved cloning support on parsers and parser groups.</li>
	       		</ul>
	       	</li>
	       	<li>
			New <c>org.apache.juneau.swap</c> package.
			<ul>
				<li>Cleaner class structure.</li>
				<li>Improved <del>BeanFilter</del> class for defining property filters on beans.</li>
				<li>Improved <del>PojoQuery</del> class for defining filters on objects (previously called <c>ObjectFilter</c>).</li>
	       		</ul>
	       	</li>
	       	<li>
			New <c>org.apache.juneau.encoders</c> package.
			<ul>
				<li>Defines API for {@link org.apache.juneau.encoders.Encoder Encoders} for enabling compression in REST servlets and clients.</li>
				<li>Previously, gzip compression was enabled by default.  This new API allows you to plug in your own compression algorithms.</li>
				<li>New {@link org.apache.juneau.encoders.GzipEncoder} class for enabling gzip compression.</li>
				<li>New <del>EncoderGroup</del> class for managing multiple encoders and finding them based on RFC2616 <c>Accept-Encoding</c> header values.</li>
			</ul>
		</li>
		<li>
			New <c>org.apache.juneau.plaintext</c> package.
			<ul>
				<li>New {@link org.apache.juneau.plaintext.PlainTextSerializer} and {@link org.apache.juneau.plaintext.PlainTextParser} classes for serializing/parsing text/plain content.</li>
			</ul>
		</li>
		<li>
			New <c>org.apache.juneau.jso</c> package.
			<ul>
				<li>New <del>JsoSerializer</del> class for serializing <c>application/x-java-serialized-object</c> content.</li>
			</ul>
		</li>
		<li>
			New <c>org.apache.juneau.soap</c> package.
			<ul>
				<li>New {@link org.apache.juneau.soap.SoapXmlSerializer} class for serializing <c>text/xml+soap</c> content.</li>
			</ul>
		</li>
		<li>
			Improved cloning support on the {@link org.apache.juneau.BeanContext} class.
			<ul>
				<li>Better caching.  Improved caching performance.</li>
			</ul>
		</li>
	       	<li>
			<c>JsonMap</c> and <c>JsonList</c> changed to <del>ObjectMap</del> and <del>ObjectList</del> to better reflect that they're not limited to just JSON support.
	   		</li>
	   		<li>
			Renamed <c>PojoSwap</c> to <del>PojoQuery</del> to not confuse it with the new Filter API.
		</li>
	</ul>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>
			Eliminated <c>org.apache.juneau.rest.serializers</c> and <c>org.apache.juneau.rest.parsers</c> packages.
			<ul>
				<li>All existing REST serializers and parsers merged into the core API.</li>
			</ul>
		</li>
	</ul>
	<h5 class='topic w800'>REST client API changes</h5>
	<ul class='spaced-list'>
		<li>
			Simplified {@link org.apache.juneau.rest.client.RestClient} API.
			<ul>
				<li>You can now only specify a single serializer or parser per client.  This significantly simplifies the code.</li>
				<li>Support for {@link org.apache.juneau.encoders.Encoder Encoders}.</li>
			</ul>
		</li>
		<li>
			Eliminated <c>RestCmdLine</c> (since it's essentially redundant with CURL).
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.14 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.15' id='5.0.0.15'>5.0.0.15 (Mar 24, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.15 -->
<div class='topic'>
	<p>
		Juno 5.0.0.15 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>		
			Juno-Wink integration components that have been requested by many for a long time!<br>
			Refer to <del>jaxrs</del> for information.
		</li>
		<li>
			New <del>@Produces</del> annotation in place of <c>ISerializer.getMediaTypes()</c> for specifying what media types a serializer produces.<br>
			Available when subclassing from {@link org.apache.juneau.serializer.Serializer}.
		</li>
		<li>
			New <del>@Consumes</del> annotation in place of <c>IParser.getMediaTypes()</c> for specifying what media types a parser consumes.<br>
			Available when subclassing from {@link org.apache.juneau.parser.Parser}.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.15 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.16' id='5.0.0.16'>5.0.0.16 (Mar 25, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.16 -->
<div class='topic'>
	<p>
		Juno 5.0.0.16 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			New <del>@Properties</del> REST method parameter annotation that can be used to get the runtime properties map through a parameter instead of through {@link org.apache.juneau.rest.RestResponse}. 
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.16 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.17' id='5.0.0.17'>5.0.0.17 (Mar 25, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.17 -->
<div class='topic'>
	<p>
		Juno 5.0.0.17 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			Charset now passed as a parameter to <c>IOutputStreamSerializer.serialize()</c> and <c>IInputStreamParser.parse()</c>. 
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.17 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.18' id='5.0.0.18'>5.0.0.18 (Mar 27, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.18 -->
<div class='topic'>
	<p>
		Juno 5.0.0.18 is a moderate update.
	</p>
	<p>
		The biggest change is the introduction of the <del>RdfSerializer</del> class that uses Jena to generate RDF/XML, RDF/XML-ABBREV, N-Tuple, N3, and Turtle output.
	</p>
	<p>
		This code should be considered prototype-quality, and subject to change in the future.<br>  
		There are plans of adding an equivalent <c>RdfParser</c> class in the future, so the serializer logic may need to be tweaked to allow POJOs to be reconstituted correctly in the parser.
	</p>
	<p>
		The <c>RdfXmlSerializer</c> class should be considered deprecated for now.<br>  
		However, I'm keeping it around, since it's considerably faster and uses far less memory than the Jena-based serializer since it serializes directly from POJOs to RDF/XML.<br> 
		It may or may not be removed in the future depending on demand.
	</p>
	<h5 class='topic w800'>Other changes</h5>
	<ul class='spaced-list'>
		<li>
			New <del>JsoParser</del> class.  
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.18 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.19' id='5.0.0.19'>5.0.0.19 (Apr 1, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.19 -->
<div class='topic'>
	<p>
		Juno 5.0.0.19 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			New methods on <del>RestServlet</del>:
			<ul>
				<li><del>RestServlet.onPreCall(RestRequest)</del></li>
				<li><del>RestServlet.onPostCall(RestRequest,RestResponse)</del></li>
			</ul>
		</li>
		<li>
			<jsf>TRIM_NULLS</jsf> setting changed to <del>SerializerContext.SERIALIZER_trimNullProperties</del>.<br>
			New property default is <jk>true</jk>. 
			Only applies to bean properties, not map or collection entries.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.19 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.20' id='5.0.0.20'>5.0.0.20 (Apr 7, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.20 -->
<div class='topic'>
	<p>
		Juno 5.0.0.20 is a major update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
			New Jena-based <del>RdfSerializer</del> for serializing POJOs to RDF/XML, RDF/XML-ABBREV, N-Triple, Turtle, and N3.<br>
			Serializes ANY POJOs to RDF, even simple objects and primitives.
		</li>
		<li>
			New Jena-based <del>RdfParser</del> for parsing RDF/XML, RDF/XML-ABBREV, N3, Turtle, and N-Triple back into POJOs.
		</li>
		<li>
			<del>XmlSerializerContext.XML_autoDetectNamespaces</del>default changed to <jk>true</jk>.<br>
			The old default value would cause XML with unmapped namespaces if you didn't manually specify them via the <del>XmlSerializerContext.XML_namespaces</del> annotation.<br>
			While setting the default to <jk>true</jk> is somewhat slower (since the serializer must crawl the POJO tree to find namespaces), the benefits of having it work out-of-the-box outweighs the performance concerns.<br>
			For developers concerned about performance, they can always change it back to false and specify the namespaces themselves.	
		</li>
	</ul>
	<h5 class='topic w800'>REST server API changes</h5>
	<ul class='spaced-list'>
		<li>
			Allow inheritance of <del>@RestResource</del> annotation.<br>
			Serializers, parsers, filters, properties , guards, and converters definitions are automatically inherited from parent classes and interfaces.
		</li>
		<li>
			Enhancements to <del>RestMethod @RestMethod</del>annotation:
			<ul>
				<li>
					New <c>RestMethod.filters()</c> annotation for defining POJO filters at the method level.
				</li>
				<li>
					New <del>RestMethod.serializersInherit()</del>and <del>RestMethod.parsersInherit()</del> annotations for controlling how serializers and parsers (and associated filters and properties) are inherited from the class.<br>
					This replaces the previous <c>addSerializers</c> and <c>addParsers</c> annotations.
			</ul>
		</li>
		<li>
			New <del>RestServletJenaDefault</del> servlet that includes serialization/parsing support for all Jena-based serializers and parsers.
		</li>
		<li>
			New <del>DefaultJenaProvider</del>JAX-RS provider that includes serialization/parsing support for all Jena-based serializers and parsers.
		</li>
		<li>
			Eliminated <c>RestServletChild</c> class.<br>  
			It's redundant with the introduction of inheritable annotations.
		</li>
		<li>
			New methods on <del>RestServlet</del>:
			<ul>
				<li><c>RestServlet.createConfigFactory()</c></li>
				<li><c>RestServlet.createSerializers()</c></li>
				<li><c>RestServlet.createParsers()</c></li>
			</ul>
			These augment the existing <c>getBeanContext()</c> / <c>getSerializers()</c> / <c>getParsers()</c> methods.		
		</li>
	</ul>
	<h5 class='topic w800'>REST client API changes</h5>
	<ul class='spaced-list'>
		<li>
			New <c>RestCall.setDateHeader(String,Object)</c> method for setting ISO8601 datetime headers.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.20 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.21' id='5.0.0.21'>5.0.0.21 (Apr 9, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.21 -->
<div class='topic'>
	<p>
		Juno 5.0.0.21 is a minor update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
			New <del>HtmlDocSerializerContext.HTMLDOC_navlinks</del> annotation for addint links to HTML page views.
		</li>
		<li>
			Renamed the properties in <del>HtmlDocSerializerContext</del> for clarity.
		</li>
	</ul>		
	<h5 class='topic w800'>Servlet API changes</h5>
	<ul class='spaced-list'>
		<li>
			Added new <c>RestServlet.addDefaultProperties(ObjectMap,RestRequest)</c> method for programatically adding properties to the property map per request.
		</li>
		<li>
			Added the following new properties in the properties map to make them easily available to serializers and parsers (since they don't have access to the HTTP request object).<br>  
			Note that the <c>SerializerContext.SERIALIZER_uriAuthority</c> and <c>SerializerContext.SERIALIZER_uriContext</c> properties were previously available.
			<ul>
				<li><c>RestServletProperties.REST_servletPath</c></li>
				<li><c>RestServletProperties.REST_pathInfo</c></li>
				<li><c>RestServletProperties.REST_method</c></li>
			</ul>
		</li>
		<li>
			Path variables annotated with <del>@Attr</del>are now automatically URL-decoded.
		</li>
	</ul>		
</div>
</div><!-- END: 5.0.0.21 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.22' id='5.0.0.22'>5.0.0.22 (Apr 12, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.22 -->
<div class='topic'>
	<p>
		Juno 5.0.0.22 is a minor update.
	</p>
	<h5 class='topic w800'>Core API changes</h5>
	<ul class='spaced-list'>
		<li>
	    	New <c><ja>@Property</ja>.nls()</c> annotation for specifying localized property values.<br>
	    	For example, allows you to set the <jsf>HTMLDOC_title</jsf> and <jsf>HTMLDOC_description</jsf> properties to localized values pulled from a resource bundle.<br>
	    	See the <c>AddressBookResource</c> class for an example.
	    </li>
	</ul>
	<h5 class='topic w800'>REST Servlet API changes</h5>
	<ul class='spaced-list'>
		<li>Fix a bug where the <c>&amp;Content</c> query parameter was not always parsed correctly.</li>
	</ul>
</div>
</div><!-- END: 5.0.0.22 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.23' id='5.0.0.23'>5.0.0.23 (Apr 14, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.23 -->
<div class='topic'>
	<p>
		Juno 5.0.0.23 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			Simplified <del>cognos Cognos</del> support.
		</li>
		<li>
			Fixed bug where <c><ja>@Xml</ja></c> annotation was not being inherited by inner classes.
		</li>
		<li>
			Javadoc stylesheet improvements.
		</li>
	</ul>		
</div>
</div><!-- END: 5.0.0.23 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.24' id='5.0.0.24'>5.0.0.24 (May 9, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.24 -->
<div class='topic'>
	<p>
		Juno 5.0.0.24 is a major update.
	</p>
	<h5 class='topic w800'>Core API updates</h5>
	<ul class='spaced-list'>
		<li>
			New support for {@link org.apache.juneau.dto.atom ATOM}.
			<ul>
				<li>New <c>AtomFeedResource</c> class added to sample war.
			</ul>
		</li>
		<li>
			New <del>XmlFormat.CONTENT</del> enum value.<br>
			Allows bean properties to be persisted as XML element text.
		</li>
		<li>
			New <del>XmlContentHandler</del>class and <del>@Xml.contentHandler</del>annotation.<br>
			Allows customized serialization and parsing of beans to XML element text.<br>
			Added for support of ATOM text content that must support both plain text and embedded XHTML.
		</li>
		<li>
			New {@link org.apache.juneau.xml.annotation.XmlSchema @XmlSchema} and updated {@link org.apache.juneau.xml.annotation.XmlNs @XmlNs} annotations to better mimic JAXB.
		</li>
		<li>
			Removed <c><ja>@Xml</ja>.valAttr</c> annotation since it's now redundant with <c><ja>@Xml</ja>(format=<jsf>CONTENT</jsf>)</c>.
			</li>
			<li>
			Fixed timezone bug in <del>CalendarSwap</del>.
		</li>
			<li>
			Simplified <c>Serializer.serialize(Object,Object,SerializerContext)</c> method.
		</li>
		<li>
			Fixed bug where lists returned by <del>ObjectMap.getObjectList(String)</del>were not updatable.
		</li>
		<li>
			Eliminated old RDF/XML serializer.
		</li>
	</ul>	
	<h5 class='topic w800'>Documentation updates</h5>
	<ul>
		<li>New {@link org.apache.juneau.json JSON Support Overview} document.</li>
		<li>New {@link org.apache.juneau.xml XML Support Overview} document.</li>
		<li>New <del>RDF Languages Support Overview</del> document.</li>
		<li>New {@link org.apache.juneau.dto.atom ATOM Support Overview} document.</li>
	</ul>
</div>
</div><!-- END: 5.0.0.24 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.25' id='5.0.0.25'>5.0.0.25 (May 11, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.25 -->
<div class='topic'>
	<p>
		Juno 5.0.0.25 is a minor update.
	</p>
	<h5 class='topic w800'>Core API updates</h5>
	<ul class='spaced-list'>
		<li>
			New {@link org.apache.juneau.dto.ResultSetList} DTO for serializing SQL result sets to JSON/XML/HTML and so forth.
		</li>
		<li>
			New <c>SqlQueryResource</c> class in the sample war for demonstrating the <c>ResultSetList</c> DTO.
		</li>
	</ul>
	<h5 class='topic w800'>Server API updates</h5>
	<ul class='spaced-list'>
		<li>
			Fixed issue with media type for CSS files being reported as <js>"text/plain"</js> instead of <js>"text/css"</js>.
		</li>
		<li>
			Moved initialization of class properties to before the call to <c>Servlet.init()</c> so that <c>getProperties()</c> can be called during servlet initialization.
		</li>
		<li>
			New <c><ja>@Property</ja>.type</c> annotation with support for using system properties as resource properties.
		</li>
	</ul>		
</div>
</div><!-- END: 5.0.0.25 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.26' id='5.0.0.26'>5.0.0.26 (Jun 5, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.26 -->
<div class='topic'>
	<p>
		Juno 5.0.0.26 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>
			FindBug fixes.
		</li>
		<li>
			Changed the way child REST resources are defined.<br>
			Eliminated the <ja>@RestChild</ja> annotation on getter methods and replaced it with <del>@RestResource(children)</del> defined on the resource class itself.<br>
			Child resource paths are specified through <del>@RestResource(path)</del>.
		</li>
		<li>
			New <del>ChildResourceDescriptions</del> bean for automatically generating the contents of router resource pages.
		</li>
		<li>
			Changed <c><ja>@RestMethod</ja>.pattern()</c> to <del>RestMethod.path() @RestMethod(path)</del>for naming consistency.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.26 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.27' id='5.0.0.27'>5.0.0.27 (July 7, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.27 -->
<div class='topic'>
	<p>
		Juno 5.0.0.27 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			Fixed some HTML formatting issues in {@link org.apache.juneau.html.HtmlSerializer}.
		</li>
		<li>
	  			<del>BasicRestServlet</del> now includes {@link org.apache.juneau.plaintext.PlainTextSerializer} and {@link org.apache.juneau.plaintext.PlainTextParser} for plain-text support.
	  		</li>
	  		<li>
			Child resources now render on default <c>OPTIONS</c> pages through new method <del>ResourceOptions.getChildren()</del>.
		</li>
		<li>
			Changes to {@link org.apache.juneau.urlencoding.UrlEncodingSerializer}/{@link org.apache.juneau.urlencoding.UrlEncodingParser} to reduce the need for quoted string values.<br>
			More changes are likely in this area of the code to support multipart form posts.
		</li>
		<li>
			FindBugs fixes.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.27 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.28' id='5.0.0.28'>5.0.0.28 (July 9, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.28 -->
<div class='topic'>
	<p>
		Juno 5.0.0.28 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			Fixes an <c>OutOfMemoryError</c> and performance issue caused by incorrect caching of class metadata. 
		</li>
		<li>
			Added <c>WriterSerializer.serialize(Object,Writer)</c> convenience method for serializing directly to a writer.<br> 
			Applies to all serializers.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.28 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.29' id='5.0.0.29'>5.0.0.29 (Aug 2, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.29 -->
<div class='topic'>
	<p>
		Juno 5.0.0.29 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			Revamped the API for filter support:
			<ul>
				<li>Updated <del>BeanFilter</del> class to mirror the {@link org.apache.juneau.annotation.Bean @Bean} annotation.</li>
				<li>Introduced support for bean <del>Bean.subTypeProperty() subtypes</del>. </li>
				<li>Replaced <c><ja>@Bean</ja>(filter=xxx)</c> with new <del>@Transform</del>annotation.</li>
			</ul>
		</li>
		<li>
			Revamped URL-Encoding support.<br>
			The old URL-Encoding serializer and parser simply used the JSON serializer/parser with a thin URL-encoding top layer.<br>
			The new URL-Encoding serialize and parser was written from scratch and is considerably more consistent in design and output.
		</li>
		<li>	
			Improved number parsing.<br> 
			The new number parser should handle any valid numeric syntax for decimals and floats that Java itself supports.
		</li>
		<li>
			{@link org.apache.juneau.json.JsonSerializer} LAX mode now quotes reserved word attributes.
		</li>
		<li>
			New predefined DateFilters with millisecond precision:
			<ul>
				<li><c>org.apache.juneau.swaps.DateSwap.ISO8601DTP</c></li>
				<li><c>org.apache.juneau.swaps.DateSwap.ISO8601DTZP</c></li>
			</ul>
		</li>
	</ul>		
</div>
</div><!-- END: 5.0.0.29 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.30' id='5.0.0.30'>5.0.0.30 (Aug 8, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.30 -->
<div class='topic'>
	<p>
		Juno 5.0.0.30 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li> 
			Fixed bug involving beans using <del>Bean.subTypes()</del>annotation in addition to <c>subTypes</c> property.
		</li>
		<li>
			Modified the JSON parser to handle non-existent JSON values to get around an issue where Cognos was generating invalid JSON.
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.30 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.31' id='5.0.0.31'>5.0.0.31 (Aug 9, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.31 -->
<div class='topic'>
	<p>
		Juno 5.0.0.31 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			Simplified the {@link org.apache.juneau.serializer.Serializer} and {@link org.apache.juneau.parser.Parser} class hierarchies.<br> 
			This reverses a previous change that added a bunch of interfaces in these APIs (and subsequently required compiling with Java 7 to get around a compiler bug).<br>
			The new class hierarchy is much simpler to understand.
		</li>
		<li>
			Added <del>XMLGregorianCalendarSwap</del> to convert these to ISO8601 strings during serialization, and vice versa during parsing.
		</li>
		<li>
			Added a strict mode to {@link org.apache.juneau.json.JsonParser}.
		</li>
		<li>
			Added default {@link org.apache.juneau.json.JsonParser#DEFAULT_STRICT} parser.
		</li>
	</ul>	
</div>
</div><!-- END: 5.0.0.31 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.32' id='5.0.0.32'>5.0.0.32 (Oct 5, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.32 -->
<div class='topic'>
	<p>
		Juno 5.0.0.32 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			New support for generating and consuming fully-compliant JSON-Schema documents.<br>
			See <del>jsonschema</del> for information.
		</li>
		<li>
			New methods added to {@link org.apache.juneau.parser.Parser}:
			<ul>
				<li><c>org.apache.juneau.parser.Parser.parseMap(Object,int,Class,Class,Class)</c></li>
				<li><c>org.apache.juneau.parser.Parser.parseCollection(Object,int,Class,Class)</c></li>
			</ul>
		</li>
			<li>
			{@link org.apache.juneau.annotation.Bean @Bean} annotation can now be defined on interfaces and inherited by subclasses.
		</li>
		<li>
				Support for customizing serialized values for <c>Enums</c> through overriding <c>toString()</c> and <c>fromString()</c> on the enum class.<br>
			Previously used <c>Enum.valueOf()</c> to convert strings back into <c>Enums</c>.<br>
			Used for JSON-Schema support to allow {@link org.apache.juneau.dto.jsonschema.JsonType} enum to be serialized to lowercase per the specification (e.g. <js>"string"</js> instead of <js>"STRING"</js>).
			</li>
			<li>
			<del>cognos Cognos</del> DTOs now have fluent-style bean setters.
			</li>
			<li>
			Support for generic bean objects whose type was erased at compile time.<br> 
			Previous behavior gave you an error message that the type could not be determined.<br>
			New behavior assumes a type of <c>Object</c> when the type is erased.
			</li>
			<li>
				Bug fixes:
				<ul>
					<li>
					When duplicate fluent-style setters were defined with different parameter types (e.g. <c>setFoo(Foo f)</c>, <c>setFoo(Bar b)</c>), the {@link org.apache.juneau.BeanMap} API would sometime choose the wrong setter as the bean property setter. <br>
					Now validates that the setter being chosen is the one whose return type matches the property getter.
				</li>
				<li>
					Passing in <c>Accept</c> GET parameters with <js>'+'</js> (e.g. <c>&amp;Accept=text/json+simple</c>) wasn't working anymore.<br>
					The <c>Accept</c> parameter is supposed to interpret spaces as <js>'+'</js> to allow you to not have to write <c>&amp;Accept=text/json%2Bsimple</c>.
					</li>
					<li>
					Parsers would not set bean properties of abstract type {@link java.lang.Number}.<br> 
					Now it detects the numeric type based on input and sets the value accordingly.		
				</li>
				</ul>
		</li>
	</ul>	
</div>
</div><!-- END: 5.0.0.32 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.33' id='5.0.0.33'>5.0.0.33 (Oct 20, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.33 -->
<div class='topic'>
	<p>
		Juno 5.0.0.33 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			Removed generic parameter from {@link org.apache.juneau.serializer.WriterSerializer} class. 
			<ul>
				<li>
					Many of the examples in the documentation were written as follows, which resulted in "unchecked" compile warnings:<br>
					<c>WriterSerializer s = <jk>new</jk> JsonSerializer();</c><br>
					These compile warnings will now go away.
				</li>
			</ul>
		</li>	
		<li>
			New settings in BeanContext.  These can be applied to all serializers/parsers.
			<ul>
				<li><del>BEAN_ignoreInvocationExceptionsOnGetters</del>
				<li><del>BEAN_ignoreInvocationExceptionsOnSetters</del>
				<li><del>BEAN_notBeanPackages_add</del>
				<li><del>BEAN_notBeanPackages_remove</del>
			</ul>
		</li>
		<li>
			Eliminated <c>addNotBeanClassPatterns(String...)</c> methods throughout API since these are now controlled by <del>BEAN_notBeanPackages_add</del> / <del>BEAN_notBeanPackages_remove</del> properties.
		</li>
		<li>
			New settings in <c>RestServletProperties</c>.
			<ul>
				<li><c>RestServletProperties.REST_trimTrailingUriSlashes</c><br>
					Also removed <c>RestRequest.getRequestURI(boolean trimTrailingSlashes)</c> method which is now redundant with this property.
				<li><c>RestServletProperties.REST_pathInfoBlankForNull</c><br>
					Also removed <c>RestRequest.getPathInfo(boolean returnBlankForNull)</c> method which is now redundant with this property.
			</ul>
		</li>
		<li>
			New JSON-Schema {@link org.apache.juneau.dto.jsonschema.JsonSchemaMap} class for supporting linked schemas.
		</li>
		<li>
			Serializers will no longer throw an exception when <c>maxDepth</c> setting is reached, and will instead simply ignore content below the specified depth.<br>
			While the old behavior was as-designed, the new behavior is more in-line with expected behavior.
		</li>
		<li>
			Added support for HTTP header <js>"X-Response-Headers"</js> to <del>RestServlet</del>. <br>
			Allows you to specify one or more headers that should be returned on the response from the servlet.<br>
			For example, to get a page to automatically refresh every 1 second, you can append the following to a URL:  <c>?x-response-headers={Refresh=1}</c>
		</li>
		<li>
			Removed <c>HtmlDocSerializerContext.<jsf>HTML_REFRESH</jsf></c> setting that added a Refresh meta tag to HTML documents, since this can now be controlled through <c>X-Response-Headers</c>.
		</li>
		<li>
			Small improvements to samples.
			<ul>
				<li><c>PhotosResource</c> now includes a default entry.
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 5.0.0.33 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.34' id='5.0.0.34'>5.0.0.34 (Nov 10, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.34 -->
<div class='topic'>
	<p>
		Juno 5.0.0.34 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>
			New support for runtime-replaced variables in REST resource properties:
			<p class='bcode'>
		<ja>@RestResource</ja>(
			messages=<js>"nls/Messages"</js>,
			properties={
				<ja>@Property</ja>(name=<js>"label"</js>,value=<js>"$L{servletTitle}"</js>),  <jc>// Localized variable in Messages.properties</jc>
				<ja>@Property</ja>(name=<js>"javaVendor"</js>,value=<js>"$S{java.vendor}"</js>),  <jc>// System property</jc>
				<ja>@Property</ja>(name=<js>"foo"</js>,value=<js>"bar"</js>),
				<ja>@Property</ja>(name=<js>"bar"</js>,value=<js>"baz"</js>),
				<ja>@Property</ja>(name=<js>"v1"</js>,value=<js>"$R{foo}"</js>),  <jc>// Request variable. value="bar"</jc>
				<ja>@Property</ja>(name=<js>"v2"</js>,value=<js>"$R{$R{foo}}"</js>)  <jc>// Nested request variable. value="baz"</jc>
			}
		)
			</p>
			See <c>RestServlet.createRequestVarResolver(RestRequest)</c> for more information.
		</li>
		<li>
			 Eliminated <ja>@Property.type</ja> annotation which was the old way of specifying NLS variables that got resolved at runtime.
		</li> 
		<li>
			New methods on {@link org.apache.juneau.rest.RestRequest}:
			<ul>
				<li><del>RestRequest.getVarResolver()</del></li>
				<li><del>RestRequest.getServletURI()</del></li>
				<li><del>RestRequest.getRequestParentURI()</del></li>
			</ul>
		</li>
		<li>
			New methods on {@link org.apache.juneau.rest.RestResponse}:
			<ul>
				<li><c>RestResponse.sendRedirect(CharSequence)</c>
			</ul>
		</li>
		<li>
			New methods on <del>RestServlet</del>that allow easier customization by subclasses:
			<ul>
				<li><del>RestServlet.createConfigFactory()</del></li>
				<li><del>RestServlet.createConverters()</del></li>
				<li><del>RestServlet.createDefaultRequestHeaders()</del></li>
				<li><del>RestServlet.createDefaultResponseHeaders()</del></li>
				<li><del>RestServlet.createEncoders()</del></li>
				<li><del>RestServlet.createFilters()</del></li>
				<li><del>RestServlet.createGuards()</del></li>
				<li><del>RestServlet.createMimetypesFileTypeMap()</del></li>
				<li><del>RestServlet.createParsers()</del></li>
				<li><del>RestServlet.createProperties()</del></li>
				<li><del>RestServlet.createRequestProperties(ObjectMap,RestRequest)</del></li>
				<li><del>RestServlet.createRequestVarResolver(RestRequest)</del></li>
				<li><del>RestServlet.createSerializers()</del></li>
				<li><del>RestServlet.createUrlEncodingParser()</del></li>
			</ul>
		</li>
		<li>
			Changed <c>RestServletNls</c> to use <c>ResourceDescription/MethodDescription</c>
				instead of <c>RestResource/RestMethod</c>
		</li>
		<li>
			New property <c>RestServletProperties.REST_htDocsFolder</c>.<br>
			New support for serving up static documents from classpath through REST interface.
		</li>
		<li>
			Exception APIs now use {@link java.text.MessageFormat} (e.g. <js>"{0}"</js>) for message variables instead of <js>"%s"</js>.
		</li>
		<li>
			New {@link org.apache.juneau.annotation.Bean#stopClass @Bean.stopClass} annotation for specifying stop classes for bean properties.
		</li>
		<li>
			New <del>BeanFilter.setStopClass(Class)</del>which is the program equivalent to the annotation above.
		</li>
		<li>
			New methods on {@link org.apache.juneau.dto.ResultSetList}:
			<ul>
				<li><c>ResultSetList.handleBlob(Blob)</c></li>
				<li><c>ResultSetList.handleClob(Clob)</c></li>
			</ul>
	</ul>	
</div>
</div><!-- END: 5.0.0.34 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.35' id='5.0.0.35'>5.0.0.35 (Nov 26, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.35 -->
<div class='topic'>
	<p>
		Juno 5.0.0.35 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li><del>RestGuard.guard(RestRequest,RestResponse)</del>now returns a boolean to allow redirects to login pages.
		<li>Fixed bug in RestServlet where occasional false positive "duplicate method with same name and path" errors were occurring.
	</ul>	
</div>
</div><!-- END: 5.0.0.35 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.0.0.36' id='5.0.0.36'>5.0.0.36 (Dec 18, 2013)</a></h3>
<div class='topic'><!-- START: 5.0.0.36 -->
<div class='topic'>
	<p>
		Juno 5.0.0.36 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>Implemented <c>org.apache.juneau.urlencoding.UrlEncodingParser.parseArgs(Reader,int,ClassMeta[])</c>.
		<li><c>name</c> parameter of <del>ResourceDescription.ResourceDescription(String,String,String)</del>. 
			is now automatically URL-encoded so that the name can contain special characters (e.g. <js>"foo/bar(baz)"</js>).
		<li>Support for URL-matching and path info containing encoded characters (e.g. <js>'/'</js>) now supported.	
		<li>Removed some lazy-initialization of bean information in {@link org.apache.juneau.ClassMeta} that allowed the removal of
			some synchronized blocks.
		<li>Improved support of <del>BeanContext.getClassMetaFromString(String)</del>.
			Now supports primitive arrays such as <js>"long[]"</js> in addition to the previous support for the equivalent <js>"[J"</js>.
		<li>Various new convenience methods added to <del>StringUtils</del> and <del>ClassUtils</del>.
	</ul>	
</div>
</div><!-- END: 5.0.0.36 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.0' id='5.1.0.0'>5.1.0.0 (Jan 18, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.0 -->
<div class='topic'>
	<p>
		Juno 5.1.0.0 is a major update.
	</p>
	<h5 class='topic w800'>Major changes</h5>
	<ul class='spaced-list'>
		<li>Brand new REST client API that uses Apache HttpClient for HTTP communication.<br>
			The new client API is simply a thin layer on top of <c>HttpClient</c> that performs 
			serialization and parsing using Juno parsers but leaves all the details of the HTTP connection
			to the Apache code. <br>
			See the <del>client</del> package for details.
		<li>New <c>org.apache.juneau.rest.client.jazz</c> package and <c>org.apache.juneau.rest.client.jazz.JazzRestClient</c> class
			for performing REST operations against Jazz servers.<br>
			Includes improved support for FORM authentication, and better SSL certificate validation.
		<li>Completely redesigned URL-Encoding support.<br>
			See <del>urlencoding</del> package for details. 
		<li>Changes to Parser API.
		<ul>
			<li>Removal of <c>ExtendedReaderParser</c> abstract class and moved methods into 
				{@link org.apache.juneau.parser.ReaderParser} class.  
			<li>Removal of <c>DataFormat</c> class from API since it was no longer necessary
				due to API change above.
			<li>Removal of <c>ParserStringReader</c> class.<br>
				This was a reader optimized to work with <c>String</c> input.<br>
				However, it could interfere with garbage collection of the original string object.<br>
				Instead, the existing {@link org.apache.juneau.parser.ParserReader} was enhanced to work
				well with <c>String</c> input, and tests show no significant performance differences.
			<li>New <c>org.apache.juneau.parser.Parser.parse(Object,int,ClassMeta)</c> convenience method added.
		</ul>
	</ul>	
	<h5 class='topic w800'>Other changes</h5>
	<ul class='spaced-list'>
		<li>Various new methods added to <del>StringUtils</del> and <del>ClassUtils</del>.
		<li>Improved support on <del>BeanContext.getClassMetaFromString(String)</del>.<br>
			Now supports resolving <c>"long[]"</c>, and so forth.
		<li><del>ResourceDescription</del>name parameter is now automatically URL-encoded in links.
		<li>{@link org.apache.juneau.rest.RestRequest} now correctly handles cases involving URL-encoded characters in the 
			path info portion of URLs (e.g. <c>http://host/contextRoot/foo%2Fbar</c>).
		<li>Removed lazy-initialization that required locking in {@link org.apache.juneau.ClassMeta}.  
		<li>New <c>BeanContext.setDefaultParser(ReaderParser)</c> method added for specifying 
			a default parser to use in a bean context (used when converting beans to <c>Strings</c> using 
			<del>BeanContext.convertToType(Object,Class)</del>.
			Old behavior simply used the default JSON serializer in these cases.
		<li>More consistent handling of exceptions across all parsers.
		<li>Minor changes to {@link org.apache.juneau.rest.RestRequest} class.
		<ul>
			<li>Changed the order of parameters on <del>RestRequest.getParameter(String,Class)</del>.
			<li>Added <c>RestRequest.getMapParameter(String,Class,Class,Class)</c> and 
				<c>RestRequest.getCollectionParameter(String,Class,Class)}</c> methods.
		</ul>
	</ul>
</div>
</div><!-- END: 5.1.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.1' id='5.1.0.1'>5.1.0.1 (Jan 25, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.1 -->
<div class='topic'>
	<p>
		Juno 5.1.0.1 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>Addressed some behavioral differences between Tomcat and WAS.  
		<ul>
			<li>Query parameter lookup is now always case-insensitive (per WAS behavior).
			<li>Consistent handling of redirect requests (Tomcat and WAS handle relative redirect paths differently).
		</ul>
		<li>Fixed bug involving incorrect resolution of overlapping URL match patterns.
		<li>Overall improvements in HTTP request parameter and header value resolution.  
		<li>Made workspace changes so as not to be dependent on the WAS test environment being loaded.
		<li>Renamed <ja>@Remainder</ja> annotation to <del>@PathRemainder</del>.
		<li>Fixed bug involving incorrect calculation of <c>pathInfo</c> on child resources.
	</ul>	
</div>
</div><!-- END: 5.1.0.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.2' id='5.1.0.2'>5.1.0.2 (Apr 27, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.2 -->
<div class='topic'>
	<p>
		Juno 5.1.0.2 is a minor update.
	</p>
	<ul class='spaced-list'>
		<li>Fixed issue preventing <c>&amp;Accept-Language</c> from being used as a GET parameter.  
		<li>Minor XSS vulnerability fix.
		<li>Empty results on HTML pages now shows <js>"no results"</js> instead of a blank page.
		<li>Fixed issues preventing REST pages from rendering HTML in newer versions of Internet Explorer.
		<li>Changed <c>RestServletProperties.REST_allowMethodParam</c> to be disabled by default.  
	</ul>
</div>
</div><!-- END: 5.1.0.2 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.3' id='5.1.0.3'>5.1.0.3 (Jun 28, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.3 -->
<div class='topic'>
	<p>
		Juno 5.1.0.3 is a moderate update.
	</p>
	
	<h5 class='topic w800'>Core API updates</h5>
	<ul class='spaced-list'>
		<li>Ability to detect and use non-public bean classes, getters/setters, and fields using the following new properties:
			<ul>
				<li><del>BeanContext.BEAN_beanConstructorVisibility</del>- Control which bean constructors are visible to Juno.
				<li><del>BeanContext.BEAN_beanClassVisibility</del>- Control which bean classes are interpreted as beans to Juno.
				<li><del>BeanContext.BEAN_beanFieldVisibility</del>- Control which fields are visible to Juno as bean properties.
				<li><del>BeanContext.BEAN_beanMethodVisibility</del>- Control which getters/setters are visible to Juno as bean properties.
			</ul>
			Removed <c>BeanContext.<jsf>INCLUDE_BEAN_FIELD_PROPERTIES</jsf></c> and <c>BeanContext.<jsf>INCLUDE_BEAN_METHOD_PROPERTIES</jsf></c> properties, since ignoring fields and methods
			can be accomplished by setting the appropriate properties above to {@link org.apache.juneau.Visibility#NONE NONE}.
			Also, the <del>@BeanProperty</del> annotation can now be used on non-public fields/getters/setters to override
			the default behavior defined by the <c>VISIBILITY</c> properties identified above.  This is a convenient way of identifying protected or
			private fields or methods as bean properties.  Previously, you could only identify public fields/getters/setters using this annotation.
		</li>
		<li>New <del>BeanContext.BEAN_useJavaBeanIntrospector</del> property that lets Juno use the Java bean <c>Introspector</c>
			class to determine bean properties.  In the previous release, the method for determining bean properties was a mixture of Juno-based and Introspector-based.
			Now it's either pure Juno-based or pure Introspector-based.  The result is considerably cleaner code and consistent behavior.
		<li>New {@link org.apache.juneau.annotation.BeanIgnore @BeanIgnore} annotation.  Replaces the previous <del>@BeanProperty(hidden=true)</del>annotation
			for ignoring bean properties.  Can also be used on classes that look like beans so that they're not treated as beans.
		<li>Support for parsing into non-static member classes.  This applies to all parsers.
		<li>New {@link org.apache.juneau.json.annotation.Json#wrapperAttr() @Json(wrapperAttr)}	annotation that automatically wraps beans and objects in a wrapper
			attribute when serializing to or parsing from JSON.
		<li>Changed the default ordering of bean properties to be in parent-to-child class order.
		<li>New <del>BeanFilter.readProperty(Object,String,Object) readProperty()</del>and <del>BeanFilter.writeProperty(Object,String,Object) writeProperty()</del>
			methods added to <del>BeanFilter</del>class to allow individualized serialization and parsing behavior on a class-by-class basis.
		<li>Eliminated previous restriction where bean subtype attributes had to be listed first in JSON objects when using the <del>Bean.subTypeProperty()</del>annotation.
			The previous behavior was not strictly JSON-compliant since JSON objects are supposed to consist of unordered lists of key/value pairs.
			While targeted for JSON, the restriction is also lifted for all other parsers.  	
		<li>New fluent-style {@link org.apache.juneau.BeanMap#load(String) BeanMap.load()} methods for initializing bean maps.
		<li>{@link org.apache.juneau.html.HtmlDocSerializer} will now embed the data portion of the output in a <c><xt>&lt;div</xt> <xa>id</xa>=<xs>'data'</xs><xt>&gt;</xt></c> element to make it easier to extract the data portion of the page in Javascript in browsers.
	</ul>
	
	<h5 class='topic w800'>REST Server API updates</h5>
	<ul class='spaced-list'>
		<li>New <del>RestRequest.getJavaMethod()</del>method for getting access to the method used to handle a request.
			Useful for accessing the method name or annotations during requests, such as in calls to <del>RestGuard.guard(RestRequest,RestResponse)</del>.
		<li>Fixed bug when using Jetty where you tried to read text input after a header was written.
		<li>Added new string variables <dc>$A{...}</dc> (request attributes) and <dc>$P{...}</dc> (request parameters) to <c>RestServlet.createRequestVarResolver(RestRequest)</c>.
	</ul>
</div>
</div><!-- END: 5.1.0.3 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.4' id='5.1.0.4'>5.1.0.4 (Aug 25, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.4 -->
<div class='topic'>
	<p>
		Juno 5.1.0.4 is a minor update.
	</p>
	
	<ul class='spaced-list'>
		<li>New <del>RestServlet.getPath()</del> method.
		<li>New <c>SerializerContext.getJavaMethod()</c> and <c>ParserContext.getJavaMethod()</c>
				to allow access to REST methods that invoked the serializers or parsers.
			For example, can be used to access additional annotations on REST methods to perform special handing
				during serialization or parsing.
		<li>Better behavior on overriding of filters in <c>BeanContext.addTransforms(Class[])</c>.
			Previously, adding multiple conflicting filters resulted in random behavior.  
			Now filters are overridden when multiple matching filters are applied.
		<li>Allow <del>HtmlDocSerializerContext</del>properties to be set via <del>Serializer.setProperty(String,Object)</del>.
			Previously, these could only be defined through override properties (e.g. through REST class and method annotations).
		<li>Fixed memory leak in XML parser.	
	</ul>
</div>
</div><!-- END: 5.1.0.4 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.5' id='5.1.0.5'>5.1.0.5 (Sept 1, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.5 -->
<div class='topic'>
	<p>
		Juno 5.1.0.5 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>New <del>Redirect</del> class that simplifies performing redirections in REST methods.
		<li>New pluggable <del>ResponseHandler</del> class and <del>@RestResource(responseHandlers)</del> annotation
			for defining customer response handlers for special kinds of POJOs.
		<li>New method <del>UrlEncodingSerializer.serializeUrlPart(Object)</del>method.
		<li>New method <del>RestRequest.getServletURIBuilder()</del>for construcing servlet-based URLs more efficiently.
		<li>New method {@link org.apache.juneau.rest.RestResponse#getNegotiatedOutputStream()} that uses encoders if a match is found, 
			and {@link org.apache.juneau.rest.RestResponse#getOutputStream()} that just return the underlying output stream without any modifications.
		<li>Fixed bug where some properties were not being propagated correctly when using <del>CoreObject.setProperties(ObjectMap)</del>
			on serializer and parser subclasses.
		<li>Fixed bug in {@link org.apache.juneau.html.HtmlSerializer} where URL keys in Maps were not being serialized as hyperlinks.
		<li>Fixed bug in {@link org.apache.juneau.json.JsonSerializer} where <js>"_class"</js> and <js>"items"</js> attributes were not quoted in strict mode when using SERIALIZER_addClassAttrs feature.	
		<li>Fixed bug where <c>Content-Encoding</c> and<c>Character-Encoding</c> headers were being set when calling {@link org.apache.juneau.rest.RestResponse#getOutputStream()}.
			These should not be set if interacting with the output streams at a low level.
		<li>Eliminated various convenience <c>RestResponse.sendRedirect(...)</c> methods due to the introduction of the <del>Redirect</del> class.
	</ul>
</div>
</div><!-- END: 5.1.0.5 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.6' id='5.1.0.6'>5.1.0.6 (Sept 21, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.6 -->
<div class='topic'>
	<p>
		Juno 5.1.0.6 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>Simplified API for <del>PojoSwap</del>.  
			Since it's rarely used, the <c>beanContext</c> parameter was replaced with a <del>PojoSwap.getBeanContext()</del> method on
			the class.
		<li>New simplified way of defining POJO filters without needing to extend <del>PojoSwap</del>.
			See <del>SurrogateSwap</del> for details.
		<li>New {@link org.apache.juneau.html.annotation.Html @Html} annotation.
			Will allow the definition of standard XHTML DTOs in future releases.  
			For now, <del>Img</del>is an example of defining an XHTML element using Juno DTOs.
		<li>{@link org.apache.juneau.json.JsonParser} now ignores trailing <c>';'</c> characters in input so that it can 
			parse strings of the form <js>"var x = {'foo':'bar'};"</js>.
		<li>New <c>TumblrParserResource</c> in the samples war file showing how to combine the REST client and server APIs into a single
			resource in order to download Tumblr blogs and convert the response into any supported response content type.
	</ul>
</div>
</div><!-- END: 5.1.0.6 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.7' id='5.1.0.7'>5.1.0.7 (Oct 5, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.7 -->
<div class='topic'>
	<p>
		Juno 5.1.0.7 is a moderate update.
	</p>
	<ul class='spaced-list'>
		<li>Improved error handling.  
		<li>New <del>ParserContext.PARSER_debug</del>and <del>SerializerContext.SERIALIZER_debug</del>.
			settings for logging additional information for debugging problems.
		<li>New <del>SERIALIZER_ignoreRecursions</del> setting for explicitly ignoring recursions when 
			serializing models.  Previously, the <jsf>SERIALIZER_detectRecursions</jsf> setting did this but now it simply looks for recursions 
			and throws exceptions when they occur.
		<li>Improved handling of <c>StackOverflowErrors</c>.  When <jsf>SERIALIZER_detectRecursions</jsf> is enabled, a useful error message
			is displayed showing the exact chain of objects that resulted in the stack overflow.
		<li>Bug fixes in {@link org.apache.juneau.dto.ResultSetList} for Oracle and SQL Server.
		<li>Serializers and parsers can now access HTTP request attributes, parameters, and headers through <c>SerializerContext.getProperties()</c> and
			<c>ParserContext.getProperties()</c>.		
		<li>Removed media-type and encoding attributes from <del>SerializerContext</del> and <del>ParserContext</del>	
			since these are now available through context properties, and are typically not used.
		<li>{@link org.apache.juneau.xml.XmlParser} now accepts <c>application/xml</c>.		
		<li>Improved handling of bean property serialization when multiple matching pojo filters for the bean property class exist.
		<li>Improved concurrency on BeanContext class.
		<li>Fixed bug in <del>Traversable</del> that was causing it to be executed even if the servlet extra path info was empty.
		<li>Fixed bug in <del>Traversable</del>where it was not picking up filters and properties defined on REST Java methods. 
	</ul>
</div>
</div><!-- END: 5.1.0.7 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.8' id='5.1.0.8'>5.1.0.8 (Oct 25, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.8 -->
<div class='topic'>
	<p>
		Juno 5.1.0.8 is a moderate update, focused primarily on performance improvements.
	</p>
	<ul class='spaced-list'>
		<li>Improved performance on JSON and URL-Encoding parsers by approximately 50% on large data sets. 
			<ul>
				<li>Rewrote {@link org.apache.juneau.parser.ParserReader} class to handle it's own buffering.
					The change allowed several optimizations to be made when dealing with JSON and URL-Encoding
					text by avoiding char array copies.  
				<li>Added a <c>estimatedSize</c> parameter to the {@link org.apache.juneau.parser.Parser} parse methods to 
					optimize buffering when the input size is known beforehand.
			</ul>
		</li>
		<li>Revamped the {@link org.apache.juneau.BeanContext} API to perform better in multi-threaded environments.
			<ul>
				<li>Introduced a new <c>BeanPropertyStore</c> class that handles creation of {@link org.apache.juneau.BeanContext} objects.
					This allows <c>BeanContext</c> objects to be considered immutable, and therefore cacheable/reusable by the framework.
					While this was technically possible to cache these objects beforehand, it relied on a locking mechanism to prevent bean contexts
						from being modified after being created.  The new mechanism is much more straightforward.
			</ul>
		</li>
		<li>Modifications to the <del>client</del> APIs to make it easier to work with custom Apache HTTP clients.
			<ul>
				<li>Added overridable <del>RestClient.createHttpClient()</del>to allow customized subclasses to construct customized HTTP clients.
				<li>Removed the <c>DefaultRestClient</c> class since it's now fully redundant with <c>RestClient</c>.
				<li>Added <c>RestClient.shutdown()</c> method for cleaning up the internal HTTP client when you're done using a REST client.
			</ul>
		</li>
	</ul>
</div>
</div><!-- END: 5.1.0.8 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.9' id='5.1.0.9'>5.1.0.9 (Dec 1, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.9 -->
<div class='topic'>
	<p>
		Juno 5.1.0.9 is a major update.
		There weren't very many code changes but the source has been made a part of Jazz Foundation.
		This required some restructuring of the project.
		The project on Jazz Hub will eventually be discontinued.
		However, the libraries on IBM Community Source will continue to be updated regularly.
	</p>
	<ul class='spaced-list'>
		<li>Project split up into 3 separate bundles:
			<ul>
				<li><c>org.apache.juneau</c> - Core serializers and parsers.
				<li><c>org.apache.juneau.rest</c> - REST server component.
				<li><c>org.apache.juneau.rest.client</c> - REST client component.
			</ul>
		<li>Code changes to facilitate breaking up bundles:
			<ul>
				<li><c>org.apache.juneau.rest.labels.Link</c> class moved to <del>Link</del>.
				<li>References to <c>org.apache.juneau.rest.RestException</c> in {@link org.apache.juneau.encoders.Encoder} class changed to <c>IOException</c>.
			</ul>
		<li>Changed configuration names for consistency with Jazz Framework.
		<li><del>RestClient.execute(HttpUriRequest)</del>method that allows subclasses to handle their own HTTP request execution.
		<li>Changes in <c>JazzRestClient</c> to handle introduction of SSO support in v6.
		<li><c>&amp;plainText</c> debug feature was broken.
		<li>Removed double-buffering in <c>RestRequest</c>.
		<li>Metadata cleanup, Find Bug fixes.
	</ul>
</div>
</div><!-- END: 5.1.0.9 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.10' id='5.1.0.10'>5.1.0.10 (Dec 23, 2014)</a></h3>
<div class='topic'><!-- START: 5.1.0.10 -->
<div class='topic'>
	<p>
		Juno 5.1.0.10 is a moderate update.
	</p>
	
	<h5 class='topic w800'>Core</h5>		
	<ul class='spaced-list'>
		<li>Major changes to URL-Encoded serializer and parser.
			<ul>
				<li>Logic for serializing and parsing URL-Encoded key-value pairs moved to {@link org.apache.juneau.urlencoding.UrlEncodingSerializer} and {@link org.apache.juneau.urlencoding.UrlEncodingParser} classes.
				<li>Logic for serializing and parsing URL-Encoded values moved to new {@link org.apache.juneau.uon.UonSerializer} and {@link org.apache.juneau.uon.UonParser} classes.
			</ul>
		</li>
		<li>Fix bug where <c>BeanRuntimeExceptions</c> weren't being thrown on subsequent calls to {@link org.apache.juneau.BeanContext#getClassMeta(Class)}.
		<li>Moved logic for <c>BeanContext.getPrimitiveDefault(Class)</c> to new {@link org.apache.juneau.ClassMeta#getPrimitiveDefault()} method for performance reasons.
		<li>Fixed bug in <del>BeanContext.addTransforms(Class[])</del>that would cause filter order to get messed up.
		<li>{@link org.apache.juneau.ClassMeta#newInstance()} can now create array instances.
		<li>Fixed indentation bugs in {@link org.apache.juneau.html.HtmlSerializer}.
		<li>Fixed issue in {@link org.apache.juneau.html.HtmlSerializer} where newlines were not being converted into line breaks.
		<li>New {@link org.apache.juneau.serializer.WriterSerializer#toString(Object)} method that's identical to the serialize method but throws <c>RuntimeExceptions</c> to make the serializer easier to use for debugging.
	</ul>
	
	<h5 class='topic w800'>Server</h5>		
	<ul class='spaced-list'>
		<li>Fixed major issue that prevented parsing URL-Encoded form posts into POJOs.
			Calling <del>HttpServlet.getParameter(String)</del>was forcing the underlying servlet code to process the HTTP body itself, preventing the <c>UrlEncodingSerializer</c>
			class from being able to parse the content.  Updated code no longer inadvertantly calls this method.
		<li>New <del>RestRequest.getQueryParameter(String)</del>, <del>RestRequest.hasQueryParameter(String)</del>, and <del>RestRequest.hasAnyQueryParameters(String[])</del>
			methods that only look for parameters in the URL query string to prevent loading and parsing of URL-Encoded form posts.
		<li>New <del>@QParam</del> and <del>@HasQParam</del>annotations for accessing query parameters from the URL query string.
		<li><c>&amp;plainText</c> parameter can now specify a false value.
		<li>Removed properties parameters from <del>RestServlet.onPreCall(RestRequest)</del>and <del>RestServlet.onPostCall(RestRequest,RestResponse)</del> methods
			since the properties are already accessible through <c>RestRequest.getProperties()</c>.
		<li>Added {@link org.apache.juneau.uon.UonSerializer} and {@link org.apache.juneau.uon.UonParser} to serializer and parser lists on 
			<del>BasicRestServlet</del>and <del>RestServletJenaDefault</del>.
	</ul>
	
	<h5 class='topic w800'>Client</h5>		
	<ul class='spaced-list'>
		<li>Moved to Apache HttpClient 4.3 to match Jazz 6.0.
		<li>Renamed <c>RestResponseEntity</c> to <del>RestRequestEntity</del>.
		<li>Improved performance on URL-Encoded form posts by serializing directly to output stream instead of serialized to string first.
		<li>New methods on {@link org.apache.juneau.rest.client.RestClient} class that makes it easier to associate serializer and parser attributes with registered serializer and parser:
			<ul>
				<li><del>RestClient.setProperty(String,Object)</del>			
				<li><del>RestClient.setProperties(ObjectMap)</del>	
				<li><del>RestClient.addNotBeanClasses(Class[])</del>		
				<li><del>RestClient.addTransforms(Class[])</del>		
				<li><del>RestClient.addImplClass(Class,Class)</del>	
			</ul>
		<li>Renamed <c>RestClient.shutdown()</c> to {@link org.apache.juneau.rest.client.RestClient#close()} to mirror change in Apache API.		
	</ul>
	
	<h5 class='topic w800'>Samples</h5>		
	<ul class='spaced-list'>
		<li>New <c>CodeFormatterResource</c> for quickly formatting Java and XML code samples in Javadocs.
		<li>New <c>UrlEncodedFormResource</c> for showing how to work with URL-Encoded form posts.
	</ul>
</div>
</div><!-- END: 5.1.0.10 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.11' id='5.1.0.11'>5.1.0.11 (Feb 14, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.11 -->
<div class='topic'>
	<p>
		Juno 5.1.0.11 is a moderate update.
	</p>
	
	<h5 class='topic w800'>Core</h5>		
	<ul class='spaced-list'>
		<li>Additions to {@link org.apache.juneau.html.annotation.Html @Html} bean annotation.
			<ul>
				<li>New {@link org.apache.juneau.html.annotation.Html#noTables() @Html(noTables)} annotation that prevents
					arrays/Collections from being serialized as tables.
				<li>New {@link org.apache.juneau.html.annotation.Html#noTableHeaders() @Html(noTableHeaders)} annotation that prevents
					HTML tables from having header rows.
			</ul>
		</li>
		<li>Several improvements to URL-Encoding support.
			<ul>
				<li>Improved whitespace handling in {@link org.apache.juneau.uon.UonParser}.
				<li>New <del>UonParserContext.UON_whitespaceAware</del>property for controlling whether whitespace is ignored.
				<li>New <del>UrlEncodingContext.URLENC_expandedParams</del>property for controlling whether arrays/Collections 
					should be serialized/parsed as multi-part parameters.
				<li>New {@link org.apache.juneau.urlencoding.annotation.UrlEncoding#expandedParams() @UrlEncoding(expandedParams)}
					annotation that specifies that bean properties of type array/Collection be serialized as multi-part parameters (e.g. <c>&amp;key=val1&amp;key=val2</c>).
			</ul>
		</li>
		<li>New <del>JsonSerializerContext.JSON_escapeSolidus</del> property for controlling whether slash characters should be escaped.
		<li>New <del>TeeOutputStream</del> and <del>TeeWriter</del>classes.
		<li>New {@link org.apache.juneau.ClassMeta#isInstance(Object)} method.
		<li>Performance improvements when using the {@link org.apache.juneau.BeanMap#add(String,Object)} method.  
			Array properties are stored in a temporary list cache until {@link org.apache.juneau.BeanMap#getBean()} is called.
		<li>New <del>BeanPropertyMeta.add(BeanMap,Object)</del> method for adding values to Collection and array properties.
		<li>Config INI files now support keys with name <js>"*"</js>.
	</ul>
	
	<h5 class='topic w800'>Server</h5>		
	<ul class='spaced-list'>
		<li>REST method parameters can now be generic types (e.g. <dc><ja>@Param</ja>(<js>"foo"</js>) Map&lt;String,Integer&gt; foo</dc>).
			This applies to headers, attributes, and parameters.
		<li>New <del>@Param(multipart)</del>
			and <del>@Query(multipart)</del>annotations
			for handling multi-part GET and POST parameters.	
		<li>GET parameters are now CASE-SENSITIVE per W3C standards.
			<ul>
				<li>
				<li><c>&amp;Content</c> must now be specified as <c>&amp;content</c>.
				<li><c>&amp;Method</c> must now be specified as <c>&amp;method</c>.
				<li><c>&amp;debug</c> must now be specified as <c>&amp;debug=true</c>.
				<li><c>&amp;plainText</c> must now be specified as <c>&amp;plainText=true</c>.
				<li><c>&amp;notrace</c> must now be specified as <c>&amp;noTrace=true</c>.
			</ul>
		</li>
		<li>Performance improvements around query parameters.
		<li>New methods on {@link org.apache.juneau.rest.RestRequest} for handling multi-part parameters:
			<ul>
				<li><del>RestRequest.getParameters(String,Class)</del>
				<li><del>RestRequest.getQueryParameters(String,Class)</del>
			</ul>
		</li>
		<li>Fixed Jetty issue in {@link org.apache.juneau.rest.RestResponse#setHeader(String,String)} where setting 
			the <c>Content-Type</c> through this method was inconsistent with the behavior in WAS/Tomcat.
		<li><c>&amp;noTrace=true</c> now prevents any errors from being logged in log file.
		<li>Workaround for Jetty issue where <c>ServletContext.getContextPath()</c> always ends with <js>"null"</js>.
		<li><c>RestServletProperties.REST_allowMethodParam</c> is now <jk>true</jk> by default on all subclasses 
			of <del>BasicRestServlet</del> and <del>RestServletJenaDefault</del>.
	</ul>
			
	<h5 class='topic w800'>Client</h5>		
	<ul class='spaced-list'>
		<li>New method <del>RestCall.allowRedirectsOnPosts(boolean)</del>.
		<li>New method <c>RestCall.peekInputStream()</c> allows you to read response bodies without interrupting execution flow.
		<li>New method <del>RestCall.toString()</del> now useful for debugging purposes.  
			Shows all request/response headers and bodies.
		<li><del>RestCallException</del>now includes <c>HttpResponse</c> object for easier debugging.
		<li>New method <c>RestClient.addListener(RestClientListener)</c> for registering request/response listeners.
		<li>New <del>RestClient.setClassLoader(ClassLoader)</del>method.
		<li>TLS support in <c>JazzRestClient</c>.
	</ul>
	
	<h5 class='topic w800'>Other changes</h5>	
	<ul class='spaced-list'>
		<li><c>samples.ear</c> and <c>samples.war</c> projects
			have been replaced with an OSGi bundle with activated servlets in <c>juno.samples</c>.
	</ul>
</div>
</div><!-- END: 5.1.0.11 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.12' id='5.1.0.12'>5.1.0.12 (Mar 28, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.12 -->
<div class='topic'>
	<p>
		Juno 5.1.0.12 is a minor update.
	</p>
	
	<h5 class='topic w800'>Core</h5>		
	<ul class='spaced-list'>
		<li>Fixed <del>ConfigFile.isEmpty()</del>method.
		<li>Changed behavior on {@link org.apache.juneau.uon.UonParser} to not treat <js>'~'</js> characters as escapes
			unless followed by one of the following characters:  <c>( ) , $ = ~</c>.
	</ul>
	
	<h5 class='topic w800'>Client</h5>		
	<ul class='spaced-list'>
		<li>New class <del>RestCallInterceptor</del>.  
			Allows responses to be inspected and modified before being processed.  
			Replaces <c>RestClientListener</c> class.
		<li>Minor connection cleanup fixes.
	</ul>
</div>
</div><!-- END: 5.1.0.12 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.13' id='5.1.0.13'>5.1.0.13 (Apr 24, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.13 -->
<div class='topic'>
	<p>
		Juno 5.1.0.13 is a minor update.
	</p>
	
	<h5 class='topic w800'>Core</h5>		
	<ul class='spaced-list'>
		<li>{@link org.apache.juneau.ClassMeta#newInstance()} method can now create new instances of arrays.
		<li>Arguments passed to <del>Link</del> are now serialized using {@link org.apache.juneau.urlencoding.UrlEncodingSerializer}, so arbitrary POJOs can now be passed as arguments.
		<li>New date filters:  <c>org.apache.juneau.swaps.Datefilter.ISO8601DTZP</c> and <c>org.apache.juneau.swaps.Datefilter.SimpleP</c>.
		<li>New <del>HtmlDocSerializerContext.HTMLDOC_nowrap</del>setting for {@link org.apache.juneau.html.HtmlDocSerializer} class.  
			Adds <js>"* {white-space:nowrap}"</js> to the style header to prevent word wrapping.
		<li>Fixed bug in {@link org.apache.juneau.uon.UonParser} where passing in a blank value on an array or collection type in a form post would cause a <c>ClassCastException</c>.  
			New behavior creates an empty array or <c>Collection</c>.
		<li>Improved implementation of <del>UrlEncodingSerializer.serializeUrlPart(Object)</del> method.
	</ul>
	
	<h5 class='topic w800'>Server</h5>		
	<ul class='spaced-list'>
		<li><del>RestConverter</del> API fixed to handle the existence of POJO filters.
			<del>Introspectable</del>/<del>Queryable</del>/<del>Traversable</del> classes can now work with filtered POJOs.  
		<li><del>@RestResource(messages)</del>annotation can now be defined on super and subclasses so that NLS messages can be defined in multiple resource bundles.
		<li>Performance improvements in <c>RestServletNls</c> class. 
		<li>Fixed bug where two REST java methods mapped to the same path pattern wasn't triggering an exception when it was supposed to.
	</ul>
	
	<h5 class='topic w800'>Client</h5>		
	<ul class='spaced-list'>	
		<li>New <del>RestCall.setRedirectMaxAttempts(int)</del>method to prevent endless redirection loops.
		<li>New <del>RestCall.setRetryable(int,long,RetryOn)</del>method to automatically retry on failed connection attempts.
		<li>New <c>RestCallInterceptor.onRetry(RestCall,int,HttpRequest,HttpResponse)</c> method for listening in on retry attempts.		
	</ul>
</div>
</div><!-- END: 5.1.0.13 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.14' id='5.1.0.14'>5.1.0.14 (May 10, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.14 -->
<div class='topic'>
	<p>
		Juno 5.1.0.14 is a moderate update.
	</p>
	<p>
		The major addition is support for <dc>Remoteable Services</dc>, the ability
			to invoke server-side POJO methods through client-side proxy interfaces.
	</p>
	
	<h5 class='topic w800'>Core</h5>		
	<ul class='spaced-list'>
		<li>Simplified <del>PojoIntrospector</del> class.
		<li>New <del>ClassUtils.getMethodSignature(Method)</del>method.
	</ul>
	
	<h5 class='topic w800'>Client</h5>		
	<ul class='spaced-list'>
		<li>New methods in {@link org.apache.juneau.rest.client.RestClient} for working with remoteable services:
		<ul>
			<li><del>RestClient.setRemoteableServletUri(String)</del>
			<li><del>RestClient.getRemoteableProxy(Class)</del>
		</ul>
	</ul>
	
	<h5 class='topic w800'>Server</h5>		
	<ul class='spaced-list'>
		<li>Added a default OPTIONS page to <del>BasicRestServlet</del>and <del>RestServletJenaDefault</del>.
		<li><c>RestServletProperties.REST_allowMethodParam</c> has been enhanced to allow you to
			explicitly specify which HTTP methods can be used in the <c>&amp;method</c> parameter.
		<li>New methods added to {@link org.apache.juneau.rest.RestRequest}:
		<ul>
			<li><del>RestRequest.getParser()</del>
			<li><del>RestRequest.getReaderParser()</del>
		</ul>
	</ul>
</div>
</div><!-- END: 5.1.0.14 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.15' id='5.1.0.15'>5.1.0.15 (May 24, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.15 -->
<div class='topic'>
	<p>
		Juno 5.1.0.15 is a minor update.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>New properties in <del>SerializerContext</del>:
			<ol>
				<li><del>SerializerContext.SERIALIZER_relativeUriBase</del>
				<li><del>SerializerContext.SERIALIZER_absolutePathUriBase</del>
			</ol>
			These replace the <c>SERIALIZER_uriAuthority</c> and <c>SERIALIZER_uriContext</c> properties.
		</li>
		<li>Improvements in {@link org.apache.juneau.csv.CsvSerializer}.
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New properties in <c>RestServletProperties</c>:
			<ol>
				<li><c>REST_defaultCharset</c>
				<li><c>REST_servletURI</c>
				<li><c>REST_relativeServletURI</c>
			</ol>
		<li>Improvements involving path calculations when servlets deployed outside of a war file with a context root.
	</ul>
	
	<h5 class='topic w800'>Client</h5>
	<ul class='spaced-list'>
		<li>New methods in <del>RestCall</del>:
			<ol>
				<li><del>RestRequest.getHeader(String,Class)</del>
				<li><del>RestRequest.getHeader(String,Object,Class)</del>
				<li><del>RestRequest.getHeader(String,Type,Type...)</del>
				<li><del>RestRequest.getQueryParameter(String,Class)</del>
				<li><del>RestRequest.getQueryParameter(String,Object,Class)</del>
				<li><del>RestRequest.getQueryParameter(String,Type,Type...)</del>
				<li><del>RestRequest.getQueryParameter(String,Object,Type,Type...)</del>
				<li><del>RestRequest.getQueryParameters(String,Class)</del>
				<li><del>RestRequest.getQueryParameters(String,Type,Type...)</del>
				<li><del>RestRequest.getFormDataParameter(String,Class)</del>
				<li><del>RestRequest.getFormDataParameter(String,Object,Class)</del>
				<li><del>RestRequest.getFormDataParameters(String,Class)</del>
				<li><del>RestRequest.getFormDataParameter(String,Type,Type...)</del>
				<li><del>RestRequest.getFormDataParameters(String,Type,Type...)</del>
				<li><del>RestRequest.getPathParameter(String,Class)</del>
				<li><del>RestRequest.getPathParameter(String,Type,Type...)</del>
				<li><del>RestRequest.getBody(Class)</del>
				<li><del> RestRequest.getBody(Type,Type...)</del>
			</ol>
		</li>
	</ul>
</div>
</div><!-- END: 5.1.0.15 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.16' id='5.1.0.16'>5.1.0.16 (June 28, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.16 -->
<div class='topic'>
	<p>
		Juno 5.1.0.16 is a moderate update.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>New methods on {@link org.apache.juneau.ClassMeta} that eliminates language-specific code in 
			the general class metadata.
			<ul>
				<li><del>ClassMeta.getXmlMeta()</del>
				<li><del>ClassMeta.getJsonMeta()</del>
				<li><del>ClassMeta.getHtmlMeta()</del>
				<li><del>ClassMeta.getUrlEncodingMeta()</del>
				<li><del>ClassMeta.getRdfMeta()</del>
			</ul>
		<li>New {@link org.apache.juneau.dto.jsonschema.JsonType#ANY} enum.
		<li>New <del>@Html(asPlainText)</del> annotation.
		<li>New <del>HtmlDocSerializerContext.HTMLDOC_cssImports</del>property.
		<li>Significant changes to RDF support.
			<ul>
				<li>New <del>@Rdf</del> and <del>@RdfSchema</del>
					annotations.  These replace the use of defining namespaced through the XML annotations, and allows XML and RDF to be
					serialized using different namespaces.
				<li>Support for serializing arrays/collections as RDF bags, RDF lists, and multi-valued properties.   
				<li>Fixed warning message about <js>"tab"</js> setting when using the N3/Turtle serializers.
			</ul>
		<li>New <del>SerializerContext.SERIALIZER_sortCollections</del>and 
			<del>SerializerContext.SERIALIZER_sortMaps</del>properties.
		<li>FindBug fixes.
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New <del>RestRequest.getServletParentURI()</del>method.
		<li>New <c>$R{servletParentURI}</c> variable.
		<li>Removed final modifier from <del>ChildResourceDescriptions</del>.
	</ul>
	
	<h5 class='topic w800'>Samples</h5>
	<ul class='spaced-list'>
		<li>Added source code links to examples.
	</ul>
</div>
</div><!-- END: 5.1.0.16 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.17' id='5.1.0.17'>5.1.0.17 (Aug 3, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.17 -->
<div class='topic'>
	<p>
		Juno 5.1.0.17 is a major update.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>{@link org.apache.juneau.BeanMap#get(Object)} and {@link org.apache.juneau.BeanMap#put(String,Object)} now
			automatically performs filtering if filters are defined on the bean property or bean property class.
			<ul>
				<li>Deleted the following methods which are now unnecessary:
					<ul>
						<li><c>BeanMap.getFiltered(String)</c>
						<li><c>BeanMap.putFiltered(String,Object)</c>
						<li><c>BeanMapEntry.getFiltered(String)</c>
						<li><c>BeanMapEntry.putFiltered(String,Object)</c>
						<li><c>BeanMapEntry.putFiltered(String,Object)</c>
						<li><c>BeanPropertyMeta.getFiltered()</c>
						<li><c>BeanPropertyMeta.setFiltered(Object)</c>
						<li><c>BeanPropertyMeta.getTransformedClassMeta()</c>
					</ul>
				<li>{@link org.apache.juneau.BeanPropertyMeta#getClassMeta()} now returns the filtered type of the property.
			</ul> 
		<li><del>StringVarResolver</del> now has support for chained resolvers.
		<li><del>StringVarResolver</del>  now resolves variables inside resolved values.
			i.e. if a resolved variable value itself contains a variable, it now resolves that variable too.
		<li>Fixed bug where inner interface classes being used in <del>RestResource.filters()</del> were being
			interpreted as surrogate classes because they have hidden 1-arg constructors due to being inner classes.
		<li>Fixed bug in {@link org.apache.juneau.internal.MultiSet} where exception was being thrown if last set was empty.
		<li>New <del>ZipFileList</del>class for providing efficiently zipped directories through the REST interface.
		<li>New <c>RdfProperties.RDF_useXmlNamespaces</c> property.			
		<li>New <del>XmlParserContext.XML_preserveRootElement</del> property.
		<li>Worked around bug in Sun VM on OS/X where XML parser was throwing an exception when trying to set a reporter.			
	</ul>
	
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New <del>ZipFileListResponseHandler</del>class.
		<li>Simplified labels in servlet resource bundles:
			<ul>
				<li><c>"[ClassName].ResourceDescription"</c> is now <c>"[ClassName].label"</c>.
				<li><c>"[ClassName].MethodDescription.[methodName]"</c> is now <c>"[ClassName].[methodName]"</c>.
			</ul>
		<li>Several changes to {@link org.apache.juneau.rest.RestRequest}:
			<ul>
				<li>Added new methods:
					<ul>
						<li><del>RestRequest.getQueryParameterMap()</del>
						<li><del>RestRequest.getQueryParameterNames()</del>
						<li><del>RestRequest.getPathInfoUndecoded()</del>
						<li><del>RestRequest.getPathRemainderUndecoded()</del>
						<li><del>RestRequest.getTrimmedRequestURI()</del>
						<li><del>RestRequest.getTrimmedRequestURL()</del>
						<li><del>RestRequest.getServletTitle()</del>
						<li><del>RestRequest.getServletDescription()</del>
						<li><del>RestRequest.getMethodDescription()</del>
					</ul>
				<li>Behavior changes to {@link org.apache.juneau.rest.RestRequest#getPathInfo()} to follow Servlet specs.
					Returns <jk>null</jk> instead of blank for no path info.
				<li><del>RestRequest.getPathRemainder()</del>now automatically decodes the path remainder. 
					Use <del>RestRequest.getPathRemainderUndecoded()</del>to get the unencoded path remainder.
				<li>Bug fixes in <del>RestRequest.getRequestParentURI()</del>when servlet is mapped to <js>"/*"</js>.
				<li>Bug fixes in <del>RestRequest.getServletURI()</del>when servlet is mapped to <js>"/*"</js>.
			</ul>
		<li>New string replacement variables:
			<ul>
				<li><c>$R{contextPath}</c> - Returns value from {@link org.apache.juneau.rest.RestRequest#getContextPath()}
				<li><c>$R{methodDescription}</c> - Returns value from <del>RestRequest.getMethodDescription()</del>
				<li><c>$R{resourceTitle}</c> - Returns value from <del>RestRequest.getServletTitle()</del>
				<li><c>$R{resourceDescription}</c> - Returns value from <del>RestRequest.getServletDescription()</del>
				<li><c>$R{trimmedRequestURI}</c> - Returns value from <del>RestRequest.getTrimmedRequestURI()</del>
				<li><c>$E{var}</c> - Environment variables.
			</ul>
		<li>Added methods <del>RestServlet.getDescription(RestRequest)</del>and <del>RestServlet.getLabel(RestRequest)</del>.
		<li><del>BasicRestServlet</del> and <del>RestServletJenaDefault</del> now provide default HTML titles
			and descriptions:
			<p class='bcode'>
		<ja>@Property</ja>(name=<jsf>HTMLDOC_title</jsf>, value=<js>"$R{resourceTitle}"</js>),
		<ja>@Property</ja>(name=<jsf>HTMLDOC_description</jsf>, value=<js>"$R{resourceDescription}"</js>)
			</p>
		<li>Options pages on <del>BasicRestServlet</del> and <del>RestServletJenaDefault</del> now provide default descriptions and back links:
			and descriptions:
			<p class='bcode'>
		<ja>@Property</ja>(name=<jsf>HTMLDOC_navlinks</jsf>, value=<js>"{back:'$R{servletURI}"</js>),
		<ja>@Property</ja>(name=<jsf>HTMLDOC_description</jsf>, value=<js>"Resource options"</js>)
			</p>
		<li>New <del>BasicRestServletGroup</del>class.
		<li>Removed <c>RestServletProperties.REST_trimTrailingUriSlashes</c> and <c>RestServletProperties.REST_pathInfoBlankForNull</c>. 
		<li>New annotations for providing labels and descriptions.  Useful if you don't plan on having to support other languages, so you don't 
			want to provide labels in resource bundles.
			<ul>
				<li><del>RestResource.label()</del>
				<li><del>@RestResource(description)</del>
				<li><del>RestMethod.description() @RestMethod(description)</del>
				<li><del>RestMethod.responses()</del>
				<li><del>Attr.description()</del>
				<li><del>Content.description()</del>
				<li><del>HasParam.description()</del>
				<li><del>HasQParam.description()</del>
				<li><del>Header.description()</del>
				<li><del>Param.description()</del>
				<li><del>QParam.description()</del>
			</ul>
		<li>Support for sorting resources by name in <del>ChildResourceDescriptions</del>.
	</ul>
	
	<h5 class='topic w800'>Samples</h5>
	<ul class='spaced-list'>
		<li>Added <c>/tempDir/upload</c> showing how to use <c>ServletFileUpload</c> with multipart form posts.
	</ul>
</div>
</div><!-- END: 5.1.0.17 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.18' id='5.1.0.18'>5.1.0.18 (Aug 5, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.18 -->
<div class='topic'>
	<p>
		Juno 5.1.0.18 is a minor update affecting the server component only.
	</p>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>Fixed bug where localized strings weren't resolving when using chained resource bundles.
		<li>Servlet and method labels and descriptions can now contain embedded string variables.
		<li>New <del>RestMethod.input()</del>and <del>RestMethod.responses()</del>
			annotations.
			These replace the various <c>description</c> annotations added 2 days ago with a simpler design.
		<li>New methods on <del>RestServlet</del>:
			<ul>
				<li><del>RestServlet.getMethodDescription(String,RestRequest)</del>so that subclasses
					can override the method description in the OPTIONS page.
				<li><del>RestServlet.createRequestVarResolver(RestRequest)</del>so that subclasses
					can override and augment the variable resolver.
				<li><del>RestServlet.resolveChild(Class)</del>and <del>RestServlet.replaceChild(RestServlet)</del>
					classes that allows customized resolution of servlet instances (e.g. if services are defined in OSGi).
			</ul> 
		<li>Reverted the <del>MethodDescription</del>back to 5.1.0.16 since it was being used by someone.
	</ul>
</div>
</div><!-- END: 5.1.0.18 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.19' id='5.1.0.19'>5.1.0.19 (Aug 15, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.19 -->
<div class='topic'>
	<p>
		Juno 5.1.0.19 is a minor update in terms of core functionality.
		But it introduces a <del>Microservices</del> project for building REST microservices and docker containers.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>Beans can now be serialized to and parsed from <del>ObjectMap ObjectMaps</del>.
			See <dc>Serializing to ObjectMaps</dc> for details.
		<li>New <del>ObjectMap.include(String[])</del>and <del>ObjectMap.exclude(String[])</del>methods.
		<li>{@link org.apache.juneau.html.annotation.Html @Html} annotations can now be applied to bean properties.
		<li>New <del>IOPipe</del> utility class.
		<li>Behavior change on <del>StringVarResolver</del>.  <jk>null</jk> input now results in blank strings instead of <jk>null</jk>.
	</ul>
	
	<h5 class='topic w800'>Client</h5>
	<ul class='spaced-list'>
		<li>New <del>RestClient.doCallback(String)</del>method.
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New {@link org.apache.juneau.rest.RestRequest#getHeaders()} method.
		<li>New <c>RestResponse.getUnbufferedWriter()</c> method.
		<li>Fixed bug that was preventing <c>x-response-headers</c> parameter from working correctly.
		<li>Added {@link org.apache.juneau.annotation.Bean#properties() @Bean.properties} annotations to the various 
			classes in <c>org.apache.juneau.rest.labels</c> so that the order of the bean properties are consistent
			on all JVMs.  On IBM JVMs this is unnecessary because the order of the properties as defined in the class
			are stored in the bytecode.  Other JVMs such as OpenJRE do not implement this feature causing the bean
			properties to be in random order.
		<li>New <del>ResourceDescription.ResourceDescription(RestRequest,String,String)</del>constructor.
	</ul>
</div>
</div><!-- END: 5.1.0.19 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.1.0.20' id='5.1.0.20'>5.1.0.20 (Sept 5, 2015)</a></h3>
<div class='topic'><!-- START: 5.1.0.20 -->
<div class='topic'>
	<p>
		Juno 5.1.0.20 is a moderate update.
		The biggest improvement is the ability to associate external INI config files with REST servlets using the <del>ConfigFile</del> functionality.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>Significant API changes to <c>org.apache.juneau.config</c> API.
			<ul>
				<li><del>ConfigFile</del> is now thread safe and can be shared across multiple threads.
				<li>New <del>ConfigMgr</del> class for managing configuration files.
				<li>Serializers and parsers can be associated with config files for storing and retrieving POJOs.  
					Default support provided for JSON.
			</ul>
		</li>
		<li>New {@link org.apache.juneau.html.SimpleHtmlWriter} class.  
			Can be used for simple HTML DOM construction.
		<li>New <del>ProcBuilder</del> class for calling external processes.
		<li>New <del>ObjectMap.remove(Class,String,Object)</del>method.
		<li><js>"class='link'"</js> added to links generated by {@link org.apache.juneau.html.HtmlDocSerializer}.
		<li>New <del>EncoderGroup.append(EncoderGroup)</del>method.
		<li>New <c>HtmlDocSerializerContext.HTMLDOC_addLinks</c> configuration property.
		<li>Modified the <c>Parser.createContext(ObjectMap,Method,Object)</c> method.  
			Outer context objects can be passed in to create instances of non-static inner classes.
		<li>Fixed bug in {@link org.apache.juneau.html.HtmlStrippedDocSerializer} where exception was thrown when trying to serialize primitive arrays.
		<li>{@link org.apache.juneau.json.JsonParser} now handles parsing JSON boolean/numeric values as strings to bean properties of type boolean or number. 
		<li>{@link org.apache.juneau.urlencoding.UrlEncodingSerializer} and {@link org.apache.juneau.urlencoding.UrlEncodingParser} now 
			represent arrays and collections as key-value pairs where the keys are numbers (e.g. <js>"?0=foo&amp;1=bar"</js>).
		<li>Various internal improvements to <del>IOPipe</del>.
		<li>New <del>ReflectionUtils.getResource(Class,String)</del>method.
		<li><del>StringUtils.parseNumber(String,Class)</del> now returns zero for empty strings. 
			This affects the way most parsers handle blank values.
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>You can now parse into non-static inner classes of a servlet for parameters/attributes/content.
			Useful if you like to define your marshaller beans inside your servlet.
		<li>Changes to <del>RestServlet</del>:
			<ul>
				<li>New methods for accessing external INI config files:<br>  
					<del>RestServlet.getConfig()</del><br>
					<del>RestServlet.createConfigFile()</del>
				<li>New <js>"$C{...}"</js> variable that resolve to INI config file values.
				<li>New <js>"$UE{...}"</js> variable that  URL-encodes the value inside the variable.
				<li>New convenience methods for retrieving classpath resource files:<br>  
					<del>RestServlet.getResource(String)</del><br>
					<del>RestServlet.getResourceAsString(String)</del><br>
					<del>RestServlet.getResource(Class,String,String)</del>.
						Useful if you want to load predefined POJOs from JSON files in your classpath.
				<li>New <del>RestServlet.handleNotFound(int,RestRequest,RestResponse)</del> method for customized handling
					of when a resource or method was not found.  
			</ul>
		<li><del>BasicRestServlet</del> now automatically processes <js>"/favicon.ico"</js> requests by 
			overriding the new <del>RestServlet.handleNotFound(int,RestRequest,RestResponse)</del>method.
		<li>New {@link org.apache.juneau.rest.RestRequest} methods: 
			<ul>
				<li><del>RestRequest.resolveVars(String)</del>
				<li><c>RestRequest.getVarResource(String)</c>
				<li><del>RestRequest.getConfig()</del>
			</ul>
		<li>New {@link org.apache.juneau.rest.RestResponse} methods: 
			<ul>
				<li>{@link org.apache.juneau.rest.RestResponse#getDirectWriter(String)}.
				<li>{@link org.apache.juneau.rest.RestResponse#getNegotiatedWriter()}.  
					<c>getWriter()</c> now returns an unnegotiated writer.  
					<c>getUnbufferedWriter()</c> has been removed.
			</ul>
		<li>New <del>RestMethod.encoders() @RestMethod(encoders)</del>and 
			<del>RestMethod.inheritEncoders()</del> annotations.  
			Allows encoders to be fine-tuned at the method level.
		<li>New <del>@RestResource(config)</del> annotation for associating external <del>ConfigFile</del>config files with servlets.
		<li><del>ResourceLink</del>.
		<li>New <c>org.apache.juneau.rest.matcher</c> package for commonly-used <del>RestMatchers</del>:
			<ul>
				<li><del>MultipartFormDataMatcher</del>
				<li><del>UrlEncodedFormMatcher</del>
			</ul>
	</ul>
			
	<h5 class='topic w800'>Microservice</h5>
	<ul class='spaced-list'>
		<li>New juneau-microservice.jar file that encapsulates all 3 juneau jars with code necessary for creating fast and efficent jetty-powered REST microservices.<br>
			Contains the following:
			<ul>
				<li>Jetty 8.0
				<li>Apache HttpClient 4.3.5
				<li>Apache Commons FileUpload 1.3.1
			</ul>
		<li>Microservice now supports Java 6 (previously required Java 7)
	</ul>
</div>
</div><!-- END: 5.1.0.20 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.2.0.0' id='5.2.0.0'>5.2.0.0 (Dec 30, 2015)</a></h3>
<div class='topic'><!-- START: 5.2.0.0 -->
<div class='topic'>
	<p>
		Juno 5.2.0.0 is a major update.
		Major changes have been made to the microservice architecture and config INI file APIs.
	</p>
	
	<h5 class='topic w800'>Core</h5>
	<ul class='spaced-list'>
		<li>Significant changes and enhancements to the <c>org.apache.juneau.config</c> API.
			<ul>
				<li>More consistent handling of comma-delimited lists of objects.
				<li>New methods in <del>ConfigFile</del>:
					<ul>
						<li><del>ConfigFile.getStringArray(String)</del>,<del>ConfigFile.getStringArray(String,String[])</del>
						<li><del>ConfigFile.getSectionAsBean(String,Class)</del>- Instantiate a new bean with property values in the specified section..
						<li><del>ConfigFile.writeProperties(String,Object,boolean,Class[])</del>- Copy the properties in a config file section into properties on an existing bean or POJO.
						<li><del>ConfigFile.getSectionMap(String)</del>- Get all the resolved values in a section.
						<li><del>ConfigFile.containsNonEmptyValue(String)</del>
						<li><del>ConfigFile.isEncoded(String)</del>
						<li><del>ConfigFile.addListener(ConfigFileListener)</del>- Listen for modification events on the config file.
						<li><del>ConfigFile.merge(ConfigFile)</del>- Merge the contents of another config file into this config file.
						<li><del>ConfigFile.getResolving()</del>, <del>ConfigFile.getResolving(StringVarResolver)</del>- Return an instance of the config file that resolves string variables.
							Much more efficient than the previous design since the same underlying config file object is shared.
						<li><del>ConfigFile.toWritable()</del> - Wraps the config file in a <del>Writable</del>interface so that it can be serialized by the REST interface as a plain-text INI file instead of as a serialized POJO.
						<li><del>ConfigFile.getInt(String)</del>- Now supports <js>"M"</js> and <js>"K"</js> to identify millions and thousands.
					</ul>
				<li>New methods in <del>ConfigMgr</del>:
					<ul>
						<li><del>ConfigMgr.create()</del>, <del>ConfigMgr.create(Reader)</del>, <del>ConfigMgr.create(File)</del>
						<li><del>ConfigMgr.deleteAll()</del>	
					</ul>
				<li>New methods in <del>Section</del>:
					<ul>
						<li><del>Section.setParent(ConfigFileImpl)</del>- Used by parsers to set the config file for this section.
						<li><del>Section.setName(String)</del> - Used by parsers to set the name for this section.
					</ul>
				<li>New interfaces:
					<ul>
						<li><del>ConfigFileListener</del>
						<li><del>SectionListener</del>
						<li><del>EntryListener</del>
					</ul>
				<li><del>Encoder</del> methods have access to field names to use them as salt values.
				<li>The name of the default section is now <js>"default"</js>.  Before it was just <jk>null</jk>.
				<li><del>XorEncoder</del> XOR key can be overridden through the <js>"org.apache.juneau.config.XorEncoder.key"</js> system property.
			</ul> 
		<li>Support for converting Strings to POJOs if the POJO class has any of the following static methods: 
			<ul>
				<li><c>fromString(String)</c>
				<li><c>valueOf(String)</c> (e.g. enums)
				<li><c>parse(String)</c> (e.g. logging <c>Level</c> class)
				<li><c>parseString(String)</c>
				<li><c>forName(String)</c> (e.g. <c>Class</c> and <c>Charset</c> classes)
			</ul>
		<li>Support for parsing into objects with unbound type variables.
			For example, if you have a class <c>Pair&lt;S,T&gt;</c> and you try to parse into this
			class (e.g. <c>parser.parse(in, Pair.<jk>class</jk>)</c>), the unbound type variables
			is interpreted as <c>Object</c> instead of throwing an exception.
		<li>Support for serializing/parsing the following new types:
			<ul>
				<li><c>AtomicInteger</c>
				<li><c>AtomicLong</c>
				<li><c>BigInteger</c>
				<li><c>BigDecimal</c>
			</ul>
		<li>Parsers have been enhanced to allow parent POJOs and field names to be passed into child POJOs.
			New {@link org.apache.juneau.annotation.NameProperty @NameProperty} and {@link org.apache.juneau.annotation.ParentProperty @ParentProperty}
				annotations are provided for identifying methods for setting names and parent POJOs on child POJOs.
			For example, the config file <del>Section</del> class represents a section
			in a config file.  It needs to know it's own name and have a link to the <del>ConfigFile</del> 
			that it belongs to.  With these new annotations, config files can be reconstructed using any of the parsers.
		<li>New classes and interfaces:
			<ul>
				<li><del>Streamable</del> interface for identifying objects that can be serialized directly to an output stream.
				<li><del>Writable</del> interface for identifying objects that can be serialized directly to a writer.
				<li><del>StringObject</del> class that can be used for delayed object serialization.
				<li><del>ByteArrayCache</del>
				<li><del>ByteArrayInOutStream</del>
				<li><del>FileUtils</del>
				<li><del>ThrowableUtils</del>
				<li><del>StringVarMultipart</del>
				<li><del>StringVarWithDefault</del>
			</ul> 
		<li>New fields on <del>ObjectList</del>:
			<ul>
				<li><del>ObjectList.EMPTY_LIST</del>
			</ul>
		<li>New fields and methods on <del>ObjectMap</del>:
			<ul>
				<li><del>ObjectMap.EMPTY_MAP</del>
				<li><del>ObjectMap.getStringArray(String)</del>
				<li><del>ObjectMap.getStringArray(String,String[])</del>
				<li><del>ObjectMap.putIfNull(String,Object)</del>
				<li><del>ObjectMap.putIfEmpty(String,Object)</del>
			</ul>
		<li>New methods in {@link org.apache.juneau.internal.ArrayUtils}:
			<ul>
				<li><del>ArrayUtils.contains(Object,Object[])</del>
				<li><del>ArrayUtils.indexOf(Object,Object[])</del>
				<li><del>ArrayUtils.toPrimitiveArray(Object)</del>
			</ul>	
		<li>New methods in <del>IOUtils</del>:
			<ul>
				<li><del>IOUtils.pipe(Reader,Writer)</del>
				<li><del>IOUtils.read(File)</del>
				<li><del>IOUtils.readFile(String)</del>
				<li><del>IOUtils.write(File,Reader)</del>
			</ul>
		<li>New methods on <del>PojoRest</del>:
			<ul>
				<li><del>PojoRest.get(Class,String,Object)</del>
				<li><del>PojoRest.getString(String)</del>
				<li><del>PojoRest.getString(String,String)</del>
				<li><del>PojoRest.getInt(String)</del>
				<li><del>PojoRest.getInt(String,Integer)</del>
				<li><del>PojoRest.getLong(String)</del>
				<li><del>PojoRest.getLong(String,Long)</del>
				<li><del>PojoRest.getBoolean(String)</del>
				<li><del>PojoRest.getBoolean(String,Boolean)</del>
				<li><del>PojoRest.getMap(String)</del>
				<li><del>PojoRest.getMap(String,Map)</del>
				<li><del>PojoRest.getList(String)</del>
				<li><del>PojoRest.getList(String,List)</del>
				<li><del>getObjectMap(String)</del>
				<li><del>getObjectMap(String,ObjectMap)</del>
				<li><del>getObjectList(String)</del>
				<li><del>getObjectList(String,ObjectList)</del>
			</ul>
		<li>New methods on <del>ProcBuilder</del>:
			<ul>
				<li><del>ProcBuilder.pipeTo(Writer,boolean)</del>
				<li><del>ProcBuilder.pipeTo(Writer)</del>
				<li><del>ProcBuilder.logTo(Writer,boolean)</del>
				<li><del>ProcBuilder.logTo(Writer)</del>
				<li><del>ProcBuilder.logTo(Level,Logger)</del>
				<li><del>ProcBuilder.maxExitStatus(int)</del>
			</ul>
		<li>New methods on <del>StringUtils</del>:
			<ul>
				<li><del>StringUtils.isEmpty(Object)</del>
				<li><del>StringUtils.nullIfEmpty(String)</del>
				<li><del>StringUtils.base64EncodeToString(String)</del>
				<li><del>StringUtils.base64Encode(byte[])</del>
				<li><del>StringUtils.base64DecodeToString(String)</del>
				<li><del>StringUtils.base64Decode(String)</del>
				<li><del>StringUtils.generateUUID(int)</del>
				<li><del>StringUtils.trim(String)</del>
				<li><del>StringUtils.parseISO8601Date(String)</del>
				<li><del>StringUtils.replaceVars(String,Map)</del>
				<li><del>StringUtils.pathStartsWith(String,String)</del>
				<li><del>StringUtils.pathStartsWith(String,String[])</del>
			</ul>
		<li>New <del>StringVar.doResolve(String)</del>method.
		<li>New <del>StringVarResolver.DEFAULT</del>field.
		<li>Eliminated dependency on <c>javax.mail.internet.MimeUtility</c> by implementing our own <del>StringUtils.base64Encode(byte[])</del> method.
		<li><del>CalendarSwap</del> and <del>DateSwap</del> classes now handle blank input better.  Returns <jk>null</jk> instead of throwing an exception.
		<li>{@link org.apache.juneau.html.HtmlDocSerializer} specifies the default CSS location as <c>/servletPath/style.css</c> instead of <c>/servletPath/htdocs/juneau.css</c>.  
			This coincides with enhancements made in the server code for specifying styles.
		<li>{@link org.apache.juneau.html.HtmlDocSerializer} wraps output in two div tags instead of one (e.g. <c>&lt;div class='outerdata'&gt;&lt;div class='data' id='data'&gt;...&lt;/div&gt;&lt;/div&gt;</c>).
			Needed for supporting the new devops look-and-feel.
		<li>Fixed indentation inconsistencies in {@link org.apache.juneau.html.HtmlDocSerializer}.
		<li>Renamed <del>HtmlSchemaSerializer</del> to <del>HtmlSchemaDocSerializer</del>.
		<li>RDF serializers and parsers now support <c>RdfProperties.RDF_looseCollection</c> loose collections.
		<li>RDF parser handles case where resources point to themselves (an unfortunate behavior in JFS RDF documents).
		<li>JSON parser with throw an exception in strict mode if it encounters numbers that are valid in Java but invalid in JSON (e.g. octal, hexadecimal numbers).
		<li>{@link org.apache.juneau.parser.Parser} methods now check for <jk>null</jk> input.
		<li><del>SerializerGroup</del> and <del>ParserGroup</del> ignores serializers and parsers if they throw <c>NoClassDefFoundErrors</c>.
		<li>{@link org.apache.juneau.urlencoding.UrlEncodingParser} creates lists if the same attribute name is encountered more than once.  Before it would just replace the previous value with the new value.
		<li>New <del>UrlEncodingSerializer.DEFAULT_SIMPLE_EXPANDED</del>serializer.
		<li>Changes to <del>Args</del>:
			<ul>
				<li><c>getMainArg(int)</c> changed to <del>Args.getArg(int)</del>.  
					Non-existent arguments are returned as <jk>null</jk> instead of blank strings.  
					This is more inline with the behavior of the rest of the library.
				<li>New <del>Args.hasArg(int)</del> method.
			</ul> 
		<li>Removed <c>org.apache.juneau.utils.CharsetUtils</c> class.
		<li>Removed <c>org.apache.juneau.utils.ConcurrentIdentityList</c> class.
		<li>Fixed bug in <del>MultiIterable</del> class.
		<li><del>PojoIntrospector</del> must now be instantiated with a <c>ReaderParser</c>.
			Simplifies the API on the class.
		<li><del>PojoRest</del> must now be instantiated with a <c>ReaderParser</c>.
			Simplifies the API on the class.
		<li><del>MessageBundle</del> and <c>SafeResourceMultiBundle</c> moved from server component.
		<li>Several bug fixes and performance improvements in <del>StringVarResolver</del>.
		<li>Various enhancements to <del>TeeWriter</del> and <del>TeeOutputStream</del>.
		<li>Renamed <del>CharSet</del> to <del>AsciiSet</del>.
		<li><del>SerializerGroup</del> and <del>ParserGroup</del>now ignores <c>NoClassDefFoundErrors</c>
			so that resources that include Jena support can continue to operate even if the Jena libraries are not present.
		<li>New {@link org.apache.juneau.internal.FileUtils#createTempFile(String)} method.
		<li>New <del>PojoQuery</del> modified to handle bean getters that throw exceptions.
	</ul>
	
	<h5 class='topic w800'>Client</h5>
	<ul class='spaced-list'>
		<li>Upgraded to use Apache HttpClient 4.5.
		<li>New classes:
			<ul>
				<li><del>AllowAllRedirects</del>
				<li><del>HttpMethod</del>
				<li><del>ResponsePattern</del>
				<li><del>SimpleX509TrustManager</del>
				<li><del>SSLOpts</del>
			</ul>
		<li>Removed <c>org.apache.juneau.rest.client.LaxRedirectStrategy</c>.  Use HTTP Client equivalent.
		<li>New methods on <del>RestCall</del>:
			<ul>
				<li><del>RestCall.addInterceptor(RestCallInterceptor)</del>
				<li><del>RestCall.pipeTo(Writer)</del>
				<li><del>RestCall.pipeTo(Writer,boolean)</del>
				<li><del>RestCall.pipeTo(String,Writer,boolean)</del>
				<li><del>RestCall.getWriter(String)</del>
				<li><del>RestCall.pipeTo(OutputStream)</del>
				<li><del>RestCall.pipeTo(OutputStream,boolean)</del>
				<li><del>RestCall.pipeTo(String,OutputStream,boolean)</del>
				<li><del>RestCall.getOutputStream(String)</del>
				<li><del>RestCall.byLines()</del>
				<li><del>RestCall.captureResponse()</del>
				<li><del>RestCall.successPattern(String)</del>
				<li><del>RestCall.failurePattern(String)</del>
				<li><del>RestCall.addResponsePattern(ResponsePattern)</del>
				<li><del>RestCall.run()</del>- Renamed from <c>execute()</c>.
				<li><del>RestCall.getCapturedResponse()</del>
				<li><del>RestCall.getResponsePojoRest(Class)</del>
				<li><del>RestCall.getResponsePojoRest()</del>
				<li><del>RestCall.logTo(Level,Logger)</del>
				<li><del>RestCall.setConfig(RequestConfig)</del>
			</ul>
		<li>New lifecycle listener methods on <del>RestCallInterceptor</del>:
			<ul>
				<li><del>RestCallInterceptor.onInit(RestCall)</del>
				<li><del>RestCallInterceptor.onClose(RestCall)</del>
			</ul>
		<li>New methods on {@link org.apache.juneau.rest.client.RestClient}:
			<ul>
				<li><del>RestClient.setBasicAuth(String,int,String,String)</del>
				<li><del>RestClient.logTo(Level,Logger)</del>
				<li><del>RestClient.setRootUrl(String)</del>
				<li><del>RestClient.enableSSL(SSLOpts)</del>
				<li><del>RestClient.enableLaxSSL()</del>
				<li><del>RestClient.doCall(HttpMethod,Object,Object)</del>
				<li><del>RestClient.createHttpClientBuilder()</del>
			</ul>
		<li>New passthrough methods on {@link org.apache.juneau.rest.client.RestClient} defined on <c>HttpClientBuilder</c>:
			<ul>
				<li><del>RestClient.setRedirectStrategy(RedirectStrategy)</del>
				<li><del>RestClient.setDefaultCookieSpecRegistry(Lookup)</del>
				<li><del>RestClient.setRequestExecutor(HttpRequestExecutor)</del>
				<li><del>RestClient.setSSLHostnameVerifier(HostnameVerifier)</del>
				<li><del>RestClient.setPublicSuffixMatcher(PublicSuffixMatcher)</del>
				<li><del>RestClient.setSSLContext(SSLContext)</del>
				<li><del>RestClient.setSSLSocketFactory(LayeredConnectionSocketFactory)</del>
				<li><del>RestClient.setMaxConnTotal(int)</del>
				<li><del>RestClient.setMaxConnPerRoute(int)</del>
				<li><del>RestClient.setDefaultSocketConfig(SocketConfig)</del>
				<li><del>RestClient.setDefaultConnectionConfig(ConnectionConfig)</del>
				<li><del>RestClient.setConnectionTimeToLive(long,TimeUnit)</del>
				<li><del>RestClient.setConnectionManager(HttpClientConnectionManager)</del>
				<li><del>RestClient.setConnectionManagerShared(boolean)</del>
				<li><del>RestClient.setConnectionReuseStrategy(ConnectionReuseStrategy)</del>
				<li><del>RestClient.setKeepAliveStrategy(ConnectionKeepAliveStrategy)</del>
				<li><del>RestClient.setTargetAuthenticationStrategy(AuthenticationStrategy)</del>
				<li><del>RestClient.setProxyAuthenticationStrategy(AuthenticationStrategy)</del>
				<li><del>RestClient.setUserTokenHandler(UserTokenHandler)</del>
				<li><del>RestClient.disableConnectionState()</del>
				<li><del>RestClient.setSchemePortResolver(SchemePortResolver)</del>
				<li><del>setUserAgent(String)</del>
				<li><del>RestClient.setDefaultHeaders(Collection)</del>
				<li><del>RestClient.addInterceptorFirst(HttpResponseInterceptor)</del>
				<li><del>RestClient.addInterceptorLast(HttpResponseInterceptor)</del>
				<li><del>RestClient.addInterceptorFirst(HttpRequestInterceptor)</del>
				<li><del>RestClient.addInterceptorLast(HttpRequestInterceptor)</del>
				<li><del>RestClient.disableCookieManagement()</del>
				<li><del>RestClient.disableContentCompression()</del>
				<li><del>RestClient.disableAuthCaching()</del>
				<li><del>RestClient.setHttpProcessor(HttpProcessor)</del>
				<li><del>RestClient.setRetryHandler(HttpRequestRetryHandler)</del>
				<li><del>RestClient.disableAutomaticRetries()</del>
				<li><del>RestClient.setProxy(HttpHost)</del>
				<li><del>RestClient.setRoutePlanner(HttpRoutePlanner)</del>
				<li><del>RestClient.disableRedirectHandling()</del>
				<li><del>RestClient.setConnectionBackoffStrategy(ConnectionBackoffStrategy)</del>
				<li><del>RestClient.setBackoffManager(BackoffManager)</del>
				<li><del>RestClient.setServiceUnavailableRetryStrategy(ServiceUnavailableRetryStrategy)</del>
				<li><del>RestClient.setDefaultCookieStore(CookieStore)</del>
				<li><del>RestClient.setDefaultCredentialsProvider(CredentialsProvider)</del>
				<li><del>RestClient.setDefaultAuthSchemeRegistry(Lookup)</del>
				<li><del>RestClient.setContentDecoderRegistry(Map)</del>
				<li><del>RestClient.setDefaultRequestConfig(RequestConfig)</del>
				<li><del>RestClient.useSystemProperties()</del>
				<li><del>RestClient.evictExpiredConnections()</del>
				<li><del>RestClient.evictIdleConnections(long,TimeUnit)</del>
			</ul>
		<li><c>JazzRestClient</c> now supports OIDC authentication.
		<li>These classes are now deprecated and will be removed in a future release:
			<ul>
				<li><c>org.apache.juneau.rest.client.jazz.CertificateStore</c>
				<li><c>org.apache.juneau.rest.client.jazz.ICertificateValidator</c>
				<li><c>org.apache.juneau.rest.client.jazz.ITrustStoreProvider</c>
				<li><c>org.apache.juneau.rest.client.jazz.LenientCertificateValidator</c>
				<li><c>org.apache.juneau.rest.client.jazz.SharedTrustStoreProvider</c>
				<li><c>org.apache.juneau.rest.client.jazz.ValidatingX509TrustManager</c>
			</ul>
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New <del>ReaderResource</del> class.   
			Represents the contents of a text file with convenience methods for resolving
			<del>StringVar</del> variables and adding HTTP response headers.	
			REST Java methods can return instances of these to serialize <c>Readers</c>
				containing text with <del>StringVarResolver</del> variables in them.
		<li>New <del>StreamResource</del>class.   
			REST Java methods can return instances of these to serialize <c>OutputStreams</c>.
		<li>Fixed a bug in the stack trace hash algorithm in <del>RestException</del>.
		<li>New methods in {@link org.apache.juneau.rest.RestRequest}:
			<ul>
				<li><del>RestRequest.getReaderResource(String)</del>- Replaces <c>getVarResource(String)</c>.
				<li><del>RestRequest.getReaderResource(String,boolean)</del>
				<li><del>RestRequest.getReaderResource(String,boolean,String)</del>
			</ul>
		<li>Changes in {@link org.apache.juneau.rest.RestResponse}:
			<ul>
				<li>Don't set <c>Content-Encoding: identity</c> when no encoding is used.  Some clients don't interpret it correctly.
			</ul>
		<li>New methods in <del>RestServlet</del>:
			<ul>
				<li><del>RestServlet.getChildClasses()</del>  - Programmatic equivalent to <del>@RestResource(children)</del>annotation.
				<li><del>RestServlet.shouldLog(HttpServletRequest,HttpServletResponse,RestException)</del>
				<li><del>RestServlet.shouldLogStackTrace(HttpServletRequest,HttpServletResponse,RestException)</del>
				<li><del>RestServlet.logObjects(Level,String,Object[])</del>
				<li><del>RestServlet.resolveStaticFile(String)</del>
				<li><del>RestServlet.createStyleSheet()</del>
				<li><del>RestServlet.createFavIcon()</del>
				<li><del>RestServlet.createStaticFilesMap()</del>
				<li><del>RestServlet.getConfigMgr()</del>
			</ul>
		<li>Removed <del>JsoParser</del>
			from <del>BasicRestServlet</del>and <del>RestServletJenaDefault</del>.  
			These may represent a security risk if not handled correctly, so removed
			them as a precaution.
		<li>Removed <c>RestServletProperties.REST_htDocsFolder</c>.  Replaced with <del>@RestResource(staticFiles)</del>}.
		<li>New annotations on <del>@RestResource</del>.
			<ul>
				<li><del>RestResource.stylesheet()</del>
				<li><del>RestResource.favicon()</del>
				<li><del>@RestResource(staticFiles)</del>
			</ul>
		<li>Eliminated <c>org.apache.juneau.rest.jaxrs.JsonProvider</c> class.  
			Some JAX-RS implementations use code scanning to find providers, so if you were using <c>DefaultJenaProvider</c>, it would
			pick up <c>JsonProvider</c> as well.  It's easy enough to create your own implementation if needed.
		<li>OPTIONS pages now specify <c>consumes</c> and <c>produces</c> fields instead of <c>accept</c> and <c>contentType</c> which was confusing.  
		<li>Eliminated <c>properties</c> from OPTIONS pages. 
		<li>New <del>ResourceLink.ResourceLink(String,RestRequest,String,Object[])</del> constructor.
		<li>New response handlers:
			<ul>
				<li><del>StreamableHandler</del> - Allows REST Java methods to return instances of <del>Streamable</del>.
				<li><del>WritableHandler</del>- Allows REST Java methods to return instances of <del>Writable</del>.
			</ul>
		<li>New DevOps stylesheet.
		<li>Servlet initialization and HTTP requests are now logged at <JSF>FINE</JSF> level.
		<li>Added <jk>abstract</jk> modifier on various <l>RestServlet</l> subclasses to indicate that they're meant to be subclassed.
		<li>New <del>RestUtils.trimPathInfo(StringBuffer,String,String)</del> method.
	</ul>
	
	<h5 class='topic w800'>Microservice</h5>
	<ul class='spaced-list'>
		<li>Completely revamped API.
		<li>New {@link org.apache.juneau.microservice.Microservice} class that serves as a generic
			interface for microservices and their lifecycles.
		<li>New <del>RestMicroservice</del> class that implements a microservice
			consisting of a REST interface.
			<ul>
				<li>REST resources and configuration settings can be defined through either manifest files
					or config files.
				<li>Enhanced logging support.
				<li>Easy-to-configure SSL support.
				<li>BASIC auth support.
				<li>Automatic restartability if the config file changes.
			</ul>
		<li>Eliminated <c>org.apache.juneau.microservice.Main</c> class.  This is replaced by
			the microservice classes defined above.
		<li><del>Resource</del> and <del>ResourceGroup</del>
			classes now support the following new string variables:
			<ul>
				<li><js>"$A{key,default}""</js> - Command line arguments.
				<li><js>"$MF{key,default}""</js> - Manifest file entries.
			</ul> 
		<li>CSS stylesheet now configurable through config file entry <js>"REST/stylesheet"</js>.
		<li>New <del>BasicRestServletJena</del> class if you want your REST interface to support RDF.
		<li>Eliminated the following classes:
			<ul>
				<li><c>org.apache.juneau.microservice.RootResource</c>
				<li><c>org.apache.juneau.microservice.SampleResource</c>
			</ul> 
		<li>New predefined reusable resources:
			<ul>
				<li>{@link org.apache.juneau.microservice.resources.ConfigResource} - REST resource for viewing and editing microservice config file.
				<li>{@link org.apache.juneau.microservice.resources.LogsResource} - REST resource for viewing log files.
				<li>{@link org.apache.juneau.microservice.resources.SampleRootResource} - Sample REST resource that contains the config and logs resource as children.
				<li>{@link org.apache.juneau.microservice.resources.ShutdownResource} - REST resource for stopping the microservice JVM.  Useful for testing purposes.
			</ul>
	</ul>
	
	<h5 class='topic w800'>Samples</h5>
	<ul class='spaced-list'>
		<li>Converted to a REST microservice.
		<li>Look-and-feel changed to IBM DevOps.
	</ul>
	
	<h5 class='topic w800'>Documentation Updates</h5>
	<ul class='spaced-list'>
		<li><del>microservice</del> - New package-level javadoc.
		<li><del>config</del> - New package-level javadoc.
		<li><del>StringVarResolver</del> - New documentation.
		<li><del>client</del> - New package-level javadoc.
		<li><dc>Overview / Samples</dc> - New section.
		<li><dc>org.apache.juneau.swap / Stop Classes</dc> - New section.
		<li><del>rest</del>- Extensive updates.
	</ul>
</div>
</div><!-- END: 5.2.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#5.2.0.1' id='5.2.0.1'>5.2.0.1 (Mar 23, 2016)</a></h3>
<div class='topic'><!-- START: 5.2.0.1 -->
<div class='topic'>
	<p>
		Juno 5.2.0.1 is a moderate update.
	</p>
	
	<h5 class='topic w800'>com.ibm.team.juno</h5>
	<ul class='spaced-list'>
		<li>Improved support for multi-line values in config files.
			Any line that begins with whitespace is interpreted as a continuation of the previous line.
		<li>Support for <js>'\uXXXX'</js> character sequences in config files.
		<li>Fixed issue in {@link org.apache.juneau.xml.XmlSerializer} where <js>'\r'</js> and <js>'\n'</js> characters were not being handled per XML specs.
		<li>New methods on <del>ObjectList</del>:  
			<ul>
				<li><del>ObjectList.getAt(Class,String)</del>
				<li><del>ObjectList.putAt(String,Object)</del>
				<li><del>ObjectList.postAt(String,Object)</del>
				<li><del>ObjectList.deleteAt(String)</del>
			</ul>
		<li>New methods on <del>ObjectMap</del>:  
			<ul>
				<li><del>ObjectMap.getAt(Class,String)</del>
				<li><del>ObjectMap.putAt(String,Object)</del>
				<li><del>ObjectMap.postAt(String,Object)</del>
				<li><del>ObjectMap.deleteAt(String)</del>
			</ul>
		<li><del>@ThreadSafe</del>annotation.
		<li>New <c>ClassFilter</c> class.
		<li><del>ConfigFile.getResolving(StringVarResolver,boolean)</del>method.
		<li><del>ConfigFile.getStringVar()</del>method.
		<li>New <del>ParserContext.PARSER_trimStrings</del>property.
		<li>New <del>SerializerContext.SERIALIZER_trimStrings</del>property.
		<li><del>Args.getStringVar()</del> method.
		<li>New {@link org.apache.juneau.utils.ManifestFile} class
		<li>New <del>MessageBundle</del> class.  Replaces <l>SafeResourceBundle</l>/<l>SafeResourceMultiBundle</l>/<l>RestNls</l>.
		<li>New <del>StringMapVar</del> class.
		<li>New <del>StringVars</del> class with reusable common <del>StringVar</del> instances.
		<li>New <del>JuneauLogger</del>class.
		<li>Default value for <del>XmlParserContext.XML_trimWhitespace</del>changed to <jk>true</jk>.			
	</ul>
	
	<h5 class='topic w800'>Server</h5>
	<ul class='spaced-list'>
		<li>New methods on {@link org.apache.juneau.rest.RestContext}:
			<ul>
				<li>{@link org.apache.juneau.rest.RestContext#getMessages()}
			</ul>
	</ul>
	
	<h5 class='topic w800'>Client</h5>
	<ul class='spaced-list'>
		<li>Fixed potential issue in {@link org.apache.juneau.rest.client.RestClient} where the HTTP connection pool could end up exhausted if an error occurred.
		<li>Improved thread safety on {@link org.apache.juneau.rest.client.RestClient}.
		<li>New warning message is logged if a {@link org.apache.juneau.rest.client.RestClient} is garbage collected without being closed:  
			<js>"WARNING:  RestClient garbage collected before it was finalized."</js>
	</ul>
</div>
</div><!-- END: 5.2.0.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.0.0' id='6.0.0'>6.0.0 (Oct 3, 2016)</a></h3>
<div class='topic'><!-- START: 6.0.0 -->
<div class='topic'>
	<p>
		Juneau 6.0.0 is a major update.
	</p>
	<p>
		The major change is rebranding from "Juno" to "Juneau" in preparation for donation to the Apache Foundation.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>Major changes around how serializer and parser class properties are defined to improve performance
			and concurrency.
			<ul>
				<li>New <del>PropertyStore</del> class - Used for creating context objects.
				<li>New {@link org.apache.juneau.Context} class - Read-only configurations for serializers and parsers.
				<li>New <del>Session</del> class - One-time use objects used by serializers and parsers.
				<li>All context context properties can now also be specified via system properties.
			</ul>
		</li>
		<li>Refactored serializer and parser APIs for more consistency between stream-based and character-based serializers
			and parsers.
			<ul>
				<li>More consistent handling of exceptions.
				<li>More consistent method declarations.
			</ul>
		<li>Refactored var resolver API and added them to a new package - <c>org.apache.juneau.svl</c>.
			<ul>
				<li>Support for stream-based variables - {@link org.apache.juneau.svl.StreamedVar}.
				<li>Added support for context and session objects.
			</ul>
		<li>Eliminated <js>"_class"</js> properties and replaced them with <js>"_type"</js> properties.
			The class properties were a little-used feature where we would serialize fully-qualified class names when the class type could not be inferred through reflection.  
			It's been replaced with bean type names and bean dictionaries.
			Instead of class names, we serialize <js>"_type"</js> properties whose name is the type name defined on the bean being serialized.  
			The parsers use a 'dictionary' of bean classes to resolve those names to actual bean classes.
			The following features were added to enable this support:
			<ul>
				<li>{@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)} - Annotation that defines an identifying name for a bean class.
				<li><del>BeanFilterBuilder.typeName(String)</del>- Programmatic equivalent to annotation above.
				<li><del>BeanContext.BEAN_beanDictionary</del> - List of bean classes that make up the bean dictionary for lookup
					during parsing. 
				<li><del>BEAN_beanTypePropertyName</del> - The overridable type property name.  Default is <js>"_type"</js>.
				<li><del>@BeanProperty(beanDictionary)</del>- Define a type dictionary
					for a particular bean property value.  This overrides the value specified using <del>BeanContext.BEAN_beanDictionary</del>.
				<li><del>SerializerContext.SERIALIZER_addBeanTypeProperties</del>- Controls whether type properties are serialized.
			</ul>
			In addition, the {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)} value replaces the <c>@Xml(name)</c> annotation, and the 
			<js>"type"</js> and <js>"_class"</js> attributes in the XML and HTML serializers have been standardized on a single <js>"_type"</js> attribute.
		<li>Refactor bean filter support to use <del>BeanFilterBuilder</del> class.
			Allows the <c>BeanFilter</c> class to use final fields.
		<li>{@link org.apache.juneau.msgpack MessagePack} support.
		<li>Serializers can now serialize directly to {@link java.io.File Files}.
			See {@link org.apache.juneau.serializer.Serializer#serialize(Object,Object)}
		<li>Parsers can now parse directly from {@link java.io.File Files} and other types.
			See {@link org.apache.juneau.parser.Parser#parse(Object,ClassMeta)}
		<li>Parsers will automatically covert numeric input to POJOs that have numeric constructors (e.g. <c>java.util.Date</c>).
		<li>Renamed 'Filters' to 'BeanFilters' and 'PojoSwaps'.  Filters is just too overloaded a term.
		<li>Internal utility classes moved to a new <c>org.apache.juneau.internal</c> package.
			These internal utility classes are not meant for consumption outside the Juneau codebase.
		<li>New methods on {@link org.apache.juneau.parser.Parser}:
			<ul>
				<li><c>org.apache.juneau.parser.Parser.createSession(ObjectMap,Method,Object)</c>
				<li><del>Parser.getMediaRanges()</del>
			</ul>
		</li>
		<li>New methods on {@link org.apache.juneau.serializer.Serializer}:
			<ul>
				<li><c>org.apache.juneau.serializer.Serializer.createSession(ObjectMap,Method)</c>
				<li><del>Serializer.getMediaRanges()</del>
			</ul>
		</li>
		<li>New {@link org.apache.juneau.annotation.Bean#sort() @Bean(sort)} annotation.
		<li>Added <ja>@Bean.properties</ja> annotations on various DTO beans to make the ordering consistent
			between IBM and Oracle JVMs.<br>
			IBM JVMs maintain the order of methods in a class, whereas Oracle JVMs do not.
		<li>Serializers and parsers now automatically convert {@link java.lang.Class} objects to readable names via <del>ClassUtils.getReadableClassName(Class)</del>.
		<li>Eliminated the <c>ClassFilter</c> class since it's no longer needed.
		<li>Code and concurrency improvements to <del>SerializerGroup</del>and <del>ParserGroup</del>.
		<li>Various enhancements to <del>BeanContext.convertToType(Object,Class)</del>.
		<li>New properties on {@link org.apache.juneau.html.HtmlSerializer}:
			<ul>
				<li><del>HtmlSerializerContext.HTML_detectLinksInStrings</del>- Automatically detect hyperlinks in strings.
				<li><del>HtmlSerializerContext.HTML_lookForLabelParameters</del>- Specify anchor text by appending <c>&amp;label=MyLabel</c> to URL.
				<li><del>HtmlSerializerContext.HTML_labelParameter</del>- Specify what URL parameter to use as the anchor text label.
				<li><del>HtmlSerializerContext.URI_ANCHOR</del>option for <del>HtmlSerializerContext.HTML_uriAnchorText</del>.				
			</ul>
		</li>
		<li>Removed generics from {@link org.apache.juneau.BeanPropertyMeta}.
		<li>Introduced new classes to eliminate the references to language-specific metadata in the core metadata classes:
			<ul>
				<li><del>ClassMetaExtended</del>/ <del>ClassMeta.getExtendedMeta(Class)</del> 
				<li><del>BeanMetaExtended</del>/<del>BeanMeta.getExtendedMeta(Class)</del> 
				<li><del>BeanPropertyMetaExtended</del>/ <del>BeanPropertyMeta.getExtendedMeta(Class)</del> 
			</ul>
		</li>
		<li>Renamed <c>@Transform</c> annotation to <del>@Pojo</del> so that it can be used for various POJO-related behavior, not just associating transforms.  
		<li>Introduced {@link org.apache.juneau.dto.swagger Swagger DTOs}.
	</ul>		
	
	<h5 class='topic w800'>org.apache.juneau.rest</h5>
	<ul class='spaced-list'>
		<li>OPTIONS pages replaced with Swagger documents.
			Lots of changes related to supporting Swagger.
			<ul>
				<li>Annotation name changes to conform to Swagger specs:  <ja>@Attr</ja>-&gt;<ja>@Path</ja>, <ja>@QParam</ja>-&gt;<ja>@Query</ja>, <ja>@Param</ja>-&gt;<ja>@FormData</ja>, <ja>@Content</ja>-&gt;<ja>@Body</ja>
				<li>Eliminated <c>ResourceOptions</c> and related code.
				<li>New annotations and related methods:
					<ul>
						<li><del>@RestResource(title)</del>/ <del>RestInfoProvider.getTitle(RestRequest)</del>
						<li><del>@RestResource(description)</del>/ <del>RestInfoProvider.getDescription(RestRequest)</del>
						<li><del>@RestResource(termsOfService)</del>/ <del>RestInfoProvider.getTermsOfService(RestRequest)</del>
						<li><del>@RestResource(contact)</del>/ <del>RestInfoProvider.getContact(RestRequest)</del>
						<li><del>@RestResource(license)</del>/ <del>RestInfoProvider.getLicense(RestRequest)</del>
						<li><del>@RestResource(version)</del>/ <del>RestInfoProvider.getVersion(RestRequest)</del>
						<li><del>@RestResource(tags)</del>/ <del>RestInfoProvider.getTags(RestRequest)</del>
						<li><del>@RestResource(externalDocs)</del>/ <del>RestInfoProvidergetExternalDocs(RestRequest)</del>
						<li><del>RestMethod.summary() @RestMethod(summary)</del>/ <del>RestInfoProvider.getMethodSummary(String,RestRequest)</del>
						<li><del>RestMethod.description() @RestMethod(description)</del>/<del>RestInfoProvider.getMethodDescription(String,RestRequest)</del>
						<li><del>@RestMethod(externalDocs)</del>
						<li><del>@RestMethod(tags)</del>
						<li><del>@RestMethod(deprecated)</del> 
						<li><del>@RestMethod(parameters)</del>
						<li><del>@RestMethod(responses)</del>
					</ul>
				</li>					
			</ul>
		<li>New <del>RestServletContext.paramFormat</del>context property.
		<li>New/updated methods on <del>RestServlet</del>:
			<ul>
				<li><del>RestServlet.createProperties()</del>
				<li><del>RestServlet.createBeanContext(ObjectMap,Class[],Class[])</del>
				<li><del>RestServlet.createBeanFilters()</del>
				<li><del>RestServlet.createPojoSwaps()</del>
				<li><del>RestServlet.createParsers(ObjectMap,Class[],Class[])</del>
				<li><del>RestServlet.createUrlEncodingSerializer(ObjectMap,Class[],Class[])</del>
				<li><del>RestServlet.createUrlEncodingParser(ObjectMap,Class[],Class[])</del>
				<li><del>RestServlet.createConverters(ObjectMap)</del>
				<li><del>RestServlet.createDefaultRequestHeaders(ObjectMap)</del>
				<li><del>RestServlet.createDefaultResponseHeaders(ObjectMap)</del>
				<li><del>RestServlet.createEncoders(ObjectMap)</del>
				<li><del>RestServlet.createGuards(ObjectMap)</del>
				<li><del>RestServlet.createMimetypesFileTypeMap(ObjectMap)</del>
				<li><del>RestServlet.createResponseHandlers(ObjectMap)</del>
			</ul>
		</li>
		<li>New client-version annotations:
			<ul>
				<li><del>RestResource.clientVersionHeader</del> - The name of the header used to identify the client version.
				<li><del>RestMethod.clientVersion</del> - The client version range applied to a Java method.
			</ul>
		</li>
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest.client</h5>
	<ul class='spaced-list'>
		<li>Removed the <c>JazzRestClient</c> class.
		<li>New method <del>RestClient.setClientVersion(String)</del>.
	</ul>		
</div>
</div><!-- END: 6.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.0.1' id='6.0.1'>6.0.1 (Jan 3, 2017)</a></h3>
<div class='topic'><!-- START: 6.0.1 -->
<div class='topic'>
	<p>
		Juneau 6.0.1 is a minor update.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>General improvements to JSON parser.
			<ul>
				<li>Several fixes to handle obscure edge cases.
			</ul>
		<li>New properties in <del>ParserContext</del>.
			<ul>
				<li><del>ParserContext.PARSER_strict</del>
				<li><del>ParserContext.PARSER_inputStreamCharset</del>
				<li><del>ParserContext.PARSER_fileCharset</del>
			</ul>
		<li>Removed <c>JsonParserContext.JSON_strictMode</c>.  Replaced by <c>PARSER_strict</c>.		
		<li><c><jk>byte[]</jk></c> arrays can now be passed to {@link org.apache.juneau.parser.Parser#parse(Object,Class)} for reader-based parsers.	
	</ul>			
</div>
</div><!-- END: 6.0.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.1.0' id='6.1.0'>6.1.0 (Feb 25, 2017)</a></h3>
<div class='topic'><!-- START: 6.1.0 -->
<div class='topic'>
	<p>
		Juneau 6.1.0 is a major update.
	</p>
	<p>
		In particular, this release cleans up the {@link org.apache.juneau.BeanContext} API to match
		the <del>PropertyStore</del>/{@link org.apache.juneau.Context}/<del>Session</del> paradigm
		previously used in the serializer and parser APIs.
		It also makes several improvements to the HTML and XML serialization support and introduces HTML5 DTO beans.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>Improvements to XML serialization support.
			<ul>
				<li>New supported XML formats:
				<ul>
					<li>{@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS} format can now be applied to bean classes to have all bean properties serialized
						as attributes instead of elements by default.
					<li>{@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENT} format can now be applied to bean properties to override the {@link org.apache.juneau.xml.annotation.XmlFormat#ATTRS}
						setting above on specific bean properties.
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#ELEMENTS} format can be applied to a bean property of type array/Collection to represent the child elements.
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED} format can be applied to a bean property of type array/Collection to represent mixed content (text + child elements).
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#MIXED_PWS} format.  Identical to <jsf>MIXED</jsf> except preserves whitespace.
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} format can be applied to a bean property of a single object to represent a text node as a child.
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT_PWS} format.  Identical to <jsf>TEXT</jsf> except preserves whitespace.
					<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#XMLTEXT} format that's identical to {@link org.apache.juneau.xml.annotation.XmlFormat#TEXT} except 
						XML content is not escaped and serialized directly as the child content.  The parser will reconvert this to the original XML text during parsing.
				</ul>
				<li>New support methodology and other improvements to <del>xml</del> documentation.
				<li>Eliminated unnecessary <xt>&lt;string&gt;</xt> elements.
				<li>Eliminated <del>XmlContentHandler</del> class.
				<li>Parser efficiency improvements through reuse of string builders.
				<li>Reworked and simplified the default XML serializers.  The {@link org.apache.juneau.xml.XmlSerializer#DEFAULT} serializer now has namespaces disabled,
					and {@link org.apache.juneau.xml.XmlSerializer#DEFAULT_NS} has namespaces enabled.  The 'XML-JSON' serializers have been eliminated.
				<li>Eliminated the <c>addJsonTypeAttrs</c> and <c>addJsonStringTypeAttrs</c> settings.
				<li>Namespace support is now disabled by default.
			</ul>
		<li>Significant modifications and improvements to HTML serialization support.
			<ul>
				<li>Parser converted from <c>XMLEventReader</c>-based to <c>XMLStreamReader</c>.
				<li>Eliminated many unnecessary type tags and <xt>&lt;string&gt;</xt> elements and improved the readable layout.  
					The new format is much leaner.
				<li>New exhaustive support methodology section added to <del>html</del> documentation.
			</ul>
		<li>New HTML5 DTO support:  <del>html5</del>.
		<li>{@link org.apache.juneau.BeanContext} class split into separate {@link org.apache.juneau.BeanContext} and {@link org.apache.juneau.BeanSession} classes.
		<ul>
			<li>Session object meant to be single-use that can be discarded after use and contains session-level object cache and overridable Locale and TimeZone.
		</ul>  
		<li><del>SerializerContext</del> and <del>ParserContext</del>
			now extend directly from {@link org.apache.juneau.BeanContext}.
		<li>{@link org.apache.juneau.serializer.SerializerSession} and {@link org.apache.juneau.parser.ParserSession}
			now extend directly from {@link org.apache.juneau.BeanSession}.
		<li>New settings in {@link org.apache.juneau.BeanContext}:
		<ul>
			<li><del>BEAN_debug</del> - Debug setting.  Replaces individual debug properties in the serializer and parser contexts.
			<li><del>BEAN_locale</del> - Specifies a default locale at the context level.
			<li><del>BEAN_timeZone</del> - Specifies a default timezone at the context level.
			<li><del>BEAN_mediaType</del> - Specifies a default media type at the context level.
		</ul>
		<li>Improvements to Parser class:  
		<ul>
			<li>Simplified the parse methods (e.g. <c>parseMap()</c>, <c>parseCollection()</c>)
			by replacing them with two simple methods: 
			<ul>
				<li>{@link org.apache.juneau.parser.Parser#parse(Object,Class)} - Normal method.
				<li>{@link org.apache.juneau.parser.Parser#parse(Object,Type,Type...)} - Method for parsing into parameterized maps and collections.
			</ul>
			Using these methods, you can construct arbitrarily complex objects consisting of maps and collections.
			You could do this before but it required constructing a <c>ClassMeta</c> object.  
			<br>For example:
				<p class='bcode'>
		<jc>// Old way:</jc>
		ClassMeta&lt;?&gt; cm = parser.getMapClassMeta(
			HashMap.<jk>class</jk>, 
			String.<jk>class</jk>, 
			parser.getCollectionClassMeta(
				LinkedList.<jk>class</jk>, 
				MyBean.<jk>class</jk>
			)
		);
		Map&lt;String,List&lt;MyBean&gt;&gt; map = (Map&lt;String,List&lt;MyBean&gt;&gt;)parser.parse(input, cm);	
		
		<jc>// New way:</jc>
		Map&lt;String,List&lt;MyBean&gt;&gt; map = parser.parse(input, HashMap.<jk>class</jk>, String.<jk>class</jk>, LinkedList.<jk>class</jk>, MyBean.<jk>class</jk>);
				</p>
			<li>Arbitrarily-complex parameterized maps and collections can now be parsed without the need for creating intermediate <c>ClassMeta</c> objects.
			<li>No need for casting anymore if you were using the old <c>parseMap()</c> and <c>parseCollection()</c> methods!
			<li>Changes allow me to eliminate <c>BeanContext.normalizeClassMeta()</c> method.
			<li>Convenience methods added for setting parser properties:
				<p class='bcode'>
		<jc>// Old way:</jc>
		<jk>new</jk> JsonParser().setProperty(<jsf>PARSER_strict</jsf>, <jk>true</jk>).setProperty(<jsf>BEAN_locale</jsf>, mylocale);
		
		<jc>// New way:</jc>
		<jk>new</jk> JsonParser().setStrict(<jk>true</jk>).setLocale(mylocale);
				</p>
		</ul>
		<li>Improvements to Serializer class:
		<ul>
			<li>Convenience methods added for setting serializer properties:
				<p class='bcode'>
		<jc>// Old way:</jc>
		<jk>new</jk> JsonSerializer().setProperty(<jsf>JSON_simpleMode</jsf>, <jk>true</jk>).setProperty(<jsf>SERIALIZER_quoteChar</jsf>, <js>'"'</js>);
		
		<jc>// New way:</jc>
		<jk>new</jk> JsonSerializer().setSimpleMode(<jk>true</jk>).setQuoteChar(<js>'"'</js>);
				</p>
		</ul>
		<li>Simplified <del>PojoSwap</del> class.  Now just two methods:
		<ul>
			<li><del>PojoSwap.swap(BeanSession,Object)</del>
			<li><del>PojoSwap.unswap(BeanSession,Object,ClassMeta)</del>
		</ul>
		<li>General code improvements made to {@link org.apache.juneau.ClassMeta} class.
		<ul>
			<li>All fields are now final which should improve overall performance.
			<li>Replaced support for <c>toObjectMap()</c> and <c>fromObjectMap()/T(ObjectMap)</c> methods with
				generalized <c>swap(BeanSession)</c>/<c>unswap(BeanSession,X)</c>/<c>T(BeanSession,X)</c> methods.<br>
				See new section <dc>Swap methods</dc> for information.
		</ul>
		<li>Session-level media type now available through {@link org.apache.juneau.BeanSession#getMediaType()} method.
			Allows for swaps and serializer/parser behavior to be tailored to individual media types.
		<li>Several new {@link java.util.Calendar} and {@link java.util.Date} swaps:
		<ul>
			<li><del>ToString</del>,<del>ToString</del> - To {@link java.lang.String Strings} using the {@code Date.toString()} method.
			<li><del>ISO8601DT</del>,<del>ISO8601DT</del> - To ISO8601 date-time strings.
			<li><del>ISO8601DTZ</del>,<del>ISO8601DTZ</del> - Same as <jsf>ISO8601DT</jsf>, except always serializes in GMT.
			<li><del>ISO8601DTP</del>,<del>ISO8601DTP</del> - Same as <jsf>ISO8601DT</jsf> except with millisecond precision.
			<li><del>ISO8601DTPZ</del>,<del>ISO8601DTPZ</del> - Same as <jsf>ISO8601DTZ</jsf> except with millisecond precision.
			<li><del>RFC2822DT</del>,<del>RFC2822DT</del> - To RFC2822 date-time strings.
			<li><del>RFC2822DTZ</del>,<del>RFC2822DTZ</del> - Same as <jsf>RFC2822DT</jsf>, except always serializes in GMT.
			<li><del>RFC2822D</del>,<del>RFC2822D</del> - To RFC2822 date strings.
			<li><del>DateTimeSimple</del>,<del>DateTimeSimple</del> - To simple <js>"yyyy/MM/dd HH:mm:ss"</js> date-time strings.
			<li><del>DateSimple</del>,<del>DateSimple</del> - To simple <js>"yyyy/MM/dd"</js> date strings.
			<li><del>TimeSimple</del>,<del>TimeSimple</del> - To simple <js>"HH:mm:ss"</js> time strings.
			<li><del>DateFull</del>,<del>DateFull</del> - To {@link java.text.DateFormat#FULL} date strings.
			<li><del>DateLong</del>,<del>DateLong</del>- To {@link java.text.DateFormat#LONG} date strings.
			<li><del>DateMedium</del>,<del>DateMedium</del> - To {@link java.text.DateFormat#MEDIUM} date strings.
			<li><del>DateShort</del>,<del>DateShort</del>- To {@link java.text.DateFormat#SHORT} date strings.
			<li><del>TimeFull</del>,<del>TimeFull</del> - To {@link java.text.DateFormat#FULL} time strings.
			<li><del>TimeLong</del>,<del>TimeLong</del>- To {@link java.text.DateFormat#LONG} time strings.
			<li><del>TimeMedium</del>,<del>TimeMedium</del> - To {@link java.text.DateFormat#MEDIUM} time strings.
			<li><del>TimeShort</del>,<del>TimeShort</del>- To {@link java.text.DateFormat#SHORT} time strings.
			<li><del>DateTimeFull</del>,<del>DateTimeFull</del> - To {@link java.text.DateFormat#FULL} date-time strings.
			<li><del>DateTimeLong</del>,<del>DateTimeLong</del>- To {@link java.text.DateFormat#LONG} date-time strings.
			<li><del>DateTimeMedium</del>,<del>DateTimeMedium</del> - To {@link java.text.DateFormat#MEDIUM} date-time strings.
			<li><del>DateTimeShort</del>,<del>DateTimeShort</del>- To {@link java.text.DateFormat#SHORT} date-time strings.
		</ul>  
		<li>New method <del>SerializerGroup.getSerializerMatch(String)</del>that returns the matched serializer and media type.
		<li>New method <del>ParserGroup.getParserMatch(String)</del>that returns the matched parser and media type.
		<li>New method <del>EncoderGroup.getEncoderMatch(String)</del>that returns the matched encoder and encoding.
		<li>General improvements to Bean Dictionary support.
			<ul>
				<li>New {@link org.apache.juneau.BeanDictionaryList} class can be used for defining reusable sets of bean dictionaries consisting
					of classes annotated with {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)}.
				<li>New {@link org.apache.juneau.BeanDictionaryMap} class can be used for defining reusable sets of bean dictionaries consisting
					of classes not annotated with {@link org.apache.juneau.annotation.Bean#typeName() @Bean(typeName)}.
				<li>New <del>@Bean(beanDictionary)</del> annotation.
			</ul>
		<li>Removed restriction on getters and setters to be prefixed with "getX/setX/isX" if a <del>@BeanProperty(name)</del> annotation is used.
		<li>Improvements to ATOM DTO:
			<ul>
				<li>New {@link org.apache.juneau.dto.atom.AtomBuilder} class.
				<li>New setter method names for a better fluent design.
				<li>Updated <del>atom</del> documentation.
			</ul>
		<li>New <del>MapSwap</del> and <del>StringSwap</del> classes.
		<li>New {@link org.apache.juneau.serializer.WriterSerializer#println(Object)} method.  Useful for debugging purposes.
		<li>New {@link org.apache.juneau.BeanContext#getClassMeta(Type,Type...)} and {@link org.apache.juneau.BeanSession#getClassMeta(Type,Type...)}
			methods for retrieving Map and Collection class metas.  
			Replaces the various <c>getMapClassMeta()</c>/<c>getCollectionClassMeta()</c> methods.  
		<li>New section added to this document:	<dc>Juneau Data Transfer Objects (org.apache.juneau.dto)</dc>
		<li>Modified the UON specification to work with mixed content.
		<ul>
			<li>The new specification is considerably cleaner and eliminates the need for separate normal/simple modes.
				<br>It also allows for arbitrary whitespace to be added to the output without any confusion.
			<li>Eliminated the <c>UonParser.<jsf>DEFAULT_WS_AWARE</jsf></c> and <c>UrlEncodingParser.<jsf>DEFAULT_WS_AWARE</jsf></c> parsers.
				<br>The normal {@link org.apache.juneau.uon.UonParser#DEFAULT} and {@link org.apache.juneau.urlencoding.UrlEncodingParser#DEFAULT} parsers will now handle whitespace.
			<li>Eliminated the <c>UonParserContext.<jsf>UON_whitespaceAware</jsf></c> configuration setting.
			<li>Eliminated the <c>UonSerializer.<jsf>DEFAULT_SIMPLE</jsf></c>, <c>UonSerializer.<jsf>DEFAULT_SIMPLE_ENCODING</jsf></c>
				and <c>UrlEncodingSerializer.<jsf>DEFAULT_SIMPLE</jsf></c>
				serializers since there is no separate simple mode anymore.
			<li>Eliminated the <c>UonParserContext.<jsf>UON_simpleMode</jsf></c> configuration setting.
		</ul>
		<li>Added new <del>OutputStreamSerializer.serializeToHex(Object)</del>method. 
			<br>Useful mostly for testing purposes.
			<br>Equivalently, the {@link org.apache.juneau.parser.InputStreamParser#parse(Object,Class)} method can now 
				read the output from this method.
		<li>Eliminated the <c><ja>@Bean</ja>(subTypeProperty)</c> and <c><ja>@Bean</ja>(subTypes)</c> annotations
			and replaced them with the ability to define subtypes using the existing <del>@Bean(beanDictionary)</del>
			annotation on parent classes and interfaces.
			<br>This has the added benefit of simplifying the overall code.
		<li>The <del>SerializerContext.SERIALIZER_addBeanTypeProperties</del>setting is now enabled by default.
		<li>Combined the <c>SERIALIZER_addIndentation</c>/<c>JSON_addWhitespace</c>/<c>UON_addWhitespace</c>
			properties into a single <del>SerializerContext.SERIALIZER_useWhitespace</del>setting.
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest</h5>
	<ul class='spaced-list'>
		<li>{@link org.apache.juneau.rest.RestRequest} now passes locale and timezone to serializers/parsers/transforms.
		<li><del>RestRequest.getTimeZone()</del>method.
		<li>Standardized the following methods in {@link org.apache.juneau.rest.RestRequest} to remove dependency on <c>ClassMeta</c>
			objects and eliminate the need for casts:
			<ul>
				<li><del>RestRequest.getHeader(String,Class)</del>
				<li><del>RestRequest.getHeader(String,Object,Class)</del>
				<li><del> RestRequest.getHeader(String,Type,Type...)</del>
				<li><del>RestRequest.getQueryParameter(String,Class)</del>
				<li><del>RestRequest.getQueryParameter(String,Object,Class)</del>
				<li><del> RestRequest.getQueryParameter(String,Type,Type...)</del>
				<li><del> RestRequest.getQueryParameter(String,Object,Type,Type...)</del>
				<li><del>RestRequest.getQueryParameters(String,Class)</del>
				<li><del> RestRequest.getQueryParameters(String,Type,Type...)</del>
				<li><del>RestRequest.getFormDataParameter(String,Class)</del>
				<li><del>RestRequest.getFormDataParameter(String,Object,Class)</del>
				<li><del>RestRequest.getFormDataParameters(String,Class)</del>
				<li><del> RestRequest.getFormDataParameter(String,Type,Type...)</del>
				<li><del> RestRequest.getFormDataParameters(String,Type,Type...)</del>
				<li><del>RestRequest.getPathParameter(String,Class)</del>
				<li><del> RestRequest.getPathParameter(String,Type,Type...)</del>
				<li><del>RestRequest.getBody(Class)</del>
				<li><del> RestRequest.getBody(Type,Type...)</del>
			</ul>
		<li>New methods on <del>NameValuePairs</del>
		<li>Fixed issue where whitespace was not added to UON/URL-Encoding output when <c>&amp;plainText=true</c> specified.
	</ul>
</div>
</div><!-- END: 6.1.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.2.0' id='6.2.0'>6.2.0 (Apr 28, 2017)</a></h3>
<div class='topic'><!-- START: 6.2.0 -->
<div class='topic'>
	<p>
		Juneau 6.2.0 is a major update.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>
			Revamped the serializer, parser classes to use builders for creation.
			Serializers and parsers are now unmodifiable objects once they are created.
			This is a breaking code change that will require adoption.
			<p class='bcode'>
		<jc>/* Creating a new serializer or parser */ </jc>
		
		<jc>// Old way</jc>
		WriterSerializer s = <jk>new</jk> JsonSerializer().setUseWhitespace(<jk>true</jk>).pojoSwaps(BSwap.<jk>class</jk>).lock();
	
		<jc>// New way</jc>
		WriterSerializer s = JsonSerializer.<jsm>create</jsm>().ws().pojoSwaps(BSwap.<jk>class</jk>).build();
	
		<jc>/* Cloning an existing serializer or parser */ </jc>
		
		<jc>// Old way</jc>
		WriterSerializer s = SimpleJsonSerializer.<jsf>DEFAULT</jsf>
	.clone().setUseWhitespace(<jk>true</jk>).pojoSwaps(BSwap.<jk>class</jk>).lock();
	
		<jc>// New way</jc>
		WriterSerializer s = SimpleJsonSerializer.<jsf>DEFAULT</jsf>
	.builder().ws().pojoSwaps(BSwap.<jk>class</jk>).build();
			</p>	
		<li>Also introduced the following builder classes and related architecture changes to make the built objects unmodifiable:
			<ul>
				<li><del>Builder</del>
				<li><del>Builder</del>
				<li><del>Builder</del>
			</ul>
		<li>Revamped the config file API to use a build:  <del>ConfigFileBuilder</del>.
		<li>Removed the <del>Lockable</del> interface.
		<li>New <c>addBeanTypeProperties</c> setting added to serializers to override the 
			<del>SerializerContext.SERIALIZER_addBeanTypeProperties</del>setting
			for individual serializers in a serializer group:
			<ul>
				<li><del>HtmlSerializerContext.HTML_addBeanTypeProperties</del>
				<li><del>JsonSerializerContext.JSON_addBeanTypeProperties</del>
				<li><del>MsgPackSerializerContext.MSGPACK_addBeanTypeProperties</del>
				<li><del>UonSerializerContext.UON_addBeanTypeProperties</del>
				<li><del>XmlSerializerContext.XML_addBeanTypeProperties</del>
				<li><del>RdfSerializerContext.RDF_addBeanTypeProperties</del>
			</ul>
		<li>UON notation serializers and parsers moved into the new <c>org.apache.juneau.uon</c> package.
		<li>New {@link org.apache.juneau.xml.annotation.XmlFormat#VOID} format to identify HTML void elements.
		<li>Tweaks to HTML5 support.
			<ul>
				<li>Fixed handling of empty non-void elements in HTML serializer.
				<li>Added <c>style()</c> override methods to all elements.
			</ul>
		<li>Improvements to Swagger support.
			<ul>
				<li>New {@link org.apache.juneau.dto.swagger.SwaggerBuilder} class.
				<li>Fluent-style setters added to the Swagger beans.
				<li>Added Swagger examples <del>here</del> and in the <del>swagger</del> javadocs.
			</ul>
		<li>Improvements to {@link org.apache.juneau.svl.VarResolver}.
			<ul>
				<li>New {@link org.apache.juneau.svl.vars.IfVar $IF} variable for if-else block logic.
				<li><dc>$SWITCH</dc> variable for switch block logic.
				<li>Whitespace wasn't being ignored in some cases.
			</ul>
		<li>{@link org.apache.juneau.html.HtmlParser} can now parse full body contents generated by {@link org.apache.juneau.html.HtmlDocSerializer}. 
		<li>Parse-args supported added to {@link org.apache.juneau.msgpack.MsgPackParser} to allow it to be used in remoteable proxies. 
		<li>Added some convenience classes for constructing collections using a fluent interface:
			<ul>
				<li><del>AList</del>
				<li><del>ASet</del>
				<li><del>AMap</del>
			</ul>
		<li>New {@link org.apache.juneau.annotation.Bean#typePropertyName @Bean(typePropertyName)} annotation allows you to 
			specify the name of the <js>"_type"</js> property at the class level.
		<li>New methods added to HTML5 container beans:
			<ul>
				<li>{@link org.apache.juneau.dto.html5.HtmlElementContainer#getChild(int...)}
				<li>{@link org.apache.juneau.dto.html5.HtmlElementMixed#getChild(int...)}
			</ul>
		<li>New common serializer setting: <del>SerializerContext.SERIALIZER_abridged</del>.
		<li>Support for defining interface proxies against 3rd-party REST interfaces.
			<br>New package <del>remoteable</del>for all remoteable proxy interface annotations.
			<br><ja>@Remoteable</ja> annotation has been moved to this package.
		<li>Updated doc: <dc>6 - Remoteable Services</dc>
		<li>New doc: <dc>6.1 -  Interface proxies against 3rd-party REST interfaces</dc>
		<li>New URL-encoding serializer setting: <del>UrlEncodingSerializerContext.URLENC_paramFormat</del>.
		<li>New methods on {@link org.apache.juneau.urlencoding.UrlEncodingSerializer.Builder}:
		<ul>
			<li><del>Builder.paramFormat(String)</del>	
			<li><del>Builder.plainTextParams()</del>	
		</ul> 		
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest</h5>
	<ul class='spaced-list'>
		<li><del>@RestResource</del> annotation can now be applied to 
			any class!  You're no longer restricted to subclassing your resources from <del>RestServlet</del>.
			<br>This is a major enhancement in the API.  Anything you could do by subclassing from <c>RestServlet</c>
			should have an equivalent for non-<c>RestServlet</c> classes.
			<br>The only restriction is that the top-level resource must subclass from <c>RestServlet</c>.
			Child resources do not.
			<br><br>
			The majority of code has been split up into two separate classes:
			<ul>
				<li><del>RestConfig</del> - A modifiable configuration of a resource.  Subclasses from {@link javax.servlet.ServletConfig}.
				<li>{@link org.apache.juneau.rest.RestContext} - A read-only configuration that's the result of a snapshot of the config.
			</ul>
			<br><br>
			The <del>RestServlet</del>class now has the following initialization method that allows you to override
			the config settings define via annotations:
			<ul>
				<li><del>RestServlet.init(RestConfig)</del> - A modifiable configuration of a resource.
			</ul>
			Non-<c>RestServlet</c> classes must have one of the following to allow it to be instantiated:
			<ul>
				<li>A <c><jk>public</jk> T(RestConfig)</c> constructor.
				<li>A <c><jk>public</jk> T()</c> constructor.
				<li>The parent resource must have a customized <del>RestResourceResolver</del> for instantiating it.
			</ul>
			<br>
			Non-<c>RestServlet</c> classes can optionally include the following init methods to gain access to the config and context:
			<ul>
				<li><dc><jk>public</jk> init(RestConfig)</dc>
				<li><dc><jk>public</jk> init(RestContext)</dc>
			</ul>
		<li>New annotations added to <del>@RestResource</del>to allow non-<c>RestServlet</c>
			resources to do the same as subclassing directly from <c>RestServlet</c>:
			<ul>
				<li><del>RestResource.resourceResolver()</del> 
					- Specify a <del>RestResourceResolver</del>class for resolving child resources.
				<li><del>RestResource.callHandler()</del> 
					- Specify a <del>RestCallHandler</del>class for handling the lifecycle of a REST call.
				<li><del>RestResource.infoProvider()</del> 
					- Specify a <del>RestInfoProvider</del>class for customizing title/description/Swagger information on a REST resource.
				<li><del>RestResource.logger()</del> 
					- Specify a <del>RestLogger</del> class for handling logging.
			</ul>
		<li>New annotations added to <del>@RestResource</del> and <del>RestMethod @RestMethod</del>
			to simplify defining page title, text, and links on HTML views:
			<ul>
				<li><del>@RestResource(pageTitle)</del>
				<li><del>@RestMethod(pageTitle)</del> 
				<li><del>@RestResource(pageText)</del> 
				<li><del>@RestMethod(pageText)</del> 
				<li><del>@RestResource(pageLinks)</del> 
				<li><del>@RestMethod(pageLinks)</del>
			</ul>				
			<p class='bcode'>
		<jc>// Old method</jc>
		<ja>@RestResource</ja>(
			properties={
				<ja>@Property</ja>(name=<jsf>HTMLDOC_title</jsf>, value=<js>"System properties resource"</js>),
				<ja>@Property</ja>(name=<jsf>HTMLDOC_description</jsf>, value=<js>"REST interface for performing CRUD operations on system properties."</js>),
				<ja>@Property</ja>(name=<jsf>HTMLDOC_navlinks</jsf>, value=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS'}"</js>)
			}
		)
			
		<jc>// New method</jc>
		<ja>@RestResource</ja>(
			pageTitle=<js>"System properties resource"</js>,
			pageDescription=<js>"REST interface for performing CRUD operations on system properties."</js>,
			pageLinks=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS'}"</js>
		)
			</p>		
			<p>
				Typically you're going to simply want to use the <c>title</c> and <c>description</c> annotations
				which apply to both the page title/text and the swagger doc:		
			</p>
			<p class='bcode'>
		<ja>@RestResource</ja>(
			title=<js>"System properties resource"</js>,
			description=<js>"REST interface for performing CRUD operations on system properties."</js>,
			pageLinks=<js>"{up:'$R{requestParentURI}',options:'?method=OPTIONS'}"</js>
		)
			</p>
		<li><del>RestResource.stylesheet()</del> can now take in a comma-delimited list of stylesheet paths.
		<li><del>StreamResource</del> can now contain multiple sources from a variety of source types (e.g. <c><jk>byte</jk>[]</c> arrays, <c>InputStreams</c>, <c>Files</c>, etc...)
			and is now immutable.  It also includes a new <del>StreamResourceBuilder</del>class.
		<li>Simplified remoteable proxies using the <c><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</c> annotation on REST methods.
			Used to expose interface proxies without the need for <del>RemoteableServlet</del>.
		<p class='bcode'>
		<jc>// Server side</jc>
		<ja>@RestMethod</ja>(name=<js>"PROXY"</js>, path=<js>"/myproxy/*"</js>)
		<jk>public</jk> IAddressBook getProxy() {
			<jk>return</jk> <jf>addressBook</jf>;
		}
	
		<jc>// Client side</jc>
		RestClient client = RestClient.<jsm>create</jsm>().rootUrl(<jf>samplesUrl</jf>).build();			
		IAddressBook ab = client.getRemoteableProxy(IAddressBook.<jk>class</jk>, <js>"/addressBook/myproxy"</js>);
		</p>
			See <del>RestMethod.name() @RestMethod(name)</del>for more information.
		<li>{@link org.apache.juneau.rest.RestRequest#toString()} can be called at any time to view the headers and content of the request
			without affecting functionality.  Very useful for debugging.
		<li><del>RestMethod.name() @RestMethod(name)</del>annotation is now optional.  Defaults to <js>"GET"</js>.
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest.client</h5>
	<ul class='spaced-list'>
		<li>Revamped the client API to use builders.
		<li>New doc: <dc>1.5 - Debugging</dc>
		<li>The <c>RestClient</c> class <c>doX(Object url)</c> methods now handle HttpClient <c>URIBuilder</c> instances.
		<li>New methods added/updated to {@link org.apache.juneau.rest.client.RestClient}:
		<ul>
			<li><del>RestClient.getRemoteableProxy(Class,Object)</del>- For interface proxies defined using <c><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</c>.
			<li><del>RestClient.getRemoteableProxy(Class,Object,Serializer,Parser)</del>- Same as above but overrides the serializer and parser defined on the client.
			<li><del>RestClient.doPost(Object)</del>
			<li><del>RestClient.doCall(HttpMethod,Object,Object)</del> - Can now pass in instances of <del>NameValuePairs</del>for easy form posts.
				<br>This extends to all methods that take in the input.
		</ul>
		<li>New methods on <del>RestCall</del>:
			<ul>
				<li><del>RestCall.uri(Object) uri(Object)</del>
				<li><del>query(String,Object,boolean,PartSerializer)</del>
				<li><del>RestCall.query(String,Object) query(String,Object)</del>
				<li><del>RestCall.queryIfNE(String,Object) queryIfNE(String,Object)</del>
				<li><del>RestCall.query(Map) query(Map)</del>
				<li><del>RestCall.queryIfNE(Map) queryIfNE(Map)</del>
				<li><del>RestCall.query(String) query(String)</del>
				<li><del>formData(String,Object,boolean,PartSerializer)</del>
				<li><del>RestCall.formData(String,Object) formData(String,Object)</del>
				<li><del>RestCall.formDataIfNE(String,Object) formDataIfNE(String,Object)</del>
				<li><del>RestCall.formData(Map) formData(Map)</del>
				<li><del>RestCall.formDataIfNE(Map) formDataIfNE(Map)</del>
				<li><del>header(String,Object,boolean,PartSerializer)</del>
				<li><del>RestCall.header(String,Object) header(String,Object)</del>
				<li><del>RestCall.headerIfNE(String,Object) headerIfNE(String,Object)</del>
				<li><del>RestCall.headers(Map) headers(Map)</del>
				<li><del>RestCall.headersIfNE(Map) headersIfNE(Map)</del>
				<li><del>RestCall.host(String) host(String)</del>
				<li><del>RestCall.port(int) port(int)</del>
				<li><del>RestCall.userInfo(String,String) userInfo(String,String)</del>
				<li><del>RestCall.userInfo(String) userInfo(String)</del>
				<li><del>RestCall.scheme(String) scheme(String)</del>
			</ul>
		<li>New methods added to {@link org.apache.juneau.rest.client.RestClient.Builder}:
			<ul>
				<li>{@link org.apache.juneau.rest.client.RestClient.Builder#executorService(ExecutorService,boolean) executorService(ExecutorService,boolean)}
				<li><del>Builder.paramFormat(String)</del>
				<li><del>Builder.plainTextParams()</del>
				<li>{@link org.apache.juneau.rest.client.RestClient.Builder#noTrace() noTrace()} - Adds a <c>No-Trace: true</c> header on all requests to prevent
					the servlet from logging errors.
					<br>Useful for testing scenarios when you don't want the console to end up showing errors done on purpose.
				<li>{@link org.apache.juneau.rest.client.RestClient.Builder#debug() debug()} now adds a <c>Debug: true</c> header on all requests.
			</ul>
		<li>New methods added/updated to <del>RestCall</del>:
			<ul>
				<li><del>RestCall.runFuture() runFuture()</del>
				<li><del>RestCall.getResponseFuture(Class) getResponseFuture(Class)</del>
				<li><del> org.apache.juneau.rest.client.RestCall.getResponseFuture(Type,Type...) getResponseFuture(Type,Type...)</del>
				<li><del>RestCall.getResponseAsStringFuture() getResponseAsStringFuture()</del>
				<li><del>RestCall.serializer(Serializer) serializer(Serializer)</del>- Override the serializer defined on the client for a single call.
				<li><del>RestCall.parser(Parser) parser(Parser)</del> - Override the parser defined on the client for a single call.
				<li><del>input(Object)</del>- Now accepts instances of <del>NameValuePairs</del>.
				<li><del>RestCall.getResponse(Class) getResponse(Class)</del>- Can now pass in any of the following:
					<ul>
						<li>{@link org.apache.http.HttpResponse} - Returns the raw <c>HttpResponse</c> returned by the inner <c>HttpClient</c>.
						<li>{@link java.io.Reader} - Returns access to the raw reader of the response.
						<li>{@link java.io.InputStream} - Returns access to the raw input stream of the response.
					</ul>
			</ul>
		<li>New methods added to <del>NameValuePairs</del>:
			<ul>
				<li><del>NameValuePairs.append(String,Object) append(String,Object)</del>
				<li><del>append(String,Object,PartSerializer)</del>
			</ul>
		<li><del>RetryOn</del>is now an abstract class with an additional method:
			<ul>
				<li><del>RetryOn.onResponse(HttpResponse) onResponse(HttpResponse)</del>
			</ul>			
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.microservice</h5>
	<ul class='spaced-list'>
		<li><js>"REST/port"</js> configuration setting can now be a comma-limited list of port numbers to try.
			<br>You can also specify one or more <c>0</c>s to try a random port.
		<li>Methods added to <del>RestMicroservice</del>class:
		<ul>
			<li><del>getPort()</del>
			<li><del>getURI()</del>
			<li>Override methods added from {@link org.apache.juneau.microservice.Microservice} class for easier method chaining.
		</ul>
	</ul>		
</div>
</div><!-- END: 6.2.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.3.0' id='6.3.0'>6.3.0 (Jun 30, 2017)</a></h3>
<div class='topic'><!-- START: 6.3.0 -->
<div class='topic'>
	<p>
		Juneau 6.3.0 is a major update with significant new functionality for defining proxy interfaces against
		arbitrary 3rd-party REST interfaces.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>
			New package:  {@link org.apache.juneau.http}.
		<li>
			Support for dynamic beans.  See <del>@BeanProperty(name)</del>.
		<li>
			New doc: <dc>2.8 - Virtual Beans</dc>
		<li>
			New doc: <dc>2.13 - Comparison with Jackson</dc>
		<li>
			All parsers now allow for numeric types with <js>'K'</js>/<js>'M'</js>/<js>'G'</js> suffixes to represent
			kilobytes, megabytes, and gigabytes.
			<p class='bcode'>
		<jc>// Example</jc>
		<jk>int</jk> i = JsonParser.<jsf>DEFAULT</jsf>.parse(<js>"123M"</js>);  <jc>// 123MB</jc>
			</p>
		<li>New/modified methods on <del>ConfigFile</del>:
			<ul>
				<li><del>ConfigFile.put(String,String,String,boolean)</del>
				<li><del>ConfigFile.put(String,String,Object,Serializer,boolean,boolean)</del>
				<li><del> ConfigFile.getObject(String,Type,Type...)</del>
				<li><del> ConfigFile.getObject(String,Parser,Type,Type...)</del>
				<li><del>ConfigFile.getObject(String,Class)</del>
				<li><del>ConfigFile.getObject(String,Parser,Class)</del>
				<li><del> ConfigFile.getObject(String,String,Type,Type...)</del>
				<li><del> ConfigFile.getObject(String,String,Parser,Type,Type...)</del>
				<li><del>ConfigFile.getObject(String,String,Class)</del>
				<li><del>ConfigFile.getObject(String,String,Parser,Class)</del>
				<li><del> ConfigFile.getObjectWithDefault(String,Object,Type,Type...)</del>
				<li><del> ConfigFile.getObjectWithDefault(String,Parser,Object,Type,Type...)</del>
				<li><del>ConfigFile.getObjectWithDefault(String,Object,Class)</del>
				<li><del>ConfigFile.getObjectWithDefault(String,Parser,Object,Class)</del>
			</ul>
		<li>New ability to interact with config file sections with proxy interfaces with new method <del>ConfigFile.getSectionAsInterface(String,Class)</del>.
		<li><del>@BeanProperty</del>annotation can now be applied to getters
			and setters defined on interfaces.
		<li>New methods on {@link org.apache.juneau.serializer.SerializerSession} and {@link org.apache.juneau.parser.ParserSession}
			for retrieving context and runtime-override properties:
			<ul>
				<li><del>Session.getProperty(String)</del>
				<li><del>Session.getProperty(String,String)</del>
				<li><del>Session.getProperty(Class,String)</del>
				<li><del>Session.getProperty(Class,String,Object)</del>
			</ul>	
		<li>New <del>PartSerializer</del>interface particularly tailored to HTTP
			headers, query parameters, form-data parameters, and path variables.  
			<br>Allows easy user-defined serialization of these objects.
			<br>The interface can be used in the following locations:
			<ul>
				<li><del>Builder.partSerializer(Class)</del>
				<li><del>Path.serializer</del>
				<li><del>Query.serializer</del>
				<li><del>QueryIfNE.serializer</del>
				<li><del>FormData.serializer</del>
				<li><del>FormDataIfNE.serializer</del>
				<li><del>Header.serializer</del>
				<li><del>HeaderIfNE.serializer</del>
			</ul>
		<li>Across-the-board improvements to the URI-resolution support (i.e. how URIs get serialized).
			<ul>
				<li>New support for resolving URIs with the following newly-recognized protocols:
					<ul>
						<li><js>"context:/..."</js> - Relative to context-root of the application.
						<li><js>"servlet:/..."</js> - Relative to the servlet URI.
						<li><js>"request:/..."</js> - Relative to the request URI.
					</ul>
					For example, currently we define HTML page links using variables and servlet-relative URIs...
					<p class='bcode'>
		pages=<js>"{up:'$R{requestParentURI}', options:'?method=OPTIONS', upload:'upload'}"</js>
					</p>
					With these new protocols, we can define them like so:
					<p class='bcode'>
		links=<js>"{top:'context:/', up:'request:/..' ,options:'servlet:/?method=OPTIONS', upload:'servlet:/upload'}"</js>
					</p>
					The old method of using variables and servlet-relative URIs will still be supported but using 
					these new protocols should (hopefully) be easier to understand.
					<br>
					These protocols work on all serialized URL and URI objects, as well as classes and properties 
					annotated with <del>URI @URI</del>.
				<li>New classes:
					<ul>
						<li>{@link org.apache.juneau.UriContext}
						<li>{@link org.apache.juneau.UriRelativity}
						<li>{@link org.apache.juneau.UriResolution}
						<li>{@link org.apache.juneau.UriResolver}
					</ul>
				<li>New configuration properties:
					<li><del>SerializerContext.SERIALIZER_uriContext</del>
					<li><del>SerializerContext.SERIALIZER_uriRelativity</del>
					<li><del>SerializerContext.SERIALIZER_uriResolution</del>
					<li><del>SerializerContext.SERIALIZER_maxIndent</del>
			</ul>
		<li>New annotation property: <del>@BeanProperty(value)</del>.
			<br>The following two annotations are considered equivalent:
			<p class='bcode'>
		<ja>@BeanProperty</ja>(name=<js>"foo"</js>)
		
		<ja>@BeanProperty</ja>(<js>"foo"</js>)
			</p>
		<li>Fixed a race condition in ClassMeta.
		<li><jsf>URLENC_paramFormat</jsf> has been moved to <del>UonSerializer.UON_paramFormat</del>, 
			and the UON/URL-Encoding serializers will now always serialize all values as plain text.
			<br>This means that arrays and maps are converted to simple comma-delimited lists.
		<li>Listener APIs added to serializers and parsers:
			<ul>
				<li>{@link org.apache.juneau.serializer.SerializerListener}
				<li>{@link org.apache.juneau.serializer.Serializer.Builder#listener(Class)}
				<li><del>@RestResource(serializerListener)</del>
				<li><del>RestConfig.serializerListener(Class)</del>
				<li>{@link org.apache.juneau.parser.ParserListener}
				<li>{@link org.apache.juneau.parser.Parser.Builder#listener(Class)}
				<li><del>@RestResource(parserListener)</del>
				<li><del>RestConfig.parserListener(Class)</del>
				<li><del>Builder.listeners(Class,Class)</del>
			</ul>juneau-examples-core.import1.pngjuneau-examples-core.import1.png
		<li>The <del>BEAN_debug</del>flag will now capture parser input and make it
			available through the <del>ParserSession.getInputAsString()</del>method so that it can be used
			in the listeners.
		<li>Significant new functionality introduced to the HTML serializer.  
			<br>Lots of new options for customizing the HTML output.
			<ul>
				<li>New {@link org.apache.juneau.html.annotation.Html#render() @Html(render)} annotation and {@link org.apache.juneau.html.HtmlRender} class that allows you
					to customize the HTML output and CSS style on bean properties:
					<br><img class='bordered' src='doc-files/ReleaseNotes.630.1.png'>
					<br>Annotation can be applied to POJO classes and bean properties.
				<li>Several new properties for customizing parts of the HTML page:
					<ul>
						<li><del>HtmlDocSerializerContext.HTMLDOC_title</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_description</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_branding</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_header</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_nav</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_aside</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_footer</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_noResultsMessage</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_cssUrl</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_css</del>
						<li><del>HtmlDocSerializerContext.HTMLDOC_template</del>
					</ul>
				<li>New interface {@link org.apache.juneau.html.HtmlDocTemplate} that allows full control over rendering
					of HTML produced by {@link org.apache.juneau.html.HtmlDocSerializer}.
				
			</ul>
		<li>{@link org.apache.juneau.annotation.NameProperty @NameProperty} and {@link org.apache.juneau.annotation.ParentProperty @ParentProperty}
			can now be applied to fields.  
		<li>New properties on {@link org.apache.juneau.BeanContext}:
			<ul>
				<li><del>BEAN_includeProperties</del>
				<li><del>BEAN_excludeProperties</del>
			</ul>
		<li>New annotation property: <del>@BeanProperty(format)</del>.
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest</h5>
	<ul class='spaced-list'>
		<li>
			MAJOR enhancements made to the REST API.
		<li>
			The {@link org.apache.juneau.rest.RestRequest} class functionality has been broken up into the following
			functional pieces to reduce its complexity:
			<ul>
				<li><del>RestRequest.getBody()</del>- The request body.
				<li>{@link org.apache.juneau.rest.RestRequest#getHeaders()} - The request headers.
				<li><del>RestRequest.getQuery()</del>- The request query parameters.
				<li><del>RestRequest.getFormData()</del>- The request form data parameters.
				<li><del>RestRequest.getPathMatch()</del> - The path variables and remainder.
			</ul>	
			The following classes have been introduced:
			<ul>
				<li><del>RequestBody</del>
				<li><del>RequestHeaders</del>
				<li><del>RequestQuery</del>
				<li><del>RequestFormData</del>
				<li><del>RequestPath</del>
			</ul>						
		<li>
			The un-annotated parameter types that can be passed in through REST Java methods has been significantly expanded.
			<br>For reference, the previous supported types were:
			<ul>
				<li>{@link org.apache.juneau.rest.RestRequest} - The request object.
				<li>{@link javax.servlet.http.HttpServletRequest} - The superclass of <c>RestRequest</c>.
				<li>{@link org.apache.juneau.rest.RestResponse} - The response object.
				<li>{@link javax.servlet.http.HttpServletResponse} - The superclass of <c>RestResponse</c>.
			</ul>
			The new supported types are:
			<ul>
				<li><del>Accept</del>
				<li><del>AcceptCharset</del>
				<li><del>AcceptEncoding</del>
				<li><del>AcceptLanguage</del>
				<li><del>Authorization</del>
				<li><del>CacheControl</del>
				<li><del>Connection</del>
				<li><del>ContentLength</del>
				<li><del>ContentType</del>
				<li><del>Date</del>
				<li><del>Expect</del>
				<li><del>From</del>
				<li><del>Host</del>
				<li><del>IfMatch</del>
				<li><del>IfModifiedSince</del>
				<li><del>IfNoneMatch</del>
				<li><del>IfRange</del>
				<li><del>IfUnmodifiedSince</del>
				<li><del>MaxForwards</del>
				<li><del>Pragma</del>
				<li><del>ProxyAuthorization</del>
				<li><del>Range</del>
				<li><del>Referer</del>
				<li><del>TE</del>
				<li><del>UserAgent</del>
				<li><del>Upgrade</del>
				<li><del>Via</del>
				<li><del>Warning</del>
				<li>{@link java.util.TimeZone}
				<li>{@link java.io.InputStream}
				<li>{@link javax.servlet.ServletInputStream}
				<li>{@link java.io.Reader}
				<li>{@link java.io.OutputStream}
				<li>{@link javax.servlet.ServletOutputStream}
				<li>{@link java.io.Writer}
				<li>{@link java.util.ResourceBundle} - Client-localized resource bundle.
				<li><del>MessageBundle</del> - A resource bundle with additional features.
				<li>{@link java.util.Locale} - Client locale.
				<li><del>RequestHeaders</del> - API for accessing request headers.
				<li><del>RequestQuery</del> - API for accessing request query parameters.
				<li><del>RequestFormData</del> - API for accessing request form data.
				<li><del>RequestPath</del> - API for accessing path variables.
				<li><del>RequestBody</del> - API for accessing request body.
				<li>{@link org.apache.juneau.http.HttpMethod} - The method name matched (when using <c><ja>@RestMethod</ja>(name=<js>"*"</js>)</c>)
				<li>{@link java.util.logging.Logger} - The logger to use for logging.
				<li><del>JuneauLogger</del> - Logger with additional features.
				<li>{@link org.apache.juneau.rest.RestContext} - The resource read-only context.
				<li>{@link org.apache.juneau.parser.Parser} - The parser matching the request content type.
				<li>{@link org.apache.juneau.dto.swagger.Swagger} - The auto-generated Swagger doc.
				<li><del>ConfigFile</del>- The external config file for the resource.
			</ul>
			So, for example...
			<p class='bcode'>
		<jd>/** Old way */</jd> 
		<ja>@RestMethod</ja>(name=<js>"*"</js>, path=<js>"/example1/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public</jk> String example1( 
			<ja>@Method</ja> String method, 
			<ja>@Path</ja>(<js>"a1"</js>) String a1, 
			<ja>@Path</ja>(<js>"a2"</js>) <jk>int</jk> a2, 
			<ja>@Path</ja>(<js>"a3"</js>) UUID a3, 
			<ja>@Query</ja>(<js>"p1"</js>) <jk>int</jk> p1, 
			<ja>@Query</ja>(<js>"p2"</js>) String p2, 
			<ja>@Query</ja>(<js>"p3"</js>) UUID p3, 
			<ja>@Header</ja>(<js>"Accept-Language"</js>) String lang, 
			<ja>@Header</ja>(<js>"Accept"</js>) String accept 
		) 
	
		<jd>/** New way */</jd> 
		<ja>@RestMethod</ja>(name=<js>"*"</js>, path=<js>"/example2/{a1}/{a2}/{a3}/*"</js>) 
		<jk>public</jk> String example2(
			HttpMethod httpMethod,
			RequestPathParams pathParams,
			RequestQuery query,
			AcceptLanguage acceptLanguage,
			Accept accept
		)
			</p>
		<li>
			A new annotation <del>@RestResource(paramResolvers)</del>}
			that allows you to define your own custom Java method parameter resolvers.
		<li>
			Fixed bug where Writer returned by {@link org.apache.juneau.rest.RestResponse#getWriter()} was not being flushed automatically
			at the end of the HTTP call.
		<li>
			New annotations added to <del>RestMethod @RestMethod</del>:
			<ul>
				<li><del>RestMethod.defaultQuery() defaultQuery()</del>
				<li><del>RestMethod.defaultFormData() defaultFormData()</del>
				<li><del>bpIncludes()</del>
				<li><del>bpExcludes()</del>
			</ul>
		<li>
			Default values on header, query, and form-data annotations:
			<ul>
				<li><del>@Header(def)</del> - Default header value.
				<li><del>@Query(def)</del> - Default query parameter value.
				<li><del>@FormData(def)</del>- Default form data parameter value.
			</ul>
		<li>
			New attributes on <del>@RestResource</del>:
			<ul>
				<li><del>serializerListener()</del>
				<li><del>parserListener()</del>
				<li><del>widgets()</del>
				<li><del>swagger()</del>
				<li><del>htmldoc()</del>
			</ul>
		<li>
			New attributes on <del>RestMethod @RestMethod</del>:
			<ul>
				<li><del>widgets()</del>
				<li><del>RestMethod.swagger() swagger()</del>
				<li><del>RestMethod.htmldoc() htmldoc()</del>
			</ul>
		<li>
			New string vars:
			<ul>
				<li>{@link org.apache.juneau.rest.vars.UrlVar} - Resolve <js>"$U{...}"</js> variables to URLs.
				<li><del>WidgetVar</del>- Resolve <js>"$W{...}"</js> variables to widget contents.
			</ul>
		<li>
			New methods on <del>RestConfig</del>:
			<ul>
				<li><del>setHtmlTitle(String)</del>
				<li><del>setHtmlDescription(String)</del>
				<li><del>setHtmlBranding(String)</del>
				<li><del>setHtmlHeader(String)</del>
				<li><del>setHtmlLinks(String)</del>
				<li><del>setHtmlNav(String)</del>
				<li><del>setHtmlAside(String)</del>
				<li><del>setHtmlFooter(String)</del>
				<li><del>setHtmlCss(String)</del>
				<li><del>setHtmlCssUrl(String)</del>
				<li><del>setHtmlNoWrap(boolean)</del>
				<li><del>setHtmlNoResultsMessage(String)</del>
				<li><del>setHtmlTemplate(Class)</del>
				<li><del>setHtmlTemplate(HtmlDocTemplate)</del>
				<li><del>addWidget(Class)</del>
			</ul>
		<li>
			New methods on {@link org.apache.juneau.rest.RestResponse}:
			<ul>
				<li><del>setHtmlTitle(Object)</del>
				<li><del>setHtmlDescription(Object)</del>
				<li><del>setHtmlBranding(Object)</del>
				<li><del>setHtmlHeader(Object)</del>
				<li><del>setHtmlLinks(Object)</del>
				<li><del>setHtmlNav(Object)</del>
				<li><del>setHtmlAside(Object)</del>
				<li><del>setHtmlFooter(Object)</del>
				<li><del>setHtmlCss(Object)</del>
				<li><del>setHtmlCssUrl(Object)</del>
				<li><del>setHtmlNoWrap(boolean)</del>
				<li><del>setHtmlNoResultsMessage(Object)</del>
				<li><del>setHtmlTemplate(Class)</del>
				<li><del>setHtmlTemplate(HtmlDocTemplate)</del>
			</ul>
		<li>
			<c>&amp;plainText=true</c> parameter now works on byte-based serializers by converting the output to hex.
		<li>
			New classes for widget support:
			<ul>
				<li>{@link org.apache.juneau.rest.widget.Widget}
				<li><del>PoweredByJuneauWidget</del>
				<li><del>ContentTypeLinksColumnWidget</del>
				<li><del>ContentTypeLinksRowWidget</del>
				<li><del>QueryWidget</del>
			</ul>
		<li>
			<c>devops.css</c> cleaned up.
		<li>
			Removed a bunch of URL-related methods from {@link org.apache.juneau.rest.RestRequest}.  
			These all have equivalents in {@link org.apache.juneau.rest.RestRequest#getUriContext()}.
		<li>
			New annotation attributes:
			<ul>
				<li>{@link org.apache.juneau.http.annotation.Query#name() @Query(name)}
				<li>{@link org.apache.juneau.http.annotation.FormData#name() @FormData(name)}
				<li>{@link org.apache.juneau.http.annotation.Header#name() @Header(name)}
				<li>{@link org.apache.juneau.http.annotation.Path#name() @Path(name)}
				<li>{@link org.apache.juneau.http.annotation.HasQuery#name() @HasQuery(name)}
				<li>{@link org.apache.juneau.http.annotation.HasFormData#name() @HasFormData(name)}
			</ul>
		</li>
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest.client</h5>
	<ul class='spaced-list'>
		<li>
			New <del>Path</del> annotation for specifying path variables on remoteable interfaces.
		<li>
			New <del>@RequestBean</del> annotation for specifying beans with remoteable annotations
			defined on properties.
		<li>
			The following annotations (and related methods on RestCall) can now take <c>NameValuePairs</c> and beans as input 
			when using <js>"*"</js> as the name.
			<br><del>FormData</del>,<del>FormDataIfNE</del>,
			<del>Query</del>,<del>QueryIfNE</del>,
			<del>Header</del>,<del>HeaderIfNE</del> 
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.microservice</h5>
	<ul class='spaced-list'>
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.examples.rest</h5>
	<ul class='spaced-list'>
		<li>
			Many code enhancements make to examples to reflect new functionality.
		<li>All pages now render aside comments to help explain what feature they're trying to explain using the 
			new features that allow you to customize various elements of the page.
			<br>
			<img class='bordered' width='50%' src='doc-files/ReleaseNotes.630.2.png'>
	</ul>
</div>
</div><!-- END: 6.3.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.3.1' id='6.3.1'>6.3.1 (Aug 1, 2017)</a></h3>
<div class='topic'><!-- START: 6.3.1 -->
<div class='topic'>
	<p>
		Juneau 6.3.1 is a minor release.
	</p>
	
	<h5 class='topic w800'>org.apache.juneau</h5>
	<ul class='spaced-list'>
		<li>
			<del>PojoQuery</del> improvements.
		<li>
			New <del>RemoteMethod.returns()</del> annotation.
			<br>Allows you to specify whether the remote method returns the HTTP body or status code.
		<li>
			Fixed bugs with <del>BEAN_includeProperties</del> and <del>BEAN_excludeProperties</del> settings.
		<li>
			New/modified settings in <del>HtmlDocSerializerContext</del>:
			<ul>
				<li><del>HTMLDOC_script</del>
				<li><del>HTMLDOC_style</del> - Was <jsf>HTMLDOC_css</jsf>.
				<li><del>HTMLDOC_stylesheet</del> - Was <jsf>HTMLDOC_cssUrl</jsf>.  Now an array.
			</ul>
		<li>
			New <del>ResourceFinder</del>utility class.
			Allows you to search for resources up the parent hierarchy chain.
			Also allows you to search for localized resources.
		<li>
			Eliminated the following properties from <del>HtmlDocSerializerContext</del>:
			<jsf>HTMLDOC_title</jsf>, <jsf>HTMLDOC_description</jsf>, <jsf>HTMLDOC_description</jsf>
			<br>See below on changes to simplify HTML headers.
		<li>
			{@link org.apache.juneau.svl.Var} implementations can now throw exceptions and will be converted to
			<js>""{exceptionMessage}"</js> values.
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest</h5>
	<ul class='spaced-list'>
		<li>
			New 'light' stylesheet:
			<br><img src='doc-files/ReleaseNotes.631.LightStyle.png'>
			<br>Compared with previous 'devops':
			<br><img src='doc-files/ReleaseNotes.631.DevopsStyle.png'>
			<br>For those nolstalgic for old times, there's also 'original':
			<br><img src='doc-files/ReleaseNotes.631.OriginalStyle.png'>
		<li>
			Simplified the stylesheets and HTML code.
			<br>For example, the nav links are now an ordered list of elements which makes rendering as as side-bar
			(for example) easier to do in CSS.
		<li>
			Modifications to the following <ja>@HtmlDoc</ja> annotations:
			<ul>
				<li><del>HtmlDoc.navlinks() navlinks()</del>- Now an array of strings instead of a JSON object.  Simplified syntax.
					<br>For example:
					<p class='bcode'>
		<jc>// Old syntax</jc>
		htmldoc=<ja>@HtmlDoc</ja>(
			links=<js>"{"</js>
				+ <js>"up:'request:/..',"</js>
				+ <js>"options:'servlet:/?method=OPTIONS',"</js>
				+ <js>"contentTypes:'$W{ContentTypeMenuItem}',"</js>
				+ <js>"styles:'$W{StyleMenuItem}',"</js>
				+ <js>"source:'$C{Source/gitHub}/org/apache/juneau/examples/rest/PetStoreResource.java'"</js>
			+ <js>"}"</js>
		)
		
		<jc>// New syntax</jc>
		htmldoc=<ja>@HtmlDoc</ja>(
			navlinks={
				<js>"up: request:/.."</js>,
				<js>"options: servlet:/?method=OPTIONS"</js>,
				<js>"$W{ContentTypeMenuItem}"</js>,
				<js>"$W{StyleMenuItem}"</js>,
				<js>"source: $C{Source/gitHub}/org/apache/juneau/examples/rest/PetStoreResource.java"</js>
			}
		)
					</p>
					Previous syntax will still work but you're encouraged to use the simplified syntax.
				<li>Several annotations are now arrays of strings instead of simple strings.
					Values are simply concatenated with newlines which makes multi-line values cleaner.
					<ul>
						<li><del>HtmlDoc.header() header()</del>
						<li><del>HtmlDoc.nav() nav()</del>
						<li><del>HtmlDoc.aside() aside()</del>
						<li><del>HtmlDoc.footer() footer()</del>
						<li><del>HtmlDoc.script() script()</del>
						<li><del>HtmlDoc.style() style()</del>
					</ul>
					Additionally, the <js>"INHERIT"</js> string literal can be used to combine the value with
					the value defined on the servlet or parent class.  Links can also be inserted at specific
					index positions.
			</ul>
		<li>
			Improvements made to the {@link org.apache.juneau.rest.widget.Widget} API.
			<ul>
				<li>
					You can now add arbitrary CSS and Javascript along with your widgets through new methods:
					<ul>
						<li><del>Widget.getHtml(RestRequest)</del>
						<li><del>Widget.getScript(RestRequest)</del>
						<li><del>Widget.getStyle(RestRequest)</del>
					</ul>
				</li>
				<li>
					Declaration of widgets moved to <del>HtmlDoc.widgets() @HtmlDoc(widgets)</del> 
					instead of separately on <del>@RestResource</del>and <ja>@RestMethod</ja> annotations.
				<li>
					{@link org.apache.juneau.rest.widget.Widget#getName()} now defaults to the simple class name.
					<br>So now you can just refer to the class name: <js>"$W{ContentTypeMenuItem}"</js>.
				<li>
					Renamed widgets:
					<ul>
						<li><c>PoweredByApacheWidget</c> -&gt; <c>PoweredByApache</c>  
						<li><c>PoweredByJuneauWidget</c> -&gt; <c>PoweredByJuneau</c>  
					</ul>
				<li>
					New {@link org.apache.juneau.rest.widget.MenuItemWidget} can be used as a starting point for creatint pull-down menu items.
				<li>
					New {@link org.apache.juneau.rest.widget.ContentTypeMenuItem} widget that provides a pull-down menu 
					with hyperlinks for all supported languages for that page:
					<br><img src='doc-files/ReleaseNotes.631.ContentTypeMenuItem.png'>
				<li>
					Improved {@link org.apache.juneau.rest.widget.QueryMenuItem} widget that provides a pull-down menu
					of a search/view/order-by/page form:
					<br><img src='doc-files/ReleaseNotes.631.QueryMenuItem.png'>
					<br>Fields are now pre-filled with current query parameters.
				<li>
					New {@link org.apache.juneau.rest.widget.ThemeMenuItem} widget that provides a pull-down menu 
					with hyperlinks to show the content in the default stylesheets:
					<br><img src='doc-files/ReleaseNotes.631.StyleMenuItem.png'>
			</ul>
		<li>
			New/modified annotations on <del>HtmlDoc @HtmlDoc</del>:
			<ul>
				<li><del>HtmlDoc.style() style()</del>- Renamed from <c>css()</c>.
				<li><del>HtmlDoc.stylesheet() stylesheet()</del>- Renamed from <c>cssUrl()</c>.
					<br>Can now be a comma-delimited list of URLs.
				<li><del>HtmlDoc.script() script()</del>- Add arbitrary Javascript to page header.
			</ul>
	
		<li>
			Bug fix with <del>HtmlDoc.nowrap() @HtmlDoc(nowrap)</del>so that the setting only applies
			to the data contents, not the whole page.
		<li>
			Two convenience methods added to {@link org.apache.juneau.rest.RestRequest}:
			<ul>
				<li><del>RestRequest.attr(String,Object)</del>
				<li><del>RestRequest.prop(String,Object)</del>
			</ul>
		</li>
		<li>
			Annotations added:
			<ul>
				<li><del>@RestResource(siteName)</del>
				<li><del>@RestResource(flags)</del>
				<li><del>RestMethod.flags() @RestMethod(flags)</del>
			</ul>
		</li>
		<li>
			Eliminated the <del>@RestResource(stylesheet)</del>annotation.  
			It's no longer needed now that you can easily specify styles via <ja>@Htmldoc</ja>.
		<li>
			Eliminated the following annotations since they are now redundant with <del>HtmlDoc.header() @HtmlDoc(header)</del>:
			<ul>
				<li><c>title()</c>
				<li><c>description()</c>
				<li><c>branding()</c>
			</ul>
			Instead, the <del>BasicRestServlet</del>class defines the following default header
			that can be easily overridden: 
			<p class='bcode'>
		htmldoc=<ja>@HtmlDoc</ja>(
			header={
				<js>"&lt;h1&gt;$R{resourceTitle}&lt;/h1&gt;"</js>,
				<js>"&lt;h2&gt;$R{methodSummary,resourceDescription}&lt;/h2&gt;"</js>,
				<js>"&lt;a href='http://juneau.apache.org'&gt;&lt;img src='$U{servlet:/htdocs/juneau.png}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;&lt;/a&gt;"</js>
			}
		)
			</p>
			Note that the subtitle first tries using the method summary and then the servlet description.
		<li>
			New {@link org.apache.juneau.rest.vars.FileVar $F} variable resolver for resolving the contents of 
			files in the classpath.
			<br>The <c>DockerRegistryResource</c> examples shows how it can be used to pull in a localized
			file from the classpath to populate the aside section of a page.
			<p class='bcode'>
		htmldoc=<ja>@HtmlDoc</ja>(
			<jc>// Pull in aside contents from file.</jc>
			aside=<js>"$F{resources/DockerRegistryResourceAside.html}"</js>
		)
			</p>
		<li>
			New <del>ReaderResource.toCommentStrippedString()</del>method.
		<li>
			The <c>bpIncludes()</c> and <c>bpExcludes()</c> annotations on <ja>@RestMethod</ja>
			has been replaced with the following:
			<ul>
				<li><del>RestMethod.bpi() bpi()</del>- Now an array of simplified values instead of LAX JSON.
				<li><del>RestMethod.bpx() bpx()</del>- Now an array of simplified values instead of LAX JSON.
			</ul>
		<li>
			Two new variables added to <c>$R</c> variable: <js>"$R{servletClass}"</js>, <js>"$R{servletClassSimple}"</js>
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest.examples</h5>
	<ul class='spaced-list'>
		<li>
			Added CONTENT-TYPE and STYLES menu items to most pages.
		<li>
			Added improved QUERY menu item to PetStore page.
	</ul>
</div>
</div><!-- END: 6.3.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#6.4.0' id='6.4.0'>6.4.0 (Oct 5, 2017)</a></h3>
<div class='topic'><!-- START: 6.4.0 -->
<div class='topic'>
	<p>
		The major change in this release is the project structure.
	</p>
	<p>
		The library now consists of the following artifacts found in the Maven group <c>"org.apache.juneau"</c>:
	</p>
	<table class='styled w800'>
		<tr>
			<th>Category</th><th>Maven Artifacts</th><th>Description</th><th>Prereqs</th>
		</tr>
		<tr class='dark bb'>
			<td rowspan='5' style='text-align:center;font-weight:bold;padding:20px;'>Juneau Core</td>
			<td class='code'>juneau-marshall</td>
			<td>Serializers and parsers for:
				<ul style='margin:0px 10px;'>
					<li>JSON
					<li>XML
					<li>HTML
					<li>UON
					<li>URL-Encoding
					<li>MessagePack
					<li>SOAP/XML
					<li>CSV
					<li>BSON (coming soon)
					<li>YAML (coming soon)
					<li>Protobuf (coming soon)
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-marshall-rdf</td>
			<td>
				Serializers and parsers for:
				<ul style='margin:0px 10px;'>
					<li>RDF/XML
					<li>RDF/XML-Abbrev 
					<li>N-Triple
					<li>Turtle
					<li>N3
				</ul>				
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
					<li>Apache Jena 2.7.1
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-dto</td>
			<td>
				Data Transfer Objects for:
				<ul style='margin:0px 10px;'>
					<li>HTML5
					<li>Atom
					<li>Cognos
					<li>JSON-Schema
					<li>Swagger 2.0
				</ul>				
			</td>
			<td><ul style='margin:0px 10px;'><li>Java 6</li></ul></td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-svl</td>
			<td>
				Simple Variable Language API
			</td>
			<td><ul style='margin:0px 10px;'><li>Java 6</li></ul></td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-config</td>
			<td>
				Configuration file API
			</td>
			<td><ul style='margin:0px 10px;'><li>Java 6</li></ul></td>
		</tr>
		<tr class='light bb'>
			<td rowspan='3' style='text-align:center;font-weight:bold;padding:20px;'>Juneau REST</td>
			<td class='code'>juneau-rest-server</td>
			<td>
				REST Servlet API
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
					<li>Servlet 3.1
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'>juneau-rest-server-jaxrs</td>
			<td>
				Optional JAX-RS support
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
					<li>JAX-RS 2.0
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td class='code'>juneau-rest-client</td>
			<td>
				REST Client API
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
					<li>Apache HttpClient 4.5
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='2' style='text-align:center;font-weight:bold;padding:20px;'>Juneau Microservice</td>
			<td class='code'>juneau-microservice-server</td>
			<td>
				REST Microservice Server API
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 8
					<li>Eclipse Jetty 9.4.3
				</ul>
			</td>
		</tr>
		<tr class='dark bb'>
			<td class='code'>juneau-microservice-template</td>
			<td>
				Developer template project
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 8
					<li>Eclipse Jetty 9.4.3
				</ul>
			</td>
		</tr>
		<tr class='light bb'>
			<td rowspan='2' style='text-align:center;font-weight:bold;padding:20px;'>Examples</td>
			<td class='code'><c>juneau-examples-core</c></td>
			<td>
				Core code examples
			</td>
			<td></td>
		</tr>
		<tr class='light bb'>
			<td class='code'><c>juneau-examples-rest</c></td>
			<td>
				REST code examples
			</td>
			<td></td>
		</tr>
		<tr class='dark bb'>
			<td rowspan='1' style='text-align:center;font-weight:bold;padding:20px;'>Juneau All</td>
			<td class='code'><c>juneau-all</c></td>
			<td>
				Combination of the following:
				<ul style='margin:0px 10px;'>
					<li>juneau-marshall
					<li>juneau-dto
					<li>juneau-svl
					<li>juneau-config
					<li>juneau-rest-server
					<li>juneau-rest-client
				</ul>
			</td>
			<td>
				<ul style='margin:0px 10px;'>
					<li>Java 6
					<li>Servlet 3.1
					<li>Apache HttpClient 4.5
				</ul>
			</td>
		</tr>
	</table>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Improvements to swap support.
			<ul>
				<li>New {@link org.apache.juneau.annotation.Swap @Swap} annotation.
					<br>Replaces the <c>@Pojo</c> and <del>@BeanProperty(swap)</del> annotations.
				<li>Support for per-media-type swaps.
					<br>Programmatic example:
					<p class='bcode'>
		<ja>@Swap</ja>(MyJsonOnlySwap.<jk>class</jk>)			
		<jk>public class</jk> MyPojo {}
	
		<jk>public class</jk> MyJsonOnlySwap <jk>extends</jk> PojoSwap&lt;MyPojo,String&gt; {
	
				<jk>public</jk> MediaType[] forMediaTypes() {
					<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/json"</js>);
				}
	
				<jk>public</jk> String swap(BeanSession session, MyPojo o) <jk>throws</jk> Exception {
					<jk>return</jk> <js>"It's JSON!"</js>;
	 		}
					</p>
					<br>Annotated example:
					<p class='bcode'>
		<ja>@Swap</ja>(impl=ToStringSwap.<jk>class</jk>, mediaTypes=<js>"&#42;/json"</js>)
		<jk>public class</jk> MyBean { ... }
	
		<jk>public class</jk> ToStringSwap <jk>extends</jk> PojoSwap&lt;Object,String&gt; {
			<jk>public</jk> String swap(BeanSession session, Object o) <jk>throws</jk> Exception {
				<jk>return</jk> o.toString();
			}
		}
					</p>
				<li>Support for templated swaps which provide additional context information for a swap.
					<br>The following is an example of a templated swap class used to serialize POJOs to HTML using FreeMarker:
					<p class='bcode'>
		<jc>// Our abstracted templated swap class.</jc>
		<jk>public abstract class</jk> FreeMarkerSwap <jk>extends</jk> PojoSwap&lt;Object,Reader&gt; {
	
			<jk>public</jk> MediaType[] forMediaTypes() {
				<jk>return</jk> MediaType.<jsm>forStrings</jsm>(<js>"&#42;/html"</js>);
			}
	
			<jk>public</jk> Reader swap(BeanSession session, Object o, String template) <jk>throws</jk> Exception {
				<jk>return</jk> getFreeMarkerReader(template, o);  <jc>// Some method that creates raw HTML.</jc>
			}
		}
					</p>
					<p class='bcode'>
			<ja>@Swap</ja>(impl=FreeMarkerSwap.<jk>class</jk>, template=<js>"MyPojo.div.ftl"</js>)
			<jk>public class</jk> MyPojo {}
					</p>
				<li>New <del>Swaps @Swaps</del> annotation for defining multiple swaps
					against the same POJO when they're differentiated by media types:
					<p class='bcode'>
		<ja>@Swaps</ja>(
			{
				<ja>@Swap</ja>(MyJsonSwap.<jk>class</jk>),
				<ja>@Swap</ja>(MyXmlSwap.<jk>class</jk>),
				<ja>@Swap</ja>(MyOtherSwap.<jk>class</jk>)
			}
		)
		<jk>public class</jk> MyPojo {}
					</p>
			</ul>
		<li>
			New <del>Surrogate</del> interface for identifying surrogate classes.
		<li>
			Serializers can now serialize to {@link java.lang.StringBuilder StringBuilders}.
		<li>
			Serializers now serialize the contents of {@link java.io.Reader Readers} and {@link java.io.InputStream InputStreams}
			directly to the output stream or writer.
			<br>When used with conjunction with <c>PojoSwaps</c>, this can be used to provide customized
			output for specific content types.
			<p class='bcode'>
		<ja>@Pojo</ja>(swap=MyBeanSwap.<jk>class</jk>)
		<jk>public class</jk> MyBean {...}
		
		<jk>public class</jk> MyBeanSwap <jk>extends</jk> PojoSwap&lt;MyBean,Object&gt; {
			<jk>public</jk> Object swap(BeanSession session, MyPojo o) <jk>throws</jk> Exception {
				MediaType mt = session.getMediaType();
				<jk>if</jk> (mt.hasSubType(<js>"json"</js>))
					<jk>return new</jk> StringReader(<js>"{foo:'bar'}"</js>);  <jc>// Custom JSON output</jc>
				<jk>return</jk> o; <jc>// Otherwise treat as normal bean</jc>
			}
		}
		
		<jc>// Produces "{foo:'bar'}"</jc>
		String json = SimpleJsonSerializer.<jsf>DEFAULT</jsf>
	.toString(<jk>new</jk> MyBean());
			</p>
			<br>This feature helps with the implementation of language-agnostic template support such as for
			using FreeMaker to serialize POJOs to HTML.
		<li>
			{@link org.apache.juneau.serializer.SerializerSession} and {@link org.apache.juneau.parser.ParserSession}
			objects are now reusable if used within the same thread.
			<p class='bcode'>
		<jc>// Old way (still works)</jc>
		JsonSerializer.<jsf>DEFAULT</jsf>.serialize(writer1, pojo1);
		JsonSerializer.<jsf>DEFAULT</jsf>.serialize(writer2, pojo2);
		
		<jc>// Same but using a session object</jc>
		SerializerSession session = JsonSerializer.<jsf>DEFAULT</jsf>.createSession();
		<jk>try</jk> {
			session.serialize(writer1, pojo1);
			session.serialize(writer2, pojo2);
		} <jk>finally</jk> {
			session.close();
		}  			
			</p>
			This is mostly an internal change and doesn't affect the existing APIs.
		<li>
			<del>PojoSwap.swap(BeanSession,Object)</del>and <del>PojoSwap.unswap(BeanSession,Object,ClassMeta)</del> 
			can now throw arbitrary exceptions instead of having to wrap them in <c>SerializeException</c>/<c>ParseException</c>.
		<li>
			New <del>CalendarUtils</del> class that encapsulates serialization/parsing logic from <del>CalendarSwap</del>and 
			<del>DateSwap</del>.
		<li>
			New annotation {@link org.apache.juneau.html.annotation.Html#anchorText}.
		<li>
			New methods on <del>ObjectList</del>:
			<ul>
				<li><del>ObjectList.get(int,Class) get(int,Class)</del>
				<li><del> org.apache.juneau.ObjectList.get(int,Type,Type...) get(int,Type,Type...)</del>
				<li><del>ObjectList.getMap(int,Class,Class) getMap(int,Class,Class)</del>
				<li><del>ObjectList.getList(int,Class) getList(int,Class)</del>
			</ul>
		<li>
			New methods on <del>ObjectMap</del>:
			<ul>
				<li><del>ObjectMap.get(String,Class) get(String,Class)</del>
				<li><del> org.apache.juneau.ObjectMap.get(String,Type,Type...) get(String,Type,Type...)</del>
				<li><del>ObjectMap.getWithDefault(String,Object) getWithDefault(String,Object)</del>
				<li><del>ObjectMap.getWithDefault(String,Object,Class) getWithDefault(String,Object,Class)</del>
				<li><del> org.apache.juneau.ObjectMap.getWithDefault(String,Object,Type,Type...) getWithDefault(String,Object,Type,Type...)</del>
				<li><del>ObjectMap.getSwapped(String,PojoSwap) getSwapped(String,PojoSwap)</del>
				<li><del>ObjectMap.getAt(String,Class) getAt(String,Class)</del>
				<li><del> org.apache.juneau.ObjectMap.getAt(String,Type,Type...) getAt(String,Type,Type...)</del>
				<li><del>ObjectMap.getMap(String,Class,Class,Map) getMap(String,Class,Class,Map)</del>
				<li><del>ObjectMap.getList(String,Class,List) getList(String,Class,List)</del>
			</ul>
		<li>
			New methods on <del>PojoRest</del>:
			<ul>
				<li><del>PojoRest.get(String,Class) get(String,Class)</del>
				<li><del> org.apache.juneau.utils.PojoRest.get(String,Type,Type...) get(String,Type,Type...)</del>
				<li><del>PojoRest.getWithDefault(String,Object) getWithDefault(String,Object)</del>
				<li><del>PojoRest.getWithDefault(String,Object,Class) getWithDefault(String,Object,Class)</del>
				<li><del> org.apache.juneau.utils.PojoRest.getWithDefault(String,Object,Type,Type...) getWithDefault(String,Object,Type,Type...)</del>
			</ul>
		<li>
			Fixed bug where {@link org.apache.juneau.BeanSession#getMediaType()} wasn't returning a value.
		<li>
			Eliminated the <ja>@Consumes</ja> and <ja>@Produces</ja> annotations.
			<br>The supported media types are now passed in through the constructors.
			<br>This was changed to eliminate a performance issue where a field could not be set as final because
			the call to <c>getClass()</c> to retrieve the annotation value could not be called before calling
			the <c><jk>super</jk>()</c> method.
		<li>
			New class: <del>PojoMerge</del>
		<li>
			New doc: <dc>2.6.2 - @Pojo annotation</dc>
		<li>
			New doc: <dc>2.6.5 - Serializing Readers and InputStreams</dc>
	</ul>
	
	<h5 class='topic w800'>juneau-dto</h5>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.dto.html5.HtmlElementMixed#children(Object...)} can now take in collections
			of objects.
		<li>
			The DTO beans can now be serialized to strings of their typical language by calling the <c>toString()</c> method.
			<br>For example, <c>Swagger.toString()</c> produces JSON and the HTML5 <c>Form.toString()</c>
			produces HTML.
	</ul>
	
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Revamped and simplified servlet and REST-call lifecycle handling through new
			<del>@RestHook</del>annotation.
			<ul>
				<li>The <del>RestServlet.init(ServletConfig)</del>method is now final and can
					no longer be extended.
					<br>Instead, use <del>HookEvent.INIT</del> or 
					<del>HookEvent.POST_INIT</del> for initialization.
				<li>The following methods on <del>RestServlet</del> have been removed:
					<ul>
						<li><c>init(RestConfig)</c> 
							- Use <del>HookEvent.INIT</del> instead.
						<li><c>onSuccess(RestRequest, RestResponse, long)</c>
							- Use <del>HookEvent.END_CALL</del> instead.
						<li><c>onPreCall(RestRequest)</c>
							- Use <del>HookEvent.PRE_CALL</del> instead.
						<li><c>onPostCall(RestRequest, RestResponse)</c>
							- Use <del>HookEvent.POST_CALL</del> instead.
					</ul> 	
			</ul>
		<li>
			Simplified {@link org.apache.juneau.rest.widget.MenuItemWidget}.
			<br>Exposes an abstract method <del>getContent(RestRequest)</del> that
			can return raw HTML via readers or char-sequences, or any other object (such as HTML5 beans) that will
			get converted to HTML using {@link org.apache.juneau.html.HtmlSerializer#DEFAULT}.
		<li>
			<del>RestResourceResolver</del> instances are now inherited from parent resources to child resources
			unless explicitly overridden at the child level.
			<br>It's also been changed to an interface.
		<li>New annotations on <del>@RestResource</del>:
			<ul>
				<li><del>resourceResolver()</del>
					<br>Allows you to specify a resource resolver on the servlet context to make it easier to work with
					dependency injection frameworks.
				<li><del>contextPath()</del> - 
					<br>Allows you to override the context path value inherited from the servlet container.
				<li><del>allowHeaderParams()</del> - 
					<br>Replaces the <c>RestContext.REST_allowHeaderParams</c> setting.
				<li><del>allowMethodParam()</del> - 
					<br>Replaces the <c>RestContext.REST_allowMethodParam</c> setting.
				<li><del>allowBodyParam()</del> - 
					<br>Replaces the <c>RestContext.REST_allowBodyParam</c> setting.
				<li><del>renderResponseStackTraces()</del> - 
					<br>Replaces the <c>RestContext.REST_xxx</c> setting.
				<li><del>useStackTraceHashes()</del> - 
					<br>Replaces the <c>RestContext.REST_useStackTraceHashes</c> setting.
				<li><del>defaultCharset()</del> - 
					<br>Replaces the <c>RestContext.REST_defaultCharset</c> setting.
				<li><del>paramFormat()</del>- 
					<br>Replaces the <c>RestContext.REST_paramFormat</c> setting.
			</ul>
		<li>New annotations on <del>RestMethod @RestMethod</del>:
			<ul>
				<li><del>RestMethod.defaultCharset() defaultCharset()</del>- 
					<br>Replaces the <c>RestContext.REST_defaultCharset</c> setting.
				<li><del>RestMethod.paramFormat()</del>- 
					<br>Replaces the <c>RestContext.REST_paramFormat</c> setting.
			</ul>
		<li>
			The following implementation classes can now be defined as non-static inner classes of servlets/resources:
			<ul>
				<li>{@link org.apache.juneau.rest.widget.Widget}
				<li><del>RestConverter</del>
				<li><del>RestGuard</del>
				<li><del>ResponseHandler</del>
				<li><del>RestCallHandler</del>
				<li><del>RestInfoProvider</del>
				<li><del>RestResourceResolver</del>
				<li><del>RestLogger</del>
				<li>{@link org.apache.juneau.html.HtmlDocTemplate}
			</ul>
		<li>
			New tooltip template: {@link org.apache.juneau.rest.widget.Tooltip}
		<li>
			New dark theme:
			<br><img src='doc-files/ReleaseNotes.632.DarkStyle.png'>
		<li>
			Stylesheet selection now stored in HTTP session when passed in via <c>?stylesheet</c> query parameter.
		<li>
			New doc: <dc>Lifecycle Hooks</dc>
		<li>
			Eliminated the <c>RestServletJenaDefault</c> class to remove the Jena dependency class on 
			the <c>juneau-rest-server</c> artifact. 
			<br>It's simple enough to simply extend <c>BasicRestServlet</c> and add the RDF serializers and
			parsers.
	</ul>
	
	<h5 class='topic w800'>juneau-microservice</h5>
	<ul class='spaced-list'>
		<li>
			The microservice has been significantly modified to be configured via a <c>jetty.xml</c> file
			for maximum flexibility instead of the hodge-podge of support in the config file.
			<br>Top-level servlets should now be defined in the provided <c>jetty.xml</c> file.
		<li>
			New methods on <del>RestMicroservice</del>:
			<ul>
				<li><del>addServlet(Servlet,String)</del>
				<li><del>addServletAttribute(String,Object)</del>
				<li><del>getServer()</del>
				<li><del>getInstance()</del>
				<li><del>getPort()</del>
				<li><del>getContextPath()</del>
				<li><del>getProtocol()</del>
				<li><del>getHostName()</del>
			</ul>
		<li>
			New methods on {@link org.apache.juneau.microservice.Microservice}:
			<ul>
				<li>{@link org.apache.juneau.microservice.Microservice#getInstance() getInstance()}
			</ul>
		<li>
			New class <del>JettyLogger</del> for directing Jetty logging to the
			java.util.logging framework.
		<li>
			New class <del>DebugResource</del>for viewing and generating
			Jetty thread dumps through REST calls.
	</ul>
	
	<h5 class='topic w800'>org.apache.juneau.rest.examples</h5>
	<ul class='spaced-list'>
		<li>
			New example of adding a menu-item widget to the Pet Store resource (including tooltips):
			<br><img src='doc-files/ReleaseNotes.632.PetStoreAdd.png'>
	</ul>
</div>
</div><!-- END: 6.4.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.0.0' id='7.0.0'>7.0.0 (Oct 25, 2017)</a></h3>
<div class='topic'><!-- START: 7.0.0 -->
<div class='topic'>
	<p>
		This release ups the Java prerequisite to Java 7.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			New class <del>HttpMethodName</del> with valid static string HTTP method names.
	</ul>
	
	<h5 class='topic w800'>juneau-dto</h5>
	<ul class='spaced-list'>
		<li>
			Class <c>org.apache.juneau.dto.Link</c> renamed to {@link org.apache.juneau.dto.LinkString}.
			Helps avoid confusion since there are other Link classes in the library.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Annotation <c><ja>@HtmlDoc</ja>(links)</c> renamed to <del>HtmlDoc.navlinks() navlinks</del>.
		<li>
			New annotation <del>HtmlDoc.head() @HtmlDoc(head)</del>.
			<br>Allows you to specify arbitrary HTML content in the <xt>&lt;head&gt;</xt> section of the page.
		<li>
			Removed annotation <c><ja>@HtmlDoc</ja>(favIcon)</c>.
			<br>This was a discouraged way of defining fav-icons anyway, and with the addition of 
			<c><ja>@HtmlDoc</ja>(head)</c>, you can define them using:
			<p class='bcode'>
		head={
			<js>"&lt;link rel='icon' href='$U{servlet:/htdocs/juneau.png}'/&gt;"</js>
		}
			</p>
		<li>
			Removed several of the HTMLDOC-related methods from the <c>RestResponse/RestConfig/RestContext</c>
			classes and moved it into the new <del>HtmlDocBuilder</del>class.
	</ul>
</div>
</div><!-- END: 7.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.0.1' id='7.0.1'>7.0.1 (Dec 24, 2017)</a></h3>
<div class='topic'><!-- START: 7.0.1 -->
<div class='topic'>
	<p>
		This release is a minor update.
		It includes the following prereq updates:
	</p>
	<ul class='spaced-list'>
		<li>Apache HttpClient:  4.5.3 to 4.5.4
		<li>Eclipse Jetty:  9.4.6.v20170531 to 9.4.8.v20171121
	</ul>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>New static <c>create()</c> methods for builders on serializers and parsers.
			<br>This simplifies the syntax of creation of serializers and parsers by scratch.
			<p class='bcode'>
		<jc>// Old way</jc>
		JsonSerializer s1 = <jk>new</jk> JsonSerializer.Builder().ws().build();
		
		<jc>// New way</jc>
		JsonSerializer s2 = JsonSerializer.<jsm>create</jsm>().ws().build();
			</p>
			<br>The same static create methods have also been added to the following classes:
			<ul>
				<li><del>SerializerGroup.create()</del>
				<li><del>ParserGroup.create()</del>
				<li><del>EncoderGroup.create()</del>
				<li>{@link org.apache.juneau.rest.client.RestClient#create()}
				<li><del>ConfigFile.create()</del>
			</ul>
		<li>
			The order of the parameters in {@link org.apache.juneau.serializer.SerializerSession#serialize(Object,Object)}
			has been change to match {@link org.apache.juneau.serializer.Serializer#serialize(Object,Object)}.	
		<li>
			Fixed some bugs in the XML parser related to whitespace and comments.
	</ul>
	
	<h5 class='topic w800'>juneau-svl</h5>
	<ul class='spaced-list'>
		<li>New methods on {@link org.apache.juneau.svl.Var} class to restrict when nested and embedded variables
		are resolved.
			<ul>
				<li>{@link org.apache.juneau.svl.Var#allowNested()}
				<li>{@link org.apache.juneau.svl.Var#allowRecurse()}
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			New <del>@RestResource(maxInput)</del> and 
			<del>RestMethod.maxInput() @RestMethod(maxInput)</del>for alleviating
			potential DoS attacks.
	</ul>
	
	<h5 class='topic w800'>juneau-microservice-server</h5>
	<ul class='spaced-list'>
		<li>
			New pluggable console commands.
			<br>When you start up the microservice, you'll now see the following:
			<p class='bcode'>
		Running class 'RestMicroservice' using config file 'examples.cfg'.
		Server started on port 10000
	
		List of available commands:
			exit -- Shut down service
			restart -- Restarts service
			help -- Commands help
			echo -- Echo command
	
		&gt; <span style='color:green'>help help</span>
		NAME
			help -- Commands help
		
		SYNOPSIS
			help [command]
		
		DESCRIPTION
			When called without arguments, prints the descriptions of all available commands.
			Can also be called with one or more arguments to get detailed information on a command.
		
		EXAMPLES
			List all commands:
				&gt; help
			
			List help on the help command:
				&gt; help help
				
		&gt; 
			</p>
			<p>
			Commands are pluggable and extensible through the config file. 
		<p class='bcode'>
		<cc>#=======================================================================================================================
		# Console settings
		#=======================================================================================================================</cc>
		<cs>[Console]</cs>
		
		<ck>enabled</ck> = <cv>true</cv>
		
		<cc># List of available console commands.
		# These are classes that implements ConsoleCommand that allow you to submit commands to the microservice via
		# the console.
		# When listed here, the implementations must provide a no-arg constructor.
		# They can also be provided dynamically by overriding the Microservice.createConsoleCommands() method.</cc>
		<ck>commands</ck> = 
			<cv>org.apache.juneau.microservice.console.ExitCommand,
			org.apache.juneau.microservice.console.RestartCommand,
			org.apache.juneau.microservice.console.HelpCommand</cv>
		</p>
			<ul>
				<li>New classes:
					<ul>
						<li>{@link org.apache.juneau.microservice.console.ConsoleCommand}
						<li>{@link org.apache.juneau.microservice.console.ExitCommand}
						<li>{@link org.apache.juneau.microservice.console.RestartCommand}
						<li>{@link org.apache.juneau.microservice.console.HelpCommand}
					</ul>
				<li>New methods on {@link org.apache.juneau.microservice.Microservice}
					<ul>
						<li>{@link org.apache.juneau.microservice.Microservice#startConsole() startConsole()}
						<li><del>createConsoleCommands()</del>
						<li>{@link org.apache.juneau.microservice.Microservice#getConsoleReader() getConsoleReader()}
						<li>{@link org.apache.juneau.microservice.Microservice#getConsoleWriter() getConsoleWriter()}
					</ul>	
			</ul>
		<li>
			Console input reader and output writer can now be overridden.
		<li>
			Console strings are now internationalized.
	</ul>
</div>
</div><!-- END: 7.0.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.1.0' id='7.1.0'>7.1.0 (Mar 08, 2018)</a></h3>
<div class='topic'><!-- START: 7.1.0 -->
<div class='topic'>
	<p>
		Version 7.1.0 is a major update with major implementation refactoring across all aspects of the product.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Significant improvements made to the internals of the Serializer and Parser classes.
			<ul>
				<li>
					Caching improvements on serializers and parsers have reduced execution time of the core
					JUnits by approximately 1/3.
					<br>The 17000+ JUnit tests now execute in less than 10 seconds and have a cache-reuse hit rate
					of 98% (164104 serializers/parsers/bean-contexts retrieved but only 1801 created from scratch).
				<li>
					All the various separate <c>Context</c> classes (e.g. <c>JsonSerializerContext</c>) have been folded into
					their respective serializer or parser classes (e.g. <c>JsonSerializer</c>).
					<br>Additionally, these classes are their own bean contexts.
					<br>For example, the class hierarchy of <c>JsonSerializer</c> is now:
					<ul class='doctree'>
						<li class='jac'>{@link org.apache.juneau.Context}
						<ul>
							<li class='jc'>{@link org.apache.juneau.BeanContext}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer}
								<ul>
									<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializer}
									<ul>
										<li class='jc'>{@link org.apache.juneau.json.JsonSerializer}
									</ul>
								</ul>
							</ul>
						</ul>
					</ul>
					All <c>Context</c> objects are thread-safe and read-only.
				<li>
					Session objects also now have a consistent class hierarchy.
					<br>For example, the class hierarchy of <c>JsonSerializerSession</c> is now:
					<ul class='doctree'>
						<li class='jac'><del>Session</del>
						<ul>
							<li class='jc'>{@link org.apache.juneau.BeanSession}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.SerializerSession}
								<ul>
									<li class='jac'>{@link org.apache.juneau.serializer.WriterSerializerSession}
									<ul>
										<li class='jc'>{@link org.apache.juneau.json.JsonSerializerSession}
									</ul>
								</ul>
							</ul>
						</ul>
					</ul>
					Session objects are transient objects that live for the duration of a single parse.
				<li>
					Builder objects also now have a consistent class hierarchy.
					<br>For example, the class hierarchy of <c>JsonSerializer.Builder</c> is now:
					<ul class='doctree'>
						<li class='jac'>{@link org.apache.juneau.Context.Builder}
						<ul>
							<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
							<ul>
								<li class='jac'>{@link org.apache.juneau.serializer.Serializer.Builder}
								<ul>
									<li class='jc'>{@link org.apache.juneau.json.JsonSerializer.Builder}
								</ul>
							</ul>
						</ul>
					</ul>
					Builder objects are used for building up and creating <c>Context</c> objects.
				<li>
					The <del>PropertyStore</del> class has been completely rewritten.
					It is now a read-only configuration store build using the <del>PropertyStoreBuilder</del>
					class.
					<br>The previous <c>PropertyStore</c> class was overly-complicated with many read/write
					locks to ensure thread-safety. 
					<br>The new design shifts to a builder-based model with read-only <c>PropertyStore</c> objects
					that can be used as hash keys.
			</ul>
		<li>
			Improvements to the HTTP-Part APIs.
			<br>The existing <c>PartSerializer</c>/<c>PartParser</c> classes
			have been replaced with the following all located in the new <c>org.apache.juneau.httppart</c> package:
			<ul class='doctree'>
				<li class='jp'>{@link org.apache.juneau.httppart}
				<ul>
					<li class='jc'>{@link org.apache.juneau.httppart.HttpPartType}
					<li class='jic'>{@link org.apache.juneau.httppart.HttpPartSerializer}
					<ul>
						<li class='jc'><del>UonPartSerializer</del>
						<li class='jc'><del>SimpleUonPartSerializer</del>
						<li class='jc'>{@link org.apache.juneau.httppart.SimplePartSerializer}
					</ul>
					<li class='jic'>{@link org.apache.juneau.httppart.HttpPartParser}
					<ul>
						<li class='jc'><del>UonPartParser</del>
						<li class='jc'><del>SimplePartParser</del>
					</ul>
				</ul>
			</ul>
			Code for marshalling of parts have been removed from the URL-Encoding serializers and parsers.
		<li>	
			<c>Context.Builder.property(String,Object)</c> renamed to <del>Builder.set(String,Object)</del>.
		<li>
			<c>ResourceFinder</c> class has been replaced with the following:
			<ul>
				<li><del>ClasspathResourceFinder</del>
				<li><del>ClasspathResourceFinderSimple</del>
				<li><del>ClasspathResourceFinderBasic</del>
				<li><del>ClasspathResourceFinderRecursive</del>
				<li><del>ClasspathResourceManager</del>
			</ul>
		<li>
			New methods on {@link org.apache.juneau.serializer.SerializerSession}:
			<ul>
				<li>{@link org.apache.juneau.serializer.SerializerSession#getListener() getListener()}
				<li>{@link org.apache.juneau.serializer.SerializerSession#getListener(Class) getListener(Class)}
			</ul>
		<li>
			New methods on {@link org.apache.juneau.parser.ParserSession}:
			<ul>
				<li>{@link org.apache.juneau.parser.ParserSession#getListener() getListener()}
				<li>{@link org.apache.juneau.parser.ParserSession#getListener(Class) getListener(Class)}
			</ul>
		<li>
			New <del>Parser.PARSER_unbuffered</del>setting allows you to disable internal
			buffering on the JSON and UON parsers so that they can be used to read continous streams of objects.
		<li>
			New <del>JsonParser.JSON_validateEnd</del>and <del>UonParser.UON_validateEnd</del>
			settings allow you to control whether we validate that there is no garbage at the end of the parsed input.
		<li>
			New <del>Parser.PARSER_autoCloseStreams</del> setting allows input streams and
			readers passed into parsers to be automatically closed after parsing.
		<li>
			Syntax changed on unswap method on <del>Surrogate</del> classes.
			<br>It's now a regular method instead of a static method.
		<li>
			{@link org.apache.juneau.annotation.Swap @Swap} annotation can now be used with 
			<del>Surrogate</del>classes.
		<li>
			New support for <del>PojoBuilders POJO Builders</del>.	
	</ul>
	
	<h5 class='topic w800'>juneau-svl</h5>
	<ul class='spaced-list'>
		<li>
			New variables:
			<ul>
				<li>{@link org.apache.juneau.svl.vars.CoalesceVar}
				<li>{@link org.apache.juneau.svl.vars.PatternMatchVar}
				<li>{@link org.apache.juneau.svl.vars.NotEmptyVar}
				<li>{@link org.apache.juneau.svl.vars.UpperCaseVar}
				<li>{@link org.apache.juneau.svl.vars.LowerCaseVar}
			</ul>
		<li>
			Variables moved from <l>juneau-microservice</l>:
			<ul>
				<li>{@link org.apache.juneau.svl.vars.ArgsVar}
				<li>{@link org.apache.juneau.svl.vars.ManifestFileVar}
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-config</h5>
	<ul class='spaced-list'>
		<li>
			The Config API has been completely revamped.
			<br>New features include:
			<ul>
				<li>Support for pluggable storage.
				<li>File-system watcher integration support.
					<br>Changes made to file system files now automatically reflected in configurations
					and interface proxies.
				<li>New builder-based design.
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-dto</h5>
	<ul class='spaced-list'>
		<li>
			Enhancements to Swagger DTO:
			<ul>
				<li>New methods for setting and retrieving properties via name:
					<ul>
						<li>{@link org.apache.juneau.dto.swagger.SwaggerElement#get(String,Class)}
						<li>{@link org.apache.juneau.dto.swagger.SwaggerElement#set(String,Object)}
					</ul>
				<li>
					Support for setting non-standard fields such as <js>"$ref"</js> via getter and setter
					above.
				<li>
					Setter methods that take in beans and collections of beans can now take in 
					JSON strings.
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			<c>RestServletDefault</c> renamed to <del>BasicRestServlet</del>.
		<li>
			<c>RestServletGroupDefault</c> renamed to <del>BasicRestServletGroup</del>.
		<li>
			The <js>"$R{...}"</js> variable has been split into the following:
			<ul>
				<li><js>"$RA{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestAttributeVar}, first non-null value returned by <c>HttpServletRequest.getAttribute(String)</c>.
				<li><js>"$RF{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestFormDataVar}, first non-null value returned by <del>RestRequest.getFormData(String)</del>.
				<li><js>"$RH{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestHeaderVar}, first non-null value returned by {@link org.apache.juneau.rest.RestRequest#getHeader(String)}.
				<li><js>"$RI{key1[,key2...]}"</js> - <del>RestInfoVar</del>, first non-null value returned by <del>RestRequest.getInfoProvider()</del>.
					<br>The possible values are:
					<ul>
						<li><js>"contact"</js> - Value returned by {@link org.apache.juneau.dto.swagger.Info#getContact()}
						<li><js>"description"</js> - Value returned by <del>RestInfoProvider.getDescription(RestRequest)</del>
						<li><js>"externalDocs"</js> - Value returned by {@link org.apache.juneau.dto.swagger.Swagger#getExternalDocs()}
						<li><js>"license"</js> - Value returned by {@link org.apache.juneau.dto.swagger.Info#getLicense()}
						<li><js>"methodDescription"</js> - Value returned by <del>RestInfoProvider.getMethodDescription(Method,RestRequest)</del>
						<li><js>"methodSummary"</js> - Value returned by <del>RestInfoProvider.getMethodSummary(Method,RestRequest)</del>
						<li><js>"siteName"</js> - Value returned by <del>RestInfoProvider.getSiteName(RestRequest)</del>
						<li><js>"tags"</js> - Value returned by {@link org.apache.juneau.dto.swagger.Swagger#getTags()}
						<li><js>"termsOfService"</js> - Value returned by {@link org.apache.juneau.dto.swagger.Info#getTermsOfService()}
						<li><js>"title"</js> - See <del>RestInfoProvider.getTitle(RestRequest)</del>
						<li><js>"version"</js> - See {@link org.apache.juneau.dto.swagger.Info#getVersion()}
					</ul>					
				<li><js>"$RP{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestPathVar}, first non-null value returned by <del>RestRequest.getPath(String)</del>.
				<li><js>"$RQ{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestQueryVar}, first non-null value returned by <del>RestRequest.getQuery(String)</del>.
				<li><js>"$R{key1[,key2...]}"</js> - {@link org.apache.juneau.rest.vars.RequestVar}, first non-null other request variable.
					<br>The possible values are:
					<ul>
						<li><js>"contextPath"</js> - Value returned by {@link org.apache.juneau.rest.RestRequest#getContextPath()}
						<li><js>"method"</js> - Value returned by {@link org.apache.juneau.rest.RestRequest#getMethod()}
						<li><js>"methodDescription"</js> - Value returned by <del>RestRequest.getMethodDescription()</del>
						<li><js>"methodSummary"</js> - Value returned by <del>RestRequest.getMethodSummary()</del>
						<li><js>"pathInfo"</js> - Value returned by {@link org.apache.juneau.rest.RestRequest#getPathInfo()}
						<li><js>"requestParentURI"</js> - Value returned by {@link org.apache.juneau.UriContext#getRootRelativePathInfoParent()}
						<li><js>"requestURI"</js> - Value returned by {@link org.apache.juneau.rest.RestRequest#getRequestURI()}
						<li><js>"resourceDescription"</js> - Value returned by <del>RestRequest.getResourceDescription()</del>
						<li><js>"resourceTitle"</js> - See <del>RestRequest.getResourceTitle()</del>
						<li><js>"servletParentURI"</js> - Value returned by {@link org.apache.juneau.UriContext#getRootRelativeServletPathParent()}
						<li><js>"servletPath"</js> - See {@link org.apache.juneau.rest.RestRequest#getServletPath()}
						<li><js>"servletURI"</js> - See {@link org.apache.juneau.UriContext#getRootRelativeServletPath()}
						<li><js>"siteName"</js> - See <del>RestRequest.getSiteName()</del>
					</ul>
			</ul>
		<li>
			Refactored the <c>RestConfig</c> class into {@link org.apache.juneau.rest.RestContext.Builder}.
			<br>Settings on {@link org.apache.juneau.rest.RestContext} objects can now be set declaratively through the 
				following new properties:
			<ul>
				<li><del>RestContext.REST_allowHeaderParams</del>
				<li><del>RestContext.REST_allowBodyParam</del>
				<li><del>RestContext.REST_allowedMethodParams REST_allowedMethodParams</del>
				<li><del>RestContext.REST_renderResponseStackTraces REST_renderResponseStackTraces</del>
				<li><del>RestContext.REST_useStackTraceHashes</del>
				<li><del>RestContext.REST_defaultCharset REST_defaultCharset</del>
				<li><del>RestContext.REST_maxInput REST_maxInput</del>
				<li><del>RestContext.REST_paramResolvers</del>
				<li><del>RestContext.REST_converters REST_converters</del>
				<li><del>RestContext.REST_guards REST_guards</del>
				<li><del>RestContext.REST_responseHandlers</del>
				<li><del>RestContext.REST_defaultRequestHeaders</del>
				<li><del>RestContext.REST_defaultResponseHeaders</del>
				<li><del>RestContext.REST_produces REST_produces</del>
				<li><del>RestContext.REST_consumes REST_consumes</del>
				<li><del>RestContext.REST_clientVersionHeader REST_clientVersionHeader</del>
				<li><del>RestContext.REST_resourceResolver</del>
				<li><del>RestContext.REST_logger</del>
				<li><del>RestContext.REST_callHandler</del>
				<li><del>RestContext.REST_infoProvider</del>
				<li><del>RestContext.REST_path REST_path</del>
				<li><del>RestContext.REST_contextPath</del>
				<li><del>RestContext.REST_staticFiles REST_staticFiles</del>
				<li><del>RestContext.REST_staticFileResponseHeaders</del>
				<li><del>RestContext.REST_classpathResourceFinder</del>
				<li><del>RestContext.REST_useClasspathResourceCaching</del>
				<li><del>RestContext.REST_widgets</del>
				<li><del>RestContext.REST_mimeTypes</del>
			</ul>
		<li>
			Support for static files has been simplified and improved.
			<ul>
				<li>Syntax on <del>@RestResource(staticFiles)</del>has been simplified, and
					now allows you to specify response headers in the strings.
				<li>Response headers for static files can also be configured through 
					<del>RestContext.REST_staticFileResponseHeaders</del>
				<li>Static file in-memory caching now configurable through 
					<del>RestContext.REST_useClasspathResourceCaching</del>
				<li>Static file retrieval can be customized through 
					<del>RestContext.REST_classpathResourceFinder</del>
			</ul>
		<li>
			Eliminated the <c>RestMatcherReflecting</c> class.
			<br>You can now simply create a <del>RestMatcher</del> that has a public constructor that 
			takes in the server and method arguments.
		<li>
			<del>@RestResource.allowMethodParam</del>renamed to <del>RestResource.allowedMethodParams</del>.
		<li>
			<c>@RestMethod.serializersInherit</c> and <c>@RestMethod.parsersInherit</c> replaced with
			simplified <del>@RestMethod(inherit)</del>. 
		<li>
			Changes to <del>RequestFormData</del>:
			<ul>
				<li><del>RequestFormData.addDefault(Map) addDefault(Map)</del>takes in a 
					<c>Map&lt;String,Object&gt;</c> instead of <c>Map&lt;String,String&gt;</c>.
			</ul>
		<li>
			Changes to <del>RequestHeaders</del>:
			<ul>
				<li><del>RequestHeaders.addDefault(Map) addDefault(Map)</del>takes in a 
					<c>Map&lt;String,Object&gt;</c> instead of <c>Map&lt;String,String&gt;</c>.
			</ul>
		<li>
			Changes to <del>RequestQuery</del>:
			<ul>
				<li><del>RequestQuery.addDefault(Map) addDefault(Map)</del>takes in a 
					<c>Map&lt;String,Object&gt;</c> instead of <c>Map&lt;String,String&gt;</c>.
			</ul>
		<li>
			Changes to {@link org.apache.juneau.rest.RestContext}:
			<ul>
				<li><c>getResource(String,Locale)</c> renamed to <del>getClasspathResource(String,Locale)</del>
				<li><c>getResourceAsString(String,Locale)</c> renamed to <del>getClasspathResourceAsString(String,Locale)</del>
				<li><c>getResource(Class,MediaType,String,Locale)</c> renamed to <del>getClasspathResourceAsString(Class,MediaType,String,Locale)</del>
				<li>New method <del>getClasspathResource(Class,String,Locale)</del>.
				<li>New method <del>getClasspathResourceAsString(Class,String,Locale)</del>.
				<li>New method <del>getClasspathResource(Class,Class,MediaType,String,Locale)</del>.
				<li><del>RestContext.getDefaultRequestHeaders()</del>returns a 
					<c>Map&lt;String,Object&gt;</c> instead of <c>Map&lt;String,String&gt;</c>.
				<li><del>RestContext.getDefaultResponseHeaders()</del>returns a 
					<c>Map&lt;String,Object&gt;</c> instead of <c>Map&lt;String,String&gt;</c>.
			</ul>
		<li>
			Changes to {@link org.apache.juneau.rest.RestRequest}:
			<ul>	
				<li><c>getSupportedMediaTypes()</c> replaced with
					<del>RestRequest.getConsumes() getConsumes()</del>and
					<del>RestRequest.getProduces() getProduces()</del>.
				<li><c>getReaderResource(String,boolean,MediaType)</c> renamed to 
					<del>getClasspathReaderResource(String,boolean,MediaType)</del>
				<li><c>getReaderResource(String,boolean)</c> renamed to 
					<del>getClasspathHttpResource(String,boolean)</del>
				<li><c>getReaderResource(String)</c> renamed to 
					<del>getClasspathHttpResource(String)</del>
			</ul>
		<li>
			Changes to <del>@RestResource</del>
			<ul>
				<li>New <del>mimeTypes()</del>annotation.
			</ul>
		<li>
			Changes to <del>RestMethod @RestMethod</del>:
			<ul>
				<li>New <del>RestMethod.consumes() consumes()</del>and
					<del>RestMethod.produces() produces()</del>
					for overriding the supported media types inferred from the serializers and parsers.
			</ul>
		<li>
			<c>RestCallHandler</c> split up into <del>RestCallHandler</del> and 
			<del>BasicRestCallHandler</del>
		<li>
			<c>RestInfoProvider</c> split up into <del>RestInfoProvider</del> and 
			<del>BasicRestInfoProvider</del>
		<li>
			<c>RestLogger</c> split up into <del>RestLogger</del>, 
			<del>BasicRestLogger</del> and <del>NoOpRestLogger</del>
		<li>
			<c>RestResourceResolverSimple</c> renamed to <del>BasicRestResourceResolver</del>
		<li>
			Introduced the following classes that helps make the code more understandable:
			<ul>
				<li><del>RestContextProperties</del>
				<li><del>RestMethodProperties</del>
				<li><del>RequestProperties</del>
			</ul>
		<li>
			Eliminated the <c>@Messages</c> and <c>@Properties</c> REST java method parameter
			annotations.
			<br>These aren't needed anymore since you can just pass in <c>MessageBundle</c> and
			<c>RestRequestProperties</c> as unannotated parameters.
		<li>
			Revamped the <del>RestInfoProvider</del>class.
		<li>
			New builder classes:
			<ul>
				<li><del>ReaderResourceBuilder</del>
				<li><del>StreamResourceBuilder</del>
			</ul>
		<li>
			{@link org.apache.juneau.rest.RestResponse#getNegotiatedOutputStream()} now returns a 
			<del>FinishableServletOutputStream</del>and {@link org.apache.juneau.rest.RestResponse#getNegotiatedWriter()}
			now returns a <del>FinishablePrintWriter</del> that allows you to finish the output
			without closing the stream.
			<br>The <del>DefaultHandler</del> class now calls <c>finish()</c>
			instead of <c>close()</c> on the stream.
		<li>
			Added the following annotations to the <del>BasicRestServlet</del> class
			(which were previously defined on the <del>Resource</del> class):
			<p class='bcode'>
		<ja>@RestResource</ja>(
			htmldoc=<ja>@HtmlDoc</ja>(
				navlinks={
					<js>"up: request:/.."</js>,
					<js>"options: servlet:/?method=OPTIONS"</js>
				},
				stylesheet=<js>"$C{REST/stylesheet,servlet:/styles/devops.css}"</js>
			),
			
			<jc>// Optional external configuration file.</jc>
			config=<js>"$S{juneau.configFile}"</js>
		)
			</p>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			New configuration property <del>RestClient.RESTCLIENT_query</del>and
			builder method <del>Builder.query(String,Object)</del>.
		<li>
			API changes to replace <c>PartSerializer</c> with {@link org.apache.juneau.httppart.HttpPartSerializer}.
			<br>The default value is now <del>SimpleUonPartSerializer</del> which will
			serialize strings as plain-text and collections/arrays as comma-delimited lists.
			<br>We decided to change the default behavior in favor of practicality over purity.
		<li>
			New methods on <del>RestCall</del>class:
			<ul>
				<li><del>RestCall.getResponseHeader(String) getResponseHeader(String)</del>
				<li><del>RestCall.getResponseCode() getResponseCode()</del>
			</ul>
		<li>
			<del>RestCall</del> and {@link org.apache.juneau.rest.client.RestClient}
			now implement the <c>Closeable</c> interface.
	</ul>
	
	<h5 class='topic w800'>juneau-microservice</h5>
	<ul class='spaced-list'>
		<li>
			<c>Resource</c> and <c>ResourceGroup</c> classes removed.
			<br><del>BasicRestServlet</del> and <del>BasicRestServletGroup</del> can be used instead.
		<li>
			<c>ResourceJena</c> and <c>ResourceJenaGroup</c> classes renamed to
			<del>BasicRestServletJena</del>and <del>BasicRestServletJenaGroup</del>.
	</ul>
</div>
</div><!-- END: 7.1.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.2.0' id='7.2.0'>7.2.0 (Sept 25, 2018)</a></h3>
<div class='topic'><!-- START: 7.2.0 -->
<div class='topic'>
	<p>
		7.2.0 is a major release that introduces several significant new features:
	</p>
	<ul class='spaced-list'>
		<li>OpenAPI part serializing and parsing with full support for OpenAPI validation of input and output in the REST servlet and client APIs.
		<li>Swagger UI.
		<li>New HTTP-Part annotations that are applicable to both the servlet and client APIs.
		<li>Serverless servlet and client unit testing.
		<li>Simplified UI customization.
		<li>Marshalls that combines serializers and parsers into a single API.
	</ul>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			The REST client <ja>@Remoteable</ja> annotations and REST server <ja>@RemoteMethod</ja> annotations which used to be
			in separate packages in the client and server projects have been combined into a single set of annotations in 
			the {@link org.apache.juneau.http.annotation} package.
			<br>This fixes a long-standing problem where it was easy to mix up using client-side annotations in server-side code, and vis-versa.
			<br>Additionally, much work has been done on these annotations to add support for Swagger-style validations and documentation.
			<ul class='doctree'>
				<li class='ja'><del>Body</del>
				<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasFormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.HasQuery}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Request}
			</ul>
			<br>These are used with new Swagger schema/documentation annotations to produce schema-based serialization/parsing/validation 
				and auto-generated Swagger documentation:
			<ul class='doctree'>
				<li class='ja'>{@link org.apache.juneau.http.annotation.Contact}
				<li class='ja'><del>ExternalDocs</del>
				<li class='ja'><del>Items</del>
				<li class='ja'>{@link org.apache.juneau.http.annotation.License}
				<li class='ja'><del>Schema</del>
				<li class='ja'><del>SubItems</del>
				<li class='ja'><del>Tag</del>
			</ul>
			<br>Additionally, the <ja>@Remoteable</ja> annotation has been split into the following two annotations:
			<ul class='doctree'>
				<li class='ja'><del>RemoteInterface</del> 
					- Used for remote proxy interfaces served up through 
					<del>RemoteInterfaceServlet</del> or REST <js>"PROXY"</js> methods.
					<br>Defaults to <js>"POST"</js> with method signatures as paths.
				<li class='ja'><del>RemoteResource</del> 
					- Used for 3rd-party REST interfaces.
					<br>Defaults to <js>"GET"</js> with standardized naming conventions for paths.
			</ul>
		<li>
			Support for multi-valued parameters as maps or beans on server-side annotations (it was previously supported on client-side):
			<c><ja>@Query</ja>(<js>"*"</js>)</c>, <c><ja>@FormData</ja>(<js>"*"</js>)</c>, <c><ja>@Header</ja>(<js>"*"</js>)</c>, <c><ja>@Path</ja>(<js>"*"</js>)</c>
		<li>
			Support for server-side use of <ja>@Request</ja> annotation on <ja>@RestMethod</ja> annotations and new {@link org.apache.juneau.rest.RestRequest#getRequest(RequestBeanMeta)} method.
		<li>
			Fixed bug where <c><ja>@Bean</ja>(typeName)</c> was not being detected on non-bean POJO classes.
		<li>
			Fixed bug where HTML-Schema was not being rendered correctly.
		<li>
			Support for POJO examples:
			<ul class='doctree'>
				<li class='jf'><del>BeanContext.BEAN_examples</del>
				<li class='ja'>{@link org.apache.juneau.annotation.Example}
			</ul>
		<li>
			Fixed bug where parsers could report the wrong line number when an error occurred.
		<li>
			A runtime exception is now thrown if you define a <del>@BeanProperty(name)</del>but forget to
			add it to your <c><ja>@Bean</ja>(properties)</c> annotation.
		<li>
			<c><ja>@Html</ja>(asXml)</c> and <c><ja>@Html</ja>(asPlainText)</c> replaced with
			{@link org.apache.juneau.html.annotation.Html#format() @Html(format)}.
		<li>
			HTML serializer will now serializers beans and maps as HTML even when those objects are embedded
			within an object with <c><ja>@Html</ja>(format=<jsf>XML</jsf>)</c>.
			<br>The previous behavior was to serialize it as XML.
		<li>
			New settings for binary-based serializers and parsers:
			<ul class='doctree'>
				<li class='jf'><del>OutputStreamSerializer.OSSERIALIZER_binaryFormat</del>
				<li class='jf'><del>InputStreamParser.ISPARSER_binaryFormat</del>
			</ul>
		<li>
			Added support for auto-detection of fluent-style setters:
			<ul class='doctree'>
				<li class='jf'><del>BeanContext.BEAN_fluentSetters</del>
				<li class='ja'><del>Bean.fluentSetters()</del>
			</ul>
		<li>
			The <jsf>SERIALIZER_abridged</jsf> setting has been replaced with <del>Serializer.SERIALIZER_addRootType SERIALIZER_addRootType</del>
		<li>
			The <jsf>SERIALIZER_addBeanTypeProperties</jsf> setting has been replaced with <del>Serializer.SERIALIZER_addBeanTypes SERIALIZER_addBeanTypes</del>
			and is disabled by default.
		<li>
			Parse exception messages are now clearer and include code snippets of where a parse exception occurred:
			<p class='bcode' style='color:red'>
		org.apache.juneau.parser.ParseException: Expected '[' at beginning of JSON array.
			At line 80, column 20.
			While parsing into: 
				currentClass: List&lt;String&gt;
				currentProperty: required: java.util.List, field=[null], getter=[public java.util.List org.apache.juneau.dto.swagger.SchemaInfo.getRequired()], setter=[public org.apache.juneau.dto.swagger.SchemaInfo org.apache.juneau.dto.swagger.SchemaInfo.setRequired(java.util.Collection)]
		---start--
		0075: 						"name": "body",
		0076: 						"description": "Pet object that needs to be added to the store",
		0077: 						"required": true,
		0078: 						"schema": {
		0079: 							"required": true,
		0080: 						}
		0081: 					}
		0082: 				],
		0083: 				"responses": {
		0084: 					"405": {
		0085: 						"description": "Invalid input"
		---end---
			</p>
		<li>
			New property <del>Parser.PARSER_debugOutputLines</del>for controlling how many input lines are added to the exception message above.
		<li>
			New property <del>BeanContext.BEAN_useEnumNames</del>for controlling whether enums are serialized
			using their name or the <c>toString()</c> method.
		<li>
			New property <del>BeanContext.BEAN_examples</del> for defining examples of POJOs.
		<li>
			New {@link org.apache.juneau.annotation.Example @Example} annotation for defining examples of POJOs.
			<br>Used heavily in JSON-Schema support.
		<li>
			If a bean has both a <c>getX()</c> and <c>isX()</c> method, the <c>getX()</c> method takes precedence.
			<br>The previous behavior was arbitrary.
		<li>
			Significant improvements to JSON-Schema serialization support.
			<ul>
				<li>New <del>@JsonSchema</del>annotation.
			</ul>
		<li>
			Fixed <c>NullPointerException</c> when serializing beans with a dyna-property (i.e. <c><ja>@Bean</ja>(<js>"*"</js>)</c>)
			which returns a <jk>null</jk> value.
		<li>
			New option for dyna-property (i.e. <c><ja>@Bean</ja>(<js>"*"</js>)</c>) using a method that returns a collection of extra keys.
			<br>See new options #4 on <del>BeanProperty.name()</del>
		<li>
			New formats for the {@link org.apache.juneau.html.annotation.Html#format() @Html(format)} annotation:
			<ul class='doctree'>
				<li class='jf'><del>HtmlFormat.HTML_CDC</del>- Format collections as comma-delimited lists.
				<li class='jf'><del>HtmlFormat.HTML_SDC</del> - Format collections as space-delimited lists.
			</ul> 
		<li>
			Serializers now allow for q-values on the media types they handle.
			<br>For example, the accept media type on <c>JsonSerializer.Simple</c> is <js>"application/json+simple,application/json;q=0.9"</js>.
			<br>This means the serializer CAN handle requests for <js>"application/json"</js> if no other serializers provide a better match.
		<li>
			New methods for creating unmodifiable <del>ObjectMap ObjectMaps</del>and <del>ObjectList ObjectLists</del>.
			<ul class='doctree'>
				<li class='jc'><del>ObjectMap</del>
				<ul>
					<li class='jm'><del>ObjectMap.isUnmodifiable() isUnmodifable()</del>
					<li class='jm'><del>ObjectMap.unmodifiable() unmodifiable()</del>
					<li class='jm'><del>ObjectMap.modifiable() modifiable()</del>
				</ul>
				<li class='jp'><del>ObjectList</del>
				<ul>
					<li class='jm'><del>ObjectList.isUnmodifiable() isUnmodifable()</del>
					<li class='jm'><del>ObjectList.unmodifiable() unmodifiable()</del>
					<li class='jm'><del>ObjectList.modifiable() modifiable()</del>
				</ul>
			</ul>
		<li>
			The <c>JsonSerializer.Simple</c> class has been moved into the top-level <del>SimpleJsonSerializer</del> class.
		<li>
			RDF serializer subclasses have been moved into top-level classes:
			<ul>
				<li><c>RdfSerializer.Xml</c> -&gt; <del>RdfXmlSerializer</del>
				<li><c>RdfSerializer.XmlAbbrev</c> -&gt; <del>RdfXmlAbbrevSerializer</del>
				<li><c>RdfSerializer.N3</c> -&gt; <del>N3Serializer</del>
				<li><c>RdfSerializer.NTriple</c> -&gt; <del>NTripleSerializer</del>
				<li><c>RdfSerializer.Turtle</c> -&gt; <del>TurtleSerializer</del>
				<li><c>RdfParser.Xml</c> -&gt; <del>RdfXmlParser</del>
				<li><c>RdfParser.N3</c> -&gt; <del>N3Parser</del>
				<li><c>RdfParser.NTriple</c> -&gt; <del>NTripleParser</del>
				<li><c>RdfParser.Turtle</c> -&gt; <del>TurtleParser</del>
			</ul>
		<li>
			New API for pairing serializers and parsers for simplified syntax:
			<h5 class='figure'>Examples:</h5>
			<p class='bcode'>
		<jc>// Using instance.</jc>
		Json json = <jk>new</jk> Json();
		MyPojo myPojo = json.read(string, MyPojo.<jk>class</jk>);
		String string = json.write(myPojo);
			</p>
			<p class='bcode'>
		<jc>// Using DEFAULT instance.</jc>
		MyPojo myPojo = Json.<jsf>DEFAULT</jsf>.read(string, MyPojo.<jk>class</jk>);
		String string = Json.<jsf>DEFAULT</jsf>.write(myPojo);
			</p>
			<ul class='doctree'>
				<li class='jac'><del>Marshall</del>
				<ul>
					<li class='jac'><del>CharMarshall</del>
					<ul>
						<li class='jc'><del>Html</del>
						<li class='jc'><del>Json</del>
						<li class='jc'><del>PlainText</del>
						<li class='jc'><del>SimpleJson</del>
						<li class='jc'><del>Uon</del>
						<li class='jc'><del>UrlEncoding</del>
						<li class='jc'><del>Xml</del>
						<li class='jc'><del>N3</del>
						<li class='jc'><del>NTriple</del>
						<li class='jc'><del>RdfXml</del>
						<li class='jc'><del>RdfXmlAbbrev</del>
						<li class='jc'><del>Turtle</del>	
					</ul>
					<li class='jac'><del>StreamMarshall</del>
					<ul>
						<li class='jc'><del>Jso</del>
						<li class='jc'><del>MsgPack</del>
					</ul>
				</ul>
			</ul>
		<li>
			New/updated documentation:
			<ul>
				<li><a del='#juneau-marshall.JsonDetails.SimplifiedJson'>2.15.3 - Simplified JSON</a>
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-dto</h5>
	<ul class='spaced-list'>
		<li>
			Fixed bug where Swagger <del> org.apache.juneau.dto.swagger.SchemaInfo.required(Object...)</del> was defined as a boolean
			instead of a list of strings.
		<li>
			Boolean attributes are now handled correctly for HTML5.
			<br>For example, calling <c><jk>new</jk> Select().disabled(<jk>true</jk>)</c> will produce <c>&lt;select disabled='disabled'&gt;</c>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Auto-generated <del>RestSwagger Swagger UI</del>.
		<li>
			Simplified <del>@RestResource(swagger)</del>
			and <del>RestMethod.swagger() @RestMethod(swagger)</del> annotations.
		<li>
			Fixed bug in <c>UriResolver</c> when request path info had special characters.
		<li>
			Fixed bug where incorrect media type was being set on responses (e.g. <c>text/html+schema</c> instead of <c>text/html</c> for schema documents).
		<li>
			The <c>RemoteableServlet</c> class has been moved and renamed to <del>RemoteInterfaceServlet</del>.
		<li>
			<del>RemoteInterfaceServlet</del>now provides a form page for invoking remote interface methods in a browser.
		<li>
			Newlines were being stripped from <c><ja>@HtmlDoc</ja>(script)</c> when serialized which could cause script lines to become commented out.
		<li>
			New {@link org.apache.juneau.http.annotation.Response @Response} annotation that can be applied to
			throwables thrown from REST methods and POJOs returned by REST methods to specify non-200 status return codes and descriptions in Swagger documentation.
		<li>
			Swagger fields added to the following annotations:
			<ul class='doctree'>
				<li class='ja'><del>Body</del>
				<li class='ja'>{@link org.apache.juneau.http.annotation.FormData}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Header}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Path}
				<li class='ja'>{@link org.apache.juneau.http.annotation.Query}
			</ul>
		<li>
			The <ja>@PathRemainder</ja> annotation has been removed entirely.  
			<br>Use <c><ja>@Path</ja>(<js>"/*"</js>)</c> to access the path remainder which includes all the new OpenAPI parsing support.
		<li>
			"Helper" classes (i.e. reusable beans that can be returned by REST methods) have been moved to the following package with some new additions:
			<ul class='doctree'>
				<li class='jp'><del>helper</del>
				<ul>
					<li class='jc'><del>BeanDescription</del>
					<li class='jc'><del>ChildResourceDescriptions</del>
					<li class='jc'><del>ReaderResource</del>
					<li class='jc'><del>ReaderResourceBuilder</del>
					<li class='jc'><del>SeeOtherRoot</del>
					<li class='jc'><del>ResourceDescription</del>
					<li class='jc'><del>StreamResource</del>
					<li class='jc'><del>StreamResourceBuilder</del>
				</ul>
			</ul>
		<li>
			Predefined HTTP responses.
			<ul class='doctree'>
				<li class='jp'><del>response</del>
				<ul>
					<li class='jc'><del>Accepted</del>
					<li class='jc'><del>AlreadyReported</del>
					<li class='jc'><del>Continue</del>
					<li class='jc'><del>Created</del>
					<li class='jc'><del>EarlyHints</del>
					<li class='jc'><del>Found</del>
					<li class='jc'><del>IMUsed</del>
					<li class='jc'><del>MovedPermanently</del>
					<li class='jc'><del>MultipleChoices</del>
					<li class='jc'><del>MultiStatus</del>
					<li class='jc'><del>NoContent</del>
					<li class='jc'><del>NonAuthoritiveInformation</del>
					<li class='jc'><del>NotModified</del>
					<li class='jc'><del>Ok</del>
					<li class='jc'><del>PartialContent</del>
					<li class='jc'><del>PermanentRedirect</del>
					<li class='jc'><del>Processing</del>
					<li class='jc'><del>ResetContent</del>
					<li class='jc'><del>SeeOther</del>
					<li class='jc'><del>SwitchingProtocols</del>
					<li class='jc'><del>TemporaryRedirect</del>
					<li class='jc'><del>UseProxy</del>			
				</ul>
			</ul>
		<li>
			Predefined HTTP error throwables.
			<br>When added to REST Java methods, reflected in generated Swagger documentation.
			<ul class='doctree'>
				<li class='jp'><del>exception</del>
				<ul>
					<li class='jc'><del>BadRequest</del>
					<li class='jc'><del>Conflict</del>
					<li class='jc'><del>ExpectationFailed</del>
					<li class='jc'><del>FailedDependency</del>
					<li class='jc'><del>Forbidden</del>
					<li class='jc'><del>Gone</del>
					<li class='jc'><del>HttpVersionNotSupported</del>
					<li class='jc'><del>InsufficientStorage</del>
					<li class='jc'><del>InternalServerError</del>
					<li class='jc'><del>LengthRequired</del>
					<li class='jc'><del>Locked</del>
					<li class='jc'><del>LoopDetected</del>
					<li class='jc'><del>MethodNotAllowed</del>
					<li class='jc'><del>MisdirectedRequest</del>
					<li class='jc'><del>NetworkAuthenticationRequired</del>
					<li class='jc'><del>NotAcceptable</del>
					<li class='jc'><del>NotExtended</del>
					<li class='jc'><del>NotFound</del>
					<li class='jc'><del>NotImplemented</del>
					<li class='jc'><del>PayloadTooLarge</del>
					<li class='jc'><del>PreconditionFailed</del>
					<li class='jc'><del>PreconditionRequired</del>
					<li class='jc'><del>RangeNotSatisfiable</del>
					<li class='jc'><del>RequestHeaderFieldsTooLarge</del>
					<li class='jc'><del>ServiceUnavailable</del>
					<li class='jc'><del>TooManyRequests</del>
					<li class='jc'><del>Unauthorized</del>
					<li class='jc'><del>UnavailableForLegalReasons</del>
					<li class='jc'><del>UnprocessableEntity</del>
					<li class='jc'><del>UnsupportedMediaType</del>
					<li class='jc'><del>UpgradeRequired</del>
					<li class='jc'><del>UriTooLong</del>
					<li class='jc'><del>VariantAlsoNegotiates</del>
				</ul>
			</ul>	
		<li>
			The <del>HtmlDoc.nav() @HtmlDoc(nav)</del>and <del>HtmlDoc.navlinks() @HtmlDoc(navlinks)</del>
			can now both be used on the same annotation.
			<br>The contents of <c>nav()</c> are free-form HTML that gets rendered immediately after the navigation links.
		<li>
			The following new parameter types can be used on REST methods:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.parser.ReaderParser} - The reader parser matching the request content type.
				<li class='jc'>{@link org.apache.juneau.parser.InputStreamParser} - The input stream parser matching the request content type.
			</ul>
		<li>
			The <c>$F</c> variable can now be used as a initialization time variable.
			<br>For example, the <c>AtomFeedResource</c> example pulls a bean example from a file on the classpath:
			<p class='bcode'>
		<ja>@RestResource</ja>(
			path=<js>"/atom"</js>,
			title=<js>"Sample ATOM feed resource"</js>,
			properties={
				<ja>@Property</ja>(name=<jsf>BEAN_examples</jsf>, value=<js>"{'org.apache.juneau.dto.atom.Feed': $F{AtomFeedResource_example.json}}"</js>)
			},
			...
		)
			</p>
			<br>It should be noted that you cannot use the <c>$F</c> variable to retrieve localized versions of files (since you're not within
			the scope of a client request.
		<li>
			The <del>RestResource.nowrap()</del>annotation has been changed to a string with a default value of <js>"true"</js>.
			<br>Having it as a string allows us to differentiate between a set and unset value so that it can be overridden in subclasses.
		<li>
			The {@link org.apache.juneau.http.annotation.Path#name()} annotation parameter is now required.
		<li>
			New class for mock unit testing of REST resources:
			<ul class='doctree'>
				<li class='jc'><del>MockRest</del>
			</ul>
		<li>
			<c><ja>@RestMethod</ja>(inherit)</c> annotation has been removed and replaced with the following classes:
			<ul class='doctree'>
				<li class='jc'><del>Inherit</del>
				<li class='jc'><del>None</del>
			</ul>
			<br>These can be used in the following locations:
			<ul class='doctree'>
				<li class='ja'><del>RestResource.serializers()</del>
				<li class='ja'><del>RestResource.parsers()</del>
				<li class='ja'><del>RestResource.beanFilters()</del>
				<li class='ja'><del>RestResource.pojoSwaps()</del>
				<li class='ja'><del>RestMethod.serializers()</del>
				<li class='ja'><del>RestMethod.parsers()</del>
				<li class='ja'><del>RestMethod.beanFilters()</del>
				<li class='ja'><del>RestMethod.pojoSwaps()</del>
			</ul>
			<br>One advantage is that you now have control over the precedence of serializers and parsers by where you insert the <c>Inherit</c> class. 
		<li>
			<c>RequestPathMatch</c> class has been renamed to <del>RequestPath</del>.
		<li>
			{@link org.apache.juneau.http.annotation.Request @Request} objects can now be used as parameters in <ja>@RestMethod</ja> methods.
			<br>Includes new methods on {@link org.apache.juneau.rest.RestRequest}:
			<ul class='doctree'>
				<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getRequest(Class) getRequest(Class)}
				<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getRequest(RequestBeanMeta) getRequest(RequestBeanMeta)}
			</ul>
		<li>
			New methods added to {@link org.apache.juneau.rest.widget.MenuItemWidget} to allow population of menu item content using Javascript and Ajax calls:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.widget.MenuItemWidget}
				<ul>
					<li class='jm'><del>getBeforeShowScript(RestRequest)</del>
					<li class='jm'><del>getAfterShowScript(RestRequest)</del>
				</ul>
			</ul>
		<li>
			New methods added to {@link org.apache.juneau.rest.widget.Widget} to allow retrieving classpath resources with embedded SVL variables:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.widget.Widget}
				<ul>
					<li class='jm'><del>loadHtmlWithVars(RestRequest,String)</del>
					<li class='jm'><del>loadScriptWithVars(RestRequest,String)</del>
					<li class='jm'><del>loadStyleWithVars(RestRequest,String)</del>
				</ul>
			</ul>
		<li>
			New/updated documentation: 
			<br><dc>juneau-rest-server.UnitTesting</dc>
		<li>
			The behavior of the default values for <del>RestMethod.name()</del>and <del>RestMethod.path()</del>
			have changed.
			<br>If not specified, the values are inferred from the Java method name.
			<br>See Also: <del>RestMethod</del>
		<li>
			<c>RedirectToServletRoot</c> class has been renamed to <del>SeeOtherRoot</del>.
		<li>
			New REST context settings:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.RestContext}
				<ul>
					<li class='jf'><del>RestContext.REST_uriAuthority REST_uriAuthority</del>
					<li class='jf'><del>RestContext.REST_uriContext REST_uriContext</del>
					<li class='jf'><del>RestContext.REST_uriRelativity REST_uriRelativity</del>
					<li class='jf'><del>RestContext.REST_uriResolution REST_uriResolution</del>
				</ul>
			</ul>
		<li>
			New convenience annotations for specifying default <c>Accept</c> and <c>Content-Type</c> headers:
			<ul class='doctree'>	
				<li class='jc'><del>RestResource</del>
				<ul>
					<li class='jf'><del>defaultAccept</del>
					<li class='jf'><del>defaultContentType</del>
				</ul>	
				<li class='jc'><del>RestMethod</del>
				<ul>
					<li class='jf'><del>RestMethod.defaultAccept defaultAccept</del>
					<li class='jf'><del>RestMethod.defaultContentType defaultContentType</del>
				</ul>	
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			Remote Resource interfaces support OpenAPI annotations.
		<li>
			Made improvements to the builder API for defining SSL support.
			<br>New methods added:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
				<ul>
					<li class='jf'><del> org.apache.juneau.rest.client.RestClient.Builder.sslProtocols(String...) sslProtocols(String...)</del>
					<li class='jf'><del> org.apache.juneau.rest.client.RestClient.Builder.cipherSuites(String...) cipherSuites(String...)</del>
					<li class='jf'><del>Builder.hostnameVerifier(HostnameVerifier) hostnameVerifier(HostnameVerifier)</del>
					<li class='jf'><del> org.apache.juneau.rest.client.RestClient.Builder.keyManagers(KeyManager...) keyManagers(KeyManager...)</del>
					<li class='jf'><del> org.apache.juneau.rest.client.RestClient.Builder.trustManagers(TrustManager...)</del>
					<li class='jf'><del>Builder.secureRandom(SecureRandom)</del>
					<li class='jf'><del>Builder.httpClientConnectionManager(HttpClientConnectionManager)</del>
				</ul>
			</ul>
		<li>
			Clients no longer have JSON defined as the default serializer and parser.
			<br>Instead, the clients can now be used with no serializer/parser if you're working with InputStreams/Readers or
			POJOs that can be converted to Strings and converted from Strings/InputStreams/Readers.
		<li>
			Methods added to client builder to make it easy to define the transport language:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
				<ul>
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#json() json()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#xml() xml()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#html() html()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#uon() uon()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#urlEnc() urlEnc()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#msgPack() msgPack()}
					<li class='jf'>{@link org.apache.juneau.rest.client.RestClient.Builder#plainText() plainText()}
				</ul>
			</ul>
		<li>
			New method added for allowing serverless client testing against REST interfaces.
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.client.RestClient.Builder}
				<ul>
					<li class='jf'><del>mockHttpConnection(MockHttpConnection)</del>
				</ul>
			</ul>
		<li>
			Removed the deprecated <c>RestCall.execute()</c> method.
			<br>Use <del>RestCall.run()</del>.
		<li>
			<c>RestCall.input(Object)</c> method renamed to <del>RestCall.body(Object)</del>to match OpenAPI terminology.
		<li>
			Made constructors on <c>RestClient</c> and <c>RestClient.Builder</c> protected so that they can be subclassed.
		<li>
			The <c>RestClient.getRemoteableProxy()</c> methods have been split into separate methods for Remote Interfaces and Remote Resources:
			<ul class='doctree'>
				<li class='jc'>{@link org.apache.juneau.rest.client.RestClient}
				<ul>
					<li class='jm'><del>RestClient.getRemoteInterface(Class)</del>
					<li class='jm'><del>RestClient.getRemoteInterface(Class,Object)</del>
					<li class='jm'><del>RestClient.getRemoteInterface(Class,Object,Serializer,Parser)</del>
					<li class='jm'><del>RestClient.getRemoteResource(Class)</del>
					<li class='jm'><del>RestClient.getRemoteResource(Class,Object)</del>
					<li class='jm'><del>RestClient.getRemoteResource(Class,Object,Serializer,Parser)</del>
				</ul>
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-microservice</h5>
	<ul class='spaced-list'>
		<li>
			The look-and-feel of an application is now controlled through the external configuration file and access to
			CSS stylesheets in the working directory in a new folder called <c>files</c>:
			<br><img class='bordered' style='width:170px' src='doc-files/ReleaseNotes.711.1.png'>
			<br><br>
			The default configuration is this: 
			<p class='bcode'>
		<cc>#=======================================================================================================================
		# REST settings
		#=======================================================================================================================</cc>
		<cs>[REST]</cs>
		
		<ck>staticFiles</ck> = <cv>htdocs:files/htdocs</cv>
		
		<cc># Stylesheet to use for HTML views.</cc>
		<ck>theme</ck> = <cv>servlet:/htdocs/themes/devops.css</cv>
		
		<ck>headerIcon</ck> = <cv>servlet:/htdocs/images/juneau.png</cv>
		<ck>headerLink</ck> = <cv>http://juneau.apache.org</cv>
		<ck>footerIcon</ck> = <cv>servlet:/htdocs/images/asf.png</cv>
		<ck>footerLink</ck> = <cv>http://www.apache.org</cv>
		
		<ck>icon</ck> = <cv>$C{REST/headerIcon}</cv>
		<ck>header</ck> = <cv>&lt;a href='$U{$C{REST/headerLink}}'&gt;&lt;img src='$U{$C{REST/headerIcon}}' style='position:absolute;top:5;right:5;background-color:transparent;height:30px'/&gt;&lt;/a&gt;</cv>
		<ck>footer</ck> = <cv>&lt;a href='$U{$C{REST/footerLink}}'&gt;&lt;img style='float:right;padding-right:20px;height:32px' src='$U{$C{REST/footerIcon}}'&gt;</cv>	
			</p>				
			<br><br>
			Note that static files can now be served up from the <c>files</c> directory in the working directory, 
			and you have access to modify the CSS theme files.
			<br>The <c>SwaggerUI.css</c> file controls the look-and-feel of the Swagger UI, so you can make
			modification there as well.
			<br><br>
			The <c>BasicRestConfig</c> interface (which defines the default settings for the <c>BasicRestServlet</c> class)
			now looks like this...
			<p class='bcode'>
		<ja>@RestResource</ja>(
			...
			htmldoc=<ja>@HtmlDoc</ja>(
				header={
					<js>"&lt;h1&gt;$R{resourceTitle}&lt;/h1&gt;"</js>,
					<js>"&lt;h2&gt;$R{methodSummary,resourceDescription}&lt;/h2&gt;"</js>,
					<js>"$C{REST/header}"</js>
				},
				navlinks={
					<js>"up: request:/.."</js>
				},
				stylesheet=<js>"$C{REST/theme,servlet:/htdocs/themes/devops.css}"</js>,
				head={
					<js>"&lt;link rel='icon' href='$U{$C{REST/icon}}'/&gt;"</js>
				},
				footer=<js>"$C{REST/footer}"</js>
			),
		
			<jc>// These are static files that are served up by the servlet under the specified sub-paths.
			// For example, "/servletPath/htdocs/javadoc.css" resolves to the file "[servlet-package]/htdocs/javadoc.css"</jc>
			staticFiles={<js>"$C{REST/staticFiles}"</js>}
		)
		<jk>public interface</jk> BasicRestConfig {}			
				</p>	
				<br><br>
				The <c>PoweredByApache</c> widget which used to serve as a page footer has been eliminated.
				<br><br>
				If you're testing out changes in the theme stylesheets, you may want to set the following system property
				that prevents caching of those files so that you don't need to restart the microservice each time a change is made:
				<p class='bcode'>
		<cc>#=======================================================================================================================
		# System properties
		#=======================================================================================================================</cc>
		<cs>[SystemProperties]</cs>
		
		<cc># Disable classpath resource caching.
		# Useful if you're attached using a debugger and you're modifying classpath resources while running.</cc>
		<ck>RestContext.useClasspathResourceCaching.b</ck> = <cv>false</cv>
				</p>
			<li>
				Upgraded to Jetty 9.4.12.
	</ul>
</div>
</div><!-- END: 7.2.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.2.1' id='7.2.1'>7.2.1 (Oct 23, 2018)</a></h3>
<div class='topic'><!-- START: 7.2.1 -->
<div class='topic'>
	<p>
		This release contains mostly bug fixes.
		Code changes have been made to preserve binary backwards compatibility with 7.1.0.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			The <del>@JsonSchema</del> annotation has been merged with the <del>@Schema</del> annotation.
		<li>
			Annotations typically used on bean properties (getters/setters/public fields) can now be used on private fields.
			This is inline with behavior on JPA-annotated beans.
			These include:  <ja>@Swap</ja>, <ja>@Html</ja>, <ja>@Xml</ja>, <jd>@BeanProperty</jd>.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Method-level annotations (e.g. <ja>@RestMethod</ja>) and parameter-level annotations (e.g. <ja>@Query</ja>) are now inheritable
			from parent classes and interfaces. 
			<br>This allows you to define <del>RestcDualPurposeInterfaces</del>.
		<li>
			The <c>ReaderResource</c> and <c>StreamResource</c> classes have been moved to the <c>org.apache.juneau.http</c>
			package in <c>juneau-marshall</c>.  This allows them to be used as return types in remote REST interfaces.
			<br>A new <del>ResolvingReaderResource</del> class has been added that includes the variable-resolving support since
			this relies on the <c>juneau-svl</c> package.
		<li>
			The <c>RemoteInterfaceServlet</c> class has been renamed to {@link org.apache.juneau.rest.remote.RrpcServlet}.
		<li>
			<c><ja>@RestMethod</ja>(name=<js>"PROXY"</js>)</c> has been changed to <c><ja>@RestMethod</ja>(name=<js>"RRPC"</js>)</c>.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			The <c>RestClient.getRemoteInterface()</c> method has been renamed to {@link org.apache.juneau.rest.client.RestClient#getRrpcInterface(Class)}.
		<li>
			Fixed a bug where <c><ja>@RemoteMethod</ja>(path)</c> values containing '/' characters were erroneously being encoded.
	</ul>
</div>
</div><!-- END: 7.2.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#7.2.2' id='7.2.2'>7.2.2 (Nov 7, 2018)</a></h3>
<div class='topic'><!-- START: 7.2.2 -->
<div class='topic'>
	<p>
		This release contains minor bug fixes and general improvements to the PetStore sample application.
	</p>
</div>
</div><!-- END: 7.2.2 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.0.0' id='8.0.0'>8.0.0 (Jan 01, 2019)</a></h3>
<div class='topic'><!-- START: 8.0.0 -->
<div class='topic'>
	<p>
		This release cleans up deprecated APIs from the 7.2.0 release and makes significant modifications
		to the Microservice APIs.
	</p>
	
	<p>
		The project structures of the REST, Microservice, and Examples have been modified to fit new Spring Boot
		integration support.
		The structure is now as follows:
	</p>
	<ul>
		<li><c>juneau-rest</c>
		<ul>
			<li><c>juneau-rest-client</c>
			<li><c>juneau-rest-server</c>
			<li><c>juneau-rest-server-jaxrs</c>
			<li><c>juneau-rest-server-rdf</c>
			<li><b><c>juneau-rest-server-springboot</c></b> - New Spring Boot integration support classes. 
		</ul>
		<li><c>juneau-microservice</c>
		<ul>
			<li><b><c>juneau-microservice-core</c></b> - New.  Contains base {@link org.apache.juneau.microservice.Microservice} class.
			<li><b><c>juneau-microservice-jetty</c></b> - New.  Contains new {@link org.apache.juneau.microservice.jetty.JettyMicroservice} class.
			<li><b><c>juneau-my-jetty-microservice</c></b> - New.  Template starter project for Jetty-based microservices.
			<li><b><c>juneau-my-springboot-microservice</c></b> - New.  Template starter project for Spring-Boot-based microservices.
		</ul>
		<li><c>juneau-examples</c>
		<ul>
			<li><c>juneau-core</c>
			<li><b><c>juneau-microservice-rest</c></b> - Now contains only servlet example classes.  No Jetty configuration.
			<li><b><c>juneau-microservice-rest-jetty</c></b> - Servlet examples deployed using Jetty.
			<li><b><c>juneau-microservice-rest-springboot</c></b> - Servlet examples deployed using Spring Boot.
		</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-svl</h5>
	<ul class='spaced-list'>
		<li>
			New SVL variables:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.svl.vars.SubstringVar}
				<li class='jc'>{@link org.apache.juneau.svl.vars.PatternExtractVar}
				<li class='jc'>{@link org.apache.juneau.svl.vars.PatternReplaceVar}
				<li class='jc'>{@link org.apache.juneau.svl.vars.LenVar}
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-config</h5>
	<ul class='spaced-list'>
		<li>
			New methods for setting a system default configuration:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.config.Config}
				<ul>
					<li class='jm'>{@link org.apache.juneau.config.Config#getSystemDefault() getSystemDefault()}
					<li class='jm'>{@link org.apache.juneau.config.Config#setSystemDefault(Config) setSystemDefault(Config)}
				</ul>
			</ul>
		<li>
			New classpath store.
			<ul class='javatree'>
				<li class='jc'><del>ConfigClasspathStore</del>
			</ul>
		<li>
			New API method:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.config.store.ConfigStore}
				<ul>
					<li class='jm'>{@link org.apache.juneau.config.store.ConfigStore#exists(String) exists(String)}
				</ul>
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			New methods on <del>RestServlet</del>:
			<ul class='javatree'>
				<li class='jm'><del>RestServlet.setRestResourceResolver(RestResourceResolver) setRestResourceResolver(RestResourceResolver)</del>
				<li class='jm'><del>RestServlet.getPath() getPath()</del>
			</ul>
		<li>
			The registered resource resolver is now used to instantiate objects of classes defined via <del>@RestResource</del>.
			<br>This allows for any of those instance to be injectable beans.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server-springboot</h5>
	<ul class='spaced-list'>
		<li>
			New project containing classes for making it easy to use Juneau with Spring Boot.
	</ul>
	
	<h5 class='topic w800'>juneau-microservice-core</h5>
	<ul class='spaced-list'>
		<li>
			New project that consist of just the core {@link org.apache.juneau.microservice.Microservice} class and console support.
		<li>
			The Microservice API has been revamped to use a builder-based approach to creating microservices.
			<br>The new API is considerably more flexible in design and allows for the configuration and external
			files to be located in either the home directory or inside the jar classpath.
		<li>
			If the microservice cannot find a config file in the home directory with the same name as the jar and
			the <js>"juneau.configFile"</js> system property is not found, it will try to find any file in the home
			directory that ends with <js>".cfg"</js>.
		<li>
			New {@link org.apache.juneau.microservice.MicroserviceListener} API for defining lifecycle event listeners.
		<li>
			New {@link org.apache.juneau.microservice.console.ConfigCommand} class for performing config queries and updates through 
			the microservice console.
	</ul>
	
	<h5 class='topic w800'>juneau-microservice-jetty</h5>
	<ul class='spaced-list'>
		<li>
			New {@link org.apache.juneau.microservice.jetty.JettyMicroservice} class replaces the previous <c>RestMicroservice</c>.
	</ul>
	
	<h5 class='topic w800'>juneau-my-jetty-microservice</h5>
	<ul class='spaced-list'>
		<li>
			New template starter project for Jetty-based microservices.
	</ul>
	
	<h5 class='topic w800'>juneau-my-springboot-microservice</h5>
	<ul class='spaced-list'>
		<li>
			Template starter project for Spring-Boot-based microservices.
		<li>
			<c>app.json</c> and <c>Procfile</c> files for deploying examples into Heroku.
			<br>Includes instructions.
	</ul>
</div>
</div><!-- END: 8.0.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.1.0' id='8.1.0'>8.1.0 (Aug 21, 2019)</a></h3>
<div class='topic'><!-- START: 8.1.0 -->
<div class='topic'>
	<p>
		8.1.0 introduces some significant new features including:
	</p>
	<ul class='spaced-list'>
		<li>
			<del>ConfigurableAnnotations Configurable Annotations</del>
		<li>
			<del>DefaultPojoSwaps Default PojoSwaps</del>
		<li>
			<del>ConfigImports Config Imports</del>
		<li>
			<del>BasicRest BasicRest</del>, <del>BasicRestGroup BasicRestGroup</del> classes
		<li>
			<del>RestPathAnnotation Path variables on resource paths</del>
		<li>
			<del>RestmRequestAttributes Request Attributes API</del>
		<li>
			<del>RestRoleGuards Role Guards</del>
		<li>
			<del>RestLoggingAndDebugging Improved REST logging/debugging</del>
		<li>
			<a href='#juneau-rest-mock'>New MockRest API</a>
	</ul>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			New utility class for diffing beans: 
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.utils.BeanDiff}
			</ul>
		<li>
			New annotation for defining bean property names: 
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.annotation.Name}
			</ul>
		<li>
			New serializer properties:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.serializer.WriterSerializer}
				<ul>
					<li class='jf'><del>WriterSerializer.WSERIALIZER_fileCharset WSERIALIZER_fileCharset</del>
					<li class='jf'><del>WriterSerializer.WSERIALIZER_streamCharset WSERIALIZER_streamCharset</del>
				</ul>
			</ul>
		<li>
			The following POJO methods can be used to convert a POJO to/from a Map before serialization and after parsing.
			<br>It's a convenient way of defining a POJO transform.
			<ul class='javatree'>
				<li class='jm'><c><jk>public</jk> Map toMap()</c> -  Can be any type of map with string keys and object vals. 
				<li class='jm'><c><jk>public</jk> ObjectMap toMap()</c>
				<li class='jm'><c><jk>public</jk> Map toMap(BeanSession bs)</c> -  Can be any type of map with string keys and object vals. 
				<li class='jm'><c><jk>public</jk> ObjectMap toMap(BeanSession bs)</c>
				<li class='jm'><c><jk>public static</jk> T fromMap(Map m)</c> -  Can be any type of map with string keys and object vals. 
				<li class='jm'><c><jk>public static</jk> T fromMap(ObjectMap m)</c>
				<li class='jm'><c><jk>public static</jk> T fromMap(BeanSession bs, Map m)</c> -  Can be any type of map with string keys and object vals. 
				<li class='jm'><c><jk>public static</jk> T fromMap(BeanSession bs, ObjectMap m)</c>
			</ul>
		<li>
			New convenience debugging methods on Marshall API:
			<ul class='javatree'>
				<li class='jc'><del>Marshall</del>
				<ul>
					<li class='jm'><del> org.apache.juneau.marshall.Marshall.format(String,Object...) format(String,Object...)</del> - <c>MessageFormat</c>-style formatter.
					<li class='jm'><del> org.apache.juneau.marshall.Marshall.out(String,Object...) out(String,Object...)</del> - Prints <c>MessageFormat</c>-style messages to STDOUT.
					<li class='jm'><del> org.apache.juneau.marshall.Marshall.err(String,Object...) err(String,Object...)</del> - Prints <c>MessageFormat</c>-style messages to STDERR.
				</ul>
			</ul>
		<li>
			Serializer and parser APIs now throw <c>IOExceptions</c> in addition to <c>SerializeException</c> and <c>ParseException</c> to make it
			easier to determine if problems are stream based or syntax based.
		<li>
			New Java 8 date-time transforms:
			<ul class='javatree'>
				<li class='jc'><del>TemporalSwap</del> - For all Java 8 temporal types (e.g. {@link java.time.ZonedDateTime})
				<li class='jc'><del>TemporalDateSwap</del> - For {@link java.util.Date}
				<li class='jc'><del>TemporalCalendarSwap</del> - For {@link java.util.Calendar}
			</ul>
		<li>
			All serializers and parsers now have built-in default swaps for common class types:
			<ul class='javatree'>
				<li class='jc'>{@link java.util.Enumeration}
				<li class='jc'>{@link java.util.Iterator}
				<li class='jc'>{@link java.util.Locale}
				<li class='jc'>{@link java.util.Calendar} - ISO offset date-time.
				<li class='jc'>{@link java.util.Date} - Local date-time
				<li class='jc'>{@link java.time.Instant} - ISO instant.
				<li class='jc'>{@link java.time.ZonedDateTime} - ISO offset date-time.
				<li class='jc'>{@link java.time.LocalDate} - ISO local date.
				<li class='jc'>{@link java.time.LocalDateTime} - ISO local date-time.
				<li class='jc'>{@link java.time.LocalTime} - ISO local time.
				<li class='jc'>{@link java.time.OffsetDateTime} - ISO offset date-time.
				<li class='jc'>{@link java.time.OffsetTime} - ISO offset time.
				<li class='jc'>{@link java.time.Year} - ISO year.
				<li class='jc'>{@link java.time.YearMonth} - ISO year-month.
				<li class='jc'>{@link java.time.temporal.Temporal} - ISO instant.
				<li class='jc'>{@link java.util.TimeZone}
				<li class='jc'>{@link javax.xml.datatype.XMLGregorianCalendar}
				<li class='jc'>{@link java.time.ZoneId}
			</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-config</h5>
	<ul class='spaced-list'>
		<li>
			Support for import statements:
			<p class='bcode'>
		<cc>. Import values from another configuration:</cc>
		<ci>&lt;ParentConfig1&gt;</ci>
		
		<cs>[Foo]</cs>
		<ck>bar</ck> = <cv>baz</cv>
			</p>
		<li>
			The <del>ConfigFileStore</del>now automatically resolves file extensions.
			<br>New configuration property for specifying search paths for file extensions:
			<ul class='javatree'>
				<li class='jf'><del>ConfigFileStore.FILESTORE_extensions</del>
			</ul>
		<li>
			Fixed a bug where instances of <del>ConfigMemoryStore</del> ended up resolving to the same object.
		<li>
			Uses <js>"application.properties"</js> file as a system default if present.
			<br>Useful when being used in a Spring Boot application.
		<li>
			New {@link org.apache.juneau.config.Config#setSystemProperties} method for quickly moving configuration settings into the 
			system properties.
		<li>
			Entries in the system config are automatically set as system properties.
			<br>This mean you can set any of the various serializer and parser settings (e.g. <js>"JsonSerializer.simpleMode.b"</js>)
			in the default configuration area or <c>application.properties</c>.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			New annotations that can be applied to REST classes and methods to configure serializers and parsers.
			<p class='bcode'>
		<jc>// Old way using generic properties.</jc>
		<ja>@RestResource</ja>(
			path=<js>"/atom"</js>,
			title=<js>"Sample ATOM feed resource"</js>,
			properties={
				<ja>@Property</ja>(name=<jsf>WSERIALIZER_quoteChar</jsf>, value=<js>"'"</js>),
				<ja>@Property</ja>(name=<jsf>RDF_rdfxml_tab</jsf>, value=<js>"5"</js>),
				<ja>@Property</ja>(name<jsf>RDF_addRootProperty</jsf>, value=<js>"true"</js>),
				<ja>@Property</ja>(name=<jsf>BEAN_examples</jsf>, value=<js>"{'org.apache.juneau.dto.atom.Feed': $F{AtomFeedResource_example.json}}"</js>)
			}
			...
		)
		<jk>public class</jk> AtomFeedResource <jk>extends</jk> BasicRestServletJena {
			...
		}
			</p>
			<p class='bcode'>
		<jc>// New way using specific annotations.</jc>
		<ja>@RestResource</ja>(
			path=<js>"/atom"</js>,
			title=<js>"Sample ATOM feed resource"</js>
			...
		)
		<ja>@SerializerConfig</ja>(quoteChar=<js>"'"</js>)
		<ja>@RdfConfig</ja>(rdfxml_tab=<js>"5"</js>, addRootProperty=<js>"true"</js>)
		<ja>@BeanConfig</ja>(examples=<js>"Feed: $F{AtomFeedResource_example.json}"</js>)
		<jk>public class</jk> AtomFeedResource <jk>extends</jk> BasicRestServletJena {
			...
		}
			</p>
			<p>
				Config annotations are provided for all serializers and parsers:
			</p>
			<ul class='javatree'>
				<li class='ja'>{@link org.apache.juneau.annotation.BeanConfig BeanConfig}
				<li class='ja'>{@link org.apache.juneau.csv.annotation.CsvConfig CsvConfig}
				<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlConfig HtmlConfig}
				<li class='ja'>{@link org.apache.juneau.html.annotation.HtmlDocConfig HtmlDocConfig}
				<li class='ja'><del>JsoConfig JsoConfig</del>
				<li class='ja'>{@link org.apache.juneau.json.annotation.JsonConfig JsonConfig}
				<li class='ja'>{@link org.apache.juneau.jsonschema.annotation.JsonSchemaConfig JsonSchemaConfig}
				<li class='ja'>{@link org.apache.juneau.msgpack.annotation.MsgPackConfig MsgPackConfig}
				<li class='ja'>{@link org.apache.juneau.oapi.annotation.OpenApiConfig OpenApiConfig}
				<li class='ja'>{@link org.apache.juneau.parser.annotation.ParserConfig ParserConfig}
				<li class='ja'>{@link org.apache.juneau.plaintext.annotation.PlainTextConfig PlainTextConfig}
				<li class='ja'><del>RdfConfig</del>
				<li class='ja'>{@link org.apache.juneau.serializer.annotation.SerializerConfig SerializerConfig}
				<li class='ja'>{@link org.apache.juneau.soap.annotation.SoapXmlConfig SoapXmlConfig}
				<li class='ja'>{@link org.apache.juneau.uon.annotation.UonConfig UonConfig}
				<li class='ja'>{@link org.apache.juneau.urlencoding.annotation.UrlEncodingConfig UrlEncodingConfig}
				<li class='ja'>{@link org.apache.juneau.xml.annotation.XmlConfig XmlConfig}
			</ul>
		<li>
			New support for using Servlet request attributes.  
			<ul class='javatree'>
				<li class='jc'><del>RequestAttributes</del>
				<li class='jc'>{@link org.apache.juneau.rest.RestContext}
				<ul>
					<li class='jf'><del>REST_attrs</del>
				</ul>
				<li class='jc'>{@link org.apache.juneau.rest.RestContext.Builder}
				<ul>
					<li class='jm'><del> attrs(String...)</del>
					<li class='jm'><del>attr(String,Object)</del>
				</ul>
				<li class='jc'><del>RestMethodContext</del>
				<ul>
					<li class='jf'><del>RestMethodContext.RESTMETHOD_attrs RESTMETHOD_attrs</del>
				</ul>
				<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
				<ul>
					<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getAttributes() getAttributes()}
				</ul>
				<li class='jc'>{@link org.apache.juneau.rest.RestResponse}
				<ul>
					<li class='jm'>{@link org.apache.juneau.rest.RestResponse#getAttributes() getAttributes()}
					<li class='jm'><del>RestResponse.attr(String,Object) attr(String,Object)</del>
				</ul>
				<li class='ja'>{@link org.apache.juneau.rest.annotation.Attr}
				<li class='ja'><del>RestMethod.attrs()</del>
				<li class='ja'><del>RestResource.attrs()</del>
			</ul>
			<br>This deprecates the following APIs:
			<ul class='javatree'>
				<li class='jc'><del>RequestProperties</del>
				<li class='jc'><del>RestMethodProperties</del>
				<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
				<ul>
					<li class='jm'><del>RestRequest.getProperties() getProperties()</del>
					<li class='jm'><del>RestRequest.prop(String,Object) prop(String,Object)</del>
				</ul>
			</ul>
		<li>
			Added the following classes that provide the same support as the servlet classes but doesn't extend from <c>HttpServlet</c>.
			<br>This fixes an issue where instances of <del>BasicRestServlet</del> are registered as top-level servlets even though
			you don't want them to be.  
			<ul class='javatree'>
				<li class='jac'><del>BasicRest</del> - Non-servlet equivalent to <del>BasicRestServlet</del>
				<li class='jac'><del>BasicRestGroup</del> - Non-servlet equivalent to <del>BasicRestServletGroup</del>
				<li class='jac'><del>BasicRestJena</del> - Non-servlet equivalent to <del>BasicRestServletJena</del>
				<li class='jac'><del>BasicRestJenaGroup</del> - Non-servlet equivalent to <del>BasicRestServletJenaGroup</del>
			</ul>
		<li>
			HTML widgets now have access to the <c>RestResponse</c> object if they need access to the output bean.
		<li>
			New annotations for simplified role-based guards on classes and methods:
			<ul class='javatree'>
				<li class='ja'><del>RestResource</del> 
				<ul>
					<li class='jm'><del>roleGuard()</del>
					<li class='jm'><del>rolesDeclared()</del>
				</ul>
				<li class='ja'><del>RestMethod</del>
				<ul>
					<li class='jm'><del>RestMethod.roleGuard roleGuard()</del>
					<li class='jm'><del>RestMethod.rolesDeclared rolesDeclared()</del>
				</ul>
			</ul>
		<li>
			New annotations for fine-tuned handling of http-methods/http-headers as query parameters and others:
			<ul class='javatree'>
				<li class='ja'><del>RestResource</del> 
				<ul>
					<li class='jm'><del>allowedHeaderParams()</del>
					<li class='jm'><del>allowedMethodHeaders()</del>
					<li class='jm'><del>allowedMethodParams()</del>
				</ul>
			</ul>
		<li>
			The <del>@RestResource(path)</del>annotation can now use variables:
			<p class='bcode'>
		<ja>@RestResource</ja>(
			path=<js>"/myResource/{foo}/{bar}"</js>
		)
		<jk>public class</jk> MyResource <jk>extends</jk> BasicRestServlet {...}
			</p>		
		<li>
			New methods:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.rest.RestRequest}
				<ul>
					<li class='jm'>{@link org.apache.juneau.rest.RestRequest#getCharset() getCharset()}
				</ul>
				<li class='jc'>{@link org.apache.juneau.rest.RestResponse}
				<ul>
					<li class='jm'>{@link org.apache.juneau.rest.RestResponse#getCharset() getCharset()}
				</ul>
			</ul>
		<li>
			New interface method for catching arbitrary thrown objects and converting them to other throwables.
			<ul class='javatree'>
				<li class='jc'><del>RestCallHandler</del>
				<ul>
					<li class='jm'><del>RestCallHandler.convertThrowable(Throwable) convertThrowable(Throwable)</del>
				</ul>
				<li class='jc'><del>BasicRestCallHandler</del>
				<ul>
					<li class='jm'><del>convertThrowable(Throwable)</del>
				</ul>
			</ul>
		<li>
			Support for fine-tuned logging of HTTP requests and responses. 
			<p class='bcode'>
		<ja>@RestResource</ja>(
			debug=<js>"per-request"</js>,
			logging=<ja>@Logging</ja>(
				level=<js>"info"</js>,
				rules={
					<ja>@LoggingRule</ja>(codes<js>"400-499"</js>, level=<js>"warning"</js>, req=<js>"short"</js>, res=<js>"short"</js>)
					<ja>@LoggingRule</ja>(codes<js>"500-"</js>, level=<js>"severe"</js>, req=<js>"long"</js>, res=<js>"long"</js>)
				}
			)
		)
		<jk>public class</jk> MyRest {
	
			<ja>@RestMethod</ja>(
				method=<js>"POST"</js>, 
				path=<js>"foo"</js>
				logging=<ja>@Logging</ja>(
					level=<js>"info"</js>,
					rules={
						<ja>@LoggingRule</ja>(exceptions<js>"NotFound*"</js>, level=<js>"info"</js>)
						<ja>@LoggingRule</ja>(codes<js>"200"</js>, disabled=<js>"true"</js>)
					}
				)
			)
			<jk>public</jk> String myMethod() <jk>throws</jk> Exception {...}
			</p>		
			See <del>RestLoggingAndDebugging</del>for details.
		<li>
			Fixed a bug where the HTTP response was returning 405 (method not found) but should really be 404 (not found)
			when no path patterns match on any of the Java methods.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			PATCH support added.
	</ul>
</div>
</div><!-- END: 8.1.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.1.1' id='8.1.1'>8.1.1 (Sept 20, 2019)</a></h3>
<div class='topic'><!-- START: 8.1.1 -->
<div class='topic'>
	<p>
		Juneau 8.1.1 is a minor release but introduces some new features/modifications.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Support for serializing/parsing {@link java.util.Optional} objects and bean properties.
		<li>
			Fixed a bug in the parsers where the generic subtype of a complex bean property type involving both collections and arrays
			was not being found.  (e.g. <c>List&lt;Long&gt;[]</c>)
		<li>
			New packages of HTTP response/exceptions beans from <c>juneau-rest-server</c> bundle and REST proxy annotations from <c>juneau-rest-client</c> 
			so that they can be used when building REST proxy interfaces while only pulling in the marshall bundle.
			<ul>
				<li class='jp'>{@link org.apache.juneau.http.response}
				<li class='jp'><del>exception</del>
				<li class='jp'>{@link org.apache.juneau.http.remote}
			</ul>
			These replace the <c>org.apache.juneau.rest.response</c>, <c>org.apache.juneau.rest.exception</c>, and <c>org.apache.juneau.rest.client.remote</c> packages.
		<li>
			Defaulting SVL variables now won't ignore additional parameters.
			<br><js>"$S{Foo,bar,baz}"</js> used to default to <js>"bar"</js> but now will default to <js>"bar,baz"</js>.
		<li>
			Ranking support has been added to all <ja>@XConfig</ja> annotations.
			This allows you to override the normal precedence of application of config annotations on class and method hierarchies.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Support for {@link java.util.Optional} on method parameters annotated with {@link org.apache.juneau.http.annotation.Header}, {@link org.apache.juneau.http.annotation.FormData},  
			{@link org.apache.juneau.http.annotation.Query}, {@link org.apache.juneau.http.annotation.Path}.
		<li>
			Fixed issue where <del> org.apache.juneau.rest.annotation.RestMethod.debug() RestMethod.debug()</del> annotation wasn't resulting
			in the HTTP request being logged.
		<li>
			<del>RestException</del> has been deprecated and replaced by <del>HttpException</del>.
		<li>
			Resolved issue where parameterized types on <ja>@RestMethod</ja>-annotated method parameters of Spring beans.
			This is due to Spring relying on CGLIB for runtime-recompilation of beans that results in loss of parameterized-type
			information.  
			<br>In the following example, the <c>beans</c> parameter would resolve as an unparameterized <c>List</c>
			which would typically result in getting a <c>List&lt;ObjectMap&gt;<c> and subsequent <c>ClassCastExceptions</c>.   
			<p class='bcode'>
		<ja>@RestMethod</ja>
		<jk>public void</jk> doFoo(<ja>@Body</ja> List&lt;MyBean&gt; beans) {...}
			</p>
			The fix involves resolving the original bean class for resolving parameterized type while leaving
			method invocation on the proxy method so as not to bypass Spring features.
		<li>
			New methods on <del>BasicRest</del>to provide feature-parity with <del>RestServlet</del>:
			<ul class='javatree'>
				<li class='jc'><del>BasicRest</del>
					<ul class='javatreec'>
						<li class='jm'><del>BasicRest.getContext() getContext()</del>
						<li class='jm'><del>BasicRest.getRequest() getRequest()</del>
						<li class='jm'><del>BasicRest.getResponse() getResponse()</del>
						<li class='jm'><del>BasicRest.log(String) log(String)</del>
						<li class='jm'><del>BasicRest.log(String,Throwable) log(String,Throwable)</del>
						<li class='jm'><del>BasicRest.log(Level,String,Object[]) log(Level,String,Object[])</del>
						<li class='jm'><del>BasicRest.logObjects(Level,String,Object[])</del>
						<li class='jm'><del>BasicRest.log(Level,Throwable,String,Object[]) log(Level,Throwable,String,Object[])</del>
					</ul>
				</li>
			</ul>
		<li>
			The <del>@RestResource(staticFiles)</del> annotation now supports absolute path locations and multiple mappings:
			<p class='bcode'>
		<jc>// Resolves static files in root package "htdocs" or working directory "htdocs", and then relative package "htdocs".</jc>
		<ja>@RestResource</ja>(staticFiles=<js>"htdocs:/htdocsfolder,htdocs:htdocs.package"</js>)
			</p>
		<li>
			Fixed a bug in <del>@RestResource(staticFiles)</del>where the order of lookup between parent and child resources
			was wrong.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			Removed the dependency on the <c>juneau-rest-server</c> module.  
			Allows the client API to be used without pulling in all the javax.servlet and server dependencies.
	</ul>
	
	<h5 class='topic w800'>juneau-examples</h5>
	<ul class='spaced-list'>
		<li>
			The PetStore application has been moved to a separate Git repository.
			<ul>
				<li><a class='doclink' href='https://github.com/apache/juneau-petstore'>GitHub Repo</a>
				<li><a class='doclink' href='http://juneau.apache.org/index.html#petstore.html'>Documentation</a>
			</ul>
	</ul>
</div>
</div><!-- END: 8.1.1 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.1.2' id='8.1.2'>8.1.2 (Dec 01, 2019)</a></h3>
<div class='topic'><!-- START: 8.1.2 -->
<div class='topic'>
	<p>
		Juneau 8.1.2 is a moderate release.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Support for read-only and write-only properties.
			<ul>
				<li class='ja'><del>Bean.bpro()</del>
				<li class='ja'><del>Bean.bpwo()</del>
				<li class='ja'>{@link org.apache.juneau.annotation.Beanp#ro()}
				<li class='ja'>{@link org.apache.juneau.annotation.Beanp#wo()}
				<li class='jf'><del>BEAN_bpro</del>
				<li class='jf'><del>BEAN_bpwo</del>
				<li class='jm'><del>Builder.bpro(Map)</del>
				<li class='jm'><del>Builder.bpwo(Map)</del>
			</ul>
		<li>
			New convenience methods:
			<ul>	
				<li class='jm'><del>ObjectMap.parse(CharSequence)</del>
				<li class='jm'><del>ObjectList.parse(CharSequence)</del>
			</ul>
		<li>
			<del>CharMarshall</del>and <del>StreamMarshall</del> now have public constructors.
		<li>
			{@link org.apache.juneau.annotation.Beanp @Beanp} replaces <del>BeanProperty @BeanProperty</del>.
		<li>
			{@link org.apache.juneau.annotation.Beanc @Beanc} replaces <del>BeanConstructor @BeanConstructor</del>.
		<li>
			{@link org.apache.juneau.http.remote.Remote @Remote} replaces <del>RemoteResource @RemoteResource</del>.
		<li>
			Shortened names for {@link org.apache.juneau.annotation.Bean#dictionary @Bean(dictionary)} and {@link org.apache.juneau.BeanContext.Builder#beanDictionary(Class...)}.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.rest.annotation.Rest @Rest} replaces <del>RestResource @RestResource</del> with shorter syntax.
		<li>
			New method <del>RestResponse.setHeaderSafe(String,String)</del>to strip invalid characters from header values.
		<li>
			Fixed issues related to invalid characters being set on HTTP header values.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.rest.client.RestClient} is now extendible.  The constructor has been made public and simplified to:
			<del> org.apache.juneau.rest.client.RestClient.RestClient(RestClient.Builder)</del>.
		<li>
			Duplicate methods between {@link org.apache.juneau.rest.client.RestClient.Builder} and {@link org.apache.http.impl.client.HttpClientBuilder}
			have been made deprecated on the former.  This eliminates the need to try to keep the two builder classes in
			sync.
	</ul>
</div>
</div><!-- END: 8.1.2 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.1.3' id='8.1.3'>8.1.3 (Jan 20, 2020)</a></h3>
<div class='topic'><!-- START: 8.1.3 -->
<div class='topic'>
	<p>
		Juneau 8.1.3 is a moderate release.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Dynamically applied annotations: <del>DynamicallyAppliedAnnotations</del>
		<li>
			Better representation of nulls for XML and HTML content properties.
			<br>Old:  <js>"&lt;myBean&gt;&lt;null&gt;&lt;/myBean&gt;"</js>
			<br>New:  <js>"&lt;myBean nil='true'&gt;&lt;/myBean&gt;"</js>
		<li>
			Configurable properties such as <del>Context.CONTEXT_debug</del> can now be set globally by either
			system properties or environment variables.
			<br>For <jsf>CONTEXT_debug</jsf> you can use either the system
			property <js>"Context.debug"</js> or environment variables <js>"CONTEXT_DEBUG"</js>.
		<li>
			Fixed an initialization time race condition that can cause initial parse errors when concurrently parsing into
			array types like so: 
			<p class='bcode'>
		JsonParser.<jsf>DEFAULT</jsf>.parse(input, MyBean[].<jk>class</jk>);
			</p>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li> 
			Fixed bug in <del>BasicRestCallHandler</del> where if you have the following REST methods...
			<p class='bcode'>
		<ja>@RestMethod</ja>(name=<js>"GET"</js>, path=<js>"/foo"</js>)
		<ja>@RestMethod</ja>(name=<js>"*"</js>, path=<js>"/bar"</js>)
			</p>
			...and you tried to make a GET request to /bar, you'd erroneously get a 404 error instead of matching the 2nd method.
		<li> 
			Fixed an issue involving using Juneau REST with Spring Security.  When Spring Security cannot authenticate a 
			request, it sets the URL on the request to <js>"/error"</js> with a 401 status.  When Juneau then processes
			this request, it cannot find that mapping and changes the status to 404 which messes with HTTP clients.
			<br>Solution was to add a default no-op error method to the <del>BasicRestConfig</del>(and implementers):
			<p class='bcode'>
		<ja>@RestMethod</ja>(name=<js>"*"</js>, path=<js>"/error"</js>)
		<jk>public void</jk> error() {}
			</p>
		<li>
			Fixed a bug where <c><ja>@RestResource</ja>(debug=<js>"true"</js>)</c> wouldn't log requests if a 
			<ja>@RestMethod</ja>-annotated method was not matched.
		<li>
			Renamed the following annotations:
			<ul>
				<li><ja>@Rest(attrs)</ja> --&gt; <del>Rest.reqAttrs() @Rest(reqAttrs)</del>
				<li><ja>@Rest(defaultRequestHeaders)</ja> --&gt; <del>Rest.reqHeaders() @Rest(reqHeaders)</del>
				<li><ja>@Rest(defaultResponseHeaders)</ja> --&gt; <del>Rest.resHeaders() @Rest(resHeaders)</del>
				<li><ja>@RestMethod(attrs)</ja> --&gt; <del>RestMethod.reqAttrs() @RestMethod(reqAttrs)</del>
				<li><ja>@RestMethod(defaultRequestHeaders)</ja> --&gt; <del>RestMethod.reqHeaders() @RestMethod(reqHeaders)</del>
			</ul>
		<li>
			New auto-generated REST method execution statistics: <del>RestExecutionStatistics</del>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			Several convenience methods defined in {@link org.apache.juneau.rest.client.RestClient.Builder} that were deprecated in 8.1.2 have been
			undeprecated in this release due to user feedback.
	</ul>
	
	<h5 class='topic w800'>juneau-doc</h5>
	<ul class='spaced-list'>
		<li>
			New auto-generated glossary of all configurable properties: <del>GlossaryConfigurableProperties</del>
	</ul>
</div>
</div><!-- END: 8.1.3 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#8.2.0' id='8.2.0'>8.2.0 (Oct 14, 2020)</a></h3>
<div class='topic'><!-- START: 8.2.0 -->
<div class='topic'>
	<p>
		Juneau 8.2.0 is a major release. 
		The most significant change is the addition of an entirely new <del>RestClient</del> API build from scratch
		with near 100% unit test coverage.
		The new API is located in the <c>org.apache.juneau.rest.client2</c> package and will replace the old API in 9.0.
	</p>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			{@link org.apache.juneau.annotation.Bean @Bean} and {@link org.apache.juneau.annotation.BeanIgnore @BeanIgnore} annotations can alternately occur in parent class hierarchy.
			The first one found dictates whether a class is ignored as a bean or not.
		<li>
			Applying the {@link org.apache.juneau.annotation.Bean @Bean} annotation on a class will now force non-public classes to be interpreted as beans.
			For example, applying {@link org.apache.juneau.annotation.Bean @Bean} to a <jk>private</jk> class will force it to be treated as a bean.
			<br>
			Also, if a public bean constructor cannot be found, the default constructor will be used 
			regardless of it's visibility if the {@link org.apache.juneau.annotation.Bean @Bean} annotation is on the class.
		<li>
			The <ja>@Beanc</ja> annotation can now be recognized and used on non-public constructors.
		<li>
			Annotations are now aggregated across the entire class hierarchy instead of simply being overridden.
			<br>The following is an example.
			<p class='bcode'>
		<jc>// Parent class with properties a,b,c</jc>
		<ja>@Bean</ja>(bpi=<js>"a,b,c"</js>)
		<jk>public class</jk> MyClass {
			<jk>public int</jk> a, b, c, d;
		}
		
		<jc>// New behavior:  Child class with properties a,c because @Beans are aggregated.</jc>
		<jc>// Old behavior:  Child class with properties a,c,d because @Bean is overridden.</jc>
		<ja>@Bean</ja>(bpx=<js>"b"</js>)
		<jk>public class</jk> MyClass {
			<jk>public int</jk> a, b, c, d;
		}
			</p>
		<li>
			Include/exclude/read-only/write-only properties defined on the bean context now override those defined on 
			annotations of the class itself.  For example, the following methods override the {@link org.apache.juneau.annotation.Bean @Bean} 
			annotations on classes:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.BeanContext.Builder}
					<ul class='javatreec'>
						<li class='jm'><del>Builder.bpi(Class,String) bpi(Class,String)</del>
						<li class='jm'><del>Builder.bpi(String,String) bpi(String,String)</del>
						<li class='jm'><del>Builder.bpx(Class,String) bpx(Class,String)</del>
						<li class='jm'><del>Builder.bpx(String,String) bpx(String,String)</del>
						<li class='jm'><del>Builder.bpro(Class,String) bpro(Class,String)</del>
						<li class='jm'><del>Builder.bpro(String,String) bpro(String,String)</del>
						<li class='jm'><del>Builder.bpwo(Class,String) bpwo(Class,String</del>
						<li class='jm'><del>Builder.bpwo(String,String) bpwo(String,String</del>
					</ul>
				</li>
			</ul>
		<li>
			Config annotations now override class-level annotations.
			<br>For example, only the 'a' and 'b' properties get serialized on the bean below:
			<p class='bcode'>
		<jc>// Parent class with properties a,b,c</jc>
		<ja>@Bean</ja>(bpi=<js>"a,b,c"</js>)
		<jk>public class</jk> MyClass {
			<jk>public int</jk> a, b, c, d;
		}
	
		<ja>@RestMethod</ja>
		<ja>@BeanConfig</ja>(beanApply={<ja>@Bean</ja>(on=<js>"MyClass"</js>,bpi=<js>"a,b"</js>)}
		<jk>public</jk> MyClass getMyClass() {...}
			</p>
		<li>
			The following concrete annotation implementation classes are now provided that can be used with the {@link org.apache.juneau.BeanContext.Builder#annotations(Annotation...)} method:
			<ul class='javatree'>
				<li class='jc'>{@link org.apache.juneau.annotation.BeanAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.Bean}
				<li class='jc'>{@link org.apache.juneau.annotation.BeancAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.Beanc}
				<li class='jc'>{@link org.apache.juneau.annotation.BeanIgnoreAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.BeanIgnore}
				<li class='jc'>{@link org.apache.juneau.annotation.BeanpAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.Beanp}
				<li class='jc'>{@link org.apache.juneau.annotation.ExampleAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.Example}
				<li class='jc'>{@link org.apache.juneau.annotation.NamePropertyAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.NameProperty}
				<li class='jc'>{@link org.apache.juneau.annotation.ParentPropertyAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.ParentProperty}
				<li class='jc'>{@link org.apache.juneau.annotation.SwapAnnotation} <jk>implements</jk> {@link org.apache.juneau.annotation.Swap}
				<li class='jc'>{@link org.apache.juneau.annotation.UriAnnotation} <jk>implements</jk> <del>URI</del>
				<li class='jc'>{@link org.apache.juneau.csv.annotation.CsvAnnotation} <jk>implements</jk> {@link org.apache.juneau.csv.annotation.Csv}
				<li class='jc'>{@link org.apache.juneau.html.annotation.HtmlAnnotation} <jk>implements</jk> {@link org.apache.juneau.html.annotation.Html}
				<li class='jc'><del>JsoAnnotation</del> <jk>implements</jk> <del>Jso</del>
				<li class='jc'>{@link org.apache.juneau.json.annotation.JsonAnnotation} <jk>implements</jk> {@link org.apache.juneau.json.annotation.Json}
				<li class='jc'><del>SchemaAnnotation</del> <jk>implements</jk> <del>Schema</del>
				<li class='jc'>{@link org.apache.juneau.msgpack.annotation.MsgPackAnnotation} <jk>implements</jk> {@link org.apache.juneau.msgpack.annotation.MsgPack}
				<li class='jc'>{@link org.apache.juneau.oapi.annotation.OpenApiAnnotation} <jk>implements</jk> {@link org.apache.juneau.oapi.annotation.OpenApi}
				<li class='jc'>{@link org.apache.juneau.plaintext.annotation.PlainTextAnnotation} <jk>implements</jk> {@link org.apache.juneau.plaintext.annotation.PlainText}
				<li class='jc'>{@link org.apache.juneau.soap.annotation.SoapXmlAnnotation} <jk>implements</jk> {@link org.apache.juneau.soap.annotation.SoapXml}
				<li class='jc'>{@link org.apache.juneau.uon.annotation.UonAnnotation} <jk>implements</jk> {@link org.apache.juneau.uon.annotation.Uon}
				<li class='jc'>{@link org.apache.juneau.urlencoding.annotation.UrlEncodingAnnotation} <jk>implements</jk> {@link org.apache.juneau.urlencoding.annotation.UrlEncoding}
				<li class='jc'>{@link org.apache.juneau.xml.annotation.XmlAnnotation} <jk>implements</jk> {@link org.apache.juneau.xml.annotation.Xml}
			</ul>
			<br>Example:
			<p class='bcode'>
		<ja>@Bean</ja>(bpi=<js>"street,city"</js>) <jc>// Will be overridden</jc>
		<jk>public class</jk> AddressBean {...}
		
		<ja>Bean</ja> ba = <jk>new</jk> BeanAnnotation(<js>"AddressBean"</js>).bpi(<js>"street,city,state"</js>);
		WriterSerializer ws = JsonSerializer.<jsm>create</jsm>().annotations(ba).build();
		String json = ws.toString(addressBean);  <jc>// Will print street,city,state</jc>
			</p>
		<li>
			Bean maps now have the concept of "hidden" properties (properties that aren't serialized but otherwise accessible).
			<br>For example, the {@link org.apache.juneau.html.annotation.Html#link()} can now reference hidden properties:
			<p class='bcode'>
		<ja>@Bean</ja>(bpi=<js>"a"</js>) <jc>// Will be overridden</jc>
		<jk>public class</jk> MyBean {
			
			<ja>@Html</ja>(link=<js>"servlet:/{b}"</js>)
			<jk>public</jk> String <jf>a</jf>;
			
			<jk>public</jk> String <jf>b</jf>;  <jc>// Not serialized but referenced in link on a.</jc>  
				
		}
			</p>
			<br>
			The general rule for the {@link org.apache.juneau.BeanMap} class is that <c>get()</c>,<c>put()</c>, and <c>containsKey()</c>
			will work against hidden properties but <c>keySet()</c> and <c>entrySet()</c> will skip them.
		<li>
			Several bug fixes in the {@link org.apache.juneau.html.HtmlSerializer} and {@link org.apache.juneau.html.HtmlParser} classes around the handling of 
			collections and arrays of beans with <c><ja>@Bean</ja>(typeName)</c> annotations.
		<li>
			New swaps auto-added to all serializers/parsers:
			<ul>
				<li class='jc'><del>MatchResultSwap</del> 
				<li class='jc'><del>StackTraceElementSwap</del>
			</ul>		
		<li>
			{@link org.apache.juneau.html.annotation.Html#noTableHeaders} now can be applied to collections of beans.
		<li>
			New {@link org.apache.juneau.html.annotation.HtmlDocConfig#asideFloat()} setting so that you can position the contents of the aside section on the page.
		<li>
			Various minor fixes surrounding HTML serialization.
			<ul>
				<li>Collections of beans that were supposed to be serialized as tables were being serialized as lists.
				<li>Collections of beans with <c><ja>@Bean</ja>(bpi)</c> were not being serialized in the correct column order.			
			</ul>
		<li>
			Fixed a bug where a copy constructor can erroneously be recognized as a builder constructor if the class also
			has a static <c>create</c> method.  Net effect was that the copy constructor would needlessly be called during parsing.
		<li>
			New {@link org.apache.juneau.collections} package containing various convenience fluent-style collection classes:
			<ul>
				<li class='jc'><del>AList</del>
				<li class='jc'><del>ASet</del>
				<li class='jc'><del>ASortedSet</del>
				<li class='jc'><del>AMap</del>
				<li class='jc'><del>ASortedMap</del>
				<li class='jc'><del>OMap</del>
				<li class='jc'><del>OList</del>
			</ul>
		<li>
			<del>ObjectMap</del> is being deprecated and replaced with <del>OMap</del>.
		<li>
			<del>ObjectList</del> is being deprecated and replaced with <del>OList</del>.
		<li>
			All classes in the {@link org.apache.juneau.http.response} and <del>exception</del> now have <c>header(String,Object)</c>
			methods for adding response headers.
			<p class='bcode'>
		<jc>// Method that performs a BASIC Auth handshake.</jc>
		<ja>@RestMethod</ja>
		<jk>public</jk> Ok checkBasicAuth(<ja>@Header</ja>(<js>"Authorization"</js>) String auth) <jk>throws</jk> Unauthorized {
			<jk>if</jk> (auth == <jk>null</jk>) 
				<jk>throw new</jk> Unauthorized().header(<js>"WWW-Authenticate"</js>, <js>"BASIC realm=\"foo\""</js>);
			<jk>return</jk> Ok.<jsf>OK</jsf>;
		}
			</p>		
		<li>
			New annotations for multi-part support:
			<ul>
				<li class='jm'><del>Header.multi()</del>
				<li class='jm'><del>Query.multi()</del>
				<li class='jm'><del>FormData.multi()</del>
			</ul>
		<li>
			<del>BeanTraverseContext.BEANTRAVERSE_ignoreRecursions</del>setting no longer requires <del>BeanTraverseContext.BEANTRAVERSE_detectRecursions</del>
			to be enabled.
		<li>
			Fixed bug in JSON/UON/URL-Encoding serializers where indentation was not correct of first line when <del>BeanTraverseContext.BEANTRAVERSE_initialDepth</del>
			used.
		<li>
			Fixed bug in JSON/UON/URL-Encoding serializers where properties past the max depth were being serialized as null instead
			of being treated as null and not being serialized at all.
		<li>
			Fixed bug in HTML serializer where tables of maps were not sorted if <jsf>SERIALIZER_sortMaps</jsf> was specified.
		<li>
			<jsf>SERIALIZER_trimNullProperties</jsf> has been replaced with <del>Serializer.SERIALIZER_keepNullProperties SERIALIZER_keepNullProperties</del>.
		<li>
			Improvements to OpenAPI serializer and parser:
			<ul>
				<li>Collection format can now be specified on OBJECTs to allow key/value pairs to be delimited with the same support as ARRAYs.
				<li>New <del>OpenApiCommon.OAPI_format OAPI_format</del>and <del>OpenApiCommon.OAPI_collectionFormat OAPI_collectionFormat</del>properties.
			</ul>
		<li>
			Convenience methods added to {@link org.apache.juneau.httppart.HttpPartSchema} and related classes to simplify schema definitions:
			<p class='bcode'>
		<jk>import static</jk> org.apache.juneau.httppart.HttpPartSchema.*;
			
		<jc>// Old</jc>
		HttpPartSchema s = <jsm>schema</jsm>(<js>"object"</js>)
			.property(<js>"f01"</js>, <jsm>schema</jsm>(<js>"array"</js>).collectionFormat(<js>"pipes"</js>).items(<jsm>schema</jsm>(<js>"string"</js>)))
			.property(<js>"f02"</js>, <jsm>schema</jsm>(<js>"array"</js>).collectionFormat(<js>"pipes"</js>).items(<jsm>schema</jsm>(<js>"string"</js>, <js>"byte"</js>)))
			.property(<js>"f03"</js>, <jsm>schema</jsm>(<js>"array"</js>).collectionFormat(<js>"pipes"</js>).items(<jsm>schema</jsm>(<js>"string"</js>, <js>"date-time"</js>)))
			.build();
	
		<jc>// New</jc>
		HttpPartSchema s = <jsm>tObject</jsm>()
			.p(<js>"f01"</js>, <jsm>tArray</jsm>(<jsm>tString()</jsm>))
			.p(<js>"f02"</js>, <jsm>tArray</jsm>(<jsm>tByte()</jsm>))
			.p(<js>"f03"</js>, <jsm>tArray</jsm>(<jsm>tDateTime()</jsm>))
			.build();
			</p>
		<li>
			Fixes where the bean method/constructor visibility wasn't being used when finding swap methods and constructors.
		<li>
			HTML-Schema support is being deprecated due to low-use and difficulty in maintaining.  It will be removed in 9.0.
		<li>
			<c>JuneauLogger</c> class is being deprecated.  Improvements in logging in Java 8 make it obsolete.
		<li>
			Bean filters can now be specified programmatically through a builder API.
			<p class='bcode'>
		<jc>// Create a JSON serializer that only includes specified fields on a specific class.</jc>
		WriterSerializer s = JsonSerializer
			.<jsm>create</jsm>()
			.beanFilters(BeanFilter.<jsm>create</jsm>(MyBean.<jk>class</jk>).bpi(<js>"foo,bar,baz"</js>).build())
			.build();
			</p>
		<li>
			<c>BeanContext.REST_pojoSwaps</c> replaced with <del>BeanContext.BEAN_swaps</del>(and builder methods as well).
		<li>
			New Bean Property Interceptor API for intercepting calls to bean getters/setters.
			<ul>
				<li class='jac'><del>BeanInterceptor</del>
				<li class='ja'>{@link org.apache.juneau.annotation.Bean#interceptor Bean(interceptor)}
				<li class='jm'>{@link org.apache.juneau.BeanContext.Builder#beanInterceptor(Class,Class)}
			</ul>
		<li>
			Fluent setters that follow the <c>withX</c> convention are now automatically detected by all parsers.
			<p class='bcode'>
		<jc>// A bean with a fluent setter.</jc>
		<jk>public class</jk> MyBean {
			<jk>public</jk> MyBean withFoo(String <jv>foo</jv>) {
				<jk>this</jk>.<jf>foo</jf> = <jv>foo</jv>;
				<jk>return this</jk>;
			}
		}
			</p>
			Note you could previously use the <ja>@BeanProperty</ja> annotation to identify these setters.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			New <del>RestContext.REST_context REST_context</del>/<del>Rest.context() @Rest(context)</del> setting to allow you to extend the {@link org.apache.juneau.rest.RestContext}
			class.
		<li>
			{@link org.apache.juneau.rest.annotation.Rest}-annotated classes can now implement the following interfaces directly instead of having
			to define secondary classes and hook them up through annotations:
			<ul>
				<li class='jic'><del>RestCallHandler</del>- Normally defined through <del> org.apache.juneau.rest.annotation.Rest.callHandler() @Rest.callHandler()</del>.
				<li class='jic'><del>RestInfoProvider</del> - Normally defined through <del> org.apache.juneau.rest.annotation.Rest.infoProvider() @Rest.infoProvider()</del>.
				<li class='jic'><del>RestCallLogger</del>- Normally defined through <del> org.apache.juneau.rest.annotation.Rest.callLogger() @Rest.callLogger()</del>.
				<li class='jic'><del>ClasspathResourceFinder</del> - Normally defined through <del> org.apache.juneau.rest.annotation.Rest.classpathResourceFinder() @Rest.classpathResourceFinder()</del>.
			</ul>
			<br>The methods added for <del>RestInfoProvider</del> are:
			<ul>
				<li class='jac'><del>RestServlet</del>
				<ul>
					<li class='jm'><del>getSwagger(RestRequest)</del>
					<li class='jm'><del>getSiteName(RestRequest)</del>
					<li class='jm'><del>getTitle(RestRequest)</del>
					<li class='jm'><del>getDescription(RestRequest)</del>
					<li class='jm'><del>getMethodSummary(Method,RestRequest)</del>
					<li class='jm'><del>getMethodDescription(Method,RestRequest)</del>
				</ul>
				<li class='jac'><del>BasicRest</del>
				<ul>
					<li class='jm'><del>getSwagger(RestRequest)</del>
					<li class='jm'><del>getSiteName(RestRequest)</del>
					<li class='jm'><del>getTitle(RestRequest)</del>
					<li class='jm'><del>getDescription(RestRequest)</del>
					<li class='jm'><del>getMethodSummary(Method,RestRequest)</del>
					<li class='jm'><del>getMethodDescription(Method,RestRequest)</del>
				</ul>
			</ul>
			<br>The methods added for <del>RestCallLogger</del>are:
			<ul>
				<li class='jac'><del>RestServlet</del>
				<ul>
					<li class='jm'><del>RestServlet.log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse) log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse)</del>
				</ul>
				<li class='jac'><del>BasicRest</del>
				<ul>
					<li class='jm'><del>BasicRest.log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse) log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse)</del>
				</ul>
			</ul>
			<br>The methods added for <del>ClasspathResourceFinder</del>are:
			<ul>
				<li class='jac'><del>RestServlet</del>
				<ul>
					<li class='jm'><del>RestServlet.findResource(Class,String,Locale) findResource(Class,String,Locale)</del>
				</ul>
				<li class='jac'><del>BasicRest</del>
				<ul>
					<li class='jm'><del>BasicRest.findResource(Class,String,Locale) findResource(Class,String,Locale)</del>
				</ul>
			</ul>
			<br>The methods added for <del>RestResourceResolver</del>are:
			<ul>
				<li class='jac'><del>RestServlet</del>
				<ul>
					<li class='jm'><del> org.apache.juneau.rest.RestServlet.resolve(Object,Class,RestContext.Builder,Object...) resolve(Object,Class&lt;T&gt;,RestContext.Builder,Object...)</del>
				</ul>
				<li class='jac'><del>BasicRest</del>
				<ul>
					<li class='jm'><del> org.apache.juneau.rest.BasicRest.resolve(Object,Class,RestContext.Builder,Object...) resolve(Object,Class&lt;T&gt;,RestContext.Builder,Object...)</del>
				</ul>
			</ul>
		<li>
			Added the following convenience hook methods on the <del>RestServlet</del> and <del>BasicRest</del>classes:
			<ul>
				<li class='jac'><del>RestServlet</del>
				<ul>
					<li class='jm'><del> org.apache.juneau.rest.RestServlet.onInit(RestContext.Builder) onInit(RestContext.Builder)</del>
					<li class='jm'><del>RestServlet.onPostInit(RestContext) onPostInit(RestContext)</del>
					<li class='jm'><del>RestServlet.onPostInitChildFirst(RestContext) onPostInitChildFirst(RestContext)</del>
					<li class='jm'><del>RestServlet.onDestroy(RestContext) onDestroy(RestContext)</del>
					<li class='jm'><del>RestServlet.onStartCall(HttpServletRequest,HttpServletResponse) onStartCall(HttpServletRequest,HttpServletResponse)</del>
					<li class='jm'><del>RestServlet.onPreCall(RestRequest,RestResponse) onPreCall(RestRequest,RestResponse)</del>
					<li class='jm'><del>RestServlet.onPostCall(RestRequest,RestResponse) onPostCall(RestRequest,RestResponse)</del>
					<li class='jm'><del>RestServlet.onEndCall(HttpServletRequest,HttpServletResponse) onEndCall(HttpServletRequest,HttpServletResponse)</del>
				</ul>
				<li class='jac'><del>BasicRest</del>
				<ul>
					<li class='jm'><del> org.apache.juneau.rest.BasicRest.onInit(RestContext.Builder) onInit(RestContext.Builder)</del>
					<li class='jm'><del>BasicRest.onPostInit(RestContext) onPostInit(RestContext)</del>
					<li class='jm'><del>BasicRest.onPostInitChildFirst(RestContext) onPostInitChildFirst(RestContext)</del>
					<li class='jm'><del>BasicRest.onDestroy(RestContext) onDestroy(RestContext)</del>
					<li class='jm'><del>BasicRest.onStartCall(HttpServletRequest,HttpServletResponse) onStartCall(HttpServletRequest,HttpServletResponse)</del>
					<li class='jm'><del>BasicRest.onPreCall(RestRequest,RestResponse) onPreCall(RestRequest,RestResponse)</del>
					<li class='jm'><del>BasicRest.onPostCall(RestRequest,RestResponse) onPostCall(RestRequest,RestResponse)</del>
					<li class='jm'><del>BasicRest.onEndCall(HttpServletRequest,HttpServletResponse) onEndCall(HttpServletRequest,HttpServletResponse)</del>
				</ul>
			</ul>
		<li>
			New {@link org.apache.juneau.rest.annotation.Rest#debugOn() @Rest(debugOn)} annotation for turning on debug mode using class/method identifiers:
			
			<h5 class='figure'>Example:</h5>
			<p class='bcode'>
		<jc>// Turn on debug per-request on the class and always on the doX() method</jc>.
		<ja>@Rest</ja>(
			debugOn=<js>"MyResource=per-request,Mysource.doX=true"</js>  <jc>// Typically defined via system or env property</jc>.
		)
		<jk>public class</jk> MyResource {
	
			<ja>@RestMethod</ja>
			<jk>public void</jk> String doX() {
				...
			}
			 </p>
		<li>
			<del>BasicRestConfig</del> has been broken up into <del>BasicRestConfig</del> and <del>BasicRestMethods</del> so that
			you're not forced to implement methods such as <c>getOptions()</c> and <c>getStats()</c> if you're implementing the interface
			to configure your REST class.
		<li>
			Any of the following classes can now be instantiated with <c><jk>public static</jk> <jsm>create</jsm>()</c> methods:
			<ul>
				<li class='jc'><del>RestCallHandler</del>
				<li class='jc'><del>RestCallLogger</del>
				<li class='jc'><del>RestInfoProvider</del>
				<li class='jc'><del>ClasspathResourceFinder</del>
				<li class='jc'><del>RestResourceResolver</del>
				<li class='jc'><del>RestGuard</del>
				<li class='jc'><del>ResponseHandler</del>
			</ul>
		<li>
			New <del>Path.required() @Path(required)</del>annotation support.
			<br>A path can be marked as not-required when the path variable is resolved by a parent resource like so:
			<p class='bcode'>
		<ja>@Rest</ja>(path=<js>"/parent/{p1}"</js>,children=Child.<jk>class</jk>)
		<jk>public class</jk> Parent {
			...
		}
	
		<ja>@Rest</ja>(path="/child")
		<jk>public class</jk> Child {
	
			<ja>@RestMethod</ja>(path="/")
			<jk>public</jk> String doGet(<ja>@Path</ja>(name=<js>"p1"</js>,required=<jk>false</jk>) String p1) {
				<jc>// p1 will be null when accessed via "/child"</jc>
				<jc>// p1 will be non-null when accessed via "/parent/p1/child".</jc>
			}
			...
		}
			</p>
			<br>This allows the child resource to be mapped to multiple parents that may resolve various different path variables.
		<li>
			New <del>RestMethod.paths() @RestMethod(paths)</del> annotation that allows you to map multiple
			paths to the same Java method.
			<br>Example:
			<p class='bcode'>
		<ja>@RestMethod</ja>(
			name=<jsf>GET</jsf>,
			paths={<js>"/"</js>,<js>"/{foo}"</js>}
		)
		<jk>public</jk> String doGet(<ja>@Path</ja>(name=<js>"foo"</js>,required=<jk>false</jk>) String foo) {...}
			</p>
		<li>
			The <del>RestMethod @RestMethod</del>annotation is now implied on all unannotated methods of a {@link org.apache.juneau.rest.annotation.Rest @Rest}-annotated
			interface.
			<p class='bcode'>
		<ja>@Rest
		<jk>public interface</jk> MyRest {
			String getFoo();  <jc>// @RestMethod(name=GET,path="/foo") is implied.</jc>
		}
			</p>
		<li>
			Improved <del>RestContext.REST_messages REST_messages</del> support (mostly bug fixes).
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server-springboot</h5>
	<ul class='spaced-list'>
		<li>
			<del>JuneauRestInitializer</del>now provides a no-arg constructor so that it can be used in
			the <c><ja>@ConfigurationContext</ja>(initializers=JuneauRestInitializer.<jk>class</jk>)</c> when unit testing
			using <ja>@SpringBootTest</ja>.
		<li>
			New <del>ResourceDescription.ResourceDescription(String,String,String)</del>constructor and <del>ResourceDescriptions.append(String,String,String)</del> method.
		<li>
			New <del>Hyperlink</del>class.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			Completely revamped RestClient API.
			<ul>
				<li>All APIs now extend from HttpClient interfaces.
				<li>Better integration with HttpClient.
				<li>New fluent-style methods with many new convenience methods.
				<li>Updated juneau-rest-client.
			</ul>
		<li>
			<ja>@RemoteMethod</ja>-annotated methods can now return {@link java.util.concurrent.Future Futures} and 
			{@link java.util.concurrent.CompletableFuture CompletableFutures} for concurrent processing of requests.
			<br>Example:
			<p class='bcode'>
		<ja>@Remote</ja>
		<jk>public interface</jk> MyInterface {
			<jk>public</jk> Future&lt;String&gt; doGet();
		}
			
		MyInterface i = client.getRemote(MyInterface.<jk>class</jk>, <js>"http://localhost:12345/myInterface"</js>);
		Future&lt;String&gt; f = i.doGet();
		<jc>// Do other stuff.</jc>
		String result = f.get();	
			</p>
		<li>Additions to {@link org.apache.juneau.http.remote.Remote} annotation:
		<ul>
			<li>{@link org.apache.juneau.http.remote.Remote#version version} - Adds a client version header to all requests.
			<li>{@link org.apache.juneau.http.remote.Remote#headers headers} - Adds a set of headers to all requests.
			<li><del>headerSupplier</del> - Adds a dynamic supplier of headers to all requests.
		</ul>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-mock</h5>
	<ul class='spaced-list'>
		<li>
			The <c>MockRest</c> and <c>MockRemote</c> classes have been remove entirely and all existing functions
			have been moved into the improved <del>MockRestClient</del> class.  All REST test mocking can be 
			done through this single class.
	</ul>
</div>
</div><!-- END: 8.2.0 -->

<!-- ==================================================================================================== -->

<h3 class='topic' onclick='toggle(this)'><a href='#9.0.0' id='9.0.0'>9.0.0 (TBD)</a></h3>
<div class='topic'><!-- START: 9.0.0 -->
<div class='topic'>
	<p>
		Juneau 9.0.0 is a major release.  Deprecated APIs that have been accumulating over time have been removed.
		
	</p>
	<p>
		Major changes include:
	</p>
	<ul class='spaced-list'>
		<li>
			The code has undergone significant refactoring to ease maintainability and improve overall performance.
			Configuration properties have been removed entirely.  They have been replaced with a standard builder-based
			architecture.  In addition to making the code more maintainable, it also improves performance when
			creating new serializers/parsers/rest clients (and others).
		<li>
			REST servlets now seemlessly integrate with Spring Boot.  
	</ul>
	
	<h5 class='topic w800'>juneau-marshall</h5>
	<ul class='spaced-list'>
		<li>
			Eliminated the various <c><ja>@XConfig</ja>(applyX={...})</c> annotations and replaced them with the ability
			to apply targeted annotations directly to configuration classes and methods (such as REST classes/methods).
			<p class='bcode'>
	<ja>@Rest</ja>(...)
	<ja>@Bean</ja>(on=<js>"MyBean1,MyBean2"</js>,sort=<jk>true</jk>)
	<ja>@UrlEncoding</ja>(onClass=MyList.<jk>class</jk>,expandedParams=<jk>true</jk>)
	<jk>public class</jk> MyRestClass {
		
		<ja>@RestOp</ja>(...)
		<ja>@Bean</ja>(on=<js>"MyBean1,MyBean2"</js>,sort=<jk>false</jk>)
		<ja>@UrlEncoding</ja>(onClass=MyList.<jk>class</jk>,expandedParams=<jk>false</jk>)
		<jk>public</jk> Object myRestMethod() { ... }
	}
			</p>
		<li>
			{@link org.apache.juneau.marshaller.Json5 JSON 5} support.
		<li>
			New {@link org.apache.juneau.annotation.Marshalled @Marshalled} annotation for non-bean classes.
		<li>
			New {@link org.apache.juneau.annotation.BeanConfig#ignoreUnknownEnumValues() @BeanConfig(ignoreUnknownEnumValues)} annotation and support for ignoring
			unknown enum values during parsing.
		<li>
			Java Serialized Object marshalling support has been removed entirely due to security risks with usage (better safe than sorry).
	</ul>
	
	<h5 class='topic w800'>juneau-rest-common</h5>
	<p>
		New module containing the common REST classes/annotations uses by both the client and server APIs.
		These were previously contained within <c>juneau-marshall</c>.
	</p>
	<ul class='spaced-list'>
		<li>
			Significant refactoring of the classes in the {@link org.apache.juneau.http} package and subpackages.  Attempts were made to make classes as natural
			extensions to the Apache HttpComponents APIs.  Significant new functionality here.
		<li>
			<c>@RemoteMethod</c> annotation has been replaced with the following:
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.http.remote.RemoteOp}
				<li class='ja'>{@link org.apache.juneau.http.remote.RemoteGet}
				<li class='ja'>{@link org.apache.juneau.http.remote.RemotePut}
				<li class='ja'>{@link org.apache.juneau.http.remote.RemotePatch}
				<li class='ja'>{@link org.apache.juneau.http.remote.RemotePost}
				<li class='ja'>{@link org.apache.juneau.http.remote.RemoteDelete}
			</ul>
		</li>
	</ul>

	<h5 class='topic w800'>juneau-rest-server</h5>
	<ul class='spaced-list'>
		<li>
			Significant refactoring done to allow for many extensible aspects of the API to be performed through injected beans
			in Spring.  These include logging, debugging, REST method arg types, static files, file finders, swagger creators, thrown stores, response
			processors, serializers/parsers, JSON schema generators, statistics gathering stores, and default request attributes/headers and response
			headers.
		<li>
			<c>@RestMethod</c> annotation has been replaced with the following:
			<ul class='javatreec'>
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestOp}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestGet}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPut}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPatch}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestPost}
				<li class='ja'>{@link org.apache.juneau.rest.annotation.RestDelete}
			</ul>
		</li>
		<li>
			Defining REST resources with predefined marshalling support is now much simpler.  You can now extend from a basic REST servlet/object.
			<p class='bcode'>
	<jc>// A root resource that supports JSON/HTML marshalling.</jc>
	<jk>public class</jk> MyRootResources <jk>extends</jk> BasicRestServletGroup  { ... }
	
	<jc>// A child resource that supports all available marshalling.</jc>
	<jk>public class</jk> MyChildResource <jk>extends</jk> BasicRestObject { ... }
			</p>
			<ul class='javatreec'>
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestServlet}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestServletGroup}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestObject}
				<li class='jc'>{@link org.apache.juneau.rest.servlet.BasicRestObjectGroup}
			</ul>
		</li>
	</ul>
	
	<h5 class='topic w800'>juneau-dto</h5>
	<ul class='spaced-list'>
		<li>
			Addition of OpenAPI 3.0 ({@link org.apache.juneau.dto.openapi3} package).
	</ul>
	
	<h5 class='topic w800'>juneau-rest-server-springboot</h5>
	<ul class='spaced-list'>
		<li>
			The requirement for using <c>JuneauRestInitializer</c> during App initialization to use bean injection has been eliminated.
			Instead, root resources should simply extend from {@link org.apache.juneau.rest.springboot.BasicSpringRestServlet} and {@link org.apache.juneau.rest.springboot.BasicSpringRestServletGroup}.
			These will automatically hook into the Spring Boot framework for resolution of REST children and various extension beans added
			to the REST API framework.
	</ul>
	
	<h5 class='topic w800'>juneau-rest-client</h5>
	<ul class='spaced-list'>
		<li>
			While the general usage pattern stays the same, the REST client code has undergone significant rewriting.  It is now more inline
			as an extension of the Apache HttpClient library.  Much new functionality such as support for fluent assertions has been added.
			<p class='bjava'>
	<jc>// Create a basic REST client with JSON support and download a bean.</jc>
	MyBean <jv>bean</jv> = RestClient.<jsm>create</jsm>()
		.json5()
		.build()
		.get(<jsf>URI</jsf>)
		.run()
		.assertStatus().asCode().is(200)
		.assertHeader(<js>"Content-Type"</js>).matchesSimple(<js>"application/json*"</js>)
		.getContent().as(MyBean.<jk>class</jk>);
			</p>
	</ul>
	
	<h5 class='topic w800'>juneau-rest-mock</h5>
	<ul class='spaced-list'>
		<li>
			Entirely rewritten.  Changes too many to list.
	</ul>
</div>
</div><!-- END: 9.0.0 -->

</div>
<script>
	// Overrides the javadoc javascript behavior that forces the page to show the search element.
	function scrollToHash() {
		if (location.hash) {
			document.getElementById(location.hash.substring(1)).scrollIntoView();
		}
	}
	window.setTimeout(scrollToHash, 1000);
</script>
</body>								
