---
title: "Mock REST Client Overview"
slug: MockRestClientOverview
---

The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestClient.html" target="_blank">MockRestClient</a> class is used for performing
serverless unit testing of <a href="/site/apidocs/org/apache/juneau/rest/annotation/Rest.html" target="_blank">@Rest</a>-annotated and <a href="/site/apidocs/org/apache/juneau/http/remote/Remote.html" target="_blank">@Remote</a>-annotated classes.

The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestClient.html" target="_blank">MockRestClient</a> itself extends from <a href="/site/apidocs/org/apache/juneau/rest/client/RestClient.html" target="_blank">RestClient</a> providing it with the rich feature set of that API.

The following shows a simple example of invoking a PUT method on a simple REST interface and asserting the correct
status code and response body:

```java
public class MockTest {

    // A simple bean with one field.
    public static class MyBean {
        public int foo = 1;
    }

    // Our REST resource to test.
    // Simply echos the response.
    @Rest
    public static class EchoRest implements BasicRestServlet {

        @RestPut
        public MyBean echo(@Content MyBean bean) {
            return bean;
        }
    }

    // Our JUnit test.
    @Test
    public void testEcho() throws Exception {

        MyBean myBean = new MyBean();

        // Do a round-trip on the bean through the REST interface
        myBean = MockRestClient
            .create(EchoRest.class)
            .json5()
            .build()
            .put("/echo", myBean)
            .run()
            .assertStatus().is(200)
            .assertContent().is("{foo:1}")
            .getContent().as(MyBean.class);

        assertEquals(1, myBean.foo);
    }
}
```

Breaking apart the fluent method call above will help you understand how this works.

```java
@Test
public void testEcho() throws Exception {

    // Instantiate our mock client.
    MockRestClient client = MockRestClient
        .create(EchoRest.class)
        .json5()
        .build();

    // Create a request.
    RestRequest req = client.put("/echo", myBean);

    // Execute it (by calling RestCallHandler.service(...) and then returning the response object).
    RestResponse res = req.run();

    // Run assertion tests on the results.
    res.assertStatus().is(200);
    res.assertContent().is("'foo'");

    myBean = res.getContent().as(MyBean.class);
}
```

The concept of the design is simple.
The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestClient.html" target="_blank">MockRestClient</a> class is used to create instances of <a href="/site/apidocs/org/apache/juneau/rest/mock/MockServletRequest.html" target="_blank">MockServletRequest</a> and <a href="/site/apidocs/org/apache/juneau/rest/mock/MockServletResponse.html" target="_blank">MockServletResponse</a> which are passed directly to the call handler on the resource class [RestOpInvoker.invoke(RestOpSession)](API_DOCS/org/apache/juneau/rest/RestOpInvoker.html#invoke(RestOpSession)).
In effect, you're fully testing your REST API as if it were running in a live servlet container, yet not actually having
to run in a servlet container.
All aspects of the client and server side code are tested, yet no servlet container is required.
The actual over-the-wire transmission is the only aspect being bypassed.
The `create(Object)` method can take in either `Class` objects or pre-instantiated beans.
The latter is particularly useful for testing REST APIs written as Spring beans.

```java
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = {MyApp.class})
@SpringBootTest
public class MockTest {

    @Autowired
    EchoRest echoRest;

    MockRestClient client;

    @Before
    public void setup() {
        // Instantiate our mock client.
        client = MockRestClient
            .create(echoRest)
            .json5()
            .build();
    }

    // Our JUnit test.
    @Test
    public void testEcho() throws Exception {

        MyBean myBean = new MyBean();

        // Do a round-trip on the bean through the REST interface
        myBean = client
            .put("/echo", myBean)
            .run()
            .assertStatus().is(200)
            .assertContent().is("{foo:1}")
            .getContent().as(MyBean.class);

        assertEquals(1, myBean.foo);
    }
}
```

The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestRequest.html" target="_blank">MockRestRequest</a> object has convenience methods
provided to allow you to set properties directly on the underlying <a href="https://jakarta.ee/specifications/servlet/6.0/apidocs/jakarta/servlet/http/HttpServletRequest.html" target="_blank">HttpServletRequest</a> object.
The following example shows how this can be used to directly set roles on the request object to perform security
testing.

:::tip Example
```java
@Rest(roleGuard="ADMIN")
public class A {
    @RestGet
    public String get() {
        return "OK";
    }
}

@Test
public void mytest() throws Exception {
    MockRestClient client = MockRestClient.build(A.class);

    // Admin user should get 200 but anyone else should get 403-Unauthorized.
    client.get().roles("ADMIN").run().assertStatus().is(200);
    client.get().roles("USER").run().assertStatus().is(403);
}
```
:::

The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestClient.html" target="_blank">MockRestClient</a> class has a debug mode that will
cause your HTTP requests and responses to
be sent to the console:

```java
MockRestClient client = MockRestClient
    .create(MyRest.class)
    .debug()
    .json5()
    .build();
```

The <a href="/site/apidocs/org/apache/juneau/rest/mock/MockRestClient.html" target="_blank">MockRestClient</a> class can also be used for testing of <a href="/site/apidocs/org/apache/juneau/http/remote/Remote.html" target="_blank">Remote</a>-annotated interfaces against <a href="/site/apidocs/org/apache/juneau/rest/annotation/Rest.html" target="_blank">@Rest</a>-annotated resources.

:::tip Example
```java
// Our remote resource to test.
@Remote
public interface MyRemoteInterface {

    @RemoteGet("/echoQuery")
    public int echoQuery(@Query(name="id") int id);
}

// Our mocked-up REST interface to test against.
@Rest
public class MyRest {

    @RestGet
    public int echoQuery(@Query("id") String id) {
        return id;
    }
}

@Test
public void testProxy() {
    MyRemoteInterface mri = MockRestClient
        .create(MyRest.class)
        .json()
        .build()
        .getRemote(MyRemoteInterface.class);

    assertEquals(123, mri.echoQuery(123));
}
```
:::