---
title: "OpenAPI Methodology"
slug: OpenApiMethodology
---

Unlike the other Juneau serializers and parsers that convert input and output directly to-and-from POJOs, the OpenAPI
serializers and parsers use intermediate objects based on the `type` and `format` of the schema.
The following table shows the "natural" intermediate type of the object based on the `type/format`:

<table class="code-table">
<tr>
<th>Type</th>
<th>Format</th>
<th>Intermediate Java Type</th>
</tr>
<tr>
<td rowSpan="4">`string` or empty</td>
<td>`byte`<br/>`binary`<br/>`binary-spaced`</td>
<td>`byte[]`</td>
</tr>
<tr>
<td>`date`<br/>`date-time`</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Calendar.html" target="_blank">Calendar</a></td>
</tr>
<tr>
<td>`uon`</td>
<td>No intermediate type.<br/>(serialized directly to/from POJO)</td>
</tr>
<tr>
<td>empty</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" target="_blank">String</a></td>
</tr>
<tr>
<td>`boolean`</td>
<td>empty</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Boolean.html" target="_blank">Boolean</a></td>
</tr>
<tr>
<td rowSpan="2">`integer`</td>
<td>`int32`</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Integer.html" target="_blank">Integer</a></td>
</tr>
<tr>
<td>`int64`</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Long.html" target="_blank">Long</a></td>
</tr>
<tr>
<td rowSpan="2">`number`</td>
<td>`float`</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Float.html" target="_blank">Float</a></td>
</tr>
<tr>
<td>`double`</td>
<td><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Double.html" target="_blank">Double</a></td>
</tr>
<tr>
<td rowSpan="2">`array`</td>
<td>empty</td>
<td>Arrays of intermediate types on this list.</td>
</tr>
<tr>
<td>`uon`</td>
<td>No intermediate type.<br/>(serialized directly to/from POJO)</td>
</tr>
<tr>
<td rowSpan="2">`object`</td>
<td>empty</td>
<td>`Map<String,Object>`</td>
</tr>
<tr>
<td>`uon`</td>
<td>No intermediate type.<br/>(serialized directly to/from POJO)</td>
</tr>
</table>

The valid POJO types for serializing/parsing are based on the intermediate types above.
As a general rule, any POJOs that are the intermediate type or transformable to or from the intermediate type are valid
POJO types.

For example, the following POJO type can be transformed to and from a byte array.

```java
// Sample POJO class convertable to and from a byte[].
public class MyPojo {

    // Constructor used by parser.
    public MyPojo(byte[] value) {...}

    // toX method used by serializer.
    public byte[] toBytes() {...}
}
```

This example shows how that POJO can be converted to a BASE64-encoded string.

```java
// Construct a POJO.
MyPojo myPojo = ...;

// Define a schema.
HttpPartSchema schema = HttpPartSchema.tByte().build();

// Convert POJO to BASE64-encoded string.
HttpPartSerializer serializer = OpenApiSerializer.DEFAULT;
String httpPart = serializer.serialize(schema, myPojo);

// Convert BASE64-encoded string back into a POJO.
HttpPartParser parser = OpenApiParser.DEFAULT;
myPojo = parser.parse(schema, httpPart, MyPojo.class);
```

In addition to defining format, the schema also allows for validations of the serialized form.

```java
// Construct a POJO.
MyPojo myPojo = ...;

// Define a schema.
// Serialized string must be no smaller than 100 characters.
HttpPartSchema schema = HttpPartSchema.tByte().minLength(100).build();

// Convert POJO to BASE64-encoded string.
HttpPartSerializer serializer = OpenApiSerializer.DEFAULT;
String httpPart;
try {
    httpPart = serializer.serialize(schema, myPojo);
} catch (SchemaValidationException e) {
    // Oops, output too small.
}

// Convert BASE64-encoded string back into a POJO.
HttpPartParser parser = OpenApiParser.DEFAULT;
try {
    myPojo = parser.parse(schema, httpPart, MyPojo.class);
} catch (SchemaValidationException e) {
    // Oops, input too small.
}
```

It looks simple but the implementation is highly sophisticated being able to serialize and parse and validate using
complex schemas.

The next sections go more into depth on serializing and parsing various POJO types.
