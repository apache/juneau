---
title: "@Bean(typeName) Annotation"
---

The <a href="/site/apidocs/org/apache/juneau/annotation/Bean.html#typeName()" target="_blank">@Bean(typeName)</a> annotation can be used to override the Juneau default name on bean elements.

Types names serve two distinct purposes:

1. To override the element name.
2. To serve as a class identifier so that the bean class can be inferred during parsing if it cannot automatically be inferred through reflection.

:::tip Example
<table class="code-table">
<tr>
<th>Data type</th>
<th>JSON example</th>
<th>Without annotation</th>
<th>With annotation</th>
</tr>
<tr>
<td>
```java
@Bean(typeName="X")
class MyBean {
  public String a;
  public int b;
}
```
</td>
<td>
```json
{
  a: 'foo',
  b: 123
}
```
</td>
<td>
```xml
<object>
  <a>foo</a>
  <b>123</b>
</object>
```
</td>
<td>
```xml
<X>
  <a>foo</a>
  <b>123</b>
</X>
```
</td>
</tr>
</table>
:::

On bean properties, a `_type` attribute will be added if a type name is present and the bean class cannot be inferred through reflection.

In the following example, a type attribute is used on property 'b' but not property 'a' since 'b' is of type `Object` and therefore the bean class cannot be inferred.

:::tip Example
<table class="code-table">
<tr>
<th>Java</th>
<th>Without annotation</th>
<th>With annotation</th>
</tr>
<tr>
<td>
```java
class MyBean {
  public BeanX a = new BeanX();
  public Object b = new BeanX();
}

@Bean(typeName="X")
class BeanX {
  public String fx = "foo";
}
```
</td>
<td>
```xml
<object>
  <a>
    <fx>foo</fx>
  </a>
  <b>
    <fx>foo</fx>
  </b>
</object>
```
</td>
<td>
```xml
<object>
  <a>
    <fx>foo</fx>
  </a>
  <b _type='X'>
    <fx>foo</fx>
  </b>
</object>
```
</td>
</tr>
</table>
:::

:::info
`string`, `number`, `boolean`, `object`, `array`, and `null` are reserved keywords that cannot be used as type names.
:::

Beans with type names are often used in conjunction with the <a href="/site/apidocs/org/apache/juneau/annotation/Bean.html#dictionary()" target="_blank">@Bean(dictionary)</a> and <a href="/site/apidocs/org/apache/juneau/annotation/Beanp.html#dictionary()" target="_blank">@Beanp(dictionary)</a> annotations so that the beans can be resolved at parse time.
These annotations are not necessary during serialization but are needed during parsing in order to resolve the bean types.

The following examples show how type names are used under various circumstances.
Pay special attention to when `_type` attributes are and are not used.

:::tip Example
<table class="code-table">
<tr>
<th>Java</th>
<th>XML</th>
</tr>
<tr>
<td>
```java
@Bean(dictionary={BeanX.class})
class BeanWithArrayPropertiesWithTypeNames {
  public BeanX[] b1 = new BeanX[]{ 
    new BeanX() 
  };
  public Object[] b2 = new BeanX[]{ 
    new BeanX() 
  };
  public Object[] b3 = new Object[]{ 
    new BeanX() 
  };
}
```
</td>
<td>
```xml
<object>
  <b1>
    <X>
      <fx>foo</fx>
    </X>
  </b1>
  <b2>
    <X>
      <fx>foo</fx>
    </X>
  </b2>
  <b3>
    <X>
      <fx>foo</fx>
    </X>
  </b3>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(dictionary={BeanX.class})
class BeanWith2dArrayPropertiesWithTypeNames {
  public BeanX[][] b1 = new BeanX[][]{{
    new BeanX()
  }};
  public Object[][] b2 = new BeanX[][]{{
    new BeanX()
  }};
  public Object[][] b3 = new Object[][]{{
    new BeanX()
  }};
}
```
</td>
<td>
```xml
<object>
  <b1>
    <array>
      <X>
        <fx>foo</fx>
      </X>
    </array>
  </b1>
  <b2>
    <array>
      <X>
        <fx>foo</fx>
      </X>
    </array>
  </b2>
  <b3>
    <array>
      <X>
        <fx>foo</fx>
      </X>
    </array>
  </b3>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(dictionary={BeanX.class})
class BeanWithMapPropertiesWithTypeNames {
  public Map<String,BeanX> b1 = new HashMap<>() {{ 
    put("k1", new BeanX()); 
  }};
  public Map<String,Object> b2 = new HashMap<>() {{
    put("k2", new BeanX());
  }};
}
```
</td>
<td>
```xml
<object>
  <b1>
    <k1>
      <fx>foo</fx>
    </k1>
  </b1>
  <b2>
    <k2 _type='X'>
      <fx>foo</fx>
    </k2>
  </b2>
</object>
```
</td>
</tr>
</table>
:::

Bean type names are also used for resolution when abstract fields are used.
The following examples show how they are used in a variety of circumstances.

:::tip Example
<table class="code-table">
<tr>
<th>Java</th>
<th>XML</th>
</tr>
<tr>
<td>
```java
@Bean(dictionary={A.class})
class BeanWithAbstractFields {
  public A a = new A();
  public IA ia = new A();
  public AA aa = new A();
  public Object o = new A();
}

interface IA {}

abstract class AA implements IA {}

@Bean(typeName="A")
class A extends AA {
  public String fa = "foo";
}
```
</td>
<td>
```xml
<object>
  <a>
    <fa>foo</fa>
  </a>
  <ia _type='A'>
    <fa>foo</fa>
  </ia>
  <aa _type='A'>
    <fa>foo</fa>
  </aa>
  <o _type='A'>
    <fa>foo</fa>
  </o>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(dictionary={A.class})
class BeanWithAbstractArrayFields {
  public A[] a = new A[]{new A()};
  public IA[] ia1 = new A[]{new A()};
  public IA[] ia2 = new IA[]{new A()};
  public AA[] aa1 = new A[]{new A()};
  public AA[] aa2 = new AA[]{new A()};
  public Object[] o1 = new A[]{new A()};
  public Object[] o2 = new Object[]{new A()};
}
```
</td>
<td>
```xml
<object>
  <a>
    <A>
      <fa>foo</fa>
    </A>
  </a>
  <ia1>
    <A>
      <fa>foo</fa>
    </A>
  </ia1>
  <ia2>
    <A>
      <fa>foo</fa>
    </A>
  </ia2>
  <aa1>
    <A>
      <fa>foo</fa>
    </A>
  </aa1>
  <aa2>
    <A>
      <fa>foo</fa>
    </A>
  </aa2>
  <o1>
    <A>
      <fa>foo</fa>
    </A>
  </o1>
  <o2>
    <A>
      <fa>foo</fa>
    </A>
  </o2>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(dictionary={A.class})
class BeanWithAbstractMapFields {
  public Map<String,A> a = new HashMap<>() {{
    put("k1", new A());
  }};
  public Map<String,AA> b = new HashMap<>() {{
    put("k2", new A());
  }};
  public Map<String,Object> c = new HashMap<>() {{
    put("k3", new A());
  }};
}
```
</td>
<td>
```xml
<object>
  <a>
    <k1>
      <fa>foo</fa>
    </k1>
  </a>
  <b>
    <k2 _type='A'>
      <fa>foo</fa>
    </k2>
  </b>
  <c>
    <k3 _type='A'>
      <fa>foo</fa>
    </k3>
  </c>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(dictionary={A.class})
class BeanWithAbstractMapArrayFields {
  public Map<String,A[]> a = new LinkedHashMap<>() {{
    put("a1", new A[]{new A()});
  }};
  public Map<String,IA[]> ia = new LinkedHashMap<>() {{
    put("ia1", new A[]{new A()});
    put("ia2", new IA[]{new A()});
  }};
  public Map<String,AA[]> aa = new LinkedHashMap<>() {{
    put("aa1", new A[]{new A()});
    put("aa2", new AA[]{new A()});
  }};
  public Map<String,Object[]> o = new LinkedHashMap<>() {{
    put("o1", new A[]{new A()});
    put("o2", new AA[]{new A()});
  }};
}
```
</td>
<td>
```xml
<object>
  <a>
    <a1>
      <A>
        <fa>foo</fa>
      </A>
    </a1>
  </a>
  <ia>
    <ia1>
      <A>
        <fa>foo</fa>
      </A>
    </ia1>
    <ia2>
      <A>
        <fa>foo</fa>
      </A>
    </ia2>
  </ia>
  <aa>
    <aa1>
      <A>
        <fa>foo</fa>
      </A>
    </aa1>
    <aa2>
      <A>
        <fa>foo</fa>
      </A>
    </aa2>
  </aa>
  <o>
    <o1>
      <A>
        <fa>foo</fa>
      </A>
    </o1>
    <o2>
      <A>
        <fa>foo</fa>
      </A>
    </o2>
  </o>
</object>
```
</td>
</tr>
</table>
:::

On a side note, characters that cannot be represented in XML 1.0 are encoded using a simple encoding.
Note in the examples below, some characters such as `'\n'`, `'\t'`, and `'\r'` can be represented as XML entities when used in text but not in element names.
Other characters such as `'\b'` and `'\f'` cannot be encoded in XML 1.0 at all without inventing our own notation.
Whitespace characters in element names are encoded as well as whitespace end characters in text.

:::tip Example
<table class="code-table">
<tr>
<th>Java</th>
<th>XML</th>
</tr>
<tr>
<td>
```java
class BeanWithSpecialCharacters {
  public String a = "  \b\f\n\t\r  ";
}
```
</td>
<td>
```xml
<object>
  <a>_x0020_ _x0008__x000C_&#x000a;&#x0009;&#x000d; _x0020_</a>
</object>
```
</td>
</tr>
<tr>
<td>
```java
@Bean(typeName="  \b\f\n\t\r  ")
class BeanWithNamesWithSpecialCharacters {
  @Beanp(name="  \b\f\n\t\r  ")
  public String a = "  \b\f\n\t\r  ";
}
```
</td>
<td>
```xml
<_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_>
  <_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_>
    _x0020_ _x0008__x000C_&#x000a;&#x0009;&#x000d; _x0020_
  </_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_>
</_x0020__x0020__x0008__x000C__x000A__x0009__x000D__x0020__x0020_>
```
</td>
</tr>
</table>
:::

While it's true that these characters CAN be represented in XML 1.1, it's impossible to parse XML 1.1 text in Java without the XML containing an XML declaration.
Unfortunately, this, and the uselessness of the <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.xml/javax/xml/stream/XMLInputFactory.html#IS_REPLACING_ENTITY_REFERENCES" target="_blank">XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES</a> setting in Java forced us to make some hard design decisions that may not be the most elegant.