"use strict";(self.webpackChunkjuneau_documentation=self.webpackChunkjuneau_documentation||[]).push([[1922],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var a=n(96540);const o={},s=a.createContext(o);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},68358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>p});const a=JSON.parse('{"id":"topics/10.10.11.DualPurposeInterfaces","title":"Dual-purpose (end-to-end) interfaces","description":"A common coding practice is to use the same Java interface to define both your server and client side REST interfaces.","source":"@site/docs-staging/topics/10.10.11.DualPurposeInterfaces.md","sourceDirName":"topics","slug":"/topics/10.10.11.DualPurposeInterfaces","permalink":"/docs/topics/10.10.11.DualPurposeInterfaces","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/juneau/tree/main/juneau-docs-poc/juneau-documentation/docs-staging/topics/10.10.11.DualPurposeInterfaces.md","tags":[],"version":"current","frontMatter":{"title":"Dual-purpose (end-to-end) interfaces"},"sidebar":"mainSidebar","previous":{"title":"10.10.10. @Response","permalink":"/docs/topics/10.10.10.Response"},"next":{"title":"10.11. Logging and Debugging","permalink":"/docs/topics/10.11.00.LoggingAndDebugging"}}');var o=n(74848),s=n(28453);const r={title:"Dual-purpose (end-to-end) interfaces"},i=void 0,c={},p=[];function l(e){const t={a:"a",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"A common coding practice is to use the same Java interface to define both your server and client side REST interfaces.\nThe advantage to this approach is that changes that you make to your REST interface can be reflected in both places at\nthe same time, reducing the chances for compatibility mistakes."}),"\n",(0,o.jsxs)(t.p,{children:["What makes this possible is that method-level annotations such as ",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/rest/annotation/RestOp.html",children:"@RestOp"})," and parameter-level annotations such as\n",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/http/annotation/Query.html",children:"@Query"})," are inherited from parent classes.\nThis normally isn't possible but the framework will spider up the parent hierarchy of classes to find method and\nparameter level annotations defined on overridden methods."]}),"\n",(0,o.jsxs)(t.p,{children:["The general approach is to define your ",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/http/remote/Remote.html",children:"@Remote"}),"-annotated\ninterface first."]}),"\n",(0,o.jsx)(t.p,{children:"The following example is pulled from the PetStore app:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'@Remote(path="/petstore")\npublic interface PetStore {\n\n    @RemoteGet("/pet")\n    public Collection getPets() throws NotAcceptable;\n\n    @RemotDelete("/pet/{petId}")\n    public Ok deletePet(\n        @Header(\n            name="api_key",\n            description="Security API key",\n            required=true,\n            example="foobar"\n        )\n        String apiKey,\n        @Path(\n            name="petId",\n            description="Pet id to delete",\n            example="123"\n        )\n        long petId\n    ) throws IdNotFound, NotAcceptable;\n\n    ...\n'})}),"\n",(0,o.jsx)(t.p,{children:"Next you define the implementation of your interface as a normal Juneau REST resource:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'@Rest(\n    path="/petstore",\n    title="Petstore application",\n    ...\n)\npublic class PetStoreResource extends BasicRestServlet implements PetStore {\n\n    ...\n\n    @Override /* PetStore */\n    @RestOp(\n        method=GET,\n        path="/pet",\n        summary="All pets in the store",\n        ...\n    )\n    public Collection getPets() throws NotAcceptable {\n        return store.getPets();\n    }\n\n    @Override /* PetStore */\n    @RestOp(\n        method=DELETE,\n        path="/pet/{petId}",\n        summary="Deletes a pet",\n        ...\n    )\n    public Ok deletePet(String apiKey, long petId) throws IdNotFound, NotAcceptable {\n        store.removePet(petId);\n        return OK;\n    }\n'})}),"\n",(0,o.jsx)(t.p,{children:"Then use the interface as a remote resource like so:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-java",children:'RestClient client = RestClient.create().json().rootUrl("http://localhost:10000").build();\nPetStore store = client.getRemote(PetStore.class);\n\nfor (Pet pet : store.getPets()) {\n    store.deletePet("my-special-key", pet.getId());\n    System.err.println("Deleted pet:  id=" + pet.getId());\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["In the example above, we chose to add the ",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/rest/annotation/RestOp.html",children:"@RestOp"})," annotation to the implementation class.\nHowever, they could have been added to the interface instead.\nIt's personal preference where you want to place the annotations."]}),"\n",(0,o.jsxs)(t.p,{children:["Note how we didn't need to use the ",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/http/annotation/Header.html",children:"@Header"})," and ",(0,o.jsx)(t.a,{href:"../apidocs/org/apache/juneau/http/annotation/Path.html",children:"@Path"})," annotations in our implementation since the annotations were\ninherited from the interface."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);