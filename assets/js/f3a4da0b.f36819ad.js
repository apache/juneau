"use strict";(self.webpackChunkjuneau_documentation=self.webpackChunkjuneau_documentation||[]).push([[9838],{10878:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"topics/07.01.03.Swappers","title":"Swappers","description":"Swappers transform objects before they are processed by BCT assertions. They provide a way to unwrap, evaluate, or transform objects into more testable forms. Swappers are particularly useful for wrapper types like Optional, Supplier, and Future.","source":"@site/docs/topics/07.01.03.Swappers.md","sourceDirName":"topics","slug":"/topics/Swappers","permalink":"/docs/topics/Swappers","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/juneau/tree/master/juneau-docs/docs/topics/07.01.03.Swappers.md","tags":[],"version":"current","frontMatter":{"title":"Swappers","slug":"Swappers"},"sidebar":"mainSidebar","previous":{"title":"7.1.2. Listifiers","permalink":"/docs/topics/Listifiers"},"next":{"title":"7.1.4. Property Extractors","permalink":"/docs/topics/PropertyExtractors"}}');var t=r(74848),s=r(28453);const i={title:"Swappers",slug:"Swappers"},l="Swappers",p={},o=[{value:"Built-in Swappers",id:"built-in-swappers",level:2},{value:"Available Built-in Swappers",id:"available-built-in-swappers",level:3},{value:"Custom Swappers",id:"custom-swappers",level:2},{value:"Basic Custom Swapper",id:"basic-custom-swapper",level:3},{value:"Advanced Swapper Examples",id:"advanced-swapper-examples",level:3},{value:"Conditional Swapper",id:"conditional-swapper",level:3},{value:"Chained Swapper",id:"chained-swapper",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Testing Wrapped Values",id:"testing-wrapped-values",level:3},{value:"Testing Result Types",id:"testing-result-types",level:3},{value:"Testing Lazy Values",id:"testing-lazy-values",level:3},{value:"Important Considerations",id:"important-considerations",level:2},{value:"When to Use Swappers vs. Stringifiers",id:"when-to-use-swappers-vs-stringifiers",level:3},{value:"Swapper Execution Order",id:"swapper-execution-order",level:3},{value:"Thread Safety",id:"thread-safety",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"When to Create Custom Swappers",id:"when-to-create-custom-swappers",level:3},{value:"Swapper Guidelines",id:"swapper-guidelines",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Naming Conventions",id:"naming-conventions",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Monadic Types",id:"monadic-types",level:3},{value:"Async/Future Types",id:"asyncfuture-types",level:3},{value:"Validation Types",id:"validation-types",level:3},{value:"See Also",id:"see-also",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"swappers",children:"Swappers"})}),"\n",(0,t.jsx)(n.p,{children:"Swappers transform objects before they are processed by BCT assertions. They provide a way to unwrap, evaluate, or transform objects into more testable forms. Swappers are particularly useful for wrapper types like Optional, Supplier, and Future."}),"\n",(0,t.jsx)(n.h2,{id:"built-in-swappers",children:"Built-in Swappers"}),"\n",(0,t.jsx)(n.p,{children:"BCT comes with built-in swappers for common wrapper and lazy-evaluation types:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Optional types\nOptional<String> optional = Optional.of("Hello");\nassertString("Hello", optional);  // Uses optionalSwapper() - unwraps to "Hello"\n\nOptional<String> emptyOptional = Optional.empty();\nassertString("&lt;null&gt;", emptyOptional);  // Uses optionalSwapper() - unwraps to null\n\n// Supplier types\nSupplier<String> supplier = () -> "World";\nassertString("World", supplier);  // Uses supplierSwapper() - calls get() to get "World"\n\nSupplier<String> expensiveSupplier = () -> {\n    // Simulate expensive computation\n    return "Expensive Result";\n};\nassertString("Expensive Result", expensiveSupplier);  // Uses supplierSwapper() - calls get()\n\n// Future types\nCompletableFuture<String> completedFuture = CompletableFuture.completedFuture("Done");\nassertString("Done", completedFuture);  // Uses futureSwapper() - gets completed result\n\nCompletableFuture<String> pendingFuture = new CompletableFuture<>();\nassertString("&lt;pending&gt;", pendingFuture);  // Uses futureSwapper() - shows pending status\n'})}),"\n",(0,t.jsx)(n.h3,{id:"available-built-in-swappers",children:"Available Built-in Swappers"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"optionalSwapper()"})," - Unwraps Optional values to their contained value or null"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"supplierSwapper()"})," - Calls Supplier.get() to evaluate lazy values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"futureSwapper()"}),' - Extracts completed Future results or shows "<pending>" for incomplete futures']}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"custom-swappers",children:"Custom Swappers"}),"\n",(0,t.jsx)(n.p,{children:"Define custom swappers for your domain-specific wrapper types:"}),"\n",(0,t.jsx)(n.h3,{id:"basic-custom-swapper",children:"Basic Custom Swapper"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Lazy wrapper swapper\nSwapper<LazyValue> lazySwapper = (conv, lazy) -> {\n    if (lazy == null) return null;\n    return lazy.getValue();  // Evaluate the lazy value\n};\n\n// Result wrapper swapper\nSwapper<Result> resultSwapper = (conv, result) -> {\n    if (result == null) return null;\n    if (result.isSuccess()) {\n        return result.getValue();\n    } else {\n        return "Error: " + result.getError();\n    }\n};\n\n// Registration\nvar converter = BasicBeanConverter.builder()\n    .defaultSettings()\n    .addSwapper(LazyValue.class, lazySwapper)\n    .addSwapper(Result.class, resultSwapper)\n    .build();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"advanced-swapper-examples",children:"Advanced Swapper Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Either/Union type swapper\nSwapper<Either<String, Integer>> eitherSwapper = (conv, either) -> {\n    if (either == null) return null;\n    return either.isLeft() ? either.getLeft() : either.getRight();\n};\n\n// Validation result swapper\nSwapper<ValidationResult> validationSwapper = (conv, validation) -> {\n    if (validation == null) return null;\n    if (validation.isValid()) {\n        return validation.getValue();\n    } else {\n        // Return list of error messages\n        return validation.getErrors();\n    }\n};\n\n// Proxy object swapper\nSwapper<ProxyObject> proxySwapper = (conv, proxy) -> {\n    if (proxy == null) return null;\n    // Unwrap the proxy to get the real object\n    return proxy.getTarget();\n};\n\n// Registration\nvar converter = BasicBeanConverter.builder()\n    .defaultSettings()\n    .addSwapper(Either.class, eitherSwapper)\n    .addSwapper(ValidationResult.class, validationSwapper)\n    .addSwapper(ProxyObject.class, proxySwapper)\n    .build();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"conditional-swapper",children:"Conditional Swapper"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Swap based on object state\nSwapper<CachedValue> cachedValueSwapper = (conv, cached) -> {\n    if (cached == null) return null;\n    \n    if (cached.isExpired()) {\n        return "&lt;expired&gt;";\n    } else if (cached.isPending()) {\n        return "&lt;pending&gt;";\n    } else {\n        return cached.getValue();\n    }\n};\n\n// Usage\nassertString("myValue", cachedValue);  // "myValue" if valid\nassertString("&lt;expired&gt;", expiredValue);  // "&lt;expired&gt;" if expired\n'})}),"\n",(0,t.jsx)(n.h3,{id:"chained-swapper",children:"Chained Swapper"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Swapper that performs multiple transformations\nSwapper<ComplexWrapper> complexSwapper = (conv, wrapper) -> {\n    if (wrapper == null) return null;\n    \n    // Step 1: Extract inner value\n    Object inner = wrapper.getInner();\n    \n    // Step 2: Apply transformation\n    if (inner instanceof Optional) {\n        inner = ((Optional<?>) inner).orElse(null);\n    }\n    \n    // Step 3: Apply conversion\n    if (inner instanceof Supplier) {\n        inner = ((Supplier<?>) inner).get();\n    }\n    \n    return inner;\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"testing-wrapped-values",children:"Testing Wrapped Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Test Optional values\nOptional<User> optUser = userService.findById(123);\nassertBean(optUser, "name,email", "John,john@example.com");\n\n// Test Supplier values\nSupplier<Config> configSupplier = () -> loadConfig();\nassertBean(configSupplier, "timeout,retries", "30000,3");\n\n// Test Future values\nCompletableFuture<Order> futureOrder = orderService.getOrderAsync(456);\nfutureOrder.join();  // Wait for completion\nassertBean(futureOrder, "id,total", "456,99.99");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"testing-result-types",children:"Testing Result Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Test Result wrapper with custom swapper\nResult<User> result = userService.createUser(userData);\nassertBean(args().setBeanConverter(converter),\n          result, "name,email", "Alice,alice@example.com");\n\n// Test validation results\nValidationResult<Order> validation = orderValidator.validate(order);\nassertBean(args().setBeanConverter(converter),\n          validation, "id,total", "123,99.99");\n\n// Test error case\nValidationResult<Order> invalidValidation = orderValidator.validate(invalidOrder);\nassertList(args().setBeanConverter(converter),\n          invalidValidation, "Missing required field: customer", "Invalid total: -10");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"testing-lazy-values",children:"Testing Lazy Values"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Test lazy computation\nLazyValue<Report> lazyReport = new LazyValue<>(() -> generateReport());\nassertBean(args().setBeanConverter(converter),\n          lazyReport, "title,itemCount", "Monthly Report,150");\n\n// Swapper ensures the lazy value is evaluated before testing\n'})}),"\n",(0,t.jsx)(n.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-swappers-vs-stringifiers",children:"When to Use Swappers vs. Stringifiers"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use Swappers when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to unwrap or transform objects before property extraction"}),"\n",(0,t.jsx)(n.li,{children:"The object is a wrapper type (Optional, Supplier, Result, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"You want to change the object structure for testing"}),"\n",(0,t.jsx)(n.li,{children:"Property access needs to work on the unwrapped value"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use Stringifiers when:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You only need to change the string representation"}),"\n",(0,t.jsx)(n.li,{children:"The object structure is fine, just needs better formatting"}),"\n",(0,t.jsx)(n.li,{children:"You want to customize how the object appears in assertions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"swapper-execution-order",children:"Swapper Execution Order"}),"\n",(0,t.jsx)(n.p,{children:"Swappers are applied before any other processing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// 1. Swapper unwraps the Optional\nOptional<User> optUser = Optional.of(new User("Alice", 25));\n\n// 2. PropertyExtractor accesses properties on the unwrapped User\n// 3. Stringifier formats the property values\n\nassertBean(optUser, "name,age", "Alice,25");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Ensure thread-safe swappers for concurrent testing\nSwapper<ThreadSafeLazy> threadSafeSwapper = (conv, lazy) -> {\n    if (lazy == null) return null;\n    synchronized (lazy) {\n        return lazy.getValue();\n    }\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Robust swapper with error handling\nSwapper<AsyncValue> safeAsyncSwapper = (conv, async) -> {\n    if (async == null) return null;\n    try {\n        return async.get(1, TimeUnit.SECONDS);\n    } catch (TimeoutException e) {\n        return "&lt;timeout&gt;";\n    } catch (Exception e) {\n        return "&lt;error: " + e.getMessage() + "&gt;";\n    }\n};\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"when-to-create-custom-swappers",children:"When to Create Custom Swappers"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Domain-specific wrapper types"}),"\n",(0,t.jsx)(n.li,{children:"Lazy evaluation containers"}),"\n",(0,t.jsx)(n.li,{children:"Result/Either/Try types"}),"\n",(0,t.jsx)(n.li,{children:"Async/Future-like types"}),"\n",(0,t.jsx)(n.li,{children:"Proxy objects"}),"\n",(0,t.jsx)(n.li,{children:"Validation wrappers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"swapper-guidelines",children:"Swapper Guidelines"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Always handle null input appropriately"}),"\n",(0,t.jsx)(n.li,{children:"Return null for null input (maintain null semantics)"}),"\n",(0,t.jsx)(n.li,{children:"Keep swappers simple and focused on unwrapping/transformation"}),"\n",(0,t.jsx)(n.li,{children:"Avoid expensive operations in swappers when possible"}),"\n",(0,t.jsx)(n.li,{children:"Document any side effects (e.g., evaluating lazy values)"}),"\n",(0,t.jsx)(n.li,{children:"Consider thread safety for shared swappers"}),"\n",(0,t.jsx)(n.li,{children:"Handle exceptions gracefully with meaningful error messages"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Swappers are called for every object being tested"}),"\n",(0,t.jsx)(n.li,{children:"Avoid expensive operations (database calls, network requests)"}),"\n",(0,t.jsx)(n.li,{children:"Consider caching for expensive transformations"}),"\n",(0,t.jsx)(n.li,{children:"Be careful with lazy evaluation - ensure it's what you want"}),"\n",(0,t.jsx)(n.li,{children:"Use timeouts for async operations"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"naming-conventions",children:"Naming Conventions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Use descriptive names that indicate the transformation\noptionalSwapper()      // Unwraps Optional\nsupplierSwapper()      // Evaluates Supplier\nfutureSwapper()        // Extracts Future result\nresultSwapper()        // Unwraps Result type\neitherSwapper()        // Extracts Either value\nvalidationSwapper()    // Unwraps ValidationResult\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"monadic-types",children:"Monadic Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Optional/Maybe\nSwapper<Optional> optionalSwapper = (conv, opt) -> \n    opt != null ? opt.orElse(null) : null;\n\n// Try/Result\nSwapper<Try> trySwapper = (conv, tryValue) -> \n    tryValue != null ? (tryValue.isSuccess() ? tryValue.get() : tryValue.getError()) : null;\n\n// Either\nSwapper<Either> eitherSwapper = (conv, either) -> \n    either != null ? (either.isLeft() ? either.getLeft() : either.getRight()) : null;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"asyncfuture-types",children:"Async/Future Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// CompletableFuture\nSwapper<CompletableFuture> futureSwapper = (conv, future) -> {\n    if (future == null) return null;\n    if (future.isDone()) {\n        try {\n            return future.get();\n        } catch (Exception e) {\n            return "&lt;error&gt;";\n        }\n    }\n    return "&lt;pending&gt;";\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"validation-types",children:"Validation Types"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Validation result with errors\nSwapper<Validation> validationSwapper = (conv, validation) -> {\n    if (validation == null) return null;\n    return validation.isValid() ? validation.getValue() : validation.getErrors();\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/topics/Stringifiers",children:"Stringifiers"})," - Converting objects to strings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/topics/Listifiers",children:"Listifiers"})," - Converting collection-like objects to lists"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/topics/PropertyExtractors",children:"PropertyExtractors"})," - Custom property access logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/topics/JuneauBctBasics",children:"juneau-bct Basics"})," - Main BCT documentation"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var a=r(96540);const t={},s=a.createContext(t);function i(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);