"use strict";(self.webpackChunkjuneau_documentation=self.webpackChunkjuneau_documentation||[]).push([[9942],{28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const t={},r=i.createContext(t);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},84823:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"topics/17.02.00.MarshallingSecurity","title":"Marshalling Security","description":"Demarshalling vulnerabilities","source":"@site/docs/topics/17.02.00.MarshallingSecurity.md","sourceDirName":"topics","slug":"/topics/MarshallingSecurity","permalink":"/docs/topics/MarshallingSecurity","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/juneau/tree/master/juneau-docs/docs/topics/17.02.00.MarshallingSecurity.md","tags":[],"version":"current","frontMatter":{"title":"Marshalling Security","slug":"MarshallingSecurity"},"sidebar":"mainSidebar","previous":{"title":"17.1. Security Basics","permalink":"/docs/topics/SecurityBasics"},"next":{"title":"17.3. SVL Security","permalink":"/docs/topics/SvlSecurity"}}');var t=s(74848),r=s(28453);const a={title:"Marshalling Security",slug:"MarshallingSecurity"},l=void 0,o={},c=[{value:"Demarshalling vulnerabilities",id:"demarshalling-vulnerabilities",level:4},{value:"Dependent libraries",id:"dependent-libraries",level:4}];function d(e){const n={code:"code",em:"em",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h4,{id:"demarshalling-vulnerabilities",children:"Demarshalling vulnerabilities"}),"\n",(0,t.jsx)(n.p,{children:"One common security vulnerability is the ability to create arbitrary Java object instances through crafted user input."}),"\n",(0,t.jsxs)(n.p,{children:["For example, support for constructing POJOs based on an input attribute defining a fully-qualified class name like\n",(0,t.jsx)(n.code,{children:"{class:'com.foo.MyBean',...}"})]}),"\n",(0,t.jsxs)(n.p,{children:["Fortunately, Juneau does not support an open-ended ",(0,t.jsx)(n.code,{children:"class"})," attribute."]}),"\n",(0,t.jsx)(n.p,{children:"As a rule, it should not be possible to create arbitrary POJOs by any of the parsers."}),"\n",(0,t.jsxs)(n.p,{children:["The demarshalled object types are inferred via reflection of the class objects passed in through the parser method (e.g.\n",(0,t.jsx)(n.code,{children:"JsonParser.DEFAULT.parse(input, MyBean.class)"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["As long as the ",(0,t.jsx)(n.code,{children:"Class"})," object passed into this method is not constructed from user-generated input, it should be free\nfrom demarshalling vulnerabilities."]}),"\n",(0,t.jsx)(n.p,{children:"The following example shows a potential vector that circumvents the restriction above:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Don't do this!\nClass c = Class.forName(someUserInputString);\nJsonParser.DEFAULT.parse(input, c);  // Oops!  Security hole!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Juneau does support something similar to a ",(0,t.jsx)(n.code,{children:"class"})," attribute that allows you to define the POJO type at runtime.\nThis is the ",(0,t.jsx)(n.code,{children:"type"})," attribute.\nThe difference is that it's not possible to specify fully-qualified class names in ",(0,t.jsx)(n.code,{children:"type"})," attributes, and instead can\nonly specify type keys defined through bean dictionaries.\nInstead of serializing the fully-qualified class names in the output, we instead serialize type names that represent\nthose POJO types.\ni.e.\ninstead of ",(0,t.jsx)(n.code,{children:"class='com.foo.MyBean'"}),", we instead serialize ",(0,t.jsx)(n.code,{children:"type='MyBeanIdentifier'"}),".\nSince bean types are defined at compile time, it's impossible to instantiate arbitrary POJOs.\nPOJO types of generalized input are also inferred through swaps.\nAgain, since the POJO types are hardcoded at compile time, these should not be subject to demarshalling vulnerabilities.\nHowever, it is possible to circumvent this through your swap implementation as shown below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Don\'t do this!\npublic class MyInsecureSwap extends ObjectSwap {\n    public Object swap(BeanSession session, JsonMap input) throws Exception {\n        // Security hole!\n        return Class.forName(input.getString("class")).newInstance();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"All other parsers (JSON, URL-Encoding, MessagePack, etc...) work the same way in determining POJO types, so should be\nsafe from demarshalling vulnerabilities."}),"\n",(0,t.jsx)(n.h4,{id:"dependent-libraries",children:"Dependent libraries"}),"\n",(0,t.jsx)(n.p,{children:"When accessing security vulnerabilities of any library, dependent libraries must also be taken into account:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The JSON, HTML, MsgPack, URL-Encoding, and UON parsers are written from scratch and do not rely on"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"any other parsing technologies."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The XML and HTML parsers uses the built-in Java StAX parser."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This ",(0,t.jsx)(n.em,{children:"should"})," be free from vulnerabilities."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The RDF parsers rely on Apache Jena 2.7.1."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["As of ",(0,t.jsx)(n.code,{children:"7.0.1"}),", no known security vulnerabilities exist that affect Juneau at this time."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);