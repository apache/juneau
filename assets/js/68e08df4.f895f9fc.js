"use strict";(self.webpackChunkjuneau_documentation=self.webpackChunkjuneau_documentation||[]).push([[7904],{28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>s});var o=i(96540);const t={},r=o.createContext(t);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(r.Provider,{value:e},n.children)}},56496:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"topics/05.10.00.Imports","title":"Imports","description":"Configurations can import values from other configurations using the following syntax:","source":"@site/docs-staging/topics/05.10.00.Imports.md","sourceDirName":"topics","slug":"/topics/05.10.00.Imports","permalink":"/docs/topics/05.10.00.Imports","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/juneau/tree/main/juneau-docs/docs-staging/topics/05.10.00.Imports.md","tags":[],"version":"current","frontMatter":{"title":"Imports"},"sidebar":"mainSidebar","previous":{"title":"5.9. Serializing Configs","permalink":"/docs/topics/05.09.00.SerializingConfigs"},"next":{"title":"5.11.1. Config Stores Basics","permalink":"/docs/topics/05.11.01.ConfigStoresBasics"}}');var t=i(74848),r=i(28453);const a={title:"Imports"},s=void 0,c={},l=[];function d(n){const e={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"Configurations can import values from other configurations using the following syntax:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# Import values from configuration 'ParentConfig'\n<ParentConfig>\n\n# Our normal section\n[Section1]\n...\n"})}),"\n",(0,t.jsx)(e.p,{children:"A configuration can contain zero or more imports anywhere in the file.\nHowever, for clarity, imports should normally be placed in the default section of the configuration file.\nThe resolved configuration is retrieved from the configuration store used for the child configuration."}),"\n",(0,t.jsx)(e.p,{children:"Configuration imports can be nested arbitrarily deep."}),"\n",(0,t.jsxs)(e.admonition,{title:"Example",type:"tip",children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# MyConfig contents\n<ParentConfig1>\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# ParentConfig1 contents\n<ParentConfig2>\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# ParentConfig2 contents\n[Foo]\nbar = baz\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Java code\nConfig config = Config.create("MyConfig").build();\nString foo = config.get("Foo/bar").get();  // == "baz"\n'})})]}),"\n",(0,t.jsx)(e.p,{children:"Values can be overridden by child configurations."}),"\n",(0,t.jsxs)(e.admonition,{title:"Example",type:"tip",children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# MyConfig contents\n<ParentConfig1>\n\n[Foo]\nbar = baz\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# ParentConfig1 contents\n<ParentConfig2>\n\n[Foo]\nbar = qux\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# ParentConfig2 contents\n\n[Foo]\nbar = quux\n"})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'Config config = Config.create("MyConfig").build();\nString foo = config.get("Foo/bar").get();  // == "baz"\n'})})]}),"\n",(0,t.jsx)(e.p,{children:"Changes made to imported configurations are automatically reflected in the child configuration and partake in the\nlistener API as if the entries were part of the child configuration.\nOnly non-overridden values trigger listener events."}),"\n",(0,t.jsxs)(e.p,{children:["For example, if an imported configuration defines a value for ",(0,t.jsx)(e.code,{children:"Foo/bar"})," and the child configuration does not,\nmodifications to ",(0,t.jsx)(e.code,{children:"Foo/bar"})," value in the parent configuration will trigger a listener event in the child config.\nHowever, if the child configuration does also specify a value for ",(0,t.jsx)(e.code,{children:"Foo/bar"}),", a change to the parent ",(0,t.jsx)(e.code,{children:"Foo/bar"})," will NOT\ntrigger a listener event because the value ends up not being changed from the perspective of the child configuration."]}),"\n",(0,t.jsx)(e.p,{children:"Values can be overwritten in child configurations but the values will only be set in that configuration and not the\nimported configuration."}),"\n",(0,t.jsx)(e.p,{children:"Dynamically adding an import will cause change events to be generated for imported values."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# MyConfig contents starting empty\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ini",children:"# ParentConfig contents\n\n[Foo]\nbar = baz\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-java",children:'// Create our configuration.\nConfig config = Config.create("MyConfig").build();\n\n// Create a listener that sets a flag if "Foo/bar" is set.\nfinal boolean[] triggered = new boolean[1];\nConfigEventListener listener = new ConfigEventListener() {\n    public void onConfigChange(ConfigEvents events) {\n        triggered[0] = events.isKeyModified("Foo", "bar"));\n    }\n};\nconfig.addListener(listener);\n\n// Dynamically add an import to ParentConfig in the default section.\nconfig.setImport("", "ParentConfig");\nconfig.commit();\n\n// The new import statement should have triggered a config changes for imported values.\nassertTrue(triggered[0]);\n'})}),"\n",(0,t.jsxs)(e.p,{children:["Dynamically removing an import has the same effect as removing keys and generates ",(0,t.jsx)(e.code,{children:"REMOVE_ENTRY"})," events."]}),"\n",(0,t.jsx)(e.p,{children:"Note that when dynamically adding or removing imports, overridden keys in the child config will be filtered from the\nchange events."})]})}function g(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}}}]);