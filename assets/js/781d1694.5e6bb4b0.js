"use strict";(self.webpackChunkjuneau_documentation=self.webpackChunkjuneau_documentation||[]).push([[443],{16421:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"topics/07.01.01.Stringifiers","title":"Stringifiers","description":"Stringifiers define how specific types should be converted to strings for comparison in BCT assertions. They provide flexible, customizable string representations that can be tailored to your testing needs.","source":"@site/docs/topics/07.01.01.Stringifiers.md","sourceDirName":"topics","slug":"/topics/Stringifiers","permalink":"/docs/topics/Stringifiers","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/juneau/tree/master/juneau-docs/docs/topics/07.01.01.Stringifiers.md","tags":[],"version":"current","frontMatter":{"title":"Stringifiers","slug":"Stringifiers"},"sidebar":"mainSidebar","previous":{"title":"7.1. juneau-bct Basics","permalink":"/docs/topics/JuneauBctBasics"},"next":{"title":"7.1.2. Listifiers","permalink":"/docs/topics/Listifiers"}}');var t=n(74848),s=n(28453);const a={title:"Stringifiers",slug:"Stringifiers"},o="Stringifiers",l={},c=[{value:"Built-in Stringifiers",id:"built-in-stringifiers",level:2},{value:"Available Built-in Stringifiers",id:"available-built-in-stringifiers",level:3},{value:"Custom Stringifiers",id:"custom-stringifiers",level:2},{value:"Basic Custom Stringifier",id:"basic-custom-stringifier",level:3},{value:"Advanced Stringifier Example",id:"advanced-stringifier-example",level:3},{value:"Recursive Stringifier",id:"recursive-stringifier",level:3},{value:"Using Custom Converters",id:"using-custom-converters",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"When to Create Custom Stringifiers",id:"when-to-create-custom-stringifiers",level:3},{value:"Stringifier Guidelines",id:"stringifier-guidelines",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"stringifiers",children:"Stringifiers"})}),"\n",(0,t.jsx)(i.p,{children:"Stringifiers define how specific types should be converted to strings for comparison in BCT assertions. They provide flexible, customizable string representations that can be tailored to your testing needs."}),"\n",(0,t.jsx)(i.h2,{id:"built-in-stringifiers",children:"Built-in Stringifiers"}),"\n",(0,t.jsx)(i.p,{children:"BCT comes with comprehensive built-in stringifiers for common Java types:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Array types\nchar[] chars = {\'H\', \'e\', \'l\', \'l\', \'o\'};\nassertString("Hello", chars);  // Uses charArrayStringifier()\n\nbyte[] bytes = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"\nassertString("48656C6C6F", bytes);  // Uses byteArrayStringifier()\n\n// Date and time types\nDate date = new Date(1673780400000L);\nassertString("2023-01-15T11:00:00Z", date);  // Uses dateStringifier()\n\nGregorianCalendar calendar = new GregorianCalendar(2023, 0, 15);\nassertMatchesGlob("2023-01-15T*", calendar);  // Uses calendarStringifier()\n\n// Collection types\nList<String> list = List.of("a", "b", "c");\nassertString("[a,b,c]", list);  // Uses listStringifier()\n\nMap<String, String> map = Map.of("key", "value");\nassertString("{key=value}", map);  // Uses mapStringifier()\n\n// Reflection types\nassertString("String", String.class);  // Uses classStringifier()\nassertString("toString()", Object.class.getMethod("toString"));  // Uses methodStringifier()\n\n// Enum types\nassertString("RUNNABLE", Thread.State.RUNNABLE);  // Uses enumStringifier()\n\n// Stream types\nInputStream input = new ByteArrayInputStream("Hello".getBytes());\nassertString("48656C6C6F", input);  // Uses inputStreamStringifier()\n'})}),"\n",(0,t.jsx)(i.h3,{id:"available-built-in-stringifiers",children:"Available Built-in Stringifiers"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"charArrayStringifier()"})," - Converts char arrays to strings"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"byteArrayStringifier()"})," - Converts byte arrays to hex strings"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"dateStringifier()"})," - Converts Date objects to ISO-8601 format"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"calendarStringifier()"})," - Converts Calendar objects to ISO-8601 format"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"listStringifier()"})," - Converts List objects to bracket format"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"mapStringifier()"})," - Converts Map objects to brace format"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"classStringifier()"})," - Converts Class objects to readable names"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"methodStringifier()"})," - Converts Method objects to signatures"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"enumStringifier()"})," - Converts Enum values to names"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"inputStreamStringifier()"})," - Converts InputStream content to hex strings"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"readerStringifier()"})," - Converts Reader content to strings"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"fileStringifier()"})," - Converts File content to strings"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"custom-stringifiers",children:"Custom Stringifiers"}),"\n",(0,t.jsx)(i.p,{children:"Define custom stringifiers for your domain-specific types:"}),"\n",(0,t.jsx)(i.h3,{id:"basic-custom-stringifier",children:"Basic Custom Stringifier"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Date formatting\nStringifier<LocalDateTime> dateStringifier = (conv, dt) -> \n    dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n\n// Complex object formatting\nStringifier<Order> orderStringifier = (conv, order) -> \n    "Order#" + order.getId() + "[" + order.getStatus() + "]";\n\n// Registration\nvar converter = BasicBeanConverter.builder()\n    .defaultSettings()\n    .addStringifier(LocalDateTime.class, dateStringifier)\n    .addStringifier(Order.class, orderStringifier)\n    .build();\n'})}),"\n",(0,t.jsx)(i.h3,{id:"advanced-stringifier-example",children:"Advanced Stringifier Example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Money type formatting\nStringifier<Money> moneyStringifier = (conv, money) -> {\n    if (money == null) return "null";\n    return money.getCurrency().getSymbol() + \n           money.getAmount().setScale(2, RoundingMode.HALF_UP);\n};\n\n// User object with privacy handling\nStringifier<User> userStringifier = (conv, user) -> {\n    if (user == null) return "null";\n    // Mask sensitive information\n    String email = user.getEmail();\n    String maskedEmail = email.replaceAll("(.{3}).*(@.*)", "$1***$2");\n    return user.getName() + " <" + maskedEmail + ">";\n};\n\n// Registration\nvar converter = BasicBeanConverter.builder()\n    .defaultSettings()\n    .addStringifier(Money.class, moneyStringifier)\n    .addStringifier(User.class, userStringifier)\n    .build();\n\n// Usage in tests\nassertBean(args().setBeanConverter(converter),\n          order, "total,customer", "$99.99,{John Smith <joh***@example.com>}");\n'})}),"\n",(0,t.jsx)(i.h3,{id:"recursive-stringifier",children:"Recursive Stringifier"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Complex nested object stringifier\nStringifier<TreeNode> treeStringifier = new Stringifier<TreeNode>() {\n    @Override\n    public String stringify(BeanConverter conv, TreeNode node) {\n        if (node == null) return "null";\n        StringBuilder sb = new StringBuilder();\n        sb.append(node.getValue());\n        if (!node.getChildren().isEmpty()) {\n            sb.append("[");\n            for (int i = 0; i < node.getChildren().size(); i++) {\n                if (i > 0) sb.append(",");\n                sb.append(stringify(conv, node.getChildren().get(i)));\n            }\n            sb.append("]");\n        }\n        return sb.toString();\n    }\n};\n\n// Creates output like: "root[child1[grandchild1,grandchild2],child2]"\n'})}),"\n",(0,t.jsx)(i.h2,{id:"using-custom-converters",children:"Using Custom Converters"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'// Create converter with custom formatting\nvar converter = BasicBeanConverter.builder()\n    .defaultSettings()\n    .addStringifier(LocalDate.class, date -> \n        date.format(DateTimeFormatter.ISO_LOCAL_DATE))\n    .addStringifier(Money.class, money -> \n        money.getAmount().toPlainString())\n    .build();\n\n// Use in assertions\nassertBean(args().setBeanConverter(converter),\n          order, "date,total", "2023-12-01,99.99");\n'})}),"\n",(0,t.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(i.h3,{id:"when-to-create-custom-stringifiers",children:"When to Create Custom Stringifiers"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Domain objects with complex string representations"}),"\n",(0,t.jsx)(i.li,{children:"Types requiring specific formatting (dates, currencies, etc.)"}),"\n",(0,t.jsx)(i.li,{children:"Privacy-sensitive objects that need masking"}),"\n",(0,t.jsx)(i.li,{children:"Legacy objects without proper toString() implementations"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"stringifier-guidelines",children:"Stringifier Guidelines"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Keep stringifiers simple and focused on string conversion"}),"\n",(0,t.jsx)(i.li,{children:"Handle null values explicitly"}),"\n",(0,t.jsx)(i.li,{children:"Avoid side effects or state modifications"}),"\n",(0,t.jsx)(i.li,{children:"Consider thread safety for shared stringifiers"}),"\n",(0,t.jsx)(i.li,{children:"Use clear, consistent formatting that aids test readability"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Stringifiers are called frequently during testing"}),"\n",(0,t.jsx)(i.li,{children:"Avoid expensive operations (database calls, file I/O)"}),"\n",(0,t.jsx)(i.li,{children:"Cache computed values when appropriate"}),"\n",(0,t.jsx)(i.li,{children:"Consider using lazy evaluation for complex conversions"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"see-also",children:"See Also"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"/docs/topics/Listifiers",children:"Listifiers"})," - Converting collection-like objects to lists"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"/docs/topics/Swappers",children:"Swappers"})," - Transforming objects before processing"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"/docs/topics/PropertyExtractors",children:"PropertyExtractors"})," - Custom property access logic"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"/docs/topics/JuneauBctBasics",children:"juneau-bct Basics"})," - Main BCT documentation"]}),"\n"]})]})}function g(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var r=n(96540);const t={},s=r.createContext(t);function a(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);