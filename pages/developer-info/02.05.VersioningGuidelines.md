---
id: 02.05.VersioningGuidelines
title: Versioning guidelines
---

This document provides:

* A set of guidelines intended to help the Apache Juneau team balance the need to provide a stable interface to clients with the growth and evolution of components over time.
* A language for describing the changes to a component and the types of incompatibilities such changes may create.
* A protocol for communicating those changes and incompatibilities to users and developers.

## 1 - Quick guidelines

In a nutshell, Juneau release numbers are usually of the form **major.minor.point**.

* **Major releases** introduce breaking changes.
* **Minor releases** introduce new significant features.
* **Point releases** introduce new minor features and bug fixes.

## 2 - Interface types

We identify two distinct categories of APIs within a component: _external_, _internal_.

### 2.1 - The external interface

Composed of the public-facing classes, methods and fields that are likely to be consumed by external developers. In general, these consist of all public classes/methods/fields, and protected methods/fields on classes meant to be extended.

We try to avoid or at least acknowledge changes to the external interface.

### 2.2 - The internal interface

Composed of classes, methods, and fields not meant for external consumption.

We mark interfaces as internal in the following ways:

* Making them private or package-protected.
* By placing them in packages containing the name "**internal**". (e.g. "**org.apache.juneau.internal**").
* By placing them in packages containing the name "**proto**". These identify new code not yet ready for consumption.
* By specifying in the Javadoc that it's an internal interface not meant for consumption.

Developers have free reign to make changes to the internal interface. These interfaces should not be included in the Javadocs.

## 3 - Types of change

We can categorize the changes to a component according to the degree to which these changes are compatible with previous releases of the component. We define three such categories: _fully-compatible_, _interface-compatible_, and _external-interface-compatible_.

### 3.1 - Fully-compatible changes

Release _B_ is said to be _fully-compatible_ with Release _A_ if _B_ can simply replace _A_ in (nearly) all circumstances and deployments without changing the client code or configuration, and without changing the semantics of any public or protected member.

**Examples of fully-compatible changes include:**

* adding a non-abstract method to a class
* adding a class or interface to a component
* changing a member from private to protected
* changing a private attribute to a private method
* changing an implementation such that a given external library is no longer needed by the component
* changing a method or class from final to non-final
* deprecating, but not otherwise changing, a class, interface or member
* changing a component in order to fix a defect (a deviation from the documented or reasonably expected behavior), assuming no other incompatibilities are introduced

**Examples of changes which are not fully-compatible include:**

* a release that no longer supports the same set of JREs, or that requires new libraries to be added to the classpath
* changing a public or protected method signature
* changing the default value of an attribute in a behaviour-impacting way
* removing a class, interface, method or attribute from either the internal or external interface of the component

Note that not every non-fully-compatible change will cause compilation or readily apparent run-time problems.

Generally speaking, a fully-compatible change will at most change the private interface of a component, or simply add classes, methods and attributes whose use is optional to both internal and external interface clients.

### 3.2 - Interface-compatible changes

Release _B_ is said to be "interface-compatible" with Release _A_ if (nearly) all clients that can be compiled with _A_ in the classpath can also be compiled with _B_ in the classpath, without changing the semantics of any public or protected member. A configuration or classpath change may be required.

**Examples of interface-compatible changes include:**

* all fully-compatible changes
* changing a component such that it now depends upon an additional external library or configuration file

**Examples of changes which are not interface-compatible include:**

* changing a public or protected method signature
* changing the default value of an attribute in a behaviour changing way
* removing a class, interface, method or attribute from either the internal or external interface of the component

Generally speaking, an interface-compatible change will at most change the private interface of a component, or simply add classes, methods and attributes whose use is optional to both internal and external interface clients.

### 3.3 - External-interface-compatible changes

Release _B_ is said to be "external-interface-compatible" with Release _A_ if (nearly) all clients that depend only on the external interface of a component and that can be compiled with _A_ in the classpath can also be compiled with _B_ in the classpath, without changing the semantics of any member in the _external_ interface. A configuration or classpath change may be required.

**Examples of external-interface-compatible changes include:**

* all interface-compatible changes
* removing a class, interface, method or attribute from the internal interface of the component
* a change to the internal or private interface of a component that requires a change in configuration settings or in the external libraries required to use the component
* changes to the internal or private interface of a component without impacting the external interface

**Examples of changes which are not external-interface-compatible include:**

* changing the method signature of any method that is part of the external interface of the component
* changing the default value of any attribute that is part of the external interface of the component in a behaviour changing way
* removing a class, interface, method or attribute from external interface of the component

Generally speaking, external-interface-compatible changes correspond to changes to at most the internal interface of the component or the addition of optional classes, interfaces or members to the external interface.

## 4 - Release types

We identify five types of releases: "**Major**", "**Minor**", "**Point**", "**Beta**" and "**Milestone**".

Developers are encouraged to "upgrade" a release to a stronger type whenever the nature or scope of the change warrants it.

### 4.1 - Major releases

Major releases signify significant changes to a component. Developers _may_ perform a major release if there have been substantial improvements to the component. Developers _must_ perform a major release whenever the new release is not at least interface-compatible with the previous release.

### 4.2 - Minor releases

Minor releases signify enhancements to a component that do not necessitate a major release. Developers _may_ perform a minor release if the release is at least external-interface-compatible with the previous release.

In other words, whenever a client depends upon at most the external interface of a component with a given minor release, it will work with all subsequent minor releases within that major release.

### 4.3 - Point releases

A point release typically involves simple bug fixes or optimizations and minor new features. Developers _may_ perform a point release if the release is at least interface-compatible with the previous release.

In other words, whenever a client depends upon a component with a given point release, it will work with all subsequent point releases within that minor release.

### 4.4 - Beta releases

Developers may, at their option, perform a beta preview of any major, minor or point release. Beta releases may be performed for a variety of purposes such as:

* Showcasing new, untested features
* Providing early corrections of critical bugs
* Generating a stable version before large-scale changes

While every effort should be made to ensure the quality of released code, "beta" releases are essentially provided as-is with no guarantees of stability or maintenance.

### 4.5 - Milestone releases

Developers may, at their option, offer a milestone preview of any major release. A milestone release is appropriate when part of the overall component is fully functioning and the team wants to make it more widely available for testing. Those features implemented and those remaining to be implemented should be clearly defined and documented.

While every effort should be made to ensure the quality of released code, "milestone" releases are essentially provided as-is with no guarantees of stability or maintenance.

## 5 - Release numbers

### 5.1 - Dissecting the release number  

A release number is comprised of 3 components: the major release number, the minor release number, and an optional point release number. Here is a sample release number:

**2.0.4**

and it can be broken into three parts:

* **major release**: 2
* **minor release**: 0
* **point release**: 4

The next release of this component would increment the appropriate part of the release number, depending on the type of release (major, minor, or point). For example, a subsequent minor release would be version 2.1, or a subsequent major release would be 3.0.

Note that release numbers are composed of three **integers**, not three _digits_. Hence if the current release is 3.9.4, the next minor release is 3.10.0.

### 5.2 - Beta release numbers

Beta releases are denoted by adding "B" followed by the beta version number after the release number. For example, if the current release version is 2.0.4, and a developer wished to preview the next major release, the release would be labeled 3.0-B1.

### 5.3 - Milestone release numbers

Milestone releases are denoted by adding "M" followed by the milestone version number after the release number. For example, if the current release version is 2.0.4, and a developer wished to preview the next major release, the release would be labeled 3.0-M1.

## 6 - Development states

We identify four possible states: "**in development**", "**beta**", "**released**", and "**unsupported**".

### 6.1 - In development state

When a component is "in development", it is new and still relatively unstable. Typically components in this state do not have any binary releases available beyond the nightly builds. Users should be made aware that this component may change its functionality or interface before a stable release is achieved. A "milestone" release may be made while the component is still "in development" to make the features currently implemented more widely available for testing in a more stable test version.

### 6.2 - Beta state

When a component has made significant progress toward release-quality code, the committers may vote to perform a "beta" release. At this point, the component state will change from "in development" to "beta". The component will remain in this state until it is ready for its first major release.

Note that developers may skip vote to skip the "beta" state and go directly to "released", if the component is sufficiently stable.

### 6.3 - Released state

When a new component is finally production-quality, the developers may vote to perform the first major release. At this point, the component status will be changed from "beta" to "released". In the future this component will always be considered to be in the "released" state, even when new releases are initiated. The only exception is in the case of "unsupported" components.

### 6.4 - Unsupported state

Under rare circumstances, committers may vote to make a component "unsupported", if there are no resources to maintain the library or if it has been completely supplanted by another component. Only "released" components may become "unsupported"; components in other states will simply be terminated after a brief warning period.

## 7 - Comments

Using this approach it is possible to very precisely and concisely define the dependencies between a component and its clients.

For example, suppose that the application Foo depends (only) upon features of the juneau-core component that are part of the external interface in release 2.3.0. Then the maintainers of Foo can state with a high degree of certainty that Foo will work with any 2.x release of juneau-core (x >= 3).

Similarly, suppose the application Bar depends upon features of juneau-core that were part of the internal interface of release 2.3.0. Then the maintainers of Bar can state with a high degree of certainty that Bar will work with any 2.3.x release of juneau-core. Only once 2.4 (or 3.0) is released will Bar's developers have to re-evaluate.

## 8 - End Notes

* We say "nearly" here since there are rare or unusual circumstances in which changes that are usually "safe" may cause problems for a small number of users. For example, adding a new method to a component class shouldn't in general cause problems for any clients. But it may cause problems for some clients who've extended that class and already added a method with the same signature in their subclass.
