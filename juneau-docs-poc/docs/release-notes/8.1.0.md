---
title: "Release 8.1.0"
---

# Release 8.1.0

**Date:** Aug 21, 2019

8.1.0 introduces some significant new features including:
~~ConfigurableAnnotations Configurable Annotations~~
~~DefaultPojoSwaps Default PojoSwaps~~
~~ConfigImports Config Imports~~
~~BasicRest BasicRest~~, ~~BasicRestGroup BasicRestGroup~~ classes
~~RestPathAnnotation Path variables on resource paths~~
~~RestmRequestAttributes Request Attributes API~~
~~RestRoleGuards Role Guards~~
~~RestLoggingAndDebugging Improved REST logging/debugging~~
[New MockRest API](#juneau-rest-mock)
#### juneau-marshall

New utility class for diffing beans: 

<tree>
<java-class>\{@link oaj.utils.BeanDiff\}</java-class>
</tree>
New annotation for defining bean property names: 

<tree>
<java-annotation>\{@link oaj.annotation.Name\}</java-annotation>
</tree>
New serializer properties:

<tree>
<java-class>\{@link oaj.serializer.WriterSerializer\}</java-class>
<node-1><java-field>~~WriterSerializer.WSERIALIZER_fileCharset WSERIALIZER_fileCharset~~</java-field></node-1>
<node-1><java-field>~~WriterSerializer.WSERIALIZER_streamCharset WSERIALIZER_streamCharset~~</java-field></node-1>
</tree>
The following POJO methods can be used to convert a POJO to/from a Map before serialization and after parsing.
It's a convenient way of defining a POJO transform.
<tree>
<java-method>`public Map toMap()` -  Can be any type of map with string keys and object vals.</java-method>
<java-method>`public ObjectMap toMap()`</java-method>
<java-method>`public Map toMap(BeanSession bs)` -  Can be any type of map with string keys and object vals.</java-method>
<java-method>`public ObjectMap toMap(BeanSession bs)`</java-method>
<java-method>`public static T fromMap(Map m)` -  Can be any type of map with string keys and object vals.</java-method>
<java-method>`public static T fromMap(ObjectMap m)`</java-method>
<java-method>`public static T fromMap(BeanSession bs, Map m)` -  Can be any type of map with string keys and object vals.</java-method>
<java-method>`public static T fromMap(BeanSession bs, ObjectMap m)`</java-method>
</tree>
New convenience debugging methods on Marshall API:

<tree>
<java-class>~~Marshall~~</java-class>
<node-1><java-method>~~ oaj.marshall.Marshall.format(String,Object...) format(String,Object...)~~ - `MessageFormat`-style formatter.</java-method></node-1>
<node-1><java-method>~~ oaj.marshall.Marshall.out(String,Object...) out(String,Object...)~~ - Prints `MessageFormat`-style messages to STDOUT.</java-method></node-1>
<node-1><java-method>~~ oaj.marshall.Marshall.err(String,Object...) err(String,Object...)~~ - Prints `MessageFormat`-style messages to STDERR.</java-method></node-1>
</tree>
Serializer and parser APIs now throw `IOExceptions` in addition to `SerializeException` and `ParseException` to make it
easier to determine if problems are stream based or syntax based.
New Java 8 date-time transforms:

<tree>
<java-class>~~TemporalSwap~~ - For all Java 8 temporal types (e.g. \{@link java.time.ZonedDateTime\})</java-class>
<java-class>~~TemporalDateSwap~~ - For \{@link java.util.Date\}</java-class>
<java-class>~~TemporalCalendarSwap~~ - For \{@link java.util.Calendar\}</java-class>
</tree>
All serializers and parsers now have built-in default swaps for common class types:

<tree>
<java-class>\{@link java.util.Enumeration\}</java-class>
<java-class>\{@link java.util.Iterator\}</java-class>
<java-class>\{@link java.util.Locale\}</java-class>
<java-class>\{@link java.util.Calendar\} - ISO offset date-time.</java-class>
<java-class>\{@link java.util.Date\} - Local date-time</java-class>
<java-class>\{@link java.time.Instant\} - ISO instant.</java-class>
<java-class>\{@link java.time.ZonedDateTime\} - ISO offset date-time.</java-class>
<java-class>\{@link java.time.LocalDate\} - ISO local date.</java-class>
<java-class>\{@link java.time.LocalDateTime\} - ISO local date-time.</java-class>
<java-class>\{@link java.time.LocalTime\} - ISO local time.</java-class>
<java-class>\{@link java.time.OffsetDateTime\} - ISO offset date-time.</java-class>
<java-class>\{@link java.time.OffsetTime\} - ISO offset time.</java-class>
<java-class>\{@link java.time.Year\} - ISO year.</java-class>
<java-class>\{@link java.time.YearMonth\} - ISO year-month.</java-class>
<java-class>\{@link java.time.temporal.Temporal\} - ISO instant.</java-class>
<java-class>\{@link java.util.TimeZone\}</java-class>
<java-class>\{@link javax.xml.datatype.XMLGregorianCalendar\}</java-class>
<java-class>\{@link java.time.ZoneId\}</java-class>
</tree>
#### juneau-config

Support for import statements:

```text
. Import values from another configuration:
[Foo]
bar = baz
```


The ~~ConfigFileStore~~now automatically resolves file extensions.
New configuration property for specifying search paths for file extensions:

<tree>
<java-field>~~ConfigFileStore.FILESTORE_extensions~~</java-field>
</tree>
Fixed a bug where instances of ~~ConfigMemoryStore~~ ended up resolving to the same object.
Uses "application.properties" file as a system default if present.
Useful when being used in a Spring Boot application.
New \{@link oaj.config.Config#setSystemProperties\} method for quickly moving configuration settings into the 
system properties.
Entries in the system config are automatically set as system properties.
This mean you can set any of the various serializer and parser settings (e.g. "JsonSerializer.simpleMode.b")
in the default configuration area or `application.properties`.
#### juneau-rest-server

New annotations that can be applied to REST classes and methods to configure serializers and parsers.

```text
// Old way using generic properties.
@RestResource(
path="/atom",
title="Sample ATOM feed resource",
properties={
@Property(name=WSERIALIZER_quoteChar, value="'"),
@Property(name=RDF_rdfxml_tab, value="5"),
@Property(nameRDF_addRootProperty, value="true"),
@Property(name=BEAN_examples, value="{'org.apache.juneau.dto.atom.Feed': $F{AtomFeedResource_example.json}}")
}
...
)
public class AtomFeedResource extends BasicRestServletJena {
...
}
```


```text
// New way using specific annotations.
@RestResource(
path="/atom",
title="Sample ATOM feed resource"
...
)
@SerializerConfig(quoteChar="'")
@RdfConfig(rdfxml_tab="5", addRootProperty="true")
@BeanConfig(examples="Feed: $F{AtomFeedResource_example.json}")
public class AtomFeedResource extends BasicRestServletJena {
...
}
```


Config annotations are provided for all serializers and parsers:

<tree>
<java-annotation>\{@link oaj.annotation.BeanConfig BeanConfig\}</java-annotation>
<java-annotation>\{@link oaj.csv.annotation.CsvConfig CsvConfig\}</java-annotation>
<java-annotation>\{@link oaj.html.annotation.HtmlConfig HtmlConfig\}</java-annotation>
<java-annotation>\{@link oaj.html.annotation.HtmlDocConfig HtmlDocConfig\}</java-annotation>
<java-annotation>~~JsoConfig JsoConfig~~</java-annotation>
<java-annotation>\{@link oaj.json.annotation.JsonConfig JsonConfig\}</java-annotation>
<java-annotation>\{@link oaj.jsonschema.annotation.JsonSchemaConfig JsonSchemaConfig\}</java-annotation>
<java-annotation>\{@link oaj.msgpack.annotation.MsgPackConfig MsgPackConfig\}</java-annotation>
<java-annotation>\{@link oaj.oapi.annotation.OpenApiConfig OpenApiConfig\}</java-annotation>
<java-annotation>\{@link oaj.parser.annotation.ParserConfig ParserConfig\}</java-annotation>
<java-annotation>\{@link oaj.plaintext.annotation.PlainTextConfig PlainTextConfig\}</java-annotation>
<java-annotation>~~RdfConfig~~</java-annotation>
<java-annotation>\{@link oaj.serializer.annotation.SerializerConfig SerializerConfig\}</java-annotation>
<java-annotation>\{@link oaj.soap.annotation.SoapXmlConfig SoapXmlConfig\}</java-annotation>
<java-annotation>\{@link oaj.uon.annotation.UonConfig UonConfig\}</java-annotation>
<java-annotation>\{@link oaj.urlencoding.annotation.UrlEncodingConfig UrlEncodingConfig\}</java-annotation>
<java-annotation>\{@link oaj.xml.annotation.XmlConfig XmlConfig\}</java-annotation>
</tree>
New support for using Servlet request attributes.  
~~RequestAttributes~~
\{@link oajr.RestContext\}
~~REST_attrs~~
\{@link oajr.RestContext.Builder\}
~~ attrs(String...)~~
~~attr(String,Object)~~
~~RestMethodContext~~
~~RestMethodContext.RESTMETHOD_attrs RESTMETHOD_attrs~~
\{@link oajr.RestRequest\}
\{@link oajr.RestRequest#getAttributes() getAttributes()\}
\{@link oajr.RestResponse\}
\{@link oajr.RestResponse#getAttributes() getAttributes()\}
~~RestResponse.attr(String,Object) attr(String,Object)~~
\{@link oajr.annotation.Attr\}
~~RestMethod.attrs()~~
~~RestResource.attrs()~~
This deprecates the following APIs:
~~RequestProperties~~
~~RestMethodProperties~~
\{@link oajr.RestRequest\}
~~RestRequest.getProperties() getProperties()~~
~~RestRequest.prop(String,Object) prop(String,Object)~~
Added the following classes that provide the same support as the servlet classes but doesn't extend from `HttpServlet`.
This fixes an issue where instances of ~~BasicRestServlet~~ are registered as top-level servlets even though
you don't want them to be.  
~~BasicRest~~ - Non-servlet equivalent to ~~BasicRestServlet~~
~~BasicRestGroup~~ - Non-servlet equivalent to ~~BasicRestServletGroup~~
~~BasicRestJena~~ - Non-servlet equivalent to ~~BasicRestServletJena~~
~~BasicRestJenaGroup~~ - Non-servlet equivalent to ~~BasicRestServletJenaGroup~~
HTML widgets now have access to the `RestResponse` object if they need access to the output bean.
New annotations for simplified role-based guards on classes and methods:
~~RestResource~~ 
~~roleGuard()~~
~~rolesDeclared()~~
~~RestMethod~~
~~RestMethod.roleGuard roleGuard()~~
~~RestMethod.rolesDeclared rolesDeclared()~~
New annotations for fine-tuned handling of http-methods/http-headers as query parameters and others:
~~RestResource~~ 
~~allowedHeaderParams()~~
~~allowedMethodHeaders()~~
~~allowedMethodParams()~~
The ~~@RestResource(path)~~annotation can now use variables:

```text
@RestResource(
path="/myResource/{foo}/{bar}"
)
public class MyResource extends BasicRestServlet {...}
```		

New methods:
\{@link oajr.RestRequest\}
\{@link oajr.RestRequest#getCharset() getCharset()\}
\{@link oajr.RestResponse\}
\{@link oajr.RestResponse#getCharset() getCharset()\}
New interface method for catching arbitrary thrown objects and converting them to other throwables.
~~RestCallHandler~~
~~RestCallHandler.convertThrowable(Throwable) convertThrowable(Throwable)~~
~~BasicRestCallHandler~~
~~convertThrowable(Throwable)~~
Support for fine-tuned logging of HTTP requests and responses. 

```text
@RestResource(
debug="per-request",
logging=@Logging(
level="info",
rules={
@LoggingRule(codes"400-499", level="warning", req="short", res="short")
@LoggingRule(codes"500-", level="severe", req="long", res="long")
}
)
)
public class MyRest {
@RestMethod(
method="POST", 
path="foo"
logging=@Logging(
level="info",
rules={
@LoggingRule(exceptions"NotFound*", level="info")
@LoggingRule(codes"200", disabled="true")
}
)
)
public String myMethod() throws Exception {...}
```		

See ~~RestLoggingAndDebugging~~for details.
Fixed a bug where the HTTP response was returning 405 (method not found) but should really be 404 (not found)
when no path patterns match on any of the Java methods.
#### juneau-rest-client

PATCH support added.
