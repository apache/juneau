---
title: "Dynamically Applied Annotations"
---

In the section [TODO: Swaps](TODO.md), you were introduced to annotations that can be applied to bean classes, methods, fields, and constructors such as [@Bean]({{API_DOCS}}/org/apache/juneau/annotation/Bean.html):

```java
// Address class with only street/city/state properties (in that order).
// All other properties are ignored.
@Bean(properties="street,city,state")
public class Address { ... }
```

An alternate way of applying these annotations is to attach them to unrelated classes and methods and then tell your serializer or parser where to find them.

```java
// Unannotated class.
public class Address { ... }

@Bean(onClass=Address.class, properties="street,city,state")
public static class DummyClass {}

WriterSerializer serializer = JsonSerializer
    .create()
    .applyAnnotations(DummyClass.class)
    .build();

String json = serializer.toString(addressBean);
```

The advantage to this approach is it allows you to use Juneau annotations on classes/methods/fields/constructors where you might not have access to the source code, or when you only want to selectively apply the annotation under certain scenarios instead of globally.

For example, the following shows the @Bean annotation being selectively applied on a single REST method (described later in juneau-rest-server):

```java
@RestGet
@Bean(onClass=Address.class, properties="street,city,state")
public List getAddresses() {}
```

Any Juneau annotation that has an `on()/onClass()` method can be applied dynamically this way.
These include:

<tree>
<java-annotation>[Bean]({{API_DOCS}}/org/apache/juneau/annotation/Bean.html)</java-annotation>
<java-annotation>[Beanc]({{API_DOCS}}/org/apache/juneau/annotation/Beanc.html)</java-annotation>
<java-annotation>[BeanIgnore]({{API_DOCS}}/org/apache/juneau/annotation/BeanIgnore.html)</java-annotation>
<java-annotation>[Beanp]({{API_DOCS}}/org/apache/juneau/annotation/Beanp.html)</java-annotation>
<java-annotation>[Example]({{API_DOCS}}/org/apache/juneau/annotation/Example.html)</java-annotation>
<java-annotation>[NameProperty]({{API_DOCS}}/org/apache/juneau/annotation/NameProperty.html)</java-annotation>
<java-annotation>[ParentProperty]({{API_DOCS}}/org/apache/juneau/annotation/ParentProperty.html)</java-annotation>
<java-annotation>[Swap]({{API_DOCS}}/org/apache/juneau/annotation/Swap.html)</java-annotation>
<java-annotation>[Uri]({{API_DOCS}}/org/apache/juneau/annotation/Uri.html)</java-annotation>
<java-annotation>[Csv]({{API_DOCS}}/org/apache/juneau/csv/annotation/Csv.html)</java-annotation>
<java-annotation>[Html]({{API_DOCS}}/org/apache/juneau/html/annotation/Html.html)</java-annotation>
<java-annotation>[Json]({{API_DOCS}}/org/apache/juneau/json/annotation/Json.html)</java-annotation>
<java-annotation>[Schema]({{API_DOCS}}/org/apache/juneau/annotation/Schema.html)</java-annotation>
<java-annotation>[MsgPack]({{API_DOCS}}/org/apache/juneau/msgpack/annotation/MsgPack.html)</java-annotation>
<java-annotation>[OpenApi]({{API_DOCS}}/org/apache/juneau/oapi/annotation/OpenApi.html)</java-annotation>
<java-annotation>[PlainText]({{API_DOCS}}/org/apache/juneau/plaintext/annotation/PlainText.html)</java-annotation>
<java-annotation>[SoapXml]({{API_DOCS}}/org/apache/juneau/soap/annotation/SoapXml.html)</java-annotation>
<java-annotation>[Uon]({{API_DOCS}}/org/apache/juneau/uon/annotation/Uon.html)</java-annotation>
<java-annotation>[UrlEncoding]({{API_DOCS}}/org/apache/juneau/urlencoding/annotation/UrlEncoding.html)</java-annotation>
<java-annotation>[Xml]({{API_DOCS}}/org/apache/juneau/xml/annotation/Xml.html)</java-annotation>
</tree>

The valid pattern matches are:

- Classes:
   - Fully qualified:  `com.foo.MyClass`
   - Fully qualified inner class:  `com.foo.MyClass$Inner1$Inner2`
   - Simple:  `MyClass`
   - Simple inner:  `MyClass$Inner1$Inner2`, `Inner1$Inner2`, `Inner2`
- Methods:
   - Fully qualified with args:  `com.foo.MyClass.myMethod(String,int)`, `com.foo.MyClass.myMethod(java.lang.String,int)`, `com.foo.MyClass.myMethod()`
   - Fully qualified:  `com.foo.MyClass.myMethod`
   - Simple with args:  `MyClass.myMethod(String,int)`, `MyClass.myMethod(java.lang.String,int)`, `MyClass.myMethod()`
   - Simple:  `MyClass.myMethod`
   - Simple inner class:  `MyClass$Inner1$Inner2.myMethod`, `Inner1$Inner2.myMethod`, `Inner2.myMethod`
- Fields:
   - Fully qualified:  `com.foo.MyClass.myField`
   - Simple:  `MyClass.myField`
   - Simple inner class:  `MyClass$Inner1$Inner2.myField`, `Inner1$Inner2.myField`, `Inner2.myField`
- Constructors:
   - Fully qualified with args:  `com.foo.MyClass(String,int)`, `com.foo.MyClass(java.lang.String,int)`, `com.foo.MyClass()`
   - Simple with args:  `MyClass(String,int)`, `MyClass(java.lang.String,int)`, `MyClass()`
   - Simple inner class:  `MyClass$Inner1$Inner2()`, `Inner1$Inner2()`, `Inner2()`
- A comma-delimited list of anything on this list.